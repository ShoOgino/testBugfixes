{"path":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f09ac0abea5345f77c4cf8d9f0d531da9139debc","date":1311103501,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(loader, node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf718fc7210fb8e7744d4b69704a4c9f732d1e92","date":1311538183,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(loader, node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(loader, node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa6d0ca44ce171ad041951fa8fb94731b7d778d9","date":1316629244,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(loader, node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"), \"search.similarities.\");\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(loader, node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b1605dda5afabdc06fd136fa0dd14ad326e3001","date":1326751633,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(loader, node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"), \"search.similarities.\");\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(loader, node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"), \"search.similarities.\");\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b","date":1328532481,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(loader, node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"), \"search.similarities.\");\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4ab92b64eeccdec7c69da247536d8359470cd04","date":1332909835,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15cacbf46c73bd5b0e47b57128be8852cb236160","date":1332942979,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0b7003c9a9780c96f84f429c910f05038ba58b99","date":1338589218,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"220acde8206f5221383e3777429a4fb84bed289f","date":1339892825,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8aec175aa53c7af1baf595a8a4d333e670bfe94b","date":1340675955,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f2c5389fcac652b2b765661515d7bc3e4e19937","date":1343683812,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":["349954f4394157816ec1ed15691a5f3e18638c0c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1e0c121d6dbaebf97724020e374b4bc28b95a44","date":1355188019,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.warn(\"uniqueKey is not stored - distributed search and MoreLikeThis will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.warn(\"uniqueKey is not stored - distributed search and MoreLikeThis will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","date":1362545433,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          if (isValidDynamicFieldName(name)) {\n            // make sure nothing else has the same path\n            addDynamicField(dFields, f);\n          } else {\n            String msg = \"Dynamic field name '\" + name \n                + \"' should have either a leading or a trailing asterisk, and no others.\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.warn(\"uniqueKey is not stored - distributed search and MoreLikeThis will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.warn(\"uniqueKey is not stored - distributed search and MoreLikeThis will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":["83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b","date":1363161710,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          if (isValidFieldGlob(name)) {\n            // make sure nothing else has the same path\n            addDynamicField(dFields, f);\n          } else {\n            String msg = \"Dynamic field name '\" + name \n                + \"' should have either a leading or a trailing asterisk, and no others.\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.warn(\"uniqueKey is not stored - distributed search and MoreLikeThis will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          if (isValidDynamicFieldName(name)) {\n            // make sure nothing else has the same path\n            addDynamicField(dFields, f);\n          } else {\n            String msg = \"Dynamic field name '\" + name \n                + \"' should have either a leading or a trailing asterisk, and no others.\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.warn(\"uniqueKey is not stored - distributed search and MoreLikeThis will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd","date":1364185773,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema \" + NAME + \"=\" + name);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n\n      //               /schema/fields/field | /schema/fields/dynamicField\n      expression =     stepsToPath(SCHEMA, FIELDS, FIELD)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException\n              (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n        if (null != args.get(REQUIRED)) {\n          explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(FIELD)) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n          if (isValidFieldGlob(name)) {\n            // make sure nothing else has the same path\n            addDynamicField(dFields, f);\n          } else {\n            String msg = \"Dynamic field name '\" + name \n                + \"' should have either a leading or a trailing asterisk, and no others.\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n      //fields with default values are by definition required\n      //add them to required fields, and we only have to loop once\n      // in DocumentBuilder.getDoc()\n      requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n      // OK, now sort the dynamic fields largest to smallest size so we don't get\n      // any false matches.  We want to act like a compiler tool and try and match\n      // the largest string possible.\n      Collections.sort(dFields);\n\n      log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n      // stuff it in a normal array for faster access\n      dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if (similarityFactory instanceof SchemaAware) {\n        ((SchemaAware)similarityFactory).inform(this);\n      } else {\n        // if the sim factory isn't schema aware, then we are responsible for\n        // erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n      similarity = similarityFactory.getSimilarity();\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, \n                                                 XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          if (isValidFieldGlob(name)) {\n            // make sure nothing else has the same path\n            addDynamicField(dFields, f);\n          } else {\n            String msg = \"Dynamic field name '\" + name \n                + \"' should have either a leading or a trailing asterisk, and no others.\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    SimilarityFactory simFactory = readSimilarity(loader, node);\n    if (simFactory == null) {\n      simFactory = new DefaultSimilarityFactory();\n    }\n    if (simFactory instanceof SchemaAware) {\n      ((SchemaAware)simFactory).inform(this);\n    } else {\n      // if the sim facotry isn't schema aware, then we are responsible for\n      // erroring if a field type is trying to specify a sim.\n      for (FieldType ft : fieldTypes.values()) {\n        if (null != ft.getSimilarity()) {\n          String msg = \"FieldType '\" + ft.getTypeName() + \"' is configured with a similarity, but the global similarity does not support it: \" + simFactory.getClass();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n    }\n    similarity = simFactory.getSimilarity();\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      }\n      log.info(\"default search field in schema is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (null != uniqueKeyField.getDefaultValue()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured with a default value (\"+\n          uniqueKeyField.getDefaultValue()+\")\";\n        log.error(msg);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n      }\n\n      if (!uniqueKeyField.stored()) {\n        log.warn(\"uniqueKey is not stored - distributed search and MoreLikeThis will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n          \") can not be configured to be multivalued\";\n        log.error(msg);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = \"uniqueKey field (\"+uniqueKeyFieldName+\n            \") can not be the dest of a copyField (src=\"+source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":["92f8ab19a30ff70981e43b8cc78069cb0941476e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cf81bc8c6e4078e236f0e38b3a2d0271854f207","date":1364832963,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema \" + NAME + \"=\" + name);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n\n      //               /schema/fields/field | /schema/fields/dynamicField\n      expression =     stepsToPath(SCHEMA, FIELDS, FIELD)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException\n              (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n        if (null != args.get(REQUIRED)) {\n          explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(FIELD)) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n          if (isValidFieldGlob(name)) {\n            // make sure nothing else has the same path\n            addDynamicField(dFields, f);\n          } else {\n            String msg = \"Dynamic field name '\" + name \n                + \"' should have either a leading or a trailing asterisk, and no others.\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n      //fields with default values are by definition required\n      //add them to required fields, and we only have to loop once\n      // in DocumentBuilder.getDoc()\n      requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n      // OK, now sort the dynamic fields largest to smallest size so we don't get\n      // any false matches.  We want to act like a compiler tool and try and match\n      // the largest string possible.\n      Collections.sort(dFields);\n\n      log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n      // stuff it in a normal array for faster access\n      dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if (similarityFactory instanceof SchemaAware) {\n        ((SchemaAware)similarityFactory).inform(this);\n      } else {\n        // if the sim factory isn't schema aware, then we are responsible for\n        // erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n      similarity = similarityFactory.getSimilarity();\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema \" + NAME + \"=\" + name);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n\n      //               /schema/fields/field | /schema/fields/dynamicField\n      expression =     stepsToPath(SCHEMA, FIELDS, FIELD)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException\n              (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n        if (null != args.get(REQUIRED)) {\n          explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(FIELD)) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n          if (isValidFieldGlob(name)) {\n            // make sure nothing else has the same path\n            addDynamicField(dFields, f);\n          } else {\n            String msg = \"Dynamic field name '\" + name \n                + \"' should have either a leading or a trailing asterisk, and no others.\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n      //fields with default values are by definition required\n      //add them to required fields, and we only have to loop once\n      // in DocumentBuilder.getDoc()\n      requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n      // OK, now sort the dynamic fields largest to smallest size so we don't get\n      // any false matches.  We want to act like a compiler tool and try and match\n      // the largest string possible.\n      Collections.sort(dFields);\n\n      log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n      // stuff it in a normal array for faster access\n      dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if (similarityFactory instanceof SchemaAware) {\n        ((SchemaAware)similarityFactory).inform(this);\n      } else {\n        // if the sim factory isn't schema aware, then we are responsible for\n        // erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n      similarity = similarityFactory.getSimilarity();\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":["e6df93694b323143943a3cc9169775db9a920197"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema \" + NAME + \"=\" + name);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema \" + NAME + \"=\" + name);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader \n        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load( loader, nodes );\n\n      // load the Fields\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n\n      //               /schema/fields/field | /schema/fields/dynamicField\n      expression =     stepsToPath(SCHEMA, FIELDS, FIELD)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException\n              (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n        if (null != args.get(REQUIRED)) {\n          explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(FIELD)) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n          if (isValidFieldGlob(name)) {\n            // make sure nothing else has the same path\n            addDynamicField(dFields, f);\n          } else {\n            String msg = \"Dynamic field name '\" + name \n                + \"' should have either a leading or a trailing asterisk, and no others.\";\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n      //fields with default values are by definition required\n      //add them to required fields, and we only have to loop once\n      // in DocumentBuilder.getDoc()\n      requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n      // OK, now sort the dynamic fields largest to smallest size so we don't get\n      // any false matches.  We want to act like a compiler tool and try and match\n      // the largest string possible.\n      Collections.sort(dFields);\n\n      log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n      // stuff it in a normal array for faster access\n      dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if (similarityFactory instanceof SchemaAware) {\n        ((SchemaAware)similarityFactory).inform(this);\n      } else {\n        // if the sim factory isn't schema aware, then we are responsible for\n        // erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n      similarity = similarityFactory.getSimilarity();\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28d2c2e2cfdd54f85fbd98b7c519357992039651","date":1368165099,"type":3,"author":"Shawn Heisey","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"[\");\n      sb.append(loader.getCoreProperties().getProperty(NAME));\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema \" + NAME + \"=\" + name);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09d7b02899d5e2425517737c5c091f6878ff08a3","date":1368190345,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"[\");\n      sb.append(loader.getCoreProperties().getProperty(NAME));\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"16c8b96bb5b688807272bd6bee7051c5168e1a10","date":1368203207,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"]est\");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f239f19602502b42a1690c6a62c87501f34d93ab","date":1368209946,"type":3,"author":"Shawn Heisey","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"]est\");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0","date":1377955248,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"bugIntro":["f52362fa746c58f10354f9454bed2b89f59c06b2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"72eacaf7d2bf30907a4f9bf8f734aea16c55d28a","date":1380298511,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4459434909d3f425a264c2f611dcfccb9fa65564","date":1392074781,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_47)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e1bc9368a5cae1776f5b12df9dac1b0477f8f4","date":1395589252,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_47)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/types/fieldtype | /schema/types/fieldType \n      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) \n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_47)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd330c9d05eacbd6e952fe0dea852e7ae037eb50","date":1398873035,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_47)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24b51843dd98041bc40be26a47e44d7cb49bef72","date":1403043869,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e57c73924f3b8c19defa62e96bfa34a4922d49c2","date":1403106358,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      expression = \"//\" + COPY_FIELD;\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + \" definition\");\n        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + \" definition\");\n        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse \" + MAX_CHARS + \" attribute for \" + COPY_FIELD + \" from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        if (dest.equals(uniqueKeyFieldName)) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be the \" + DESTINATION + \" of a \" + COPY_FIELD + \"(\" + SOURCE + \"=\" +source+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          \n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n      }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n              \"and destination for multiple \" + COPY_FIELDS + \" (\"+\n              entry.getValue()+\")\");\n        }\n      }\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"057a1793765d068ea9302f1a29e21734ee58d41e","date":1408130117,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37e5b631c49de2fb88f245c36ecf87650cfa4a24","date":1409693105,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/@text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f52362fa746c58f10354f9454bed2b89f59c06b2","date":1409868448,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getConfigDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getConfigDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getInstanceDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getInstanceDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":["83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0"],"bugIntro":["e6df93694b323143943a3cc9169775db9a920197"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bdf16ebe435fc9daea90a73b8683ff001c6d3523","date":1409931231,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getConfigDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getConfigDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n\n      // load the Field Types\n\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n\n      //               /schema/fieldtype | /schema/fieldType | /schema/types/fieldtype | /schema/types/fieldType\n      expression = stepsToPath(SCHEMA, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?)\n          + XPATH_OR + stepsToPath(SCHEMA, FIELD_TYPE)\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT))\n          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getConfigDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getConfigDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6df93694b323143943a3cc9169775db9a920197","date":1414102503,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema from \" + resourceName);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          loader.getConfigDir() + resourceName, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + loader.getConfigDir() + resourceName,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207","f52362fa746c58f10354f9454bed2b89f59c06b2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71387d8cb6923eb831b17a8b734608ba2e21c653","date":1414126093,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {\n          similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);\n        }\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d62f72d1c60d2be239222de52d5e7b516da5f6f","date":1428554550,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d340859910d4dceee54b4c948c16d82109476e9","date":1446747594,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new ClassicSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4d385347f072fe4bec27fd10aa036fb43648b98","date":1446749053,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new ClassicSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f74cac9b012a2a02d55bf0b9497c963ced51b41","date":1446824750,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new ClassicSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new DefaultSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"49dd2950028d6b59839f54d3801d77f769fa22ef","date":1447264120,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0)) {\n          similarityFactory = new BM25SimilarityFactory();\n        } else {\n          similarityFactory = new ClassicSimilarityFactory();\n        }\n        final NamedList similarityParams = new NamedList();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        similarityFactory = new ClassicSimilarityFactory();\n        final NamedList similarityParams = new NamedList();\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a626ec4d1c92e59fe390724d6220081047b03ce7","date":1448021525,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0)) {\n          similarityFactory = new BM25SimilarityFactory();\n        } else {\n          similarityFactory = new ClassicSimilarityFactory();\n        }\n        final NamedList similarityParams = new NamedList();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    String resourcePath = CloudUtil.unifiedResourcePath(loader) + resourceName;\n    log.info(\"Reading Solr Schema from \" + resourcePath);\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0)) {\n          similarityFactory = new BM25SimilarityFactory();\n        } else {\n          similarityFactory = new ClassicSimilarityFactory();\n        }\n        final NamedList similarityParams = new NamedList();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()), e.getMessage() + \". Schema file is \" +\n          resourcePath, e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Schema Parsing Failed: \" + e.getMessage() + \". Schema file is \" + resourcePath,\n          e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62f0db4d9791c564008d2defb3415c50e99f5425","date":1448038834,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        Version luceneVersion = getDefaultLuceneMatchVersion();\n        if (getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0)) {\n          similarityFactory = new BM25SimilarityFactory();\n        } else {\n          similarityFactory = new ClassicSimilarityFactory();\n        }\n        final NamedList similarityParams = new NamedList();\n        similarityFactory.init(SolrParams.toSolrParams(similarityParams));\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f0c8426396c925de8db3ed3f8ff40fd73670a5c","date":1474556641,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"[{}] unique key field: {}\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"126d6ad24eed13163ba0959435d5a80e5672837c","date":1474567302,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"[{}] unique key field: {}\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"553676f3825d76d371442e566bde0f95de03602b","date":1474579888,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            coreName, queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"[{}] unique key field: {}\",\n            coreName, uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"[{}] unique key field: {}\",\n            loader.getCoreProperties().getProperty(SOLR_CORE_NAME), uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d62172dd2fc1195c7e475550ac394a9948a18ae","date":1474974102,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.warn(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            coreName, queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            coreName, queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"[{}] unique key field: {}\",\n            coreName, uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":["92f8ab19a30ff70981e43b8cc78069cb0941476e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.warn(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            coreName, queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.warn(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            coreName, queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      if (loader.getCoreProperties() != null) {\n        sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));\n      } else {\n        sb.append(\"null\");\n      }\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.info(\"default search field in schema is \"+defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"using default query parser operator (OR)\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c418b5fb43bf7b591b636df532dd1ac44296469a","date":1494834249,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.warn(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            coreName, queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f","date":1495081498,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.warn(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            coreName, queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d057970b5f9fcaabc49d2f54c59a5d2a09da1769","date":1495200448,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"no default search field specified in schema.\");\n      } else {\n        defaultSearchFieldName=node.getNodeValue().trim();\n        // throw exception if specified, but not found or not indexed\n        if (defaultSearchFieldName!=null) {\n          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n            String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n        log.warn(\"[{}] default search field in schema is {}. WARNING: Deprecated, please use 'df' on request instead.\",\n            coreName, defaultSearchFieldName);\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.debug(\"Default query parser operator not set in Schema\");\n      } else {\n        isExplicitQueryParserDefaultOperator = true;\n        queryParserDefaultOperator=node.getNodeValue().trim();\n        log.warn(\"[{}] query parser default operator is {}. WARNING: Deprecated, please use 'q.op' on request instead.\",\n            coreName, queryParserDefaultOperator);\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"971845d6bc50ab0157b3e338a283ce62d69e0384","date":1497033549,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92f8ab19a30ff70981e43b8cc78069cb0941476e","date":1497374252,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd","0d62172dd2fc1195c7e475550ac394a9948a18ae"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n\n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4","date":1499084229,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc018b79379c67835b40b1259cd3dc931df60944","date":1499109112,"type":3,"author":"Anshum Gupta","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final boolean modernSim = getDefaultLuceneMatchVersion().onOrAfter(Version.LUCENE_6_0_0);\n        final Class simClass = modernSim ? SchemaSimilarityFactory.class : ClassicSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee622110ba6021d0390037e77574743c1e55348c","date":1546700916,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df151630bfbea5338a007b97bfd37e4ec94f873f","date":1553017904,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    assert null != is : \"schema InputSource should never be null\";\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3","date":1583932828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    assert null != is : \"schema InputSource should never be null\";\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH, substitutableProperties);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    assert null != is : \"schema InputSource should never be null\";\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      String coreName = getCoreName(\"null\");\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      sb.append(\"[\");\n      sb.append(coreName);\n      sb.append(\"] \");\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    assert null != is : \"schema InputSource should never be null\";\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH, substitutableProperties);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(\"{}\", sb);\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(\"{}\", sb);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no {} specified in schema.\", UNIQUE_KEY);\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(\"{} is not stored - distributed search and MoreLikeThis will not work\", UNIQUE_KEY);\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    assert null != is : \"schema InputSource should never be null\";\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH, substitutableProperties);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(sb.toString());\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(sb.toString());\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no \" + UNIQUE_KEY + \" specified in schema.\");\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(UNIQUE_KEY + \" is not stored - distributed search and MoreLikeThis will not work\");\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  protected void readSchema(InputSource is) {\n    assert null != is : \"schema InputSource should never be null\";\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH, substitutableProperties);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(\"{}\", sb);\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(\"{}\", sb);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(solrClassLoader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(solrClassLoader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = solrClassLoader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no {} specified in schema.\", UNIQUE_KEY);\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(\"{} is not stored - distributed search and MoreLikeThis will not work\", UNIQUE_KEY);\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }\n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n\n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","sourceOld":"  protected void readSchema(InputSource is) {\n    assert null != is : \"schema InputSource should never be null\";\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      XmlConfigFile schemaConf = new XmlConfigFile(loader, SCHEMA, is, SLASH+SCHEMA+SLASH, substitutableProperties);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      String expression = stepsToPath(SCHEMA, AT + NAME);\n      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      StringBuilder sb = new StringBuilder();\n      // Another case where the initialization from the test harness is different than the \"real world\"\n      if (nd==null) {\n        sb.append(\"schema has no name!\");\n        log.warn(\"{}\", sb);\n      } else {\n        name = nd.getNodeValue();\n        sb.append(\"Schema \");\n        sb.append(NAME);\n        sb.append(\"=\");\n        sb.append(name);\n        log.info(\"{}\", sb);\n      }\n\n      //                      /schema/@version\n      expression = stepsToPath(SCHEMA, AT + VERSION);\n      version = schemaConf.getFloat(expression, 1.0f);\n\n      // load the Field Types\n      final FieldTypePluginLoader typeLoader = new FieldTypePluginLoader(this, fieldTypes, schemaAware);\n      expression = getFieldTypeXPathExpressions();\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      typeLoader.load(loader, nodes);\n\n      // load the fields\n      Map<String,Boolean> explicitRequiredProp = loadFields(document, xpath);\n\n      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity\n      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      similarityFactory = readSimilarity(loader, node);\n      if (similarityFactory == null) {\n        final Class<?> simClass = SchemaSimilarityFactory.class;\n        // use the loader to ensure proper SolrCoreAware handling\n        similarityFactory = loader.newInstance(simClass.getName(), SimilarityFactory.class);\n        similarityFactory.init(new ModifiableSolrParams());\n      } else {\n        isExplicitSimilarity = true;\n      }\n      if ( ! (similarityFactory instanceof SolrCoreAware)) {\n        // if the sim factory isn't SolrCoreAware (and hence schema aware), \n        // then we are responsible for erroring if a field type is trying to specify a sim.\n        for (FieldType ft : fieldTypes.values()) {\n          if (null != ft.getSimilarity()) {\n            String msg = \"FieldType '\" + ft.getTypeName()\n                + \"' is configured with a similarity, but the global similarity does not support it: \" \n                + similarityFactory.getClass();\n            log.error(msg);\n            throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n          }\n        }\n      }\n\n      //                      /schema/defaultSearchField/text()\n      expression = stepsToPath(SCHEMA, \"defaultSearchField\", TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting defaultSearchField in schema not supported since Solr 7\");\n      }\n\n      //                      /schema/solrQueryParser/@defaultOperator\n      expression = stepsToPath(SCHEMA, \"solrQueryParser\", AT + \"defaultOperator\");\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node != null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Setting default operator in schema (solrQueryParser/@defaultOperator) not supported\");\n      }\n\n      //                      /schema/uniqueKey/text()\n      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);\n      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);\n      if (node==null) {\n        log.warn(\"no {} specified in schema.\", UNIQUE_KEY);\n      } else {\n        uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n        uniqueKeyFieldName=uniqueKeyField.getName();\n        uniqueKeyFieldType=uniqueKeyField.getType();\n        \n        // we fail on init if the ROOT field is *explicitly* defined as incompatible with uniqueKey\n        // we don't want ot fail if there happens to be a dynamicField matching ROOT, (ie: \"*\")\n        // because the user may not care about child docs at all.  The run time code\n        // related to child docs can catch that if it happens\n        if (fields.containsKey(ROOT_FIELD_NAME) && ! isUsableForChildDocs()) {\n          String msg = ROOT_FIELD_NAME + \" field must be defined using the exact same fieldType as the \" +\n            UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\") uses: \" + uniqueKeyFieldType.getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        if (null != uniqueKeyField.getDefaultValue()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured with a default value (\"+\n              uniqueKeyField.getDefaultValue()+\")\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (!uniqueKeyField.stored()) {\n          log.warn(\"{} is not stored - distributed search and MoreLikeThis will not work\", UNIQUE_KEY);\n        }\n        if (uniqueKeyField.multiValued()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n              \") can not be configured to be multivalued\";\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n\n        if (uniqueKeyField.getType().isPointField()) {\n          String msg = UNIQUE_KEY + \" field (\"+uniqueKeyFieldName+\n            \") can not be configured to use a Points based FieldType: \" + uniqueKeyField.getType().getTypeName();\n          log.error(msg);\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n        \n        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n          uniqueKeyField.required = true;\n          requiredFields.add(uniqueKeyField);\n        }\n      }                \n\n      /////////////// parse out copyField commands ///////////////\n      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n      // expression = \"/schema/copyField\";\n    \n      dynamicCopyFields = new DynamicCopy[] {};\n      loadCopyFields(document, xpath);\n\n      postReadInform();\n\n    } catch (SolrException e) {\n      throw new SolrException(ErrorCode.getErrorCode(e.code()),\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Can't load schema \" + loader.resourceLocation(resourceName) + \": \" + e.getMessage(), e);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n    log.info(\"Loaded schema {}/{} with uniqueid field {}\", name, version, uniqueKeyFieldName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e4ab92b64eeccdec7c69da247536d8359470cd04":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"553676f3825d76d371442e566bde0f95de03602b":["126d6ad24eed13163ba0959435d5a80e5672837c"],"49dd2950028d6b59839f54d3801d77f769fa22ef":["2f74cac9b012a2a02d55bf0b9497c963ced51b41"],"72eacaf7d2bf30907a4f9bf8f734aea16c55d28a":["83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0"],"f239f19602502b42a1690c6a62c87501f34d93ab":["16c8b96bb5b688807272bd6bee7051c5168e1a10"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"4459434909d3f425a264c2f611dcfccb9fa65564":["72eacaf7d2bf30907a4f9bf8f734aea16c55d28a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"15cacbf46c73bd5b0e47b57128be8852cb236160":["e4ab92b64eeccdec7c69da247536d8359470cd04"],"a626ec4d1c92e59fe390724d6220081047b03ce7":["49dd2950028d6b59839f54d3801d77f769fa22ef"],"971845d6bc50ab0157b3e338a283ce62d69e0384":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["aa6d0ca44ce171ad041951fa8fb94731b7d778d9"],"cf718fc7210fb8e7744d4b69704a4c9f732d1e92":["f09ac0abea5345f77c4cf8d9f0d531da9139debc"],"ee622110ba6021d0390037e77574743c1e55348c":["cc018b79379c67835b40b1259cd3dc931df60944"],"30c8e5574b55d57947e989443dfde611646530ee":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cc018b79379c67835b40b1259cd3dc931df60944"],"37e5b631c49de2fb88f245c36ecf87650cfa4a24":["057a1793765d068ea9302f1a29e21734ee58d41e"],"220acde8206f5221383e3777429a4fb84bed289f":["0b7003c9a9780c96f84f429c910f05038ba58b99"],"9d62f72d1c60d2be239222de52d5e7b516da5f6f":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"126d6ad24eed13163ba0959435d5a80e5672837c":["62f0db4d9791c564008d2defb3415c50e99f5425","7f0c8426396c925de8db3ed3f8ff40fd73670a5c"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9cf81bc8c6e4078e236f0e38b3a2d0271854f207":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"0d340859910d4dceee54b4c948c16d82109476e9":["9d62f72d1c60d2be239222de52d5e7b516da5f6f"],"e6df93694b323143943a3cc9169775db9a920197":["bdf16ebe435fc9daea90a73b8683ff001c6d3523"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["220acde8206f5221383e3777429a4fb84bed289f","8aec175aa53c7af1baf595a8a4d333e670bfe94b"],"d1e0c121d6dbaebf97724020e374b4bc28b95a44":["8f2c5389fcac652b2b765661515d7bc3e4e19937"],"2f74cac9b012a2a02d55bf0b9497c963ced51b41":["b4d385347f072fe4bec27fd10aa036fb43648b98"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["8aec175aa53c7af1baf595a8a4d333e670bfe94b","8f2c5389fcac652b2b765661515d7bc3e4e19937"],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["d1e0c121d6dbaebf97724020e374b4bc28b95a44"],"8aec175aa53c7af1baf595a8a4d333e670bfe94b":["220acde8206f5221383e3777429a4fb84bed289f"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"bdf16ebe435fc9daea90a73b8683ff001c6d3523":["f52362fa746c58f10354f9454bed2b89f59c06b2"],"15e1bc9368a5cae1776f5b12df9dac1b0477f8f4":["4459434909d3f425a264c2f611dcfccb9fa65564"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["8f2c5389fcac652b2b765661515d7bc3e4e19937","d1e0c121d6dbaebf97724020e374b4bc28b95a44"],"09d7b02899d5e2425517737c5c091f6878ff08a3":["28d2c2e2cfdd54f85fbd98b7c519357992039651"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":["dd330c9d05eacbd6e952fe0dea852e7ae037eb50","24b51843dd98041bc40be26a47e44d7cb49bef72"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d057970b5f9fcaabc49d2f54c59a5d2a09da1769":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"057a1793765d068ea9302f1a29e21734ee58d41e":["24b51843dd98041bc40be26a47e44d7cb49bef72"],"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","c418b5fb43bf7b591b636df532dd1ac44296469a"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["e6df93694b323143943a3cc9169775db9a920197"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["62f0db4d9791c564008d2defb3415c50e99f5425"],"08970e5b8411182a29412c177eff67ec1110095b":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207"],"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4":["28288370235ed02234a64753cdbf0c6ec096304a"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["df151630bfbea5338a007b97bfd37e4ec94f873f"],"df151630bfbea5338a007b97bfd37e4ec94f873f":["ee622110ba6021d0390037e77574743c1e55348c"],"24b51843dd98041bc40be26a47e44d7cb49bef72":["dd330c9d05eacbd6e952fe0dea852e7ae037eb50"],"aa6d0ca44ce171ad041951fa8fb94731b7d778d9":["cf718fc7210fb8e7744d4b69704a4c9f732d1e92"],"b4d385347f072fe4bec27fd10aa036fb43648b98":["0d340859910d4dceee54b4c948c16d82109476e9"],"8f2c5389fcac652b2b765661515d7bc3e4e19937":["8aec175aa53c7af1baf595a8a4d333e670bfe94b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["62f0db4d9791c564008d2defb3415c50e99f5425","0d62172dd2fc1195c7e475550ac394a9948a18ae"],"cc018b79379c67835b40b1259cd3dc931df60944":["28288370235ed02234a64753cdbf0c6ec096304a","cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4"],"83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0":["f239f19602502b42a1690c6a62c87501f34d93ab"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["553676f3825d76d371442e566bde0f95de03602b"],"f52362fa746c58f10354f9454bed2b89f59c06b2":["37e5b631c49de2fb88f245c36ecf87650cfa4a24"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["971845d6bc50ab0157b3e338a283ce62d69e0384"],"28d2c2e2cfdd54f85fbd98b7c519357992039651":["08970e5b8411182a29412c177eff67ec1110095b"],"28288370235ed02234a64753cdbf0c6ec096304a":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["62f0db4d9791c564008d2defb3415c50e99f5425","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"16c8b96bb5b688807272bd6bee7051c5168e1a10":["09d7b02899d5e2425517737c5c091f6878ff08a3"],"f09ac0abea5345f77c4cf8d9f0d531da9139debc":["c26f00b574427b55127e869b935845554afde1fa"],"0b7003c9a9780c96f84f429c910f05038ba58b99":["15cacbf46c73bd5b0e47b57128be8852cb236160"],"c418b5fb43bf7b591b636df532dd1ac44296469a":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","8f2c5389fcac652b2b765661515d7bc3e4e19937"],"dd330c9d05eacbd6e952fe0dea852e7ae037eb50":["15e1bc9368a5cae1776f5b12df9dac1b0477f8f4"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"62f0db4d9791c564008d2defb3415c50e99f5425":["a626ec4d1c92e59fe390724d6220081047b03ce7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"9df8125ba9193a2e2e285ed92157810b1952a244":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"]},"commit2Childs":{"e4ab92b64eeccdec7c69da247536d8359470cd04":["15cacbf46c73bd5b0e47b57128be8852cb236160"],"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"553676f3825d76d371442e566bde0f95de03602b":["0d62172dd2fc1195c7e475550ac394a9948a18ae"],"49dd2950028d6b59839f54d3801d77f769fa22ef":["a626ec4d1c92e59fe390724d6220081047b03ce7"],"72eacaf7d2bf30907a4f9bf8f734aea16c55d28a":["4459434909d3f425a264c2f611dcfccb9fa65564"],"f239f19602502b42a1690c6a62c87501f34d93ab":["83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["e4ab92b64eeccdec7c69da247536d8359470cd04"],"4459434909d3f425a264c2f611dcfccb9fa65564":["15e1bc9368a5cae1776f5b12df9dac1b0477f8f4"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"15cacbf46c73bd5b0e47b57128be8852cb236160":["0b7003c9a9780c96f84f429c910f05038ba58b99"],"a626ec4d1c92e59fe390724d6220081047b03ce7":["62f0db4d9791c564008d2defb3415c50e99f5425"],"971845d6bc50ab0157b3e338a283ce62d69e0384":["92f8ab19a30ff70981e43b8cc78069cb0941476e"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"cf718fc7210fb8e7744d4b69704a4c9f732d1e92":["aa6d0ca44ce171ad041951fa8fb94731b7d778d9"],"ee622110ba6021d0390037e77574743c1e55348c":["df151630bfbea5338a007b97bfd37e4ec94f873f"],"30c8e5574b55d57947e989443dfde611646530ee":[],"37e5b631c49de2fb88f245c36ecf87650cfa4a24":["f52362fa746c58f10354f9454bed2b89f59c06b2"],"220acde8206f5221383e3777429a4fb84bed289f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","8aec175aa53c7af1baf595a8a4d333e670bfe94b"],"126d6ad24eed13163ba0959435d5a80e5672837c":["553676f3825d76d371442e566bde0f95de03602b"],"9d62f72d1c60d2be239222de52d5e7b516da5f6f":["0d340859910d4dceee54b4c948c16d82109476e9"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9cf81bc8c6e4078e236f0e38b3a2d0271854f207":["08970e5b8411182a29412c177eff67ec1110095b"],"0d340859910d4dceee54b4c948c16d82109476e9":["b4d385347f072fe4bec27fd10aa036fb43648b98"],"e6df93694b323143943a3cc9169775db9a920197":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"d1e0c121d6dbaebf97724020e374b4bc28b95a44":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"2f74cac9b012a2a02d55bf0b9497c963ced51b41":["49dd2950028d6b59839f54d3801d77f769fa22ef"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b"],"8aec175aa53c7af1baf595a8a4d333e670bfe94b":["fe33227f6805edab2036cbb80645cc4e2d1fa424","d6f074e73200c07d54f242d3880a8da5a35ff97b","8f2c5389fcac652b2b765661515d7bc3e4e19937"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["30c8e5574b55d57947e989443dfde611646530ee"],"bdf16ebe435fc9daea90a73b8683ff001c6d3523":["e6df93694b323143943a3cc9169775db9a920197"],"15e1bc9368a5cae1776f5b12df9dac1b0477f8f4":["dd330c9d05eacbd6e952fe0dea852e7ae037eb50"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"09d7b02899d5e2425517737c5c091f6878ff08a3":["16c8b96bb5b688807272bd6bee7051c5168e1a10"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":[],"c26f00b574427b55127e869b935845554afde1fa":["f09ac0abea5345f77c4cf8d9f0d531da9139debc"],"d057970b5f9fcaabc49d2f54c59a5d2a09da1769":["e9017cf144952056066919f1ebc7897ff9bd71b1","971845d6bc50ab0157b3e338a283ce62d69e0384","28288370235ed02234a64753cdbf0c6ec096304a"],"057a1793765d068ea9302f1a29e21734ee58d41e":["37e5b631c49de2fb88f245c36ecf87650cfa4a24"],"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["9d62f72d1c60d2be239222de52d5e7b516da5f6f"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["126d6ad24eed13163ba0959435d5a80e5672837c"],"08970e5b8411182a29412c177eff67ec1110095b":["28d2c2e2cfdd54f85fbd98b7c519357992039651"],"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4":["cc018b79379c67835b40b1259cd3dc931df60944"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["9df8125ba9193a2e2e285ed92157810b1952a244"],"24b51843dd98041bc40be26a47e44d7cb49bef72":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","057a1793765d068ea9302f1a29e21734ee58d41e"],"df151630bfbea5338a007b97bfd37e4ec94f873f":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"aa6d0ca44ce171ad041951fa8fb94731b7d778d9":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e9017cf144952056066919f1ebc7897ff9bd71b1","c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c418b5fb43bf7b591b636df532dd1ac44296469a"],"8f2c5389fcac652b2b765661515d7bc3e4e19937":["d1e0c121d6dbaebf97724020e374b4bc28b95a44","d6f074e73200c07d54f242d3880a8da5a35ff97b","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"b4d385347f072fe4bec27fd10aa036fb43648b98":["2f74cac9b012a2a02d55bf0b9497c963ced51b41"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"cc018b79379c67835b40b1259cd3dc931df60944":["ee622110ba6021d0390037e77574743c1e55348c","30c8e5574b55d57947e989443dfde611646530ee"],"83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0":["72eacaf7d2bf30907a4f9bf8f734aea16c55d28a"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"f52362fa746c58f10354f9454bed2b89f59c06b2":["bdf16ebe435fc9daea90a73b8683ff001c6d3523"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","28288370235ed02234a64753cdbf0c6ec096304a"],"28d2c2e2cfdd54f85fbd98b7c519357992039651":["09d7b02899d5e2425517737c5c091f6878ff08a3"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4","cc018b79379c67835b40b1259cd3dc931df60944"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"16c8b96bb5b688807272bd6bee7051c5168e1a10":["f239f19602502b42a1690c6a62c87501f34d93ab"],"f09ac0abea5345f77c4cf8d9f0d531da9139debc":["cf718fc7210fb8e7744d4b69704a4c9f732d1e92"],"0b7003c9a9780c96f84f429c910f05038ba58b99":["220acde8206f5221383e3777429a4fb84bed289f"],"c418b5fb43bf7b591b636df532dd1ac44296469a":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"dd330c9d05eacbd6e952fe0dea852e7ae037eb50":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","24b51843dd98041bc40be26a47e44d7cb49bef72"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"62f0db4d9791c564008d2defb3415c50e99f5425":["126d6ad24eed13163ba0959435d5a80e5672837c","7f0c8426396c925de8db3ed3f8ff40fd73670a5c","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"9df8125ba9193a2e2e285ed92157810b1952a244":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","d6f074e73200c07d54f242d3880a8da5a35ff97b","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","e57c73924f3b8c19defa62e96bfa34a4922d49c2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}