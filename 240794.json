{"path":"solr/core/src/java/org/apache/solr/spelling/PossibilityIterator#internalNextAdvance().mjava","commits":[{"id":"0ad9ec888e587ca9a3279368245cdf00aabdc108","date":1338832525,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/PossibilityIterator#internalNextAdvance().mjava","pathOld":"/dev/null","sourceNew":"  private void internalNextAdvance() {\n    List<SpellCheckCorrection> possibleCorrection = null;\n    if (nextOnes != null && nextOnes.hasNext()) {\n      possibleCorrection = nextOnes.next();\n    } else {\n      if (done) {\n        throw new NoSuchElementException();\n      }\n      possibleCorrection = new ArrayList<SpellCheckCorrection>();\n      List<List<SpellCheckCorrection>> possibleCorrections = null;\n      int rank = 0;\n      while (!done\n          && (possibleCorrections == null || possibleCorrections.size() == 0)) {\n        rank = 0;\n        for (int i = 0; i < correctionIndex.length; i++) {\n          List<SpellCheckCorrection> singleWordPossibilities = possibilityList\n              .get(i);\n          SpellCheckCorrection singleWordPossibility = singleWordPossibilities\n              .get(correctionIndex[i]);\n          rank += correctionIndex[i];\n          if (i == correctionIndex.length - 1) {\n            correctionIndex[i]++;\n            if (correctionIndex[i] == singleWordPossibilities.size()) {\n              correctionIndex[i] = 0;\n              if (correctionIndex.length == 1) {\n                done = true;\n              }\n              for (int ii = i - 1; ii >= 0; ii--) {\n                correctionIndex[ii]++;\n                if (correctionIndex[ii] >= possibilityList.get(ii).size()\n                    && ii > 0) {\n                  correctionIndex[ii] = 0;\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n          possibleCorrection.add(singleWordPossibility);\n        }\n        if (correctionIndex[0] == possibilityList.get(0).size()) {\n          done = true;\n        }\n        if (suggestionsMayOverlap) {\n          possibleCorrections = separateOverlappingTokens(possibleCorrection);\n        } else {\n          possibleCorrections = new ArrayList<List<SpellCheckCorrection>>(1);\n          possibleCorrections.add(possibleCorrection);\n        }\n      }\n      nextOnes = possibleCorrections.iterator();\n      nextOnesRank = rank;\n      nextOnesIndex = 0;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/PossibilityIterator#internalNextAdvance().mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/PossibilityIterator#internalNextAdvance().mjava","sourceNew":"  private void internalNextAdvance() {\n    List<SpellCheckCorrection> possibleCorrection = null;\n    if (nextOnes != null && nextOnes.hasNext()) {\n      possibleCorrection = nextOnes.next();\n    } else {\n      if (done) {\n        throw new NoSuchElementException();\n      }\n      possibleCorrection = new ArrayList<>();\n      List<List<SpellCheckCorrection>> possibleCorrections = null;\n      int rank = 0;\n      while (!done\n          && (possibleCorrections == null || possibleCorrections.size() == 0)) {\n        rank = 0;\n        for (int i = 0; i < correctionIndex.length; i++) {\n          List<SpellCheckCorrection> singleWordPossibilities = possibilityList\n              .get(i);\n          SpellCheckCorrection singleWordPossibility = singleWordPossibilities\n              .get(correctionIndex[i]);\n          rank += correctionIndex[i];\n          if (i == correctionIndex.length - 1) {\n            correctionIndex[i]++;\n            if (correctionIndex[i] == singleWordPossibilities.size()) {\n              correctionIndex[i] = 0;\n              if (correctionIndex.length == 1) {\n                done = true;\n              }\n              for (int ii = i - 1; ii >= 0; ii--) {\n                correctionIndex[ii]++;\n                if (correctionIndex[ii] >= possibilityList.get(ii).size()\n                    && ii > 0) {\n                  correctionIndex[ii] = 0;\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n          possibleCorrection.add(singleWordPossibility);\n        }\n        if (correctionIndex[0] == possibilityList.get(0).size()) {\n          done = true;\n        }\n        if (suggestionsMayOverlap) {\n          possibleCorrections = separateOverlappingTokens(possibleCorrection);\n        } else {\n          possibleCorrections = new ArrayList<>(1);\n          possibleCorrections.add(possibleCorrection);\n        }\n      }\n      nextOnes = possibleCorrections.iterator();\n      nextOnesRank = rank;\n      nextOnesIndex = 0;\n    }\n  }\n\n","sourceOld":"  private void internalNextAdvance() {\n    List<SpellCheckCorrection> possibleCorrection = null;\n    if (nextOnes != null && nextOnes.hasNext()) {\n      possibleCorrection = nextOnes.next();\n    } else {\n      if (done) {\n        throw new NoSuchElementException();\n      }\n      possibleCorrection = new ArrayList<SpellCheckCorrection>();\n      List<List<SpellCheckCorrection>> possibleCorrections = null;\n      int rank = 0;\n      while (!done\n          && (possibleCorrections == null || possibleCorrections.size() == 0)) {\n        rank = 0;\n        for (int i = 0; i < correctionIndex.length; i++) {\n          List<SpellCheckCorrection> singleWordPossibilities = possibilityList\n              .get(i);\n          SpellCheckCorrection singleWordPossibility = singleWordPossibilities\n              .get(correctionIndex[i]);\n          rank += correctionIndex[i];\n          if (i == correctionIndex.length - 1) {\n            correctionIndex[i]++;\n            if (correctionIndex[i] == singleWordPossibilities.size()) {\n              correctionIndex[i] = 0;\n              if (correctionIndex.length == 1) {\n                done = true;\n              }\n              for (int ii = i - 1; ii >= 0; ii--) {\n                correctionIndex[ii]++;\n                if (correctionIndex[ii] >= possibilityList.get(ii).size()\n                    && ii > 0) {\n                  correctionIndex[ii] = 0;\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n          possibleCorrection.add(singleWordPossibility);\n        }\n        if (correctionIndex[0] == possibilityList.get(0).size()) {\n          done = true;\n        }\n        if (suggestionsMayOverlap) {\n          possibleCorrections = separateOverlappingTokens(possibleCorrection);\n        } else {\n          possibleCorrections = new ArrayList<List<SpellCheckCorrection>>(1);\n          possibleCorrections.add(possibleCorrection);\n        }\n      }\n      nextOnes = possibleCorrections.iterator();\n      nextOnesRank = rank;\n      nextOnesIndex = 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}