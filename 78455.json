{"path":"solr/core/src/java/org/apache/solr/cluster/placement/plugins/SamplePluginAffinityReplicaPlacement#computePlacement(Cluster,PlacementRequest,AttributeFetcher,PlacementPlanFactory).mjava","commits":[{"id":"f5d9700b23e8e9b11b845fcecef89dbdf21373d9","date":1600294231,"type":0,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/plugins/SamplePluginAffinityReplicaPlacement#computePlacement(Cluster,PlacementRequest,AttributeFetcher,PlacementPlanFactory).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressForbidden(reason = \"Ordering.arbitrary() has no equivalent in Comparator class. Rather reuse than copy.\")\n  public PlacementPlan computePlacement(Cluster cluster, PlacementRequest request, AttributeFetcher attributeFetcher,\n                                        PlacementPlanFactory placementPlanFactory) throws PlacementException {\n    Set<Node> nodes = request.getTargetNodes();\n    SolrCollection solrCollection = request.getCollection();\n\n    // Request all needed attributes\n    attributeFetcher.requestNodeSystemProperty(AVAILABILITY_ZONE_SYSPROP).requestNodeSystemProperty(REPLICA_TYPE_SYSPROP);\n    attributeFetcher.requestNodeCoreCount().requestNodeFreeDisk();\n    attributeFetcher.fetchFrom(nodes);\n    final AttributeValues attrValues = attributeFetcher.fetchAttributes();\n\n    // Split the set of nodes into 3 sets of nodes accepting each replica type (sets can overlap if nodes accept multiple replica types)\n    // These subsets sets are actually maps, because we capture the number of cores (of any replica type) present on each node.\n    // Also get the number of currently existing cores per node, so we can keep update as we place new cores to not end up\n    // always selecting the same node(s).\n    Pair<EnumMap<Replica.ReplicaType, Set<Node>>, Map<Node, Integer>> p = getNodesPerReplicaType(nodes, attrValues);\n\n    EnumMap<Replica.ReplicaType, Set<Node>> replicaTypeToNodes = p.first();\n    Map<Node, Integer> coresOnNodes = p.second();\n\n    // All available zones of live nodes. Due to some nodes not being candidates for placement, and some existing replicas\n    // being one availability zones that might be offline (i.e. their nodes are not live), this set might contain zones\n    // on which it is impossible to place replicas. That's ok.\n    ImmutableSet<String> availabilityZones = getZonesFromNodes(nodes, attrValues);\n\n    // Build the replica placement decisions here\n    Set<ReplicaPlacement> replicaPlacements = new HashSet<>();\n\n    // Let's now iterate on all shards to create replicas for and start finding home sweet homes for the replicas\n    for (String shardName : request.getShardNames()) {\n      // Iterate on the replica types in the enum order. We place more strategic replicas first\n      // (NRT is more strategic than TLOG more strategic than PULL). This is in case we eventually decide that less\n      // strategic replica placement impossibility is not a problem that should lead to replica placement computation\n      // failure. Current code does fail if placement is impossible (constraint is at most one replica of a shard on any node).\n      for (Replica.ReplicaType replicaType : Replica.ReplicaType.values()) {\n        makePlacementDecisions(solrCollection, shardName, availabilityZones, replicaType, request.getCountReplicasToCreate(replicaType),\n                attrValues, replicaTypeToNodes, coresOnNodes, placementPlanFactory, replicaPlacements);\n      }\n    }\n\n    return placementPlanFactory.createPlacementPlan(request, replicaPlacements);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65352f844eb9e9a677ec4eb2abced4404f08181d","date":1600297608,"type":0,"author":"noblepaul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/plugins/SamplePluginAffinityReplicaPlacement#computePlacement(Cluster,PlacementRequest,AttributeFetcher,PlacementPlanFactory).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressForbidden(reason = \"Ordering.arbitrary() has no equivalent in Comparator class. Rather reuse than copy.\")\n  public PlacementPlan computePlacement(Cluster cluster, PlacementRequest request, AttributeFetcher attributeFetcher,\n                                        PlacementPlanFactory placementPlanFactory) throws PlacementException {\n    Set<Node> nodes = request.getTargetNodes();\n    SolrCollection solrCollection = request.getCollection();\n\n    // Request all needed attributes\n    attributeFetcher.requestNodeSystemProperty(AVAILABILITY_ZONE_SYSPROP).requestNodeSystemProperty(REPLICA_TYPE_SYSPROP);\n    attributeFetcher.requestNodeCoreCount().requestNodeFreeDisk();\n    attributeFetcher.fetchFrom(nodes);\n    final AttributeValues attrValues = attributeFetcher.fetchAttributes();\n\n    // Split the set of nodes into 3 sets of nodes accepting each replica type (sets can overlap if nodes accept multiple replica types)\n    // These subsets sets are actually maps, because we capture the number of cores (of any replica type) present on each node.\n    // Also get the number of currently existing cores per node, so we can keep update as we place new cores to not end up\n    // always selecting the same node(s).\n    Pair<EnumMap<Replica.ReplicaType, Set<Node>>, Map<Node, Integer>> p = getNodesPerReplicaType(nodes, attrValues);\n\n    EnumMap<Replica.ReplicaType, Set<Node>> replicaTypeToNodes = p.first();\n    Map<Node, Integer> coresOnNodes = p.second();\n\n    // All available zones of live nodes. Due to some nodes not being candidates for placement, and some existing replicas\n    // being one availability zones that might be offline (i.e. their nodes are not live), this set might contain zones\n    // on which it is impossible to place replicas. That's ok.\n    ImmutableSet<String> availabilityZones = getZonesFromNodes(nodes, attrValues);\n\n    // Build the replica placement decisions here\n    Set<ReplicaPlacement> replicaPlacements = new HashSet<>();\n\n    // Let's now iterate on all shards to create replicas for and start finding home sweet homes for the replicas\n    for (String shardName : request.getShardNames()) {\n      // Iterate on the replica types in the enum order. We place more strategic replicas first\n      // (NRT is more strategic than TLOG more strategic than PULL). This is in case we eventually decide that less\n      // strategic replica placement impossibility is not a problem that should lead to replica placement computation\n      // failure. Current code does fail if placement is impossible (constraint is at most one replica of a shard on any node).\n      for (Replica.ReplicaType replicaType : Replica.ReplicaType.values()) {\n        makePlacementDecisions(solrCollection, shardName, availabilityZones, replicaType, request.getCountReplicasToCreate(replicaType),\n                attrValues, replicaTypeToNodes, coresOnNodes, placementPlanFactory, replicaPlacements);\n      }\n    }\n\n    return placementPlanFactory.createPlacementPlan(request, replicaPlacements);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"65352f844eb9e9a677ec4eb2abced4404f08181d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f5d9700b23e8e9b11b845fcecef89dbdf21373d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65352f844eb9e9a677ec4eb2abced4404f08181d"]},"commit2Childs":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["65352f844eb9e9a677ec4eb2abced4404f08181d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f5d9700b23e8e9b11b845fcecef89dbdf21373d9","65352f844eb9e9a677ec4eb2abced4404f08181d"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}