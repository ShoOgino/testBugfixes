{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicy(LogDocMergePolicy.class.getName());\n    systemSetPropertySolrTestsMergePolicyFactory(LogDocMergePolicyFactory.class.getName());\n    \n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicy(LogDocMergePolicy.class.getName());\n    systemSetPropertySolrTestsMergePolicyFactory(LogDocMergePolicyFactory.class.getName());\n    \n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n    \n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicy(LogDocMergePolicy.class.getName());\n    systemSetPropertySolrTestsMergePolicyFactory(LogDocMergePolicyFactory.class.getName());\n    \n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a90707313d8771252add9c6b6e290868f5ee5","date":1488893546,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    // HACK: Don't use a RandomMergePolicy, but only use the mergePolicyFactory that we've just set\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICYFACTORY, \"true\");\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICY, \"false\");\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n    \n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70d848516a5d0b23d183a2ceb4f4fb8634205956","date":1496408348,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    // HACK: Don't use a RandomMergePolicy, but only use the mergePolicyFactory that we've just set\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICYFACTORY, \"true\");\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICY, \"false\");\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    // HACK: Don't use a RandomMergePolicy, but only use the mergePolicyFactory that we've just set\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICYFACTORY, \"true\");\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICY, \"false\");\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41725d3c68dcac6ccfe29dec314c6e56a62cebb4","date":1498237980,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    System.setProperty(\"solr.tests.intClassName\", random().nextBoolean()? \"TrieIntField\": \"IntPointField\");\n    System.setProperty(\"solr.tests.longClassName\", random().nextBoolean()? \"TrieLongField\": \"LongPointField\");\n    System.setProperty(\"solr.tests.floatClassName\", random().nextBoolean()? \"TrieFloatField\": \"FloatPointField\");\n    System.setProperty(\"solr.tests.doubleClassName\", random().nextBoolean()? \"TrieDoubleField\": \"DoublePointField\");\n\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    // HACK: Don't use a RandomMergePolicy, but only use the mergePolicyFactory that we've just set\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICYFACTORY, \"true\");\n    System.setProperty(SYSTEM_PROPERTY_SOLR_TESTS_USEMERGEPOLICY, \"false\");\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e1bfbfa5a260860e3f12522fca45ec1240752f","date":1521057510,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    randomizeUpdateLogImpl();\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1","date":1598647393,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#beforeSuperClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeSuperClass() throws Exception {\n    schemaString = \"schema-inplace-updates.xml\";\n    configString = \"solrconfig-tlog.xml\";\n\n    // we need consistent segments that aren't re-ordered on merge because we're\n    // asserting inplace updates happen by checking the internal [docid]\n    systemSetPropertySolrTestsMergePolicyFactory(NoMergePolicyFactory.class.getName());\n\n    randomizeUpdateLogImpl();\n\n    initCore(configString, schemaString);\n    \n    // sanity check that autocommits are disabled\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxTime);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoCommmitMaxDocs);\n    assertEquals(-1, h.getCore().getSolrConfig().getUpdateHandlerInfo().autoSoftCommmitMaxDocs);\n    \n    // assert that NoMergePolicy was chosen\n    RefCounted<IndexWriter> iw = h.getCore().getSolrCoreState().getIndexWriter(h.getCore());\n    try {\n      IndexWriter writer = iw.get();\n      assertTrue(\"Actual merge policy is: \" + writer.getConfig().getMergePolicy(),\n          writer.getConfig().getMergePolicy() instanceof NoMergePolicy); \n    } finally {\n      iw.decref();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"41725d3c68dcac6ccfe29dec314c6e56a62cebb4":["70d848516a5d0b23d183a2ceb4f4fb8634205956"],"70d848516a5d0b23d183a2ceb4f4fb8634205956":["104a90707313d8771252add9c6b6e290868f5ee5"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["e9017cf144952056066919f1ebc7897ff9bd71b1","41725d3c68dcac6ccfe29dec314c6e56a62cebb4"],"28288370235ed02234a64753cdbf0c6ec096304a":["104a90707313d8771252add9c6b6e290868f5ee5","41725d3c68dcac6ccfe29dec314c6e56a62cebb4"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["104a90707313d8771252add9c6b6e290868f5ee5","70d848516a5d0b23d183a2ceb4f4fb8634205956"],"17e1bfbfa5a260860e3f12522fca45ec1240752f":["28288370235ed02234a64753cdbf0c6ec096304a"],"104a90707313d8771252add9c6b6e290868f5ee5":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["17e1bfbfa5a260860e3f12522fca45ec1240752f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"41725d3c68dcac6ccfe29dec314c6e56a62cebb4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"70d848516a5d0b23d183a2ceb4f4fb8634205956":["41725d3c68dcac6ccfe29dec314c6e56a62cebb4","e9017cf144952056066919f1ebc7897ff9bd71b1"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["17e1bfbfa5a260860e3f12522fca45ec1240752f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"17e1bfbfa5a260860e3f12522fca45ec1240752f":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"104a90707313d8771252add9c6b6e290868f5ee5":["70d848516a5d0b23d183a2ceb4f4fb8634205956","28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["104a90707313d8771252add9c6b6e290868f5ee5"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}