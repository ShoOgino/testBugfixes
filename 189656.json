{"path":"lucene/contrib/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","commits":[{"id":"f9fdc0777b84633cc8cfa8995ff5b0d411e4515b","date":1313816278,"type":1,"author":"Christopher John Male","isMerge":false,"pathNew":"lucene/contrib/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"lucene/contrib/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f9fdc0777b84633cc8cfa8995ff5b0d411e4515b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["f9fdc0777b84633cc8cfa8995ff5b0d411e4515b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"f9fdc0777b84633cc8cfa8995ff5b0d411e4515b":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f9fdc0777b84633cc8cfa8995ff5b0d411e4515b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}