{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester#createResults(TopDocs,int,CharSequence,boolean,Set[String],String).mjava","commits":[{"id":"f13ec1b606a28789743a563929e7c556e8218297","date":1389302034,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester#createResults(TopDocs,int,CharSequence,boolean,Set[String],String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create the results based on the search hits.\n   * Can be overridden by subclass to add particular behavior (e.g. weight transformation)\n   * @throws IOException If there are problems reading fields from the underlying Lucene index.\n   */\n  protected List<LookupResult> createResults(TopDocs hits, int num, CharSequence charSequence,\n                                             boolean doHighlight, Set<String> matchedTokens, String prefixToken)\n      throws IOException {\n\n    List<LookupResult> results = new ArrayList<LookupResult>();\n    BytesRef scratch = new BytesRef();\n    for (int i=0;i<hits.scoreDocs.length;i++) {\n      ScoreDoc sd = hits.scoreDocs[i];\n      textDV.get(sd.doc, scratch);\n      String text = scratch.utf8ToString();\n      long score = weightsDV.get(sd.doc);\n\n      BytesRef payload;\n      if (payloadsDV != null) {\n        payload = new BytesRef();\n        payloadsDV.get(sd.doc, payload);\n      } else {\n        payload = null;\n      }\n\n      LookupResult result;\n\n      if (doHighlight) {\n        Object highlightKey = highlight(text, matchedTokens, prefixToken);\n        result = new LookupResult(highlightKey.toString(), highlightKey, score, payload);\n      } else {\n        result = new LookupResult(text, score, payload);\n      }\n\n      results.add(result);\n    }\n\n    return results;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["79854637616b791a00f39ee3d5257ea093804ddb","ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a371aa649cc243e82cb8677ca960a1e0232ecedf","date":1393605574,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester#createResults(IndexSearcher,TopFieldDocs,int,CharSequence,boolean,Set[String],String).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester#createResults(TopDocs,int,CharSequence,boolean,Set[String],String).mjava","sourceNew":"  /**\n   * Create the results based on the search hits.\n   * Can be overridden by subclass to add particular behavior (e.g. weight transformation)\n   * @throws IOException If there are problems reading fields from the underlying Lucene index.\n   */\n  protected List<LookupResult> createResults(IndexSearcher searcher, TopFieldDocs hits, int num,\n                                             CharSequence charSequence,\n                                             boolean doHighlight, Set<String> matchedTokens, String prefixToken)\n      throws IOException {\n\n    BinaryDocValues textDV = MultiDocValues.getBinaryValues(searcher.getIndexReader(), TEXT_FIELD_NAME);\n\n    // This will just be null if app didn't pass payloads to build():\n    // TODO: maybe just stored fields?  they compress...\n    BinaryDocValues payloadsDV = MultiDocValues.getBinaryValues(searcher.getIndexReader(), \"payloads\");\n    List<LookupResult> results = new ArrayList<LookupResult>();\n    BytesRef scratch = new BytesRef();\n    for (int i=0;i<hits.scoreDocs.length;i++) {\n      FieldDoc fd = (FieldDoc) hits.scoreDocs[i];\n      textDV.get(fd.doc, scratch);\n      String text = scratch.utf8ToString();\n      long score = (Long) fd.fields[0];\n\n      BytesRef payload;\n      if (payloadsDV != null) {\n        payload = new BytesRef();\n        payloadsDV.get(fd.doc, payload);\n      } else {\n        payload = null;\n      }\n\n      LookupResult result;\n\n      if (doHighlight) {\n        Object highlightKey = highlight(text, matchedTokens, prefixToken);\n        result = new LookupResult(highlightKey.toString(), highlightKey, score, payload);\n      } else {\n        result = new LookupResult(text, score, payload);\n      }\n\n      results.add(result);\n    }\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Create the results based on the search hits.\n   * Can be overridden by subclass to add particular behavior (e.g. weight transformation)\n   * @throws IOException If there are problems reading fields from the underlying Lucene index.\n   */\n  protected List<LookupResult> createResults(TopDocs hits, int num, CharSequence charSequence,\n                                             boolean doHighlight, Set<String> matchedTokens, String prefixToken)\n      throws IOException {\n\n    List<LookupResult> results = new ArrayList<LookupResult>();\n    BytesRef scratch = new BytesRef();\n    for (int i=0;i<hits.scoreDocs.length;i++) {\n      ScoreDoc sd = hits.scoreDocs[i];\n      textDV.get(sd.doc, scratch);\n      String text = scratch.utf8ToString();\n      long score = weightsDV.get(sd.doc);\n\n      BytesRef payload;\n      if (payloadsDV != null) {\n        payload = new BytesRef();\n        payloadsDV.get(sd.doc, payload);\n      } else {\n        payload = null;\n      }\n\n      LookupResult result;\n\n      if (doHighlight) {\n        Object highlightKey = highlight(text, matchedTokens, prefixToken);\n        result = new LookupResult(highlightKey.toString(), highlightKey, score, payload);\n      } else {\n        result = new LookupResult(text, score, payload);\n      }\n\n      results.add(result);\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f13ec1b606a28789743a563929e7c556e8218297":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a371aa649cc243e82cb8677ca960a1e0232ecedf":["f13ec1b606a28789743a563929e7c556e8218297"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a371aa649cc243e82cb8677ca960a1e0232ecedf"]},"commit2Childs":{"f13ec1b606a28789743a563929e7c556e8218297":["a371aa649cc243e82cb8677ca960a1e0232ecedf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f13ec1b606a28789743a563929e7c556e8218297"],"a371aa649cc243e82cb8677ca960a1e0232ecedf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}