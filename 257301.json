{"path":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","commits":[{"id":"9813dd0748537c429b7c0a9b4723ea1ba496c047","date":1330304954,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,SolrCore).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n        // the first time we are run, we will get a startupCore - after\n        // we will get null and must use cc.getCore\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement, SolrCore startupCore)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n        // the first time we are run, we will get a startupCore - after\n        // we will get null and must use cc.getCore\n        if (startupCore == null) {\n          core = cc.getCore(coreName);\n        } else {\n          core = startupCore;\n        }\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null && startupCore == null) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement, startupCore);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n        // the first time we are run, we will get a startupCore - after\n        // we will get null and must use cc.getCore\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e09ce11407bbc5b3c56bdbe35736b7a22692f644","date":1342974259,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n        // the first time we are run, we will get a startupCore - after\n        // we will get null and must use cc.getCore\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n        // the first time we are run, we will get a startupCore - after\n        // we will get null and must use cc.getCore\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n        // the first time we are run, we will get a startupCore - after\n        // we will get null and must use cc.getCore\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"789648b7b86660572822e0223bf70afa36525b9d","date":1344353391,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n          log.info(\"I may be the new leader - try and sync\");\n          // we are going to attempt to be the leader\n          // first cancel any current recovery\n          core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps));\n        \n        // If I am going to be the leader I have to be active\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n          log.info(\"I may be the new leader - try and sync\");\n          // we are going to attempt to be the leader\n          // first cancel any current recovery\n          core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps));\n        \n        // If I am going to be the leader I have to be active\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n          log.info(\"I may be the new leader - try and sync\");\n          // we are going to attempt to be the leader\n          // first cancel any current recovery\n          core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps));\n        \n        // If I am going to be the leader I have to be active\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n//          System.out.println(\"I may be the new Leader:\" + leaderPath\n//              + \" - I need to try and sync\");\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        \n        // If I am going to be the leader I have to be active\n        // System.out.println(\"I am leader go active\");\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    waitForReplicasToComeUp(weAreReplacement);\n    \n    // wait for local leader state to clear...\n    // int tries = 0;\n    // while (zkController.getClusterState().getLeader(collection, shardId) !=\n    // null) {\n    // System.out.println(\"leader still shown \" + tries + \" \" +\n    // zkController.getClusterState().getLeader(collection, shardId));\n    // Thread.sleep(1000);\n    // tries++;\n    // if (tries == 30) {\n    // break;\n    // }\n    // }\n    // Thread.sleep(1000);\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        // System.out.println(\"there is a better leader candidate it appears\");\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      if (weAreReplacement) {\n        log.info(\"I may be the new leader - try and sync\");\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        boolean success = syncStrategy.sync(zkController, core, leaderProps);\n        // solrcloud_debug\n        // try {\n        // RefCounted<SolrIndexSearcher> searchHolder =\n        // core.getNewestSearcher(false);\n        // SolrIndexSearcher searcher = searchHolder.get();\n        // try {\n        // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n        // + \" synched \"\n        // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        // } finally {\n        // searchHolder.decref();\n        // }\n        // } catch (Exception e) {\n        //\n        // }\n        if (!success && anyoneElseActive()) {\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n      }\n      \n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        if (!cc.isShutDown()) {\n          // we could not publish ourselves as leader - rejoin election\n          rejoinLeaderElection(coreName, core);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    try {\n      core = cc.getCore(coreName);\n      // we do this after the above super. call so that we don't\n      // briefly think we are the leader and then end up not being\n      // able to publish that we are the leader.\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n          log.info(\"I may be the new leader - try and sync\");\n          // we are going to attempt to be the leader\n          // first cancel any current recovery\n          core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps));\n        \n        // If I am going to be the leader I have to be active\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","bugFix":null,"bugIntro":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","a6378064655e76cd7b908b1cab4ce425b384b508","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    waitForReplicasToComeUp(weAreReplacement);\n    \n    // wait for local leader state to clear...\n    // int tries = 0;\n    // while (zkController.getClusterState().getLeader(collection, shardId) !=\n    // null) {\n    // System.out.println(\"leader still shown \" + tries + \" \" +\n    // zkController.getClusterState().getLeader(collection, shardId));\n    // Thread.sleep(1000);\n    // tries++;\n    // if (tries == 30) {\n    // break;\n    // }\n    // }\n    // Thread.sleep(1000);\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        // System.out.println(\"there is a better leader candidate it appears\");\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      if (weAreReplacement) {\n        log.info(\"I may be the new leader - try and sync\");\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        boolean success = syncStrategy.sync(zkController, core, leaderProps);\n        // solrcloud_debug\n        // try {\n        // RefCounted<SolrIndexSearcher> searchHolder =\n        // core.getNewestSearcher(false);\n        // SolrIndexSearcher searcher = searchHolder.get();\n        // try {\n        // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n        // + \" synched \"\n        // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        // } finally {\n        // searchHolder.decref();\n        // }\n        // } catch (Exception e) {\n        //\n        // }\n        if (!success && anyoneElseActive()) {\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n      }\n      \n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        if (!cc.isShutDown()) {\n          // we could not publish ourselves as leader - rejoin election\n          rejoinLeaderElection(coreName, core);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    try {\n      core = cc.getCore(coreName);\n      // we do this after the above super. call so that we don't\n      // briefly think we are the leader and then end up not being\n      // able to publish that we are the leader.\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement)\n      throws KeeperException, InterruptedException, IOException {\n    if (cc != null) {\n      String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n      SolrCore core = null;\n      try {\n     \n        core = cc.getCore(coreName);\n\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Fatal Error, SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps)) {\n          // System.out.println(\"there is a better leader candidate it appears\");\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n\n        if (weAreReplacement) {\n          if (zkClient.exists(leaderPath, true)) {\n            zkClient.delete(leaderPath, -1, true);\n          }\n          log.info(\"I may be the new leader - try and sync\");\n          // we are going to attempt to be the leader\n          // first cancel any current recovery\n          core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          boolean success = syncStrategy.sync(zkController, core, leaderProps);\n          if (!success && anyoneElseActive()) {\n            rejoinLeaderElection(leaderSeqPath, core);\n            return;\n          } \n        }\n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps));\n        \n        // If I am going to be the leader I have to be active\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.ACTIVE);\n        \n      } finally {\n        if (core != null ) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    super.runLeaderProcess(weAreReplacement);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","date":1346692465,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process. afterExpiration=\" + afterExpiration);\n    \n    String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        // System.out.println(\"there is a better leader candidate it appears\");\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      if (weAreReplacement) {\n        log.info(\"I may be the new leader - try and sync\");\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        boolean success = syncStrategy.sync(zkController, core, leaderProps);\n        // solrcloud_debug\n        // try {\n        // RefCounted<SolrIndexSearcher> searchHolder =\n        // core.getNewestSearcher(false);\n        // SolrIndexSearcher searcher = searchHolder.get();\n        // try {\n        // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n        // + \" synched \"\n        // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        // } finally {\n        // searchHolder.decref();\n        // }\n        // } catch (Exception e) {\n        //\n        // }\n        if (!success && anyoneElseActive()) {\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n      }\n      \n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        if (!cc.isShutDown()) {\n          // we could not publish ourselves as leader - rejoin election\n          rejoinLeaderElection(coreName, core);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    try {\n      core = cc.getCore(coreName);\n      // we do this after the above super. call so that we don't\n      // briefly think we are the leader and then end up not being\n      // able to publish that we are the leader.\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    waitForReplicasToComeUp(weAreReplacement);\n    \n    // wait for local leader state to clear...\n    // int tries = 0;\n    // while (zkController.getClusterState().getLeader(collection, shardId) !=\n    // null) {\n    // System.out.println(\"leader still shown \" + tries + \" \" +\n    // zkController.getClusterState().getLeader(collection, shardId));\n    // Thread.sleep(1000);\n    // tries++;\n    // if (tries == 30) {\n    // break;\n    // }\n    // }\n    // Thread.sleep(1000);\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        // System.out.println(\"there is a better leader candidate it appears\");\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      if (weAreReplacement) {\n        log.info(\"I may be the new leader - try and sync\");\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        boolean success = syncStrategy.sync(zkController, core, leaderProps);\n        // solrcloud_debug\n        // try {\n        // RefCounted<SolrIndexSearcher> searchHolder =\n        // core.getNewestSearcher(false);\n        // SolrIndexSearcher searcher = searchHolder.get();\n        // try {\n        // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n        // + \" synched \"\n        // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        // } finally {\n        // searchHolder.decref();\n        // }\n        // } catch (Exception e) {\n        //\n        // }\n        if (!success && anyoneElseActive()) {\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n      }\n      \n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        if (!cc.isShutDown()) {\n          // we could not publish ourselves as leader - rejoin election\n          rejoinLeaderElection(coreName, core);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    try {\n      core = cc.getCore(coreName);\n      // we do this after the above super. call so that we don't\n      // briefly think we are the leader and then end up not being\n      // able to publish that we are the leader.\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process. afterExpiration=\" + afterExpiration);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        // System.out.println(\"there is a better leader candidate it appears\");\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      if (weAreReplacement) {\n        log.info(\"I may be the new leader - try and sync\");\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        boolean success = syncStrategy.sync(zkController, core, leaderProps);\n        // solrcloud_debug\n        // try {\n        // RefCounted<SolrIndexSearcher> searchHolder =\n        // core.getNewestSearcher(false);\n        // SolrIndexSearcher searcher = searchHolder.get();\n        // try {\n        // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n        // + \" synched \"\n        // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        // } finally {\n        // searchHolder.decref();\n        // }\n        // } catch (Exception e) {\n        //\n        // }\n        if (!success && anyoneElseActive()) {\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n      }\n      \n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        if (!cc.isShutDown()) {\n          // we could not publish ourselves as leader - rejoin election\n          rejoinLeaderElection(coreName, core);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    try {\n      core = cc.getCore(coreName);\n      // we do this after the above super. call so that we don't\n      // briefly think we are the leader and then end up not being\n      // able to publish that we are the leader.\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process. afterExpiration=\" + afterExpiration);\n    \n    String coreName = leaderProps.get(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        // System.out.println(\"there is a better leader candidate it appears\");\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      if (weAreReplacement) {\n        log.info(\"I may be the new leader - try and sync\");\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        boolean success = syncStrategy.sync(zkController, core, leaderProps);\n        // solrcloud_debug\n        // try {\n        // RefCounted<SolrIndexSearcher> searchHolder =\n        // core.getNewestSearcher(false);\n        // SolrIndexSearcher searcher = searchHolder.get();\n        // try {\n        // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n        // + \" synched \"\n        // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        // } finally {\n        // searchHolder.decref();\n        // }\n        // } catch (Exception e) {\n        //\n        // }\n        if (!success && anyoneElseActive()) {\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n      }\n      \n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        if (!cc.isShutDown()) {\n          // we could not publish ourselves as leader - rejoin election\n          rejoinLeaderElection(coreName, core);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    try {\n      core = cc.getCore(coreName);\n      // we do this after the above super. call so that we don't\n      // briefly think we are the leader and then end up not being\n      // able to publish that we are the leader.\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process. afterExpiration=\" + afterExpiration);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        // System.out.println(\"there is a better leader candidate it appears\");\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      if (weAreReplacement) {\n        log.info(\"I may be the new leader - try and sync\");\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        boolean success = syncStrategy.sync(zkController, core, leaderProps);\n        // solrcloud_debug\n        // try {\n        // RefCounted<SolrIndexSearcher> searchHolder =\n        // core.getNewestSearcher(false);\n        // SolrIndexSearcher searcher = searchHolder.get();\n        // try {\n        // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n        // + \" synched \"\n        // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        // } finally {\n        // searchHolder.decref();\n        // }\n        // } catch (Exception e) {\n        //\n        // }\n        if (!success && anyoneElseActive()) {\n          rejoinLeaderElection(leaderSeqPath, core);\n          return;\n        }\n      }\n      \n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        if (!cc.isShutDown()) {\n          // we could not publish ourselves as leader - rejoin election\n          rejoinLeaderElection(coreName, core);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n    }\n    \n    try {\n      core = cc.getCore(coreName);\n      // we do this after the above super. call so that we don't\n      // briefly think we are the leader and then end up not being\n      // able to publish that we are the leader.\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"bugIntro":["9cef9edf6786c51f767f53339f5be3ccb5e1a491","a032cd95d0190153904daad76121a281d8034fd5","26cb11ce089e71fb909641e7030b53c7d9e3fff3","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1525b4dfbc0d413b8d7247da232009778e624836","date":1351101135,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["b0cf323d076e7c974924dfab9ae2182c0f4ccb9b","6198e18a87837d41cdd5df8c554e124619d99e4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["9cef9edf6786c51f767f53339f5be3ccb5e1a491"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a032cd95d0190153904daad76121a281d8034fd5","date":1352746146,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"448aa18a7a928a0f11c904582b22b9cd5ec63846","date":1355012177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(coreName, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"446d2d126e2d0a9c63a498d792c4072c820c1e95","date":1363304661,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0cf323d076e7c974924dfab9ae2182c0f4ccb9b","date":1368637309,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      \n      if (!success && (ulog == null || ulog.getRecentUpdates().getVersions(1).isEmpty())) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      if (!success && ulog.getRecentUpdates().getVersions(1).isEmpty()) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":["1525b4dfbc0d413b8d7247da232009778e624836"],"bugIntro":["6198e18a87837d41cdd5df8c554e124619d99e4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6198e18a87837d41cdd5df8c554e124619d99e4c","date":1368737399,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      \n      if (!success && (ulog == null || ulog.getRecentUpdates().getVersions(1).isEmpty())) {\n        // we failed sync, but we have no versions - we can't sync in that case\n        // - we were active\n        // before, so become leader anyway\n        log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n        success = true;\n      }\n      \n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":["1525b4dfbc0d413b8d7247da232009778e624836","b0cf323d076e7c974924dfab9ae2182c0f4ccb9b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process.\");\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, \"leader\",\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps));\n      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92a4da96826f502cf1a56a096929b37ce73e523a","date":1374584011,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement && leaderVoteWait != null) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c52ad29218ee436d52c57bf0829b98acad9de379","date":1383401544,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            System.err.println(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      // try {\n      // RefCounted<SolrIndexSearcher> searchHolder =\n      // core.getNewestSearcher(false);\n      // SolrIndexSearcher searcher = searchHolder.get();\n      // try {\n      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n      // + \" synched \"\n      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n      // } finally {\n      // searchHolder.decref();\n      // }\n      // } catch (Exception e) {\n      //\n      // }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89b56ee224dbe29ee4436d91a7070ca418ffc4fb","date":1383492966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            System.err.println(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3a8e79d99866477b7e2b0951ea2e4c397a7e57f","date":1385928947,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97bd2b0da4beced82821b752b29576be986cf1ff","date":1387747012,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n\n\n      // if !success but no one else is in active mode,\n      // we are the leader anyway\n      // TODO: should we also be leader if there is only one other active?\n      // if we couldn't sync with it, it shouldn't be able to sync with us\n      // TODO: this needs to be moved to the election context - the logic does\n      // not belong here.\n      if (!success\n          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,\n              shardId)) {\n        log.info(\"Sync was not a success but no one else is active! I am the leader\");\n        success = true;\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        try {\n          if (!success) {\n            cancelElection();\n          }\n        } finally {\n          if (core != null) {\n            core.close();\n          }\n        }\n        \n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Throwable t) {\n        SolrException.log(log, \"Exception while trying to sync\", t);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    \n    try {\n      super.runLeaderProcess(weAreReplacement);\n    } catch (Throwable t) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", t);\n      cancelElection();\n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n    \n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","849494cf2f3a96af5c8c84995108ddd8456fcd04","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"bugIntro":["9cef9edf6786c51f767f53339f5be3ccb5e1a491"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"26cb11ce089e71fb909641e7030b53c7d9e3fff3","date":1390348343,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        try {\n          if (!success) {\n            cancelElection();\n          }\n        } finally {\n          if (core != null) {\n            core.close();\n          }\n        }\n        \n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        try {\n          if (!success) {\n            cancelElection();\n          }\n        } finally {\n          if (core != null) {\n            core.close();\n          }\n        }\n        \n      }\n    }\n    \n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dedd8b6e67b7ac7a77554562fddcf90e0031a95c","date":1391930936,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        try {\n          if (!success) {\n            cancelElection();\n          }\n        } finally {\n          if (core != null) {\n            core.close();\n          }\n        }\n        \n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        try {\n          if (!success) {\n            cancelElection();\n          }\n        } finally {\n          if (core != null) {\n            core.close();\n          }\n        }\n        \n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"97bd2b0da4beced82821b752b29576be986cf1ff":["d3a8e79d99866477b7e2b0951ea2e4c397a7e57f"],"89b56ee224dbe29ee4436d91a7070ca418ffc4fb":["c52ad29218ee436d52c57bf0829b98acad9de379"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["6198e18a87837d41cdd5df8c554e124619d99e4c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9813dd0748537c429b7c0a9b4723ea1ba496c047"],"789648b7b86660572822e0223bf70afa36525b9d":["e09ce11407bbc5b3c56bdbe35736b7a22692f644"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["1525b4dfbc0d413b8d7247da232009778e624836"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["789648b7b86660572822e0223bf70afa36525b9d"],"b0cf323d076e7c974924dfab9ae2182c0f4ccb9b":["446d2d126e2d0a9c63a498d792c4072c820c1e95"],"446d2d126e2d0a9c63a498d792c4072c820c1e95":["448aa18a7a928a0f11c904582b22b9cd5ec63846"],"6198e18a87837d41cdd5df8c554e124619d99e4c":["b0cf323d076e7c974924dfab9ae2182c0f4ccb9b"],"e09ce11407bbc5b3c56bdbe35736b7a22692f644":["9813dd0748537c429b7c0a9b4723ea1ba496c047"],"aba371508186796cc6151d8223a5b4e16d02e26e":["9813dd0748537c429b7c0a9b4723ea1ba496c047","e09ce11407bbc5b3c56bdbe35736b7a22692f644"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","789648b7b86660572822e0223bf70afa36525b9d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dedd8b6e67b7ac7a77554562fddcf90e0031a95c":["26cb11ce089e71fb909641e7030b53c7d9e3fff3"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["9813dd0748537c429b7c0a9b4723ea1ba496c047","e09ce11407bbc5b3c56bdbe35736b7a22692f644"],"f2126b84bd093fa3d921582a109a0ee578c28126":["a6378064655e76cd7b908b1cab4ce425b384b508","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["97bd2b0da4beced82821b752b29576be986cf1ff"],"9813dd0748537c429b7c0a9b4723ea1ba496c047":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["37a0f60745e53927c4c876cfe5b5a58170f0646c","92a4da96826f502cf1a56a096929b37ce73e523a"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"fa64435b5902ce266c23755a4a00691a3285dab8":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"92a4da96826f502cf1a56a096929b37ce73e523a":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d9405f486872f1e416304dfe389741f4ee2f8a4d","448aa18a7a928a0f11c904582b22b9cd5ec63846"],"d3a8e79d99866477b7e2b0951ea2e4c397a7e57f":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["d6f074e73200c07d54f242d3880a8da5a35ff97b","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["6198e18a87837d41cdd5df8c554e124619d99e4c"],"a6378064655e76cd7b908b1cab4ce425b384b508":["fa64435b5902ce266c23755a4a00691a3285dab8"],"a032cd95d0190153904daad76121a281d8034fd5":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","789648b7b86660572822e0223bf70afa36525b9d"],"c52ad29218ee436d52c57bf0829b98acad9de379":["92a4da96826f502cf1a56a096929b37ce73e523a"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb","d3a8e79d99866477b7e2b0951ea2e4c397a7e57f"],"448aa18a7a928a0f11c904582b22b9cd5ec63846":["a032cd95d0190153904daad76121a281d8034fd5"],"26cb11ce089e71fb909641e7030b53c7d9e3fff3":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"1525b4dfbc0d413b8d7247da232009778e624836":["a6378064655e76cd7b908b1cab4ce425b384b508"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dedd8b6e67b7ac7a77554562fddcf90e0031a95c"]},"commit2Childs":{"97bd2b0da4beced82821b752b29576be986cf1ff":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"89b56ee224dbe29ee4436d91a7070ca418ffc4fb":["d3a8e79d99866477b7e2b0951ea2e4c397a7e57f","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"789648b7b86660572822e0223bf70afa36525b9d":["6013b4c7388f1627659c8f96c44abd10a294d3a6","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["f2126b84bd093fa3d921582a109a0ee578c28126","407687e67faf6e1f02a211ca078d8e3eed631027","a032cd95d0190153904daad76121a281d8034fd5"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","05a14b2611ead08655a2b2bdc61632eb31316e57"],"b0cf323d076e7c974924dfab9ae2182c0f4ccb9b":["6198e18a87837d41cdd5df8c554e124619d99e4c"],"446d2d126e2d0a9c63a498d792c4072c820c1e95":["b0cf323d076e7c974924dfab9ae2182c0f4ccb9b"],"6198e18a87837d41cdd5df8c554e124619d99e4c":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"e09ce11407bbc5b3c56bdbe35736b7a22692f644":["789648b7b86660572822e0223bf70afa36525b9d","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","9813dd0748537c429b7c0a9b4723ea1ba496c047"],"dedd8b6e67b7ac7a77554562fddcf90e0031a95c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["26cb11ce089e71fb909641e7030b53c7d9e3fff3"],"9813dd0748537c429b7c0a9b4723ea1ba496c047":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e09ce11407bbc5b3c56bdbe35736b7a22692f644","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["fa64435b5902ce266c23755a4a00691a3285dab8"],"fa64435b5902ce266c23755a4a00691a3285dab8":["a6378064655e76cd7b908b1cab4ce425b384b508"],"92a4da96826f502cf1a56a096929b37ce73e523a":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","c52ad29218ee436d52c57bf0829b98acad9de379"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"d3a8e79d99866477b7e2b0951ea2e4c397a7e57f":["97bd2b0da4beced82821b752b29576be986cf1ff","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","92a4da96826f502cf1a56a096929b37ce73e523a"],"a6378064655e76cd7b908b1cab4ce425b384b508":["f2126b84bd093fa3d921582a109a0ee578c28126","1525b4dfbc0d413b8d7247da232009778e624836"],"a032cd95d0190153904daad76121a281d8034fd5":["448aa18a7a928a0f11c904582b22b9cd5ec63846"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"c52ad29218ee436d52c57bf0829b98acad9de379":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"448aa18a7a928a0f11c904582b22b9cd5ec63846":["446d2d126e2d0a9c63a498d792c4072c820c1e95","407687e67faf6e1f02a211ca078d8e3eed631027"],"26cb11ce089e71fb909641e7030b53c7d9e3fff3":["dedd8b6e67b7ac7a77554562fddcf90e0031a95c"],"1525b4dfbc0d413b8d7247da232009778e624836":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","c7869f64c874ebf7f317d22c00baf2b6857797a6","f2126b84bd093fa3d921582a109a0ee578c28126","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","407687e67faf6e1f02a211ca078d8e3eed631027","05a14b2611ead08655a2b2bdc61632eb31316e57","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}