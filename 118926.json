{"path":"lucene/core/src/java/org/apache/lucene/util/IndexableBinaryStringTools#encode(byte[],int,int,char[],int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/IndexableBinaryStringTools#encode(byte[],int,int,char[],int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/IndexableBinaryStringTools#encode(byte[],int,int,char[],int,int).mjava","sourceNew":"  /**\n   * Encodes the input byte sequence into the output char sequence.  Before\n   * calling this method, ensure that the output array has sufficient\n   * capacity by calling {@link #getEncodedLength(byte[], int, int)}.\n   * \n   * @param inputArray byte sequence to be encoded\n   * @param inputOffset initial offset into inputArray\n   * @param inputLength number of bytes in inputArray\n   * @param outputArray char sequence to store encoded result\n   * @param outputOffset initial offset into outputArray\n   * @param outputLength length of output, must be getEncodedLength\n   */\n  public static void encode(byte[] inputArray, int inputOffset,\n      int inputLength, char[] outputArray, int outputOffset, int outputLength) {\n    assert (outputLength == getEncodedLength(inputArray, inputOffset,\n        inputLength));\n    if (inputLength > 0) {\n      int inputByteNum = inputOffset;\n      int caseNum = 0;\n      int outputCharNum = outputOffset;\n      CodingCase codingCase;\n      for (; inputByteNum + CODING_CASES[caseNum].numBytes <= inputLength; ++outputCharNum) {\n        codingCase = CODING_CASES[caseNum];\n        if (2 == codingCase.numBytes) {\n          outputArray[outputCharNum] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)\n              + (((inputArray[inputByteNum + 1] & 0xFF) >>> codingCase.finalShift) & codingCase.finalMask) & (short) 0x7FFF);\n        } else { // numBytes is 3\n          outputArray[outputCharNum] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)\n              + ((inputArray[inputByteNum + 1] & 0xFF) << codingCase.middleShift)\n              + (((inputArray[inputByteNum + 2] & 0xFF) >>> codingCase.finalShift) & codingCase.finalMask) & (short) 0x7FFF);\n        }\n        inputByteNum += codingCase.advanceBytes;\n        if (++caseNum == CODING_CASES.length) {\n          caseNum = 0;\n        }\n      }\n      // Produce final char (if any) and trailing count chars.\n      codingCase = CODING_CASES[caseNum];\n\n      if (inputByteNum + 1 < inputLength) { // codingCase.numBytes must be 3\n        outputArray[outputCharNum++] = (char) ((((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift) + ((inputArray[inputByteNum + 1] & 0xFF) << codingCase.middleShift)) & (short) 0x7FFF);\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = (char) 1;\n      } else if (inputByteNum < inputLength) {\n        outputArray[outputCharNum++] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift) & (short) 0x7FFF);\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = caseNum == 0 ? (char) 1 : (char) 0;\n      } else { // No left over bits - last char is completely filled.\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = (char) 1;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Encodes the input byte sequence into the output char sequence.  Before\n   * calling this method, ensure that the output array has sufficient\n   * capacity by calling {@link #getEncodedLength(byte[], int, int)}.\n   * \n   * @param inputArray byte sequence to be encoded\n   * @param inputOffset initial offset into inputArray\n   * @param inputLength number of bytes in inputArray\n   * @param outputArray char sequence to store encoded result\n   * @param outputOffset initial offset into outputArray\n   * @param outputLength length of output, must be getEncodedLength\n   */\n  public static void encode(byte[] inputArray, int inputOffset,\n      int inputLength, char[] outputArray, int outputOffset, int outputLength) {\n    assert (outputLength == getEncodedLength(inputArray, inputOffset,\n        inputLength));\n    if (inputLength > 0) {\n      int inputByteNum = inputOffset;\n      int caseNum = 0;\n      int outputCharNum = outputOffset;\n      CodingCase codingCase;\n      for (; inputByteNum + CODING_CASES[caseNum].numBytes <= inputLength; ++outputCharNum) {\n        codingCase = CODING_CASES[caseNum];\n        if (2 == codingCase.numBytes) {\n          outputArray[outputCharNum] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)\n              + (((inputArray[inputByteNum + 1] & 0xFF) >>> codingCase.finalShift) & codingCase.finalMask) & (short) 0x7FFF);\n        } else { // numBytes is 3\n          outputArray[outputCharNum] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)\n              + ((inputArray[inputByteNum + 1] & 0xFF) << codingCase.middleShift)\n              + (((inputArray[inputByteNum + 2] & 0xFF) >>> codingCase.finalShift) & codingCase.finalMask) & (short) 0x7FFF);\n        }\n        inputByteNum += codingCase.advanceBytes;\n        if (++caseNum == CODING_CASES.length) {\n          caseNum = 0;\n        }\n      }\n      // Produce final char (if any) and trailing count chars.\n      codingCase = CODING_CASES[caseNum];\n\n      if (inputByteNum + 1 < inputLength) { // codingCase.numBytes must be 3\n        outputArray[outputCharNum++] = (char) ((((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift) + ((inputArray[inputByteNum + 1] & 0xFF) << codingCase.middleShift)) & (short) 0x7FFF);\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = (char) 1;\n      } else if (inputByteNum < inputLength) {\n        outputArray[outputCharNum++] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift) & (short) 0x7FFF);\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = caseNum == 0 ? (char) 1 : (char) 0;\n      } else { // No left over bits - last char is completely filled.\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = (char) 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/IndexableBinaryStringTools#encode(byte[],int,int,char[],int,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Encodes the input byte sequence into the output char sequence.  Before\n   * calling this method, ensure that the output array has sufficient\n   * capacity by calling {@link #getEncodedLength(byte[], int, int)}.\n   * \n   * @param inputArray byte sequence to be encoded\n   * @param inputOffset initial offset into inputArray\n   * @param inputLength number of bytes in inputArray\n   * @param outputArray char sequence to store encoded result\n   * @param outputOffset initial offset into outputArray\n   * @param outputLength length of output, must be getEncodedLength\n   */\n  public static void encode(byte[] inputArray, int inputOffset,\n      int inputLength, char[] outputArray, int outputOffset, int outputLength) {\n    assert (outputLength == getEncodedLength(inputArray, inputOffset,\n        inputLength));\n    if (inputLength > 0) {\n      int inputByteNum = inputOffset;\n      int caseNum = 0;\n      int outputCharNum = outputOffset;\n      CodingCase codingCase;\n      for (; inputByteNum + CODING_CASES[caseNum].numBytes <= inputLength; ++outputCharNum) {\n        codingCase = CODING_CASES[caseNum];\n        if (2 == codingCase.numBytes) {\n          outputArray[outputCharNum] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)\n              + (((inputArray[inputByteNum + 1] & 0xFF) >>> codingCase.finalShift) & codingCase.finalMask) & (short) 0x7FFF);\n        } else { // numBytes is 3\n          outputArray[outputCharNum] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)\n              + ((inputArray[inputByteNum + 1] & 0xFF) << codingCase.middleShift)\n              + (((inputArray[inputByteNum + 2] & 0xFF) >>> codingCase.finalShift) & codingCase.finalMask) & (short) 0x7FFF);\n        }\n        inputByteNum += codingCase.advanceBytes;\n        if (++caseNum == CODING_CASES.length) {\n          caseNum = 0;\n        }\n      }\n      // Produce final char (if any) and trailing count chars.\n      codingCase = CODING_CASES[caseNum];\n\n      if (inputByteNum + 1 < inputLength) { // codingCase.numBytes must be 3\n        outputArray[outputCharNum++] = (char) ((((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift) + ((inputArray[inputByteNum + 1] & 0xFF) << codingCase.middleShift)) & (short) 0x7FFF);\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = (char) 1;\n      } else if (inputByteNum < inputLength) {\n        outputArray[outputCharNum++] = (char) (((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift) & (short) 0x7FFF);\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = caseNum == 0 ? (char) 1 : (char) 0;\n      } else { // No left over bits - last char is completely filled.\n        // Add trailing char containing the number of full bytes in final char\n        outputArray[outputCharNum++] = (char) 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"]},"commit2Childs":{"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}