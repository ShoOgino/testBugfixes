{"path":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","commits":[{"id":"39d51e9acac1e629cffe47855e85dc6dedc4754d","date":1305711497,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"874088165d9cc50370b30219daa24a1946758ee6","date":1306148325,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"605b061fadf71aa6458c0005eaae83a98350c403","date":1307117658,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a154343e160a5590f17dfdfad7e4c384fc22836","date":1308000861,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ed208afa1e7aa98899ddb1dedfddedddf898253","date":1308079587,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93c59ad5034eecd863f267bd75e1df7b8a51e427","date":1309162882,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f","date":1310403131,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", StringField.TYPE_STORED, idBase + i));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.optimize(true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    IndexDocValuesField valField = new IndexDocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e4db59c6b6c10e25322cfb41c4c19d78b4298bd","date":1317197236,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.optimize(true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", StringField.TYPE_STORED, idBase + i));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.optimize(true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2","04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.optimize(true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2e8d7ba2175f47e280231533f7d3016249cea88b"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["7e4db59c6b6c10e25322cfb41c4c19d78b4298bd"],"2553b00f699380c64959ccb27991289aae87be2e":["9ed208afa1e7aa98899ddb1dedfddedddf898253","93c59ad5034eecd863f267bd75e1df7b8a51e427"],"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f":["93c59ad5034eecd863f267bd75e1df7b8a51e427"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["8a154343e160a5590f17dfdfad7e4c384fc22836","93c59ad5034eecd863f267bd75e1df7b8a51e427"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","8a154343e160a5590f17dfdfad7e4c384fc22836"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","605b061fadf71aa6458c0005eaae83a98350c403"],"605b061fadf71aa6458c0005eaae83a98350c403":["874088165d9cc50370b30219daa24a1946758ee6"],"39d51e9acac1e629cffe47855e85dc6dedc4754d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93c59ad5034eecd863f267bd75e1df7b8a51e427":["8a154343e160a5590f17dfdfad7e4c384fc22836"],"874088165d9cc50370b30219daa24a1946758ee6":["39d51e9acac1e629cffe47855e85dc6dedc4754d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f"],"8a154343e160a5590f17dfdfad7e4c384fc22836":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"7e4db59c6b6c10e25322cfb41c4c19d78b4298bd":["1509f151d7692d84fae414b2b799ac06ba60fcb4"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["9ed208afa1e7aa98899ddb1dedfddedddf898253"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["d638301ad1cfcae567b681b893bc8781f0ee48a5","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"2553b00f699380c64959ccb27991289aae87be2e":[],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["2553b00f699380c64959ccb27991289aae87be2e"],"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","8a154343e160a5590f17dfdfad7e4c384fc22836"],"605b061fadf71aa6458c0005eaae83a98350c403":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"39d51e9acac1e629cffe47855e85dc6dedc4754d":["874088165d9cc50370b30219daa24a1946758ee6"],"93c59ad5034eecd863f267bd75e1df7b8a51e427":["2553b00f699380c64959ccb27991289aae87be2e","c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"874088165d9cc50370b30219daa24a1946758ee6":["605b061fadf71aa6458c0005eaae83a98350c403"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","2e8d7ba2175f47e280231533f7d3016249cea88b","39d51e9acac1e629cffe47855e85dc6dedc4754d"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"8a154343e160a5590f17dfdfad7e4c384fc22836":["d083e83f225b11e5fdd900e83d26ddb385b6955c","9ed208afa1e7aa98899ddb1dedfddedddf898253","93c59ad5034eecd863f267bd75e1df7b8a51e427"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["7e4db59c6b6c10e25322cfb41c4c19d78b4298bd"],"7e4db59c6b6c10e25322cfb41c4c19d78b4298bd":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}