{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","commits":[{"id":"a69ebf290ab26d026cc224e517e0d93d931ac87b","date":1549869083,"type":1,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapSelect(HeapPointWriter,PointWriter,PointWriter,int,int,int,int,int).mjava","sourceNew":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefix) {\n    final int offset = dim * bytesPerDim + commonPrefix;\n    new RadixSelector(bytesSorted - commonPrefix) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0;\n        if (k + commonPrefix < bytesPerDim) {\n          // dim bytes\n          int block = i / points.valuesPerBlock;\n          int index = i % points.valuesPerBlock;\n          return points.blocks.get(block)[index * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k + commonPrefix - bytesPerDim);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[bytesPerDim];\n    points.getPackedValueSlice(partitionPoint, bytesRef1);\n    System.arraycopy(bytesRef1.bytes, bytesRef1.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","sourceOld":"  private byte[] heapSelect(HeapPointWriter points, PointWriter left, PointWriter right, int dim, int from, int to, int partitionPoint, int commonPrefix) throws IOException {\n    final int offset = dim * bytesPerDim + commonPrefix;\n    new RadixSelector(bytesSorted - commonPrefix) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0;\n        if (k + commonPrefix < bytesPerDim) {\n          // dim bytes\n          int block = i / points.valuesPerBlock;\n          int index = i % points.valuesPerBlock;\n          return points.blocks.get(block)[index * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k + commonPrefix - bytesPerDim);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n    }.select(from, to, partitionPoint);\n\n    for (int i = from; i < to; i++) {\n      points.getPackedValueSlice(i, bytesRef1);\n      int docID = points.docIDs[i];\n      if (i < partitionPoint) {\n        left.append(bytesRef1, docID);\n      } else {\n        right.append(bytesRef1, docID);\n      }\n    }\n    byte[] partition = new byte[bytesPerDim];\n    points.getPackedValueSlice(partitionPoint, bytesRef1);\n    System.arraycopy(bytesRef1.bytes, bytesRef1.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2344a1c769566d8c85cffcacc5e55153fa54b86","date":1550661298,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","sourceNew":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefix) {\n    final int offset = dim * bytesPerDim + commonPrefix;\n    final int dimCmpBytes = bytesPerDim - commonPrefix;\n    new RadixSelector(bytesSorted - commonPrefix) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k - dimCmpBytes);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n\n      @Override\n      protected Selector getFallbackSelector(int d) {\n        int skypedBytes = d + commonPrefix;\n        final int start = dim * bytesPerDim + skypedBytes;\n        final int end =  dim * bytesPerDim + bytesPerDim;\n        return new IntroSelector() {\n\n          int pivotDoc = -1;\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            pivotDoc = points.docIDs[i];\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesLength;\n              int jOffset = j * packedBytesLength;\n              int cmp = FutureArrays.compareUnsigned(points.block, iOffset + start, iOffset + end,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return points.docIDs[i] - points.docIDs[j];\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesLength;\n              int cmp = FutureArrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return pivotDoc - points.docIDs[j];\n          }\n        };\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[bytesPerDim];\n    PointValue pointValue = points.getPackedValueSlice(partitionPoint);\n    BytesRef packedValue = pointValue.packedValue();\n    System.arraycopy(packedValue.bytes, packedValue.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","sourceOld":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefix) {\n    final int offset = dim * bytesPerDim + commonPrefix;\n    new RadixSelector(bytesSorted - commonPrefix) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0;\n        if (k + commonPrefix < bytesPerDim) {\n          // dim bytes\n          int block = i / points.valuesPerBlock;\n          int index = i % points.valuesPerBlock;\n          return points.blocks.get(block)[index * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k + commonPrefix - bytesPerDim);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[bytesPerDim];\n    points.getPackedValueSlice(partitionPoint, bytesRef1);\n    System.arraycopy(bytesRef1.bytes, bytesRef1.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","sourceNew":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefix) {\n    final int offset = dim * bytesPerDim + commonPrefix;\n    final int dimCmpBytes = bytesPerDim - commonPrefix;\n    new RadixSelector(bytesSorted - commonPrefix) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k - dimCmpBytes);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n\n      @Override\n      protected Selector getFallbackSelector(int d) {\n        int skypedBytes = d + commonPrefix;\n        final int start = dim * bytesPerDim + skypedBytes;\n        final int end =  dim * bytesPerDim + bytesPerDim;\n        return new IntroSelector() {\n\n          int pivotDoc = -1;\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            pivotDoc = points.docIDs[i];\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesLength;\n              int jOffset = j * packedBytesLength;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + start, iOffset + end,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return points.docIDs[i] - points.docIDs[j];\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesLength;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return pivotDoc - points.docIDs[j];\n          }\n        };\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[bytesPerDim];\n    PointValue pointValue = points.getPackedValueSlice(partitionPoint);\n    BytesRef packedValue = pointValue.packedValue();\n    System.arraycopy(packedValue.bytes, packedValue.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","sourceOld":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefix) {\n    final int offset = dim * bytesPerDim + commonPrefix;\n    final int dimCmpBytes = bytesPerDim - commonPrefix;\n    new RadixSelector(bytesSorted - commonPrefix) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k - dimCmpBytes);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n\n      @Override\n      protected Selector getFallbackSelector(int d) {\n        int skypedBytes = d + commonPrefix;\n        final int start = dim * bytesPerDim + skypedBytes;\n        final int end =  dim * bytesPerDim + bytesPerDim;\n        return new IntroSelector() {\n\n          int pivotDoc = -1;\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            pivotDoc = points.docIDs[i];\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesLength;\n              int jOffset = j * packedBytesLength;\n              int cmp = FutureArrays.compareUnsigned(points.block, iOffset + start, iOffset + end,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return points.docIDs[i] - points.docIDs[j];\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesLength;\n              int cmp = FutureArrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return pivotDoc - points.docIDs[j];\n          }\n        };\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[bytesPerDim];\n    PointValue pointValue = points.getPackedValueSlice(partitionPoint);\n    BytesRef packedValue = pointValue.packedValue();\n    System.arraycopy(packedValue.bytes, packedValue.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7f06758793500ca773d0df1037290e6e404fb33","date":1562230223,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","sourceNew":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefixLength) {\n    final int dimOffset = dim * bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = bytesPerDim - commonPrefixLength;\n    final int dataOffset = numIndexDims * bytesPerDim - dimCmpBytes;\n    new RadixSelector(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesDocIDLength + dimOffset + k] & 0xff;\n        } else {\n          // data bytes\n          return points.block[i * packedBytesDocIDLength + dataOffset + k] & 0xff;\n        }\n      }\n\n      @Override\n      protected Selector getFallbackSelector(int d) {\n        final int skypedBytes = d + commonPrefixLength;\n        final int dimStart = dim * bytesPerDim + skypedBytes;\n        final int dimEnd =  dim * bytesPerDim + bytesPerDim;\n        final int dataOffset = numIndexDims * bytesPerDim;\n        // data length is composed by the data dimensions plus the docID\n        final int dataLength = (numDataDims - numIndexDims) * bytesPerDim + Integer.BYTES;\n        return new IntroSelector() {\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesDocIDLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            System.arraycopy(points.block, i * packedBytesDocIDLength + dataOffset, scratch, bytesPerDim, dataLength);\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesDocIDLength;\n              int jOffset = j * packedBytesDocIDLength;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + dimStart, iOffset + dimEnd, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int iOffset = i * packedBytesDocIDLength + dataOffset;\n            int jOffset = j * packedBytesDocIDLength + dataOffset;\n            return Arrays.compareUnsigned(points.block, iOffset, iOffset + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesDocIDLength;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int jOffset = j * packedBytesDocIDLength + dataOffset;\n            return Arrays.compareUnsigned(scratch, bytesPerDim, bytesPerDim + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n        };\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[bytesPerDim];\n    PointValue pointValue = points.getPackedValueSlice(partitionPoint);\n    BytesRef packedValue = pointValue.packedValue();\n    System.arraycopy(packedValue.bytes, packedValue.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","sourceOld":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefix) {\n    final int offset = dim * bytesPerDim + commonPrefix;\n    final int dimCmpBytes = bytesPerDim - commonPrefix;\n    new RadixSelector(bytesSorted - commonPrefix) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k - dimCmpBytes);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n\n      @Override\n      protected Selector getFallbackSelector(int d) {\n        int skypedBytes = d + commonPrefix;\n        final int start = dim * bytesPerDim + skypedBytes;\n        final int end =  dim * bytesPerDim + bytesPerDim;\n        return new IntroSelector() {\n\n          int pivotDoc = -1;\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            pivotDoc = points.docIDs[i];\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesLength;\n              int jOffset = j * packedBytesLength;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + start, iOffset + end,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return points.docIDs[i] - points.docIDs[j];\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesLength;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return pivotDoc - points.docIDs[j];\n          }\n        };\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[bytesPerDim];\n    PointValue pointValue = points.getPackedValueSlice(partitionPoint);\n    BytesRef packedValue = pointValue.packedValue();\n    System.arraycopy(packedValue.bytes, packedValue.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSelect(HeapPointWriter,int,int,int,int,int).mjava","sourceNew":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefixLength) {\n    final int dimOffset = dim * config.bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = config.bytesPerDim - commonPrefixLength;\n    final int dataOffset = config.packedIndexBytesLength - dimCmpBytes;\n    new RadixSelector(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * config.bytesPerDoc + dimOffset + k] & 0xff;\n        } else {\n          // data bytes\n          return points.block[i * config.bytesPerDoc + dataOffset + k] & 0xff;\n        }\n      }\n\n      @Override\n      protected Selector getFallbackSelector(int d) {\n        final int skypedBytes = d + commonPrefixLength;\n        final int dimStart = dim * config.bytesPerDim + skypedBytes;\n        final int dimEnd =  dim * config.bytesPerDim + config.bytesPerDim;\n        // data length is composed by the data dimensions plus the docID\n        final int dataLength = (config.numDims - config.numIndexDims) * config.bytesPerDim + Integer.BYTES;\n        return new IntroSelector() {\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < config.bytesPerDim) {\n              System.arraycopy(points.block, i * config.bytesPerDoc + dim * config.bytesPerDim, scratch, 0, config.bytesPerDim);\n            }\n            System.arraycopy(points.block, i * config.bytesPerDoc + config.packedIndexBytesLength, scratch, config.bytesPerDim, dataLength);\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < config.bytesPerDim) {\n              int iOffset = i * config.bytesPerDoc;\n              int jOffset = j * config.bytesPerDoc;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + dimStart, iOffset + dimEnd, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int iOffset = i * config.bytesPerDoc + config.packedIndexBytesLength;\n            int jOffset = j * config.bytesPerDoc + config.packedIndexBytesLength;\n            return Arrays.compareUnsigned(points.block, iOffset, iOffset + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < config.bytesPerDim) {\n              int jOffset = j * config.bytesPerDoc;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, config.bytesPerDim, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int jOffset = j * config.bytesPerDoc + config.packedIndexBytesLength;\n            return Arrays.compareUnsigned(scratch, config.bytesPerDim, config.bytesPerDim + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n        };\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[config.bytesPerDim];\n    PointValue pointValue = points.getPackedValueSlice(partitionPoint);\n    BytesRef packedValue = pointValue.packedValue();\n    System.arraycopy(packedValue.bytes, packedValue.offset + dim * config.bytesPerDim, partition, 0, config.bytesPerDim);\n    return partition;\n  }\n\n","sourceOld":"  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefixLength) {\n    final int dimOffset = dim * bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = bytesPerDim - commonPrefixLength;\n    final int dataOffset = numIndexDims * bytesPerDim - dimCmpBytes;\n    new RadixSelector(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesDocIDLength + dimOffset + k] & 0xff;\n        } else {\n          // data bytes\n          return points.block[i * packedBytesDocIDLength + dataOffset + k] & 0xff;\n        }\n      }\n\n      @Override\n      protected Selector getFallbackSelector(int d) {\n        final int skypedBytes = d + commonPrefixLength;\n        final int dimStart = dim * bytesPerDim + skypedBytes;\n        final int dimEnd =  dim * bytesPerDim + bytesPerDim;\n        final int dataOffset = numIndexDims * bytesPerDim;\n        // data length is composed by the data dimensions plus the docID\n        final int dataLength = (numDataDims - numIndexDims) * bytesPerDim + Integer.BYTES;\n        return new IntroSelector() {\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesDocIDLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            System.arraycopy(points.block, i * packedBytesDocIDLength + dataOffset, scratch, bytesPerDim, dataLength);\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesDocIDLength;\n              int jOffset = j * packedBytesDocIDLength;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + dimStart, iOffset + dimEnd, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int iOffset = i * packedBytesDocIDLength + dataOffset;\n            int jOffset = j * packedBytesDocIDLength + dataOffset;\n            return Arrays.compareUnsigned(points.block, iOffset, iOffset + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesDocIDLength;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int jOffset = j * packedBytesDocIDLength + dataOffset;\n            return Arrays.compareUnsigned(scratch, bytesPerDim, bytesPerDim + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n        };\n      }\n    }.select(from, to, partitionPoint);\n\n    byte[] partition = new byte[bytesPerDim];\n    PointValue pointValue = points.getPackedValueSlice(partitionPoint);\n    BytesRef packedValue = pointValue.packedValue();\n    System.arraycopy(packedValue.bytes, packedValue.offset + dim * bytesPerDim, partition, 0, bytesPerDim);\n    return partition;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7f06758793500ca773d0df1037290e6e404fb33":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["c7f06758793500ca773d0df1037290e6e404fb33"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["a69ebf290ab26d026cc224e517e0d93d931ac87b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a69ebf290ab26d026cc224e517e0d93d931ac87b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"c7f06758793500ca773d0df1037290e6e404fb33":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["c7f06758793500ca773d0df1037290e6e404fb33"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a69ebf290ab26d026cc224e517e0d93d931ac87b"],"a69ebf290ab26d026cc224e517e0d93d931ac87b":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}