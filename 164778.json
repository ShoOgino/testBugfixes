{"path":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db603debe12d21cac9f37467b795dd3a8559496a","date":1292767070,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb1b144119d471f0d0af58fe8cf3af07b40f72be","date":1292778444,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["60679157c78fc286ee35471398529a1e5749621c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60679157c78fc286ee35471398529a1e5749621c","date":1292841330,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":["eb1b144119d471f0d0af58fe8cf3af07b40f72be"],"bugIntro":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          updateMergeThreads();\n          if (verbose())\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n\n          merger.start();\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abba363b04df5f50b5ec36177b5cd17c3fe73d6b","date":1295268568,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"660be90ac3e6be139532015fd7a2bfd2d4037f18","date":1296318179,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          message(\"  consider merge \" + merge.segString(dir));\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":["8984893e6e8e4eaf80ab863dafae092a2e9b0eaa","b1405362241b561f5590ff4a87d5d6e173bcd9cf","0ebc2085cdebd1e698f670bed4679ec7306f8a57","ba7fd1181f778e9954547e8e6a47587ebf08e3fb","aa4b66eb16ead894fa7130904af6ecf34331f050"],"bugIntro":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          message(\"  consider merge \" + merge.segString(dir));\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer)\n    throws CorruptIndexException, IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while(true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          message(\"  consider merge \" + merge.segString(dir));\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          final MergeThread merger;\n          long startStallTime = 0;\n          while (mergeThreadCount() >= maxMergeCount) {\n            startStallTime = System.currentTimeMillis();\n            if (verbose()) {\n              message(\"    too many merges; stalling...\");\n            }\n            try {\n              wait();\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (verbose()) {\n            if (startStallTime != 0) {\n              message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n            }\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          assert mergeThreadCount() < maxMergeCount;\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5df35ab57c223ea11aec64b53bf611904f3dced","date":1323640545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          message(\"  consider merge \" + merge.segString(dir));\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose())\n          message(\"  no more merges pending; now return\");\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          message(\"  consider merge \" + merge.segString(dir));\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + writer.segString(merge.segments));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + merge.segString(dir));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + writer.segString(merge.segments));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + writer.segString(merge.segments));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["660be90ac3e6be139532015fd7a2bfd2d4037f18"],"70ad682703b8585f5d0a637efec044d57ec05efb":["9454a6510e2db155fb01faa5c049b06ece95fab9","60679157c78fc286ee35471398529a1e5749621c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["660be90ac3e6be139532015fd7a2bfd2d4037f18","c5df35ab57c223ea11aec64b53bf611904f3dced"],"db603debe12d21cac9f37467b795dd3a8559496a":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","60679157c78fc286ee35471398529a1e5749621c"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","abba363b04df5f50b5ec36177b5cd17c3fe73d6b"],"60679157c78fc286ee35471398529a1e5749621c":["eb1b144119d471f0d0af58fe8cf3af07b40f72be"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","660be90ac3e6be139532015fd7a2bfd2d4037f18"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"abba363b04df5f50b5ec36177b5cd17c3fe73d6b":["60679157c78fc286ee35471398529a1e5749621c"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["c5df35ab57c223ea11aec64b53bf611904f3dced"],"660be90ac3e6be139532015fd7a2bfd2d4037f18":["abba363b04df5f50b5ec36177b5cd17c3fe73d6b"],"eb1b144119d471f0d0af58fe8cf3af07b40f72be":["db603debe12d21cac9f37467b795dd3a8559496a"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["e79a6d080bdd5b2a8f56342cf571b5476de04180","660be90ac3e6be139532015fd7a2bfd2d4037f18"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","9ce667c6d3400b22523701c549c0d35e26da8b46"],"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"db603debe12d21cac9f37467b795dd3a8559496a":["eb1b144119d471f0d0af58fe8cf3af07b40f72be"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"60679157c78fc286ee35471398529a1e5749621c":["70ad682703b8585f5d0a637efec044d57ec05efb","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","abba363b04df5f50b5ec36177b5cd17c3fe73d6b"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"abba363b04df5f50b5ec36177b5cd17c3fe73d6b":["e79a6d080bdd5b2a8f56342cf571b5476de04180","660be90ac3e6be139532015fd7a2bfd2d4037f18"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"660be90ac3e6be139532015fd7a2bfd2d4037f18":["c5df35ab57c223ea11aec64b53bf611904f3dced","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"eb1b144119d471f0d0af58fe8cf3af07b40f72be":["60679157c78fc286ee35471398529a1e5749621c"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["70ad682703b8585f5d0a637efec044d57ec05efb","db603debe12d21cac9f37467b795dd3a8559496a","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}