{"path":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","commits":[{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          boolean lastIsSubBlock = false;\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && target.startsWith(term)) {\n              // Recurse\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                lastIsSubBlock = isSubBlock;\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                if (lastIsSubBlock) {\n                  // Recurse\n                  currentFrame = pushFrame(getState());\n                  break;\n                } else {\n                  //if (DEBUG) System.out.println(\"  fallback return term=\" + brToString(term) + \" curFrame.nextEnt=\" + currentFrame.nextEnt);\n                  return;\n                }\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b03ea9834e2d1bc787272cb563d331fa60f8686d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b03ea9834e2d1bc787272cb563d331fa60f8686d","date":1313940162,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          boolean lastIsSubBlock = false;\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && target.startsWith(term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                lastIsSubBlock = isSubBlock;\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","sourceOld":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          boolean lastIsSubBlock = false;\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix);\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && target.startsWith(term)) {\n              // Recurse\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                lastIsSubBlock = isSubBlock;\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                if (lastIsSubBlock) {\n                  // Recurse\n                  currentFrame = pushFrame(getState());\n                  break;\n                } else {\n                  //if (DEBUG) System.out.println(\"  fallback return term=\" + brToString(term) + \" curFrame.nextEnt=\" + currentFrame.nextEnt);\n                  return;\n                }\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","bugFix":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && target.startsWith(term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","sourceOld":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          boolean lastIsSubBlock = false;\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && target.startsWith(term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                lastIsSubBlock = isSubBlock;\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61f30939a6ca0891c7b0c0f34aa43800bd4c9a15","date":1322511317,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && StringHelper.startsWith(target, term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","sourceOld":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && target.startsWith(term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && StringHelper.startsWith(target, term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","sourceOld":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && StringHelper.startsWith(target, term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b03ea9834e2d1bc787272cb563d331fa60f8686d":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"61f30939a6ca0891c7b0c0f34aa43800bd4c9a15":["3cc749c053615f5871f3b95715fe292f34e70a53"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["b03ea9834e2d1bc787272cb563d331fa60f8686d"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["61f30939a6ca0891c7b0c0f34aa43800bd4c9a15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["b03ea9834e2d1bc787272cb563d331fa60f8686d"],"b03ea9834e2d1bc787272cb563d331fa60f8686d":["3cc749c053615f5871f3b95715fe292f34e70a53"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"61f30939a6ca0891c7b0c0f34aa43800bd4c9a15":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"3cc749c053615f5871f3b95715fe292f34e70a53":["61f30939a6ca0891c7b0c0f34aa43800bd4c9a15"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}