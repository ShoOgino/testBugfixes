{"path":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.ApiInfo#ApiInfo(PluginMeta,List[String]).mjava","commits":[{"id":"650b520f2a4daa4b0712e2393dc29ae7f21f10ac","date":1593054531,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.ApiInfo#ApiInfo(PluginMeta,List[String]).mjava","pathOld":"/dev/null","sourceNew":"    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    public ApiInfo(PluginMeta info, List<String> errs) {\n      this.info = info;\n      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n      pkg = klassInfo.first();\n      if (pkg != null) {\n        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n        if (p == null) {\n          errs.add(\"Invalid package \" + klassInfo.first());\n          return;\n        }\n        this.pkgVersion = p.getVersion(info.version);\n        if (pkgVersion == null) {\n          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n          return;\n        }\n        try {\n          klas = pkgVersion.getLoader().findClass(klassInfo.second(), Object.class);\n        } catch (Exception e) {\n          log.error(\"Error loading class\", e);\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n      } else {\n        try {\n          klas = Class.forName(klassInfo.second());\n        } catch (ClassNotFoundException e) {\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n        pkgVersion = null;\n      }\n      if (!Modifier.isPublic(klas.getModifiers())) {\n        errs.add(\"Class must be public and static : \" + klas.getName());\n        return;\n      }\n\n      try {\n        List<Api> apis = AnnotatedApi.getApis(klas, null);\n        for (Object api : apis) {\n          EndPoint endPoint = ((AnnotatedApi) api).getEndPoint();\n          if (endPoint.path().length > 1 || endPoint.method().length > 1) {\n            errs.add(\"Only one HTTP method and url supported for each API\");\n          }\n          if (endPoint.method().length != 1 || endPoint.path().length != 1) {\n            errs.add(\"The @EndPint must have exactly one method and path attributes\");\n          }\n          List<String> pathSegments = StrUtils.splitSmart(endPoint.path()[0], '/', true);\n          PathTrie.replaceTemplates(pathSegments, Collections.singletonMap(\"plugin-name\", info.name));\n          if (V2HttpCall.knownPrefixes.contains(pathSegments.get(0))) {\n            errs.add(\"path must not have a prefix: \"+pathSegments.get(0));\n          }\n\n        }\n      } catch (Exception e) {\n        errs.add(e.toString());\n      }\n      if (!errs.isEmpty()) return;\n\n      Constructor constructor = klas.getConstructors()[0];\n      if (constructor.getParameterTypes().length > 1 ||\n          (constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0] != CoreContainer.class)) {\n        errs.add(\"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n        return;\n      }\n      if (!Modifier.isPublic(constructor.getModifiers())) {\n        errs.add(\"Must have a public constructor \");\n        return;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2c4fba12438c1407e259b55774b5bbb707046a8","date":1593319746,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.ApiInfo#ApiInfo(PluginMeta,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.ApiInfo#ApiInfo(PluginMeta,List[String]).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    public ApiInfo(PluginMeta info, List<String> errs) {\n      this.info = info;\n      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n      pkg = klassInfo.first();\n      if (pkg != null) {\n        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n        if (p == null) {\n          errs.add(\"Invalid package \" + klassInfo.first());\n          return;\n        }\n        this.pkgVersion = p.getVersion(info.version);\n        if (pkgVersion == null) {\n          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n          return;\n        }\n        try {\n          klas = pkgVersion.getLoader().findClass(klassInfo.second(), Object.class);\n        } catch (Exception e) {\n          log.error(\"Error loading class\", e);\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n      } else {\n        try {\n          klas = Class.forName(klassInfo.second());\n        } catch (ClassNotFoundException e) {\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n        pkgVersion = null;\n      }\n      if (!Modifier.isPublic(klas.getModifiers())) {\n        errs.add(\"Class must be public and static : \" + klas.getName());\n        return;\n      }\n\n      try {\n        List<Api> apis = AnnotatedApi.getApis(klas, null);\n        for (Object api : apis) {\n          EndPoint endPoint = ((AnnotatedApi) api).getEndPoint();\n          if (endPoint.path().length > 1 || endPoint.method().length > 1) {\n            errs.add(\"Only one HTTP method and url supported for each API\");\n          }\n          if (endPoint.method().length != 1 || endPoint.path().length != 1) {\n            errs.add(\"The @EndPint must have exactly one method and path attributes\");\n          }\n          List<String> pathSegments = StrUtils.splitSmart(endPoint.path()[0], '/', true);\n          PathTrie.replaceTemplates(pathSegments, getTemplateVars(info));\n          if (V2HttpCall.knownPrefixes.contains(pathSegments.get(0))) {\n            errs.add(\"path must not have a prefix: \"+pathSegments.get(0));\n          }\n\n        }\n      } catch (Exception e) {\n        errs.add(e.toString());\n      }\n      if (!errs.isEmpty()) return;\n\n      Constructor constructor = klas.getConstructors()[0];\n      if (constructor.getParameterTypes().length > 1 ||\n          (constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0] != CoreContainer.class)) {\n        errs.add(\"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n        return;\n      }\n      if (!Modifier.isPublic(constructor.getModifiers())) {\n        errs.add(\"Must have a public constructor \");\n        return;\n      }\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    public ApiInfo(PluginMeta info, List<String> errs) {\n      this.info = info;\n      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n      pkg = klassInfo.first();\n      if (pkg != null) {\n        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n        if (p == null) {\n          errs.add(\"Invalid package \" + klassInfo.first());\n          return;\n        }\n        this.pkgVersion = p.getVersion(info.version);\n        if (pkgVersion == null) {\n          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n          return;\n        }\n        try {\n          klas = pkgVersion.getLoader().findClass(klassInfo.second(), Object.class);\n        } catch (Exception e) {\n          log.error(\"Error loading class\", e);\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n      } else {\n        try {\n          klas = Class.forName(klassInfo.second());\n        } catch (ClassNotFoundException e) {\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n        pkgVersion = null;\n      }\n      if (!Modifier.isPublic(klas.getModifiers())) {\n        errs.add(\"Class must be public and static : \" + klas.getName());\n        return;\n      }\n\n      try {\n        List<Api> apis = AnnotatedApi.getApis(klas, null);\n        for (Object api : apis) {\n          EndPoint endPoint = ((AnnotatedApi) api).getEndPoint();\n          if (endPoint.path().length > 1 || endPoint.method().length > 1) {\n            errs.add(\"Only one HTTP method and url supported for each API\");\n          }\n          if (endPoint.method().length != 1 || endPoint.path().length != 1) {\n            errs.add(\"The @EndPint must have exactly one method and path attributes\");\n          }\n          List<String> pathSegments = StrUtils.splitSmart(endPoint.path()[0], '/', true);\n          PathTrie.replaceTemplates(pathSegments, Collections.singletonMap(\"plugin-name\", info.name));\n          if (V2HttpCall.knownPrefixes.contains(pathSegments.get(0))) {\n            errs.add(\"path must not have a prefix: \"+pathSegments.get(0));\n          }\n\n        }\n      } catch (Exception e) {\n        errs.add(e.toString());\n      }\n      if (!errs.isEmpty()) return;\n\n      Constructor constructor = klas.getConstructors()[0];\n      if (constructor.getParameterTypes().length > 1 ||\n          (constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0] != CoreContainer.class)) {\n        errs.add(\"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n        return;\n      }\n      if (!Modifier.isPublic(constructor.getModifiers())) {\n        errs.add(\"Must have a public constructor \");\n        return;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.ApiInfo#ApiInfo(PluginMeta,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.ApiInfo#ApiInfo(PluginMeta,List[String]).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    public ApiInfo(PluginMeta info, List<String> errs) {\n      this.info = info;\n      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n      pkg = klassInfo.pkg;\n      if (pkg != null) {\n        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n        if (p == null) {\n          errs.add(\"Invalid package \" + klassInfo.pkg);\n          return;\n        }\n        this.pkgVersion = p.getVersion(info.version);\n        if (pkgVersion == null) {\n          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n          return;\n        }\n        try {\n          klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n        } catch (Exception e) {\n          log.error(\"Error loading class\", e);\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n      } else {\n        try {\n          klas = Class.forName(klassInfo.className);\n        } catch (ClassNotFoundException e) {\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n        pkgVersion = null;\n      }\n      if (!Modifier.isPublic(klas.getModifiers())) {\n        errs.add(\"Class must be public and static : \" + klas.getName());\n        return;\n      }\n\n      try {\n        List<Api> apis = AnnotatedApi.getApis(klas, null);\n        for (Object api : apis) {\n          EndPoint endPoint = ((AnnotatedApi) api).getEndPoint();\n          if (endPoint.path().length > 1 || endPoint.method().length > 1) {\n            errs.add(\"Only one HTTP method and url supported for each API\");\n          }\n          if (endPoint.method().length != 1 || endPoint.path().length != 1) {\n            errs.add(\"The @EndPint must have exactly one method and path attributes\");\n          }\n          List<String> pathSegments = StrUtils.splitSmart(endPoint.path()[0], '/', true);\n          PathTrie.replaceTemplates(pathSegments, getTemplateVars(info));\n          if (V2HttpCall.knownPrefixes.contains(pathSegments.get(0))) {\n            errs.add(\"path must not have a prefix: \"+pathSegments.get(0));\n          }\n\n        }\n      } catch (Exception e) {\n        errs.add(e.toString());\n      }\n      if (!errs.isEmpty()) return;\n\n      Constructor constructor = klas.getConstructors()[0];\n      if (constructor.getParameterTypes().length > 1 ||\n          (constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0] != CoreContainer.class)) {\n        errs.add(\"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n        return;\n      }\n      if (!Modifier.isPublic(constructor.getModifiers())) {\n        errs.add(\"Must have a public constructor \");\n        return;\n      }\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    public ApiInfo(PluginMeta info, List<String> errs) {\n      this.info = info;\n      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n      pkg = klassInfo.first();\n      if (pkg != null) {\n        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n        if (p == null) {\n          errs.add(\"Invalid package \" + klassInfo.first());\n          return;\n        }\n        this.pkgVersion = p.getVersion(info.version);\n        if (pkgVersion == null) {\n          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n          return;\n        }\n        try {\n          klas = pkgVersion.getLoader().findClass(klassInfo.second(), Object.class);\n        } catch (Exception e) {\n          log.error(\"Error loading class\", e);\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n      } else {\n        try {\n          klas = Class.forName(klassInfo.second());\n        } catch (ClassNotFoundException e) {\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n        pkgVersion = null;\n      }\n      if (!Modifier.isPublic(klas.getModifiers())) {\n        errs.add(\"Class must be public and static : \" + klas.getName());\n        return;\n      }\n\n      try {\n        List<Api> apis = AnnotatedApi.getApis(klas, null);\n        for (Object api : apis) {\n          EndPoint endPoint = ((AnnotatedApi) api).getEndPoint();\n          if (endPoint.path().length > 1 || endPoint.method().length > 1) {\n            errs.add(\"Only one HTTP method and url supported for each API\");\n          }\n          if (endPoint.method().length != 1 || endPoint.path().length != 1) {\n            errs.add(\"The @EndPint must have exactly one method and path attributes\");\n          }\n          List<String> pathSegments = StrUtils.splitSmart(endPoint.path()[0], '/', true);\n          PathTrie.replaceTemplates(pathSegments, getTemplateVars(info));\n          if (V2HttpCall.knownPrefixes.contains(pathSegments.get(0))) {\n            errs.add(\"path must not have a prefix: \"+pathSegments.get(0));\n          }\n\n        }\n      } catch (Exception e) {\n        errs.add(e.toString());\n      }\n      if (!errs.isEmpty()) return;\n\n      Constructor constructor = klas.getConstructors()[0];\n      if (constructor.getParameterTypes().length > 1 ||\n          (constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0] != CoreContainer.class)) {\n        errs.add(\"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n        return;\n      }\n      if (!Modifier.isPublic(constructor.getModifiers())) {\n        errs.add(\"Must have a public constructor \");\n        return;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f67fd8fd2e9ce826d02daa00a0ba2fd1ba1ba6c2","date":1600737649,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.ApiInfo#ApiInfo(PluginMeta,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.ApiInfo#ApiInfo(PluginMeta,List[String]).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    public ApiInfo(PluginMeta info, List<String> errs) {\n      this.info = info;\n      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n      pkg = klassInfo.pkg;\n      if (pkg != null) {\n        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n        if (ver.isEmpty()) {\n          //may be we are a bit early. Do a refresh and try again\n         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n        }\n        if (ver.isEmpty()) {\n          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n          if (p == null) {\n            errs.add(\"Invalid package \" + klassInfo.pkg);\n            return;\n          } else {\n            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n            return;\n          }\n        }\n        this.pkgVersion = ver.get();\n        try {\n          klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n        } catch (Exception e) {\n          log.error(\"Error loading class\", e);\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n      } else {\n        try {\n          klas = Class.forName(klassInfo.className);\n        } catch (ClassNotFoundException e) {\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n        pkgVersion = null;\n      }\n      if (!Modifier.isPublic(klas.getModifiers())) {\n        errs.add(\"Class must be public and static : \" + klas.getName());\n        return;\n      }\n\n      try {\n        List<Api> apis = AnnotatedApi.getApis(klas, null);\n        for (Object api : apis) {\n          EndPoint endPoint = ((AnnotatedApi) api).getEndPoint();\n          if (endPoint.path().length > 1 || endPoint.method().length > 1) {\n            errs.add(\"Only one HTTP method and url supported for each API\");\n          }\n          if (endPoint.method().length != 1 || endPoint.path().length != 1) {\n            errs.add(\"The @EndPint must have exactly one method and path attributes\");\n          }\n          List<String> pathSegments = StrUtils.splitSmart(endPoint.path()[0], '/', true);\n          PathTrie.replaceTemplates(pathSegments, getTemplateVars(info));\n          if (V2HttpCall.knownPrefixes.contains(pathSegments.get(0))) {\n            errs.add(\"path must not have a prefix: \"+pathSegments.get(0));\n          }\n\n        }\n      } catch (Exception e) {\n        errs.add(e.toString());\n      }\n      if (!errs.isEmpty()) return;\n\n      Constructor constructor = klas.getConstructors()[0];\n      if (constructor.getParameterTypes().length > 1 ||\n          (constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0] != CoreContainer.class)) {\n        errs.add(\"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n        return;\n      }\n      if (!Modifier.isPublic(constructor.getModifiers())) {\n        errs.add(\"Must have a public constructor \");\n        return;\n      }\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    public ApiInfo(PluginMeta info, List<String> errs) {\n      this.info = info;\n      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n      pkg = klassInfo.pkg;\n      if (pkg != null) {\n        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n        if (p == null) {\n          errs.add(\"Invalid package \" + klassInfo.pkg);\n          return;\n        }\n        this.pkgVersion = p.getVersion(info.version);\n        if (pkgVersion == null) {\n          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n          return;\n        }\n        try {\n          klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n        } catch (Exception e) {\n          log.error(\"Error loading class\", e);\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n      } else {\n        try {\n          klas = Class.forName(klassInfo.className);\n        } catch (ClassNotFoundException e) {\n          errs.add(\"Error loading class \" + e.toString());\n          return;\n        }\n        pkgVersion = null;\n      }\n      if (!Modifier.isPublic(klas.getModifiers())) {\n        errs.add(\"Class must be public and static : \" + klas.getName());\n        return;\n      }\n\n      try {\n        List<Api> apis = AnnotatedApi.getApis(klas, null);\n        for (Object api : apis) {\n          EndPoint endPoint = ((AnnotatedApi) api).getEndPoint();\n          if (endPoint.path().length > 1 || endPoint.method().length > 1) {\n            errs.add(\"Only one HTTP method and url supported for each API\");\n          }\n          if (endPoint.method().length != 1 || endPoint.path().length != 1) {\n            errs.add(\"The @EndPint must have exactly one method and path attributes\");\n          }\n          List<String> pathSegments = StrUtils.splitSmart(endPoint.path()[0], '/', true);\n          PathTrie.replaceTemplates(pathSegments, getTemplateVars(info));\n          if (V2HttpCall.knownPrefixes.contains(pathSegments.get(0))) {\n            errs.add(\"path must not have a prefix: \"+pathSegments.get(0));\n          }\n\n        }\n      } catch (Exception e) {\n        errs.add(e.toString());\n      }\n      if (!errs.isEmpty()) return;\n\n      Constructor constructor = klas.getConstructors()[0];\n      if (constructor.getParameterTypes().length > 1 ||\n          (constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0] != CoreContainer.class)) {\n        errs.add(\"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n        return;\n      }\n      if (!Modifier.isPublic(constructor.getModifiers())) {\n        errs.add(\"Must have a public constructor \");\n        return;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f67fd8fd2e9ce826d02daa00a0ba2fd1ba1ba6c2":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["e2c4fba12438c1407e259b55774b5bbb707046a8"],"650b520f2a4daa4b0712e2393dc29ae7f21f10ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2c4fba12438c1407e259b55774b5bbb707046a8":["650b520f2a4daa4b0712e2393dc29ae7f21f10ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f67fd8fd2e9ce826d02daa00a0ba2fd1ba1ba6c2"]},"commit2Childs":{"f67fd8fd2e9ce826d02daa00a0ba2fd1ba1ba6c2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["f67fd8fd2e9ce826d02daa00a0ba2fd1ba1ba6c2"],"650b520f2a4daa4b0712e2393dc29ae7f21f10ac":["e2c4fba12438c1407e259b55774b5bbb707046a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["650b520f2a4daa4b0712e2393dc29ae7f21f10ac"],"e2c4fba12438c1407e259b55774b5bbb707046a8":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}