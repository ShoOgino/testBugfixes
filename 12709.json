{"path":"lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"/dev/null","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99cf56f3a650b908f7017a72f9d23940418f8a52","date":1284891529,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":5,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","99cf56f3a650b908f7017a72f9d23940418f8a52"],"99cf56f3a650b908f7017a72f9d23940418f8a52":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99cf56f3a650b908f7017a72f9d23940418f8a52"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","99cf56f3a650b908f7017a72f9d23940418f8a52"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"99cf56f3a650b908f7017a72f9d23940418f8a52":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}