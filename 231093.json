{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","commits":[{"id":"41aee74b5f91a096e3fd950f4a336bc763f0e7a7","date":1381772070,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqPayloadIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator tfit) throws IOException {\n    if (tfit.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqPayloadIterator tfit) throws IOException {\n    if (tfit.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a645276cbaf5dc96a42fd473b9019bde352996c8","date":1391806699,"type":3,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator tfit) throws IOException {\n    if (tfit.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"36f5a8c57e16c0f801006a52f87c75378427852e","date":1393256707,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba791bce8103c79e38f957e9c5a53a75871bd918","date":1393539206,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":["7bf07f4ebadc7539de83a531e64678350d78ca26","ec8eab7160b056ec8e7148e8754bf056eb47e423"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b","date":1395588343,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":["d334a3e8e6b94298d8cf2802a403a096c06f0b92","7bf07f4ebadc7539de83a531e64678350d78ca26"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbc3688252d4a8045d69a164236b2cf87b721f17","date":1409846185,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      Files.delete(tempInput.toPath());\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      if (success) {\n        Files.delete(tempSorted.toPath());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":["7bf07f4ebadc7539de83a531e64678350d78ca26","ec8eab7160b056ec8e7148e8754bf056eb47e423"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    Path tempInput = Files.createTempFile(\n        OfflineSorter.defaultTempDir(), FSTCompletionLookup.class.getSimpleName(), \".input\");\n    Path tempSorted = Files.createTempFile(\n        OfflineSorter.defaultTempDir(), FSTCompletionLookup.class.getSimpleName(), \".sorted\");\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      Files.delete(tempInput);\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      if (success) {\n        Files.delete(tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", OfflineSorter.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", OfflineSorter.defaultTempDir());\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      Files.delete(tempInput.toPath());\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      if (success) {\n        Files.delete(tempSorted.toPath());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2","date":1443129829,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    Path tempInput = Files.createTempFile(\n        OfflineSorter.getDefaultTempDir(), FSTCompletionLookup.class.getSimpleName(), \".input\");\n    Path tempSorted = Files.createTempFile(\n        OfflineSorter.getDefaultTempDir(), FSTCompletionLookup.class.getSimpleName(), \".sorted\");\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      Files.delete(tempInput);\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      if (success) {\n        Files.delete(tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    Path tempInput = Files.createTempFile(\n        OfflineSorter.defaultTempDir(), FSTCompletionLookup.class.getSimpleName(), \".input\");\n    Path tempSorted = Files.createTempFile(\n        OfflineSorter.defaultTempDir(), FSTCompletionLookup.class.getSimpleName(), \".sorted\");\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      Files.delete(tempInput);\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      if (success) {\n        Files.delete(tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFile(tempInput.getName());\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    Path tempInput = Files.createTempFile(\n        OfflineSorter.getDefaultTempDir(), FSTCompletionLookup.class.getSimpleName(), \".input\");\n    Path tempSorted = Files.createTempFile(\n        OfflineSorter.getDefaultTempDir(), FSTCompletionLookup.class.getSimpleName(), \".sorted\");\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);\n      Files.delete(tempInput);\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      if (success) {\n        Files.delete(tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFiles(Collections.singleton(tempInput.getName()));\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFile(tempInput.getName());\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFile(tempInput.getName());\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFiles(Collections.singleton(tempInput.getName()));\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950b7a6881d14da782b60444c11295e3ec50d41a","date":1458379095,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFile(tempInput.getName());\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFile(tempInput.getName());\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7849935cc625c020857f3b29be91b5d4323d19aa","date":1458978426,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFile(tempInput.getName());\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp2 = new BytesRef();\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = scratch.bytes;\n        tmp2.offset = scratch.offset + input.getPosition();\n        tmp2.length = scratch.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix);\n    ExternalRefSorter externalSorter = new ExternalRefSorter(sorter);\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    String tempSortedFileName = null;\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    count = 0;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      int inputLineCount = 0;\n      while ((spare = iterator.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(iterator.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n        inputLineCount++;\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      tempDir.deleteFile(tempInput.getName());\n\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, externalSorter, sharedTailLength);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRefBuilder tmp1 = new BytesRefBuilder();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes());\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLineCount);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes();\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length() - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n        count++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer, externalSorter);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"f4abec28b874149a7223e32cc7a01704c27790de":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"a645276cbaf5dc96a42fd473b9019bde352996c8":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2":["f4abec28b874149a7223e32cc7a01704c27790de"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["a645276cbaf5dc96a42fd473b9019bde352996c8","36f5a8c57e16c0f801006a52f87c75378427852e"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"36f5a8c57e16c0f801006a52f87c75378427852e":["a645276cbaf5dc96a42fd473b9019bde352996c8"],"7849935cc625c020857f3b29be91b5d4323d19aa":["950b7a6881d14da782b60444c11295e3ec50d41a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"950b7a6881d14da782b60444c11295e3ec50d41a":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7849935cc625c020857f3b29be91b5d4323d19aa"]},"commit2Childs":{"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["a645276cbaf5dc96a42fd473b9019bde352996c8"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"f4abec28b874149a7223e32cc7a01704c27790de":["8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2"],"a645276cbaf5dc96a42fd473b9019bde352996c8":["ba791bce8103c79e38f957e9c5a53a75871bd918","36f5a8c57e16c0f801006a52f87c75378427852e"],"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["f4abec28b874149a7223e32cc7a01704c27790de"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":[],"36f5a8c57e16c0f801006a52f87c75378427852e":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"7849935cc625c020857f3b29be91b5d4323d19aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"950b7a6881d14da782b60444c11295e3ec50d41a":["7849935cc625c020857f3b29be91b5d4323d19aa"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["950b7a6881d14da782b60444c11295e3ec50d41a","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}