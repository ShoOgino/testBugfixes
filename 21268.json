{"path":"src/java/org/apache/solr/search/HashDocSet#rehash(int).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/HashDocSet#rehash(int).mjava","pathOld":"/dev/null","sourceNew":"  // As the size of this int hashtable is expected to be small\n  // (thousands at most), I did not try to keep the rehash function\n  // reversible (important to avoid collisions in large hash tables).\n  private int rehash(int val) {\n    int h,s,v;\n    final int comp=~val;\n\n    // don't left shift too far... the only bits\n    // that count in the answer are the ones on the right.\n    // We want to put more of the bits on the left\n    // into the answer.\n    // Keep small tables in mind.  We may be only using\n    // the first 5 or 6 bits.\n\n    // on the first rehash, use complement instead of val to shift\n    // so we don't end up with 0 again if val==0.\n    h = val ^ (comp>>8);\n    s = h & mask;\n    v = table[s];\n    if (v==EMPTY || v==val) return s;\n\n    h ^= (v << 17) | (comp >>> 16);   // this is reversible\n    s = h & mask;\n    v = table[s];\n    if (v==EMPTY || v==val) return s;\n\n    h ^= (h << 8) | (comp >>> 25);    // this is reversible\n    s = h & mask;\n    v = table[s];\n    if (v==EMPTY || v==val) return s;\n\n    /**********************\n     // Knuth, Thomas Wang, http://www.concentric.net/~Ttwang/tech/inthash.htm\n     // This magic number has no common factors with 2^32, and magic/(2^32) approximates\n     // the golden ratio.\n    private static final int magic = (int)2654435761L;\n\n    h = magic*val;\n    s = h & mask;\n    v=table[s];\n    if (v==EMPTY || v==val) return s;\n\n    // the mult with magic should have thoroughly mixed the bits.\n    // add entropy to the right half from the left half.\n    h ^= h>>>16;\n    s = h & mask;\n    v=table[s];\n    if (v==EMPTY || v==val) return s;\n    *************************/\n\n    // linear scan now... ug.\n    final int start=s;\n    while (++s<tablesize) {\n      v=table[s];\n      if (v==EMPTY || v==val) return s;\n    }\n    s=start;\n    while (--s>=0) {\n      v=table[s];\n      if (v==EMPTY || v==val) return s;\n    }\n    return s;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e97c9c9ecb6ca9b558635bc9787f15f4cf19040","date":1169358391,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/solr/search/HashDocSet#rehash(int).mjava","sourceNew":null,"sourceOld":"  // As the size of this int hashtable is expected to be small\n  // (thousands at most), I did not try to keep the rehash function\n  // reversible (important to avoid collisions in large hash tables).\n  private int rehash(int val) {\n    int h,s,v;\n    final int comp=~val;\n\n    // don't left shift too far... the only bits\n    // that count in the answer are the ones on the right.\n    // We want to put more of the bits on the left\n    // into the answer.\n    // Keep small tables in mind.  We may be only using\n    // the first 5 or 6 bits.\n\n    // on the first rehash, use complement instead of val to shift\n    // so we don't end up with 0 again if val==0.\n    h = val ^ (comp>>8);\n    s = h & mask;\n    v = table[s];\n    if (v==EMPTY || v==val) return s;\n\n    h ^= (v << 17) | (comp >>> 16);   // this is reversible\n    s = h & mask;\n    v = table[s];\n    if (v==EMPTY || v==val) return s;\n\n    h ^= (h << 8) | (comp >>> 25);    // this is reversible\n    s = h & mask;\n    v = table[s];\n    if (v==EMPTY || v==val) return s;\n\n    /**********************\n     // Knuth, Thomas Wang, http://www.concentric.net/~Ttwang/tech/inthash.htm\n     // This magic number has no common factors with 2^32, and magic/(2^32) approximates\n     // the golden ratio.\n    private static final int magic = (int)2654435761L;\n\n    h = magic*val;\n    s = h & mask;\n    v=table[s];\n    if (v==EMPTY || v==val) return s;\n\n    // the mult with magic should have thoroughly mixed the bits.\n    // add entropy to the right half from the left half.\n    h ^= h>>>16;\n    s = h & mask;\n    v=table[s];\n    if (v==EMPTY || v==val) return s;\n    *************************/\n\n    // linear scan now... ug.\n    final int start=s;\n    while (++s<tablesize) {\n      v=table[s];\n      if (v==EMPTY || v==val) return s;\n    }\n    s=start;\n    while (--s>=0) {\n      v=table[s];\n      if (v==EMPTY || v==val) return s;\n    }\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"0e97c9c9ecb6ca9b558635bc9787f15f4cf19040":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["0e97c9c9ecb6ca9b558635bc9787f15f4cf19040"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0e97c9c9ecb6ca9b558635bc9787f15f4cf19040":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0e97c9c9ecb6ca9b558635bc9787f15f4cf19040","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}