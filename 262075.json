{"path":"lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesConsumer#merge(org.apache.lucene.index.codecs.MergeState,DocValues).mjava","commits":[{"id":"39f3757037aa8f710c0cbf9a76a332de735f58b0","date":1288384416,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesConsumer#merge(org.apache.lucene.index.codecs.MergeState,DocValues).mjava","pathOld":"/dev/null","sourceNew":"  public void merge(org.apache.lucene.index.codecs.MergeState mergeState,\n      DocValues values) throws IOException {\n    // TODO we need some kind of compatibility notation for values such\n    // that two slightly different segments can be merged eg. fixed vs.\n    // variable byte len or float32 vs. float64\n    int docBase = 0;\n    boolean merged = false;\n    /*\n     * We ignore the given DocValues here and merge from the subReaders directly\n     * to support bulk copies on the DocValues Writer level. if this gets merged\n     * with MultiDocValues the writer can not optimize for bulk-copyable data\n     */\n    for (final IndexReader reader : mergeState.readers) {\n      final DocValues r = reader.docValues(mergeState.fieldInfo.name);\n      if (r != null) {\n        merged = true;\n        merge(new Writer.MergeState(r, docBase, reader.maxDoc(), reader\n            .getDeletedDocs()));\n      }\n      docBase += reader.numDocs();\n    }\n    if (merged)\n      finish(mergeState.mergedDocCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16dc5aef9648bb8fedce2ef55874f52e62c2766d","date":1293994163,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesConsumer#merge(org.apache.lucene.index.codecs.MergeState,DocValues).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesConsumer#merge(org.apache.lucene.index.codecs.MergeState,DocValues).mjava","sourceNew":"  /**\n   * Merges the given {@link org.apache.lucene.index.codecs.MergeState} into\n   * this {@link DocValuesConsumer}.\n   * \n   * @param mergeState\n   *          the state to merge\n   * @param values\n   *          the docValues to merge in\n   * @throws IOException\n   *           if an {@link IOException} occurs\n   */\n  public void merge(org.apache.lucene.index.codecs.MergeState mergeState,\n      DocValues values) throws IOException {\n    assert mergeState != null;\n    // TODO we need some kind of compatibility notation for values such\n    // that two slightly different segments can be merged eg. fixed vs.\n    // variable byte len or float32 vs. float64\n    int docBase = 0;\n    boolean merged = false;\n    /*\n     * We ignore the given DocValues here and merge from the subReaders directly\n     * to support bulk copies on the DocValues Writer level. if this gets merged\n     * with MultiDocValues the writer can not optimize for bulk-copyable data\n     */\n    for (final IndexReader reader : mergeState.readers) {\n      final DocValues r = reader.docValues(mergeState.fieldInfo.name);\n      if (r != null) {\n        merged = true;\n        merge(new Writer.MergeState(r, docBase, reader.maxDoc(), reader\n            .getDeletedDocs()));\n      }\n      docBase += reader.numDocs();\n    }\n    if (merged) {\n      finish(mergeState.mergedDocCount);\n    }\n  }\n\n","sourceOld":"  public void merge(org.apache.lucene.index.codecs.MergeState mergeState,\n      DocValues values) throws IOException {\n    // TODO we need some kind of compatibility notation for values such\n    // that two slightly different segments can be merged eg. fixed vs.\n    // variable byte len or float32 vs. float64\n    int docBase = 0;\n    boolean merged = false;\n    /*\n     * We ignore the given DocValues here and merge from the subReaders directly\n     * to support bulk copies on the DocValues Writer level. if this gets merged\n     * with MultiDocValues the writer can not optimize for bulk-copyable data\n     */\n    for (final IndexReader reader : mergeState.readers) {\n      final DocValues r = reader.docValues(mergeState.fieldInfo.name);\n      if (r != null) {\n        merged = true;\n        merge(new Writer.MergeState(r, docBase, reader.maxDoc(), reader\n            .getDeletedDocs()));\n      }\n      docBase += reader.numDocs();\n    }\n    if (merged)\n      finish(mergeState.mergedDocCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d47326e0c6ce589b6962777df409aad0550940fa","date":1304584540,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DocValuesConsumer#merge(org.apache.lucene.index.codecs.MergeState,DocValues).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesConsumer#merge(org.apache.lucene.index.codecs.MergeState,DocValues).mjava","sourceNew":"  /**\n   * Merges the given {@link org.apache.lucene.index.codecs.MergeState} into\n   * this {@link DocValuesConsumer}.\n   * \n   * @param mergeState\n   *          the state to merge\n   * @param values\n   *          the docValues to merge in\n   * @throws IOException\n   *           if an {@link IOException} occurs\n   */\n  public void merge(org.apache.lucene.index.codecs.MergeState mergeState,\n      DocValues values) throws IOException {\n    assert mergeState != null;\n    // TODO we need some kind of compatibility notation for values such\n    // that two slightly different segments can be merged eg. fixed vs.\n    // variable byte len or float32 vs. float64\n    int docBase = 0;\n    boolean merged = false;\n    /*\n     * We ignore the given DocValues here and merge from the subReaders directly\n     * to support bulk copies on the DocValues Writer level. if this gets merged\n     * with MultiDocValues the writer can not optimize for bulk-copyable data\n     */\n    for (final IndexReader reader : mergeState.readers) {\n      final DocValues r = reader.docValues(mergeState.fieldInfo.name);\n      if (r != null) {\n        merged = true;\n        merge(new Writer.MergeState(r, docBase, reader.maxDoc(), reader\n            .getDeletedDocs()));\n      }\n      docBase += reader.numDocs();\n    }\n    if (merged) {\n      finish(mergeState.mergedDocCount);\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the given {@link org.apache.lucene.index.codecs.MergeState} into\n   * this {@link DocValuesConsumer}.\n   * \n   * @param mergeState\n   *          the state to merge\n   * @param values\n   *          the docValues to merge in\n   * @throws IOException\n   *           if an {@link IOException} occurs\n   */\n  public void merge(org.apache.lucene.index.codecs.MergeState mergeState,\n      DocValues values) throws IOException {\n    assert mergeState != null;\n    // TODO we need some kind of compatibility notation for values such\n    // that two slightly different segments can be merged eg. fixed vs.\n    // variable byte len or float32 vs. float64\n    int docBase = 0;\n    boolean merged = false;\n    /*\n     * We ignore the given DocValues here and merge from the subReaders directly\n     * to support bulk copies on the DocValues Writer level. if this gets merged\n     * with MultiDocValues the writer can not optimize for bulk-copyable data\n     */\n    for (final IndexReader reader : mergeState.readers) {\n      final DocValues r = reader.docValues(mergeState.fieldInfo.name);\n      if (r != null) {\n        merged = true;\n        merge(new Writer.MergeState(r, docBase, reader.maxDoc(), reader\n            .getDeletedDocs()));\n      }\n      docBase += reader.numDocs();\n    }\n    if (merged) {\n      finish(mergeState.mergedDocCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"39f3757037aa8f710c0cbf9a76a332de735f58b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"16dc5aef9648bb8fedce2ef55874f52e62c2766d":["39f3757037aa8f710c0cbf9a76a332de735f58b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d47326e0c6ce589b6962777df409aad0550940fa":["16dc5aef9648bb8fedce2ef55874f52e62c2766d"]},"commit2Childs":{"39f3757037aa8f710c0cbf9a76a332de735f58b0":["16dc5aef9648bb8fedce2ef55874f52e62c2766d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["39f3757037aa8f710c0cbf9a76a332de735f58b0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"16dc5aef9648bb8fedce2ef55874f52e62c2766d":["d47326e0c6ce589b6962777df409aad0550940fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d47326e0c6ce589b6962777df409aad0550940fa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","d47326e0c6ce589b6962777df409aad0550940fa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}