{"path":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","commits":[{"id":"92009ce6b3696f548a1c7eb9fcf8cab29b541426","date":1375140262,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]]).mjava","sourceNew":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings({\"fallthrough\", \"resource\"})\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {\n    CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);\n    final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<Object>() : null;\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),\n      valueStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();\n            if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {\n              // we found a charset declaration in the raw bytes\n              if (charsetDecoder != null) {\n                throw new SolrException(ErrorCode.BAD_REQUEST,\n                  supportCharsetParam ? (\n                    \"Query string invalid: duplicate '\"+\n                    INPUT_ENCODING_KEY + \"' (input encoding) key.\"\n                  ) : (\n                    \"Key '\" + INPUT_ENCODING_KEY + \"' (input encoding) cannot \"+\n                    \"be used in POSTed application/x-www-form-urlencoded form data. \"+\n                    \"To set the input encoding of POSTed form data, use the \"+\n                    \"'Content-Type' header and provide a charset!\"\n                  )\n                );\n              }\n              // decode the charset from raw bytes\n              charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));\n              charsetDecoder = getCharsetDecoder(charset);\n              // finally decode all buffered tokens\n              decodeBuffer(buffer, map, charsetDecoder);\n            } else if (charsetDecoder == null) {\n              // we have no charset decoder until now, buffer the keys / values for later processing:\n              buffer.add(keyBytes);\n              buffer.add(Long.valueOf(keyPos));\n              buffer.add(valueBytes);\n              buffer.add(Long.valueOf(valuePos));\n            } else {\n              // we already have a charsetDecoder, so we can directly decode without buffering:\n              final String key = decodeChars(keyBytes, keyPos, charsetDecoder),\n                  value = decodeChars(valueBytes, valuePos, charsetDecoder);\n              MultiMapSolrParams.addParam(key, value, map);\n            }\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):\n    if (buffer != null && !buffer.isEmpty()) {\n      assert charsetDecoder == null;\n      decodeBuffer(buffer, map, getCharsetDecoder(charset));\n    }\n    return len;\n  }\n\n","sourceOld":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings(\"fallthrough\")\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, final Charset charset, final Map<String,String[]> map) throws IOException {\n    final CharsetDecoder charsetDecoder = charset.newDecoder()\n      .onMalformedInput(CodingErrorAction.REPORT)\n      .onUnmappableCharacter(CodingErrorAction.REPORT);\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream2 keyStream = new ByteArrayOutputStream2(),\n      valueStream = new ByteArrayOutputStream2();\n    ByteArrayOutputStream2 currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final String key = decodeChars(keyStream, keyPos, charsetDecoder), value = decodeChars(valueStream, valuePos, charsetDecoder);\n            MultiMapSolrParams.addParam(key, value, map);\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    return len;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":1,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]]).mjava","sourceNew":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings({\"fallthrough\", \"resource\"})\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {\n    CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);\n    final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<Object>() : null;\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),\n      valueStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();\n            if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {\n              // we found a charset declaration in the raw bytes\n              if (charsetDecoder != null) {\n                throw new SolrException(ErrorCode.BAD_REQUEST,\n                  supportCharsetParam ? (\n                    \"Query string invalid: duplicate '\"+\n                    INPUT_ENCODING_KEY + \"' (input encoding) key.\"\n                  ) : (\n                    \"Key '\" + INPUT_ENCODING_KEY + \"' (input encoding) cannot \"+\n                    \"be used in POSTed application/x-www-form-urlencoded form data. \"+\n                    \"To set the input encoding of POSTed form data, use the \"+\n                    \"'Content-Type' header and provide a charset!\"\n                  )\n                );\n              }\n              // decode the charset from raw bytes\n              charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));\n              charsetDecoder = getCharsetDecoder(charset);\n              // finally decode all buffered tokens\n              decodeBuffer(buffer, map, charsetDecoder);\n            } else if (charsetDecoder == null) {\n              // we have no charset decoder until now, buffer the keys / values for later processing:\n              buffer.add(keyBytes);\n              buffer.add(Long.valueOf(keyPos));\n              buffer.add(valueBytes);\n              buffer.add(Long.valueOf(valuePos));\n            } else {\n              // we already have a charsetDecoder, so we can directly decode without buffering:\n              final String key = decodeChars(keyBytes, keyPos, charsetDecoder),\n                  value = decodeChars(valueBytes, valuePos, charsetDecoder);\n              MultiMapSolrParams.addParam(key, value, map);\n            }\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):\n    if (buffer != null && !buffer.isEmpty()) {\n      assert charsetDecoder == null;\n      decodeBuffer(buffer, map, getCharsetDecoder(charset));\n    }\n    return len;\n  }\n\n","sourceOld":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings(\"fallthrough\")\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, final Charset charset, final Map<String,String[]> map) throws IOException {\n    final CharsetDecoder charsetDecoder = charset.newDecoder()\n      .onMalformedInput(CodingErrorAction.REPORT)\n      .onUnmappableCharacter(CodingErrorAction.REPORT);\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream2 keyStream = new ByteArrayOutputStream2(),\n      valueStream = new ByteArrayOutputStream2();\n    ByteArrayOutputStream2 currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final String key = decodeChars(keyStream, keyPos, charsetDecoder), value = decodeChars(valueStream, valuePos, charsetDecoder);\n            MultiMapSolrParams.addParam(key, value, map);\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    return len;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","sourceNew":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings({\"fallthrough\", \"resource\"})\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {\n    CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);\n    final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<>() : null;\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),\n      valueStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();\n            if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {\n              // we found a charset declaration in the raw bytes\n              if (charsetDecoder != null) {\n                throw new SolrException(ErrorCode.BAD_REQUEST,\n                  supportCharsetParam ? (\n                    \"Query string invalid: duplicate '\"+\n                    INPUT_ENCODING_KEY + \"' (input encoding) key.\"\n                  ) : (\n                    \"Key '\" + INPUT_ENCODING_KEY + \"' (input encoding) cannot \"+\n                    \"be used in POSTed application/x-www-form-urlencoded form data. \"+\n                    \"To set the input encoding of POSTed form data, use the \"+\n                    \"'Content-Type' header and provide a charset!\"\n                  )\n                );\n              }\n              // decode the charset from raw bytes\n              charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));\n              charsetDecoder = getCharsetDecoder(charset);\n              // finally decode all buffered tokens\n              decodeBuffer(buffer, map, charsetDecoder);\n            } else if (charsetDecoder == null) {\n              // we have no charset decoder until now, buffer the keys / values for later processing:\n              buffer.add(keyBytes);\n              buffer.add(Long.valueOf(keyPos));\n              buffer.add(valueBytes);\n              buffer.add(Long.valueOf(valuePos));\n            } else {\n              // we already have a charsetDecoder, so we can directly decode without buffering:\n              final String key = decodeChars(keyBytes, keyPos, charsetDecoder),\n                  value = decodeChars(valueBytes, valuePos, charsetDecoder);\n              MultiMapSolrParams.addParam(key, value, map);\n            }\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):\n    if (buffer != null && !buffer.isEmpty()) {\n      assert charsetDecoder == null;\n      decodeBuffer(buffer, map, getCharsetDecoder(charset));\n    }\n    return len;\n  }\n\n","sourceOld":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings({\"fallthrough\", \"resource\"})\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {\n    CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);\n    final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<Object>() : null;\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),\n      valueStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();\n            if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {\n              // we found a charset declaration in the raw bytes\n              if (charsetDecoder != null) {\n                throw new SolrException(ErrorCode.BAD_REQUEST,\n                  supportCharsetParam ? (\n                    \"Query string invalid: duplicate '\"+\n                    INPUT_ENCODING_KEY + \"' (input encoding) key.\"\n                  ) : (\n                    \"Key '\" + INPUT_ENCODING_KEY + \"' (input encoding) cannot \"+\n                    \"be used in POSTed application/x-www-form-urlencoded form data. \"+\n                    \"To set the input encoding of POSTed form data, use the \"+\n                    \"'Content-Type' header and provide a charset!\"\n                  )\n                );\n              }\n              // decode the charset from raw bytes\n              charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));\n              charsetDecoder = getCharsetDecoder(charset);\n              // finally decode all buffered tokens\n              decodeBuffer(buffer, map, charsetDecoder);\n            } else if (charsetDecoder == null) {\n              // we have no charset decoder until now, buffer the keys / values for later processing:\n              buffer.add(keyBytes);\n              buffer.add(Long.valueOf(keyPos));\n              buffer.add(valueBytes);\n              buffer.add(Long.valueOf(valuePos));\n            } else {\n              // we already have a charsetDecoder, so we can directly decode without buffering:\n              final String key = decodeChars(keyBytes, keyPos, charsetDecoder),\n                  value = decodeChars(valueBytes, valuePos, charsetDecoder);\n              MultiMapSolrParams.addParam(key, value, map);\n            }\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):\n    if (buffer != null && !buffer.isEmpty()) {\n      assert charsetDecoder == null;\n      decodeBuffer(buffer, map, getCharsetDecoder(charset));\n    }\n    return len;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d17ec5164debc23076db7fd11d0331f201583b5","date":1426658173,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","sourceNew":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings({\"fallthrough\", \"resource\"})\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {\n    CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);\n    final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<>() : null;\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),\n      valueStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();\n            if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {\n              // we found a charset declaration in the raw bytes\n              if (charsetDecoder != null) {\n                throw new SolrException(ErrorCode.BAD_REQUEST,\n                  supportCharsetParam ? (\n                    \"Query string invalid: duplicate '\"+\n                    INPUT_ENCODING_KEY + \"' (input encoding) key.\"\n                  ) : (\n                    \"Key '\" + INPUT_ENCODING_KEY + \"' (input encoding) cannot \"+\n                    \"be used in POSTed application/x-www-form-urlencoded form data. \"+\n                    \"To set the input encoding of POSTed form data, use the \"+\n                    \"'Content-Type' header and provide a charset!\"\n                  )\n                );\n              }\n              // decode the charset from raw bytes\n              charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));\n              charsetDecoder = getCharsetDecoder(charset);\n              // finally decode all buffered tokens\n              decodeBuffer(buffer, map, charsetDecoder);\n            } else if (charsetDecoder == null) {\n              // we have no charset decoder until now, buffer the keys / values for later processing:\n              buffer.add(keyBytes);\n              buffer.add(Long.valueOf(keyPos));\n              buffer.add(valueBytes);\n              buffer.add(Long.valueOf(valuePos));\n            } else {\n              // we already have a charsetDecoder, so we can directly decode without buffering:\n              final String key = decodeChars(keyBytes, keyPos, charsetDecoder),\n                  value = decodeChars(valueBytes, valuePos, charsetDecoder);\n              MultiMapSolrParams.addParam(key.trim(), value, map);\n            }\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):\n    if (buffer != null && !buffer.isEmpty()) {\n      assert charsetDecoder == null;\n      decodeBuffer(buffer, map, getCharsetDecoder(charset));\n    }\n    return len;\n  }\n\n","sourceOld":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings({\"fallthrough\", \"resource\"})\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {\n    CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);\n    final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<>() : null;\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),\n      valueStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();\n            if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {\n              // we found a charset declaration in the raw bytes\n              if (charsetDecoder != null) {\n                throw new SolrException(ErrorCode.BAD_REQUEST,\n                  supportCharsetParam ? (\n                    \"Query string invalid: duplicate '\"+\n                    INPUT_ENCODING_KEY + \"' (input encoding) key.\"\n                  ) : (\n                    \"Key '\" + INPUT_ENCODING_KEY + \"' (input encoding) cannot \"+\n                    \"be used in POSTed application/x-www-form-urlencoded form data. \"+\n                    \"To set the input encoding of POSTed form data, use the \"+\n                    \"'Content-Type' header and provide a charset!\"\n                  )\n                );\n              }\n              // decode the charset from raw bytes\n              charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));\n              charsetDecoder = getCharsetDecoder(charset);\n              // finally decode all buffered tokens\n              decodeBuffer(buffer, map, charsetDecoder);\n            } else if (charsetDecoder == null) {\n              // we have no charset decoder until now, buffer the keys / values for later processing:\n              buffer.add(keyBytes);\n              buffer.add(Long.valueOf(keyPos));\n              buffer.add(valueBytes);\n              buffer.add(Long.valueOf(valuePos));\n            } else {\n              // we already have a charsetDecoder, so we can directly decode without buffering:\n              final String key = decodeChars(keyBytes, keyPos, charsetDecoder),\n                  value = decodeChars(valueBytes, valuePos, charsetDecoder);\n              MultiMapSolrParams.addParam(key, value, map);\n            }\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):\n    if (buffer != null && !buffer.isEmpty()) {\n      assert charsetDecoder == null;\n      decodeBuffer(buffer, map, getCharsetDecoder(charset));\n    }\n    return len;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrRequestParsers#parseFormDataContent(InputStream,long,Charset,Map[String,String[]],boolean).mjava","sourceNew":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings({\"fallthrough\", \"resource\"})\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {\n    CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);\n    final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<>() : null;\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),\n      valueStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();\n            if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {\n              // we found a charset declaration in the raw bytes\n              if (charsetDecoder != null) {\n                throw new SolrException(ErrorCode.BAD_REQUEST,\n                  supportCharsetParam ? (\n                    \"Query string invalid: duplicate '\"+\n                    INPUT_ENCODING_KEY + \"' (input encoding) key.\"\n                  ) : (\n                    \"Key '\" + INPUT_ENCODING_KEY + \"' (input encoding) cannot \"+\n                    \"be used in POSTed application/x-www-form-urlencoded form data. \"+\n                    \"To set the input encoding of POSTed form data, use the \"+\n                    \"'Content-Type' header and provide a charset!\"\n                  )\n                );\n              }\n              // decode the charset from raw bytes\n              charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));\n              charsetDecoder = getCharsetDecoder(charset);\n              // finally decode all buffered tokens\n              decodeBuffer(buffer, map, charsetDecoder);\n            } else if (charsetDecoder == null) {\n              // we have no charset decoder until now, buffer the keys / values for later processing:\n              buffer.add(keyBytes);\n              buffer.add(Long.valueOf(keyPos));\n              buffer.add(valueBytes);\n              buffer.add(Long.valueOf(valuePos));\n            } else {\n              // we already have a charsetDecoder, so we can directly decode without buffering:\n              final String key = decodeChars(keyBytes, keyPos, charsetDecoder),\n                  value = decodeChars(valueBytes, valuePos, charsetDecoder);\n              MultiMapSolrParams.addParam(key.trim(), value, map);\n            }\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):\n    if (buffer != null && !buffer.isEmpty()) {\n      assert charsetDecoder == null;\n      decodeBuffer(buffer, map, getCharsetDecoder(charset));\n    }\n    return len;\n  }\n\n","sourceOld":"  /**\n   * Given a url-encoded form from POST content (as InputStream), map it into the given map.\n   * The given InputStream should be buffered!\n   * @param postContent to be parsed\n   * @param charset to be used to decode resulting bytes after %-decoding\n   * @param map place all parameters in this map\n   */\n  @SuppressWarnings({\"fallthrough\", \"resource\"})\n  static long parseFormDataContent(final InputStream postContent, final long maxLen, Charset charset, final Map<String,String[]> map, boolean supportCharsetParam) throws IOException {\n    CharsetDecoder charsetDecoder = supportCharsetParam ? null : getCharsetDecoder(charset);\n    final LinkedList<Object> buffer = supportCharsetParam ? new LinkedList<>() : null;\n    long len = 0L, keyPos = 0L, valuePos = 0L;\n    final ByteArrayOutputStream keyStream = new ByteArrayOutputStream(),\n      valueStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream currentStream = keyStream;\n    for(;;) {\n      int b = postContent.read();\n      switch (b) {\n        case -1: // end of stream\n        case '&': // separator\n          if (keyStream.size() > 0) {\n            final byte[] keyBytes = keyStream.toByteArray(), valueBytes = valueStream.toByteArray();\n            if (Arrays.equals(keyBytes, INPUT_ENCODING_BYTES)) {\n              // we found a charset declaration in the raw bytes\n              if (charsetDecoder != null) {\n                throw new SolrException(ErrorCode.BAD_REQUEST,\n                  supportCharsetParam ? (\n                    \"Query string invalid: duplicate '\"+\n                    INPUT_ENCODING_KEY + \"' (input encoding) key.\"\n                  ) : (\n                    \"Key '\" + INPUT_ENCODING_KEY + \"' (input encoding) cannot \"+\n                    \"be used in POSTed application/x-www-form-urlencoded form data. \"+\n                    \"To set the input encoding of POSTed form data, use the \"+\n                    \"'Content-Type' header and provide a charset!\"\n                  )\n                );\n              }\n              // decode the charset from raw bytes\n              charset = Charset.forName(decodeChars(valueBytes, keyPos, getCharsetDecoder(CHARSET_US_ASCII)));\n              charsetDecoder = getCharsetDecoder(charset);\n              // finally decode all buffered tokens\n              decodeBuffer(buffer, map, charsetDecoder);\n            } else if (charsetDecoder == null) {\n              // we have no charset decoder until now, buffer the keys / values for later processing:\n              buffer.add(keyBytes);\n              buffer.add(Long.valueOf(keyPos));\n              buffer.add(valueBytes);\n              buffer.add(Long.valueOf(valuePos));\n            } else {\n              // we already have a charsetDecoder, so we can directly decode without buffering:\n              final String key = decodeChars(keyBytes, keyPos, charsetDecoder),\n                  value = decodeChars(valueBytes, valuePos, charsetDecoder);\n              MultiMapSolrParams.addParam(key, value, map);\n            }\n          } else if (valueStream.size() > 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded invalid: missing key\");\n          }\n          keyStream.reset();\n          valueStream.reset();\n          keyPos = valuePos = len + 1;\n          currentStream = keyStream;\n          break;\n        case '+': // space replacement\n          currentStream.write(' ');\n          break;\n        case '%': // escape\n          final int upper = digit16(b = postContent.read());\n          len++;\n          final int lower = digit16(b = postContent.read());\n          len++;\n          currentStream.write(((upper << 4) + lower));\n          break;\n        case '=': // kv separator\n          if (currentStream == keyStream) {\n            valuePos = len + 1;\n            currentStream = valueStream;\n            break;\n          }\n          // fall-through\n        default:\n          currentStream.write(b);\n      }\n      if (b == -1) {\n        break;\n      }\n      len++;\n      if (len > maxLen) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"application/x-www-form-urlencoded content exceeds upload limit of \" + (maxLen/1024L) + \" KB\");\n      }\n    }\n    // if we have not seen a charset declaration, decode the buffer now using the default one (UTF-8 or given via Content-Type):\n    if (buffer != null && !buffer.isEmpty()) {\n      assert charsetDecoder == null;\n      decodeBuffer(buffer, map, getCharsetDecoder(charset));\n    }\n    return len;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["92009ce6b3696f548a1c7eb9fcf8cab29b541426"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","0d17ec5164debc23076db7fd11d0331f201583b5"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","92009ce6b3696f548a1c7eb9fcf8cab29b541426"],"0d17ec5164debc23076db7fd11d0331f201583b5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92009ce6b3696f548a1c7eb9fcf8cab29b541426":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d17ec5164debc23076db7fd11d0331f201583b5"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0d17ec5164debc23076db7fd11d0331f201583b5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"0d17ec5164debc23076db7fd11d0331f201583b5":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","92009ce6b3696f548a1c7eb9fcf8cab29b541426"],"92009ce6b3696f548a1c7eb9fcf8cab29b541426":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}