{"path":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest#testDeleteAliasedCollection().mjava","commits":[{"id":"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c","date":1562161956,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPISolrJTest#testDeleteAliasedCollection().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testDeleteAliasedCollection() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName1 = \"aliasedCollection1\";\n    String collectionName2 = \"aliasedCollection2\";\n    CollectionAdminRequest.createCollection(collectionName1, \"conf\", 1, 1).process(solrClient);\n    CollectionAdminRequest.createCollection(collectionName2, \"conf\", 1, 1).process(solrClient);\n\n    cluster.waitForActiveCollection(collectionName1, 1, 1);\n    cluster.waitForActiveCollection(collectionName2, 1, 1);\n\n    waitForState(\"Expected collection1 to be created with 1 shard and 1 replica\", collectionName1, clusterShape(1, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", collectionName2, clusterShape(1, 1));\n\n    SolrInputDocument doc = new SolrInputDocument(\"id\", \"1\");\n    solrClient.add(collectionName1, doc);\n    doc = new SolrInputDocument(\"id\", \"2\");\n    solrClient.add(collectionName2, doc);\n    solrClient.commit(collectionName1);\n    solrClient.commit(collectionName2);\n\n    assertDoc(solrClient, collectionName1, \"1\");\n    assertDoc(solrClient, collectionName2, \"2\");\n\n    CollectionAdminRequest.createAlias(collectionName1, collectionName2).process(solrClient);\n\n    RetryUtil.retryUntil(\"didn't get the new aliases\", 10, 1000, TimeUnit.MILLISECONDS, () -> {\n      try {\n        solrClient.getZkStateReader().aliasesManager.update();\n        return solrClient.getZkStateReader().getAliases()\n            .resolveSimpleAlias(collectionName1).equals(collectionName2);\n      } catch (Exception e) {\n        fail(\"exception caught refreshing aliases: \" + e);\n        return false;\n      }\n    });\n\n    // both results should come from collection 2\n    assertDoc(solrClient, collectionName1, \"2\"); // aliased\n    assertDoc(solrClient, collectionName2, \"2\"); // direct\n\n    // should be able to remove collection 1 when followAliases = false\n    CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(collectionName1);\n    delete.setFollowAliases(false);\n    delete.process(solrClient);\n    ClusterState state = solrClient.getClusterStateProvider().getClusterState();\n    assertFalse(state.getCollectionsMap().toString(), state.hasCollection(collectionName1));\n    // search should still work, returning results from collection 2\n    assertDoc(solrClient, collectionName1, \"2\"); // aliased\n    assertDoc(solrClient, collectionName2, \"2\"); // direct\n\n    // without aliases this collection doesn't exist anymore\n    delete = CollectionAdminRequest.deleteCollection(collectionName1);\n    delete.setFollowAliases(false);\n    try {\n      delete.process(solrClient);\n      fail(\"delete of nonexistent collection 1 should have failed when followAliases=false\");\n    } catch (Exception e) {\n      assertTrue(e.toString(), e.toString().contains(collectionName1));\n    }\n\n    // with followAliases=true collection 2 (and the alias) should both be removed\n    delete.setFollowAliases(true);\n    delete.process(solrClient);\n\n    state = solrClient.getClusterStateProvider().getClusterState();\n    // the collection is gone\n    assertFalse(state.getCollectionsMap().toString(), state.hasCollection(collectionName2));\n\n    // and the alias is gone\n    RetryUtil.retryUntil(\"didn't get the new aliases\", 10, 1000, TimeUnit.MILLISECONDS, () -> {\n      try {\n        solrClient.getZkStateReader().aliasesManager.update();\n        return !solrClient.getZkStateReader().getAliases().hasAlias(collectionName1);\n      } catch (Exception e) {\n        fail(\"exception caught refreshing aliases: \" + e);\n        return false;\n      }\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}