{"path":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","commits":[{"id":"837108f624718d0896bef7acd0150b66ebd816db","date":1395274740,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","pathOld":"/dev/null","sourceNew":"  private int readInputToBuffer() throws IOException {\n    final int len = input.read(tmpBuffer);\n    if (len == -1) {\n      inputFinished = true;\n      return 0;\n    }\n    inputBuffer.append(tmpBuffer, 0, len);\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n    if (normalizer.isInert(tmpBuffer[len - 1]) && !Character.isHighSurrogate(tmpBuffer[len-1])) {\n      return len;\n    } else return len + readInputToBuffer();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d6dbdc4c8eda2e99b1d71e1ea0fb304f1b94fce","date":1397165453,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","sourceNew":"  private int readInputToBuffer() throws IOException {\n    final int len = input.read(tmpBuffer);\n    if (len == -1) {\n      inputFinished = true;\n      return 0;\n    }\n    inputBuffer.append(tmpBuffer, 0, len);\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n    // this loop depends on 'isInert' (changes under normalization) but looks only at characters.\n    // so we treat all surrogates as non-inert for simplicity\n    if (normalizer.isInert(tmpBuffer[len - 1]) && !Character.isSurrogate(tmpBuffer[len-1])) {\n      return len;\n    } else return len + readInputToBuffer();\n  }\n\n","sourceOld":"  private int readInputToBuffer() throws IOException {\n    final int len = input.read(tmpBuffer);\n    if (len == -1) {\n      inputFinished = true;\n      return 0;\n    }\n    inputBuffer.append(tmpBuffer, 0, len);\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n    if (normalizer.isInert(tmpBuffer[len - 1]) && !Character.isHighSurrogate(tmpBuffer[len-1])) {\n      return len;\n    } else return len + readInputToBuffer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81b48d33779fd9654522a21c624c0f27e503f376","date":1504629245,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","sourceNew":"  private void readInputToBuffer() throws IOException {\n    while (true) {\n      // CharacterUtils.fill is supplementary char aware\n      final boolean hasRemainingChars = CharacterUtils.fill(tmpBuffer, input);\n\n      assert tmpBuffer.getOffset() == 0;\n      inputBuffer.append(tmpBuffer.getBuffer(), 0, tmpBuffer.getLength());\n\n      if (hasRemainingChars == false) {\n        inputFinished = true;\n        break;\n      }\n\n      final int lastCodePoint = Character.codePointBefore(tmpBuffer.getBuffer(), tmpBuffer.getLength());\n      if (normalizer.isInert(lastCodePoint)) {\n        // we require an inert char so that we can normalize content before and\n        // after this character independently\n        break;\n      }\n    }\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n  }\n\n","sourceOld":"  private int readInputToBuffer() throws IOException {\n    final int len = input.read(tmpBuffer);\n    if (len == -1) {\n      inputFinished = true;\n      return 0;\n    }\n    inputBuffer.append(tmpBuffer, 0, len);\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n    // this loop depends on 'isInert' (changes under normalization) but looks only at characters.\n    // so we treat all surrogates as non-inert for simplicity\n    if (normalizer.isInert(tmpBuffer[len - 1]) && !Character.isSurrogate(tmpBuffer[len-1])) {\n      return len;\n    } else return len + readInputToBuffer();\n  }\n\n","bugFix":null,"bugIntro":["8e03cd86bdf13ab41318f4d032b55b38a31af37c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8e03cd86bdf13ab41318f4d032b55b38a31af37c","date":1504639311,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","sourceNew":"  private void readInputToBuffer() throws IOException {\n    while (true) {\n      // CharacterUtils.fill is supplementary char aware\n      final boolean hasRemainingChars = CharacterUtils.fill(tmpBuffer, input);\n\n      assert tmpBuffer.getOffset() == 0;\n      inputBuffer.append(tmpBuffer.getBuffer(), 0, tmpBuffer.getLength());\n\n      if (hasRemainingChars == false) {\n        inputFinished = true;\n        break;\n      }\n\n      final int lastCodePoint = Character.codePointBefore(tmpBuffer.getBuffer(), tmpBuffer.getLength(), 0);\n      if (normalizer.isInert(lastCodePoint)) {\n        // we require an inert char so that we can normalize content before and\n        // after this character independently\n        break;\n      }\n    }\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n  }\n\n","sourceOld":"  private void readInputToBuffer() throws IOException {\n    while (true) {\n      // CharacterUtils.fill is supplementary char aware\n      final boolean hasRemainingChars = CharacterUtils.fill(tmpBuffer, input);\n\n      assert tmpBuffer.getOffset() == 0;\n      inputBuffer.append(tmpBuffer.getBuffer(), 0, tmpBuffer.getLength());\n\n      if (hasRemainingChars == false) {\n        inputFinished = true;\n        break;\n      }\n\n      final int lastCodePoint = Character.codePointBefore(tmpBuffer.getBuffer(), tmpBuffer.getLength());\n      if (normalizer.isInert(lastCodePoint)) {\n        // we require an inert char so that we can normalize content before and\n        // after this character independently\n        break;\n      }\n    }\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n  }\n\n","bugFix":["81b48d33779fd9654522a21c624c0f27e503f376"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","sourceNew":"  private void readInputToBuffer() throws IOException {\n    while (true) {\n      // CharacterUtils.fill is supplementary char aware\n      final boolean hasRemainingChars = CharacterUtils.fill(tmpBuffer, input);\n\n      assert tmpBuffer.getOffset() == 0;\n      inputBuffer.append(tmpBuffer.getBuffer(), 0, tmpBuffer.getLength());\n\n      if (hasRemainingChars == false) {\n        inputFinished = true;\n        break;\n      }\n\n      final int lastCodePoint = Character.codePointBefore(tmpBuffer.getBuffer(), tmpBuffer.getLength(), 0);\n      if (normalizer.isInert(lastCodePoint)) {\n        // we require an inert char so that we can normalize content before and\n        // after this character independently\n        break;\n      }\n    }\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n  }\n\n","sourceOld":"  private int readInputToBuffer() throws IOException {\n    final int len = input.read(tmpBuffer);\n    if (len == -1) {\n      inputFinished = true;\n      return 0;\n    }\n    inputBuffer.append(tmpBuffer, 0, len);\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n    // this loop depends on 'isInert' (changes under normalization) but looks only at characters.\n    // so we treat all surrogates as non-inert for simplicity\n    if (normalizer.isInert(tmpBuffer[len - 1]) && !Character.isSurrogate(tmpBuffer[len-1])) {\n      return len;\n    } else return len + readInputToBuffer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","sourceNew":"  private void readInputToBuffer() throws IOException {\n    while (true) {\n      // CharacterUtils.fill is supplementary char aware\n      final boolean hasRemainingChars = CharacterUtils.fill(tmpBuffer, input);\n\n      assert tmpBuffer.getOffset() == 0;\n      inputBuffer.append(tmpBuffer.getBuffer(), 0, tmpBuffer.getLength());\n\n      if (hasRemainingChars == false) {\n        inputFinished = true;\n        break;\n      }\n\n      final int lastCodePoint = Character.codePointBefore(tmpBuffer.getBuffer(), tmpBuffer.getLength(), 0);\n      if (normalizer.isInert(lastCodePoint)) {\n        // we require an inert char so that we can normalize content before and\n        // after this character independently\n        break;\n      }\n    }\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n  }\n\n","sourceOld":"  private int readInputToBuffer() throws IOException {\n    final int len = input.read(tmpBuffer);\n    if (len == -1) {\n      inputFinished = true;\n      return 0;\n    }\n    inputBuffer.append(tmpBuffer, 0, len);\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n    // this loop depends on 'isInert' (changes under normalization) but looks only at characters.\n    // so we treat all surrogates as non-inert for simplicity\n    if (normalizer.isInert(tmpBuffer[len - 1]) && !Character.isSurrogate(tmpBuffer[len-1])) {\n      return len;\n    } else return len + readInputToBuffer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/ICUNormalizer2CharFilter#readInputToBuffer().mjava","sourceNew":"  private void readInputToBuffer() throws IOException {\n    while (true) {\n      // CharacterUtils.fill is supplementary char aware\n      final boolean hasRemainingChars = CharacterUtils.fill(tmpBuffer, input);\n\n      assert tmpBuffer.getOffset() == 0;\n      inputBuffer.append(tmpBuffer.getBuffer(), 0, tmpBuffer.getLength());\n\n      if (hasRemainingChars == false) {\n        inputFinished = true;\n        break;\n      }\n\n      final int lastCodePoint = Character.codePointBefore(tmpBuffer.getBuffer(), tmpBuffer.getLength(), 0);\n      if (normalizer.isInert(lastCodePoint)) {\n        // we require an inert char so that we can normalize content before and\n        // after this character independently\n        break;\n      }\n    }\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n  }\n\n","sourceOld":"  private int readInputToBuffer() throws IOException {\n    final int len = input.read(tmpBuffer);\n    if (len == -1) {\n      inputFinished = true;\n      return 0;\n    }\n    inputBuffer.append(tmpBuffer, 0, len);\n\n    // if checkedInputBoundary was at the end of a buffer, we need to check that char again\n    checkedInputBoundary = Math.max(checkedInputBoundary - 1, 0);\n    // this loop depends on 'isInert' (changes under normalization) but looks only at characters.\n    // so we treat all surrogates as non-inert for simplicity\n    if (normalizer.isInert(tmpBuffer[len - 1]) && !Character.isSurrogate(tmpBuffer[len-1])) {\n      return len;\n    } else return len + readInputToBuffer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["1d6dbdc4c8eda2e99b1d71e1ea0fb304f1b94fce","8e03cd86bdf13ab41318f4d032b55b38a31af37c"],"685bd38810c206c93e9058f3c2cfa9827c086c27":["1d6dbdc4c8eda2e99b1d71e1ea0fb304f1b94fce","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"837108f624718d0896bef7acd0150b66ebd816db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["1d6dbdc4c8eda2e99b1d71e1ea0fb304f1b94fce","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"81b48d33779fd9654522a21c624c0f27e503f376":["1d6dbdc4c8eda2e99b1d71e1ea0fb304f1b94fce"],"1d6dbdc4c8eda2e99b1d71e1ea0fb304f1b94fce":["837108f624718d0896bef7acd0150b66ebd816db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8e03cd86bdf13ab41318f4d032b55b38a31af37c":["81b48d33779fd9654522a21c624c0f27e503f376"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"837108f624718d0896bef7acd0150b66ebd816db":["1d6dbdc4c8eda2e99b1d71e1ea0fb304f1b94fce"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["685bd38810c206c93e9058f3c2cfa9827c086c27","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"81b48d33779fd9654522a21c624c0f27e503f376":["8e03cd86bdf13ab41318f4d032b55b38a31af37c"],"1d6dbdc4c8eda2e99b1d71e1ea0fb304f1b94fce":["b21283ed01203901a7257aa4b7f0a0899c86e56e","685bd38810c206c93e9058f3c2cfa9827c086c27","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","81b48d33779fd9654522a21c624c0f27e503f376"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["837108f624718d0896bef7acd0150b66ebd816db"],"8e03cd86bdf13ab41318f4d032b55b38a31af37c":["b21283ed01203901a7257aa4b7f0a0899c86e56e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["685bd38810c206c93e9058f3c2cfa9827c086c27","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}