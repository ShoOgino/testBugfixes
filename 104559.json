{"path":"lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer#doTestRandom(double).mjava","commits":[{"id":"a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0","date":1514294096,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer#doTestRandom(double).mjava","pathOld":"/dev/null","sourceNew":"  private void doTestRandom(double optFreq) throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, newIndexWriterConfig());\n    int numDocs = atLeast(1000);\n    for (int i = 0; i < numDocs; ++i) {\n      int numAs = random().nextBoolean() ? 0 : 1 + random().nextInt(5);\n      int numBs = random().nextDouble() < optFreq ? 0 : 1 + random().nextInt(5);\n      Document doc = new Document();\n      for (int j = 0; j < numAs; ++j) {\n        doc.add(new StringField(\"f\", \"A\", Store.NO));\n      }\n      for (int j = 0; j < numBs; ++j) {\n        doc.add(new StringField(\"f\", \"B\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"f\", \"C\", Store.NO));\n      }\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    IndexSearcher searcher = newSearcher(r);\n\n    Query mustTerm = new TermQuery(new Term(\"f\", \"A\"));\n    Query shouldTerm = new TermQuery(new Term(\"f\", \"B\"));\n    Query query = new BooleanQuery.Builder()\n        .add(mustTerm, Occur.MUST)\n        .add(shouldTerm, Occur.SHOULD)\n        .build();\n\n    TopScoreDocCollector coll = TopScoreDocCollector.create(10, null, true);\n    searcher.search(query, coll);\n    ScoreDoc[] expected = coll.topDocs().scoreDocs;\n\n    // Also test a filtered query, since it does not compute the score on all\n    // matches.\n    query = new BooleanQuery.Builder()\n        .add(query, Occur.MUST)\n        .add(new TermQuery(new Term(\"f\", \"C\")), Occur.FILTER)\n        .build();\n\n    coll = TopScoreDocCollector.create(10, null, true);\n    searcher.search(query, coll);\n    ScoreDoc[] expectedFiltered = coll.topDocs().scoreDocs;\n\n    for (int i = 0; i < 4; ++i) {\n      Query must = mustTerm;\n      if (i % 2 == 1) {\n        must = new RandomApproximationQuery(must, random());\n      }\n      Query should = shouldTerm;\n      if (i >= 2) {\n        should = new RandomApproximationQuery(should, random());\n      }\n    \n      query = new BooleanQuery.Builder()\n          .add(must, Occur.MUST)\n          .add(should, Occur.SHOULD)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, false);\n      searcher.search(query, coll);\n      ScoreDoc[] actual = coll.topDocs().scoreDocs;\n\n      CheckHits.checkEqual(query, expected, actual);\n\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(new RandomApproximationQuery(new TermQuery(new Term(\"f\", \"C\")), random()), Occur.FILTER)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, false);\n      searcher.search(query, coll);\n      ScoreDoc[] actualFiltered = coll.topDocs().scoreDocs;\n\n      CheckHits.checkEqual(query, expectedFiltered, actualFiltered);\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer#doTestRandom(double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer#doTestRandom(double).mjava","sourceNew":"  private void doTestRandom(double optFreq) throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, newIndexWriterConfig());\n    int numDocs = atLeast(1000);\n    for (int i = 0; i < numDocs; ++i) {\n      int numAs = random().nextBoolean() ? 0 : 1 + random().nextInt(5);\n      int numBs = random().nextDouble() < optFreq ? 0 : 1 + random().nextInt(5);\n      Document doc = new Document();\n      for (int j = 0; j < numAs; ++j) {\n        doc.add(new StringField(\"f\", \"A\", Store.NO));\n      }\n      for (int j = 0; j < numBs; ++j) {\n        doc.add(new StringField(\"f\", \"B\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"f\", \"C\", Store.NO));\n      }\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    IndexSearcher searcher = newSearcher(r);\n\n    Query mustTerm = new TermQuery(new Term(\"f\", \"A\"));\n    Query shouldTerm = new TermQuery(new Term(\"f\", \"B\"));\n    Query query = new BooleanQuery.Builder()\n        .add(mustTerm, Occur.MUST)\n        .add(shouldTerm, Occur.SHOULD)\n        .build();\n\n    TopScoreDocCollector coll = TopScoreDocCollector.create(10, null, Integer.MAX_VALUE);\n    searcher.search(query, coll);\n    ScoreDoc[] expected = coll.topDocs().scoreDocs;\n\n    // Also test a filtered query, since it does not compute the score on all\n    // matches.\n    query = new BooleanQuery.Builder()\n        .add(query, Occur.MUST)\n        .add(new TermQuery(new Term(\"f\", \"C\")), Occur.FILTER)\n        .build();\n\n    coll = TopScoreDocCollector.create(10, null, Integer.MAX_VALUE);\n    searcher.search(query, coll);\n    ScoreDoc[] expectedFiltered = coll.topDocs().scoreDocs;\n\n    for (int i = 0; i < 4; ++i) {\n      Query must = mustTerm;\n      if (i % 2 == 1) {\n        must = new RandomApproximationQuery(must, random());\n      }\n      Query should = shouldTerm;\n      if (i >= 2) {\n        should = new RandomApproximationQuery(should, random());\n      }\n    \n      query = new BooleanQuery.Builder()\n          .add(must, Occur.MUST)\n          .add(should, Occur.SHOULD)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, 1);\n      searcher.search(query, coll);\n      ScoreDoc[] actual = coll.topDocs().scoreDocs;\n\n      CheckHits.checkEqual(query, expected, actual);\n\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(new RandomApproximationQuery(new TermQuery(new Term(\"f\", \"C\")), random()), Occur.FILTER)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, 1);\n      searcher.search(query, coll);\n      ScoreDoc[] actualFiltered = coll.topDocs().scoreDocs;\n\n      CheckHits.checkEqual(query, expectedFiltered, actualFiltered);\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doTestRandom(double optFreq) throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, newIndexWriterConfig());\n    int numDocs = atLeast(1000);\n    for (int i = 0; i < numDocs; ++i) {\n      int numAs = random().nextBoolean() ? 0 : 1 + random().nextInt(5);\n      int numBs = random().nextDouble() < optFreq ? 0 : 1 + random().nextInt(5);\n      Document doc = new Document();\n      for (int j = 0; j < numAs; ++j) {\n        doc.add(new StringField(\"f\", \"A\", Store.NO));\n      }\n      for (int j = 0; j < numBs; ++j) {\n        doc.add(new StringField(\"f\", \"B\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"f\", \"C\", Store.NO));\n      }\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    IndexSearcher searcher = newSearcher(r);\n\n    Query mustTerm = new TermQuery(new Term(\"f\", \"A\"));\n    Query shouldTerm = new TermQuery(new Term(\"f\", \"B\"));\n    Query query = new BooleanQuery.Builder()\n        .add(mustTerm, Occur.MUST)\n        .add(shouldTerm, Occur.SHOULD)\n        .build();\n\n    TopScoreDocCollector coll = TopScoreDocCollector.create(10, null, true);\n    searcher.search(query, coll);\n    ScoreDoc[] expected = coll.topDocs().scoreDocs;\n\n    // Also test a filtered query, since it does not compute the score on all\n    // matches.\n    query = new BooleanQuery.Builder()\n        .add(query, Occur.MUST)\n        .add(new TermQuery(new Term(\"f\", \"C\")), Occur.FILTER)\n        .build();\n\n    coll = TopScoreDocCollector.create(10, null, true);\n    searcher.search(query, coll);\n    ScoreDoc[] expectedFiltered = coll.topDocs().scoreDocs;\n\n    for (int i = 0; i < 4; ++i) {\n      Query must = mustTerm;\n      if (i % 2 == 1) {\n        must = new RandomApproximationQuery(must, random());\n      }\n      Query should = shouldTerm;\n      if (i >= 2) {\n        should = new RandomApproximationQuery(should, random());\n      }\n    \n      query = new BooleanQuery.Builder()\n          .add(must, Occur.MUST)\n          .add(should, Occur.SHOULD)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, false);\n      searcher.search(query, coll);\n      ScoreDoc[] actual = coll.topDocs().scoreDocs;\n\n      CheckHits.checkEqual(query, expected, actual);\n\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(new RandomApproximationQuery(new TermQuery(new Term(\"f\", \"C\")), random()), Occur.FILTER)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, false);\n      searcher.search(query, coll);\n      ScoreDoc[] actualFiltered = coll.topDocs().scoreDocs;\n\n      CheckHits.checkEqual(query, expectedFiltered, actualFiltered);\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd80b885e3e9bdc61935e784f634562d13b81979","date":1533736198,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer#doTestRandom(double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestReqOptSumScorer#doTestRandom(double).mjava","sourceNew":"  private void doTestRandom(double optFreq) throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, newIndexWriterConfig());\n    int numDocs = atLeast(1000);\n    for (int i = 0; i < numDocs; ++i) {\n      int numAs = random().nextBoolean() ? 0 : 1 + random().nextInt(5);\n      int numBs = random().nextDouble() < optFreq ? 0 : 1 + random().nextInt(5);\n      Document doc = new Document();\n      for (int j = 0; j < numAs; ++j) {\n        doc.add(new StringField(\"f\", \"A\", Store.NO));\n      }\n      for (int j = 0; j < numBs; ++j) {\n        doc.add(new StringField(\"f\", \"B\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"f\", \"C\", Store.NO));\n      }\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    IndexSearcher searcher = newSearcher(r);\n\n    Query mustTerm = new TermQuery(new Term(\"f\", \"A\"));\n    Query shouldTerm = new TermQuery(new Term(\"f\", \"B\"));\n    Query query = new BooleanQuery.Builder()\n        .add(mustTerm, Occur.MUST)\n        .add(shouldTerm, Occur.SHOULD)\n        .build();\n\n    TopScoreDocCollector coll = TopScoreDocCollector.create(10, null, Integer.MAX_VALUE);\n    searcher.search(query, coll);\n    ScoreDoc[] expected = coll.topDocs().scoreDocs;\n\n    // Also test a filtered query, since it does not compute the score on all\n    // matches.\n    query = new BooleanQuery.Builder()\n        .add(query, Occur.MUST)\n        .add(new TermQuery(new Term(\"f\", \"C\")), Occur.FILTER)\n        .build();\n\n    coll = TopScoreDocCollector.create(10, null, Integer.MAX_VALUE);\n    searcher.search(query, coll);\n    ScoreDoc[] expectedFiltered = coll.topDocs().scoreDocs;\n\n    CheckHits.checkTopScores(random(), query, searcher);\n\n    {\n      Query q = new BooleanQuery.Builder()\n          .add(new RandomApproximationQuery(mustTerm, random()), Occur.MUST)\n          .add(shouldTerm, Occur.SHOULD)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, 1);\n      searcher.search(q, coll);\n      ScoreDoc[] actual = coll.topDocs().scoreDocs;\n      CheckHits.checkEqual(query, expected, actual);\n\n      q = new BooleanQuery.Builder()\n          .add(mustTerm, Occur.MUST)\n          .add(new RandomApproximationQuery(shouldTerm, random()), Occur.SHOULD)\n          .build();\n      coll = TopScoreDocCollector.create(10, null, 1);\n      searcher.search(q, coll);\n      actual = coll.topDocs().scoreDocs;\n      CheckHits.checkEqual(q, expected, actual);\n\n      q = new BooleanQuery.Builder()\n          .add(new RandomApproximationQuery(mustTerm, random()), Occur.MUST)\n          .add(new RandomApproximationQuery(shouldTerm, random()), Occur.SHOULD)\n          .build();\n      coll = TopScoreDocCollector.create(10, null, 1);\n      searcher.search(q, coll);\n      actual = coll.topDocs().scoreDocs;\n      CheckHits.checkEqual(q, expected, actual);\n    }\n\n    {\n      Query nestedQ = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(new TermQuery(new Term(\"f\", \"C\")), Occur.FILTER)\n          .build();\n      CheckHits.checkTopScores(random(), nestedQ, searcher);\n\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(new RandomApproximationQuery(new TermQuery(new Term(\"f\", \"C\")), random()), Occur.FILTER)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, 1);\n      searcher.search(nestedQ, coll);\n      ScoreDoc[] actualFiltered = coll.topDocs().scoreDocs;\n      CheckHits.checkEqual(nestedQ, expectedFiltered, actualFiltered);\n    }\n\n    {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(new TermQuery(new Term(\"f\", \"C\")), Occur.SHOULD)\n          .build();\n\n      CheckHits.checkTopScores(random(), query, searcher);\n\n      query = new BooleanQuery.Builder()\n          .add(new TermQuery(new Term(\"f\", \"C\")), Occur.MUST)\n          .add(query, Occur.SHOULD)\n          .build();\n\n      CheckHits.checkTopScores(random(), query, searcher);\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doTestRandom(double optFreq) throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, newIndexWriterConfig());\n    int numDocs = atLeast(1000);\n    for (int i = 0; i < numDocs; ++i) {\n      int numAs = random().nextBoolean() ? 0 : 1 + random().nextInt(5);\n      int numBs = random().nextDouble() < optFreq ? 0 : 1 + random().nextInt(5);\n      Document doc = new Document();\n      for (int j = 0; j < numAs; ++j) {\n        doc.add(new StringField(\"f\", \"A\", Store.NO));\n      }\n      for (int j = 0; j < numBs; ++j) {\n        doc.add(new StringField(\"f\", \"B\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"f\", \"C\", Store.NO));\n      }\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    IndexSearcher searcher = newSearcher(r);\n\n    Query mustTerm = new TermQuery(new Term(\"f\", \"A\"));\n    Query shouldTerm = new TermQuery(new Term(\"f\", \"B\"));\n    Query query = new BooleanQuery.Builder()\n        .add(mustTerm, Occur.MUST)\n        .add(shouldTerm, Occur.SHOULD)\n        .build();\n\n    TopScoreDocCollector coll = TopScoreDocCollector.create(10, null, Integer.MAX_VALUE);\n    searcher.search(query, coll);\n    ScoreDoc[] expected = coll.topDocs().scoreDocs;\n\n    // Also test a filtered query, since it does not compute the score on all\n    // matches.\n    query = new BooleanQuery.Builder()\n        .add(query, Occur.MUST)\n        .add(new TermQuery(new Term(\"f\", \"C\")), Occur.FILTER)\n        .build();\n\n    coll = TopScoreDocCollector.create(10, null, Integer.MAX_VALUE);\n    searcher.search(query, coll);\n    ScoreDoc[] expectedFiltered = coll.topDocs().scoreDocs;\n\n    for (int i = 0; i < 4; ++i) {\n      Query must = mustTerm;\n      if (i % 2 == 1) {\n        must = new RandomApproximationQuery(must, random());\n      }\n      Query should = shouldTerm;\n      if (i >= 2) {\n        should = new RandomApproximationQuery(should, random());\n      }\n    \n      query = new BooleanQuery.Builder()\n          .add(must, Occur.MUST)\n          .add(should, Occur.SHOULD)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, 1);\n      searcher.search(query, coll);\n      ScoreDoc[] actual = coll.topDocs().scoreDocs;\n\n      CheckHits.checkEqual(query, expected, actual);\n\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(new RandomApproximationQuery(new TermQuery(new Term(\"f\", \"C\")), random()), Occur.FILTER)\n          .build();\n\n      coll = TopScoreDocCollector.create(10, null, 1);\n      searcher.search(query, coll);\n      ScoreDoc[] actualFiltered = coll.topDocs().scoreDocs;\n\n      CheckHits.checkEqual(query, expectedFiltered, actualFiltered);\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd80b885e3e9bdc61935e784f634562d13b81979":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fd80b885e3e9bdc61935e784f634562d13b81979"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0"],"a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0"],"fd80b885e3e9bdc61935e784f634562d13b81979":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["fd80b885e3e9bdc61935e784f634562d13b81979"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0":["fe3c6364bed04a73ad0884b05401d80ce96027a9"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}