{"path":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","commits":[{"id":"392e007070227c0fd1c28259a11f55a06a9bd7c2","date":1522221057,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int).mjava","sourceNew":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to \" + e.getMessage() +\n              \" Retrying with new version .... (\" + attempts + \")\");\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","sourceOld":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to \" + e.getMessage() +\n              \" Retrying with new version .... (\" + attempts + \")\");\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          if (lastVersion != null) {\n            cmd.solrDoc.setField(VERSION, lastVersion);\n          }\n          processAddWithRetry(cmd, attempts);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6db21866f23a2d17740a966f1137fb5c6df45d1","date":1522221994,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","sourceNew":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to \" + e.getMessage() +\n              \" Retrying with new version .... (\" + attempts + \")\");\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          clonedOriginalDoc = clonedOriginalDoc.deepCopy(); // copy again because the old cloned ref will be modified during processAdd\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","sourceOld":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to \" + e.getMessage() +\n              \" Retrying with new version .... (\" + attempts + \")\");\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43564cbb30b064675027cfb569564e8531096e97","date":1522334265,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int).mjava","sourceNew":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to \" + e.getMessage() +\n              \" Retrying with new version .... (\" + attempts + \")\");\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          clonedOriginalDoc = clonedOriginalDoc.deepCopy(); // copy again because the old cloned ref will be modified during processAdd\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","sourceOld":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to \" + e.getMessage() +\n              \" Retrying with new version .... (\" + attempts + \")\");\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          if (lastVersion != null) {\n            cmd.solrDoc.setField(VERSION, lastVersion);\n          }\n          processAddWithRetry(cmd, attempts);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","sourceNew":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          if (log.isWarnEnabled()) {\n            log.warn(\"Atomic update failed due to {} Retrying with new version .... ({})\"\n                , e.getMessage(), attempts);\n          }\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          clonedOriginalDoc = clonedOriginalDoc.deepCopy(); // copy again because the old cloned ref will be modified during processAdd\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","sourceOld":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to \" + e.getMessage() +\n              \" Retrying with new version .... (\" + attempts + \")\");\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          clonedOriginalDoc = clonedOriginalDoc.deepCopy(); // copy again because the old cloned ref will be modified during processAdd\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","sourceNew":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to {} Retrying with new version .... ({})\"\n              , e.getMessage(), attempts);\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          clonedOriginalDoc = clonedOriginalDoc.deepCopy(); // copy again because the old cloned ref will be modified during processAdd\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","sourceOld":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          if (log.isWarnEnabled()) {\n            log.warn(\"Atomic update failed due to {} Retrying with new version .... ({})\"\n                , e.getMessage(), attempts);\n          }\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          clonedOriginalDoc = clonedOriginalDoc.deepCopy(); // copy again because the old cloned ref will be modified during processAdd\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateProcessorFactory.AtomicUpdateProcessor#processAddWithRetry(AddUpdateCommand,int,SolrInputDocument).mjava","sourceNew":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed. Retrying with new version .... ({})\", attempts, e);\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          clonedOriginalDoc = clonedOriginalDoc.deepCopy(); // copy again because the old cloned ref will be modified during processAdd\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","sourceOld":"    private void processAddWithRetry(AddUpdateCommand cmd, int attempts, SolrInputDocument clonedOriginalDoc) throws IOException {\n      try {\n        super.processAdd(cmd);\n      } catch (SolrException e) {\n        if (attempts++ >= MAX_ATTEMPTS) {//maximum number of attempts allowed: 25\n          throw new SolrException(SERVER_ERROR,\n              \"Atomic update failed after multiple attempts due to \" + e.getMessage());\n        }\n        if (e.code() == ErrorCode.CONFLICT.code) { // version conflict\n          log.warn(\"Atomic update failed due to {} Retrying with new version .... ({})\"\n              , e.getMessage(), attempts);\n\n          Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          // if lastVersion is null then we put -1 to assert that document must not exist\n          lastVersion = lastVersion == null ? -1 : lastVersion;\n\n          // The AtomicUpdateDocumentMerger modifies the AddUpdateCommand.solrDoc to populate the real values of the\n          // modified fields. We don't want those absolute values because they are out-of-date due to the conflict\n          // so we restore the original document created in processAdd method and set the right version on it\n          cmd.solrDoc = clonedOriginalDoc;\n          clonedOriginalDoc = clonedOriginalDoc.deepCopy(); // copy again because the old cloned ref will be modified during processAdd\n          cmd.solrDoc.setField(VERSION, lastVersion);\n\n          processAddWithRetry(cmd, attempts, clonedOriginalDoc);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"740d649f013f07efbeb73ca854f106c60166e7c0":["43564cbb30b064675027cfb569564e8531096e97"],"392e007070227c0fd1c28259a11f55a06a9bd7c2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"43564cbb30b064675027cfb569564e8531096e97":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f6db21866f23a2d17740a966f1137fb5c6df45d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57c238f5fb83803b49b37b3a1a12224a64d47542":["575e66bd4b2349209027f6801184da7fc3cba13f"],"575e66bd4b2349209027f6801184da7fc3cba13f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"f6db21866f23a2d17740a966f1137fb5c6df45d1":["392e007070227c0fd1c28259a11f55a06a9bd7c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"]},"commit2Childs":{"740d649f013f07efbeb73ca854f106c60166e7c0":["575e66bd4b2349209027f6801184da7fc3cba13f"],"392e007070227c0fd1c28259a11f55a06a9bd7c2":["f6db21866f23a2d17740a966f1137fb5c6df45d1"],"43564cbb30b064675027cfb569564e8531096e97":["740d649f013f07efbeb73ca854f106c60166e7c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["392e007070227c0fd1c28259a11f55a06a9bd7c2","43564cbb30b064675027cfb569564e8531096e97"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"575e66bd4b2349209027f6801184da7fc3cba13f":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"f6db21866f23a2d17740a966f1137fb5c6df45d1":["43564cbb30b064675027cfb569564e8531096e97"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}