{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","commits":[{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param p1 is the first point.\n   * @param p2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(GeoPoint)}\n   */\n  public double surfaceDistance(final GeoPoint p1, final GeoPoint p2) {\n    final double latA = p1.getLatitude();\n    final double lonA = p1.getLongitude();\n    final double latB = p2.getLatitude();\n    final double lonB = p2.getLongitude();\n\n    final double L = lonB - lonA;\n    final double oF = 1.0 - this.flattening;\n    final double U1 = Math.atan(oF * Math.tan(latA));\n    final double U2 = Math.atan(oF * Math.tan(latB));\n    final double sU1 = Math.sin(U1);\n    final double cU1 = Math.cos(U1);\n    final double sU2 = Math.sin(U2);\n    final double cU2 = Math.cos(U2);\n\n    double sigma, sinSigma, cosSigma;\n    double cos2Alpha, cos2SigmaM;\n    \n    double lambda = L;\n    double iters = 100;\n\n    do {\n      final double sinLambda = Math.sin(lambda);\n      final double cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cU2 * sinLambda) * (cU2 * sinLambda) + (cU1 * sU2 - sU1 * cU2 * cosLambda)\n          * (cU1 * sU2 - sU1 * cU2 * cosLambda));\n      if (Math.abs(sinSigma) < Vector.MINIMUM_RESOLUTION)\n        return 0.0;\n\n      cosSigma = sU1 * sU2 + cU1 * cU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      final double sinAlpha = cU1 * cU2 * sinLambda / sinSigma;\n      cos2Alpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * sU1 * sU2 / cos2Alpha;\n\n      final double c = this.flattening * 0.625 * cos2Alpha * (4.0 + this.flattening * (4.0 - 3.0 * cos2Alpha));\n      final double lambdaP = lambda;\n      lambda = L + (1.0 - c) * this.flattening * sinAlpha * (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma *\n          (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)));\n      if (Math.abs(lambda - lambdaP) < Vector.MINIMUM_RESOLUTION)\n        break;\n    } while (--iters > 0);\n\n    if (iters == 0)\n      return 0.0;\n\n    final double uSq = cos2Alpha * this.squareRatio;\n    final double A = 1.0 + uSq * 0.00006103515625 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq * 0.0009765625 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B * 0.25 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM) - B * 0.16666666666666666666667 * cos2SigmaM\n            * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return this.c * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param p1 is the first point.\n   * @param p2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link org.apache.lucene.geo3d.GeoPoint#arcDistance(GeoPoint)}\n   */\n  public double surfaceDistance(final GeoPoint p1, final GeoPoint p2) {\n    final double latA = p1.getLatitude();\n    final double lonA = p1.getLongitude();\n    final double latB = p2.getLatitude();\n    final double lonB = p2.getLongitude();\n\n    final double L = lonB - lonA;\n    final double oF = 1.0 - this.flattening;\n    final double U1 = Math.atan(oF * Math.tan(latA));\n    final double U2 = Math.atan(oF * Math.tan(latB));\n    final double sU1 = Math.sin(U1);\n    final double cU1 = Math.cos(U1);\n    final double sU2 = Math.sin(U2);\n    final double cU2 = Math.cos(U2);\n\n    double sigma, sinSigma, cosSigma;\n    double cos2Alpha, cos2SigmaM;\n    \n    double lambda = L;\n    double iters = 100;\n\n    do {\n      final double sinLambda = Math.sin(lambda);\n      final double cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cU2 * sinLambda) * (cU2 * sinLambda) + (cU1 * sU2 - sU1 * cU2 * cosLambda)\n          * (cU1 * sU2 - sU1 * cU2 * cosLambda));\n      if (Math.abs(sinSigma) < Vector.MINIMUM_RESOLUTION)\n        return 0.0;\n\n      cosSigma = sU1 * sU2 + cU1 * cU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      final double sinAlpha = cU1 * cU2 * sinLambda / sinSigma;\n      cos2Alpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * sU1 * sU2 / cos2Alpha;\n\n      final double c = this.flattening * 0.625 * cos2Alpha * (4.0 + this.flattening * (4.0 - 3.0 * cos2Alpha));\n      final double lambdaP = lambda;\n      lambda = L + (1.0 - c) * this.flattening * sinAlpha * (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma *\n          (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)));\n      if (Math.abs(lambda - lambdaP) < Vector.MINIMUM_RESOLUTION)\n        break;\n    } while (--iters > 0);\n\n    if (iters == 0)\n      return 0.0;\n\n    final double uSq = cos2Alpha * this.squareRatio;\n    final double A = 1.0 + uSq * 0.00006103515625 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq * 0.0009765625 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B * 0.25 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM) - B * 0.16666666666666666666667 * cos2SigmaM\n            * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return this.c * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa19385d0e0b436df2304541d381046c912096ac","date":1458907196,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(GeoPoint)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param p1 is the first point.\n   * @param p2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(GeoPoint)}\n   */\n  public double surfaceDistance(final GeoPoint p1, final GeoPoint p2) {\n    final double latA = p1.getLatitude();\n    final double lonA = p1.getLongitude();\n    final double latB = p2.getLatitude();\n    final double lonB = p2.getLongitude();\n\n    final double L = lonB - lonA;\n    final double oF = 1.0 - this.flattening;\n    final double U1 = Math.atan(oF * Math.tan(latA));\n    final double U2 = Math.atan(oF * Math.tan(latB));\n    final double sU1 = Math.sin(U1);\n    final double cU1 = Math.cos(U1);\n    final double sU2 = Math.sin(U2);\n    final double cU2 = Math.cos(U2);\n\n    double sigma, sinSigma, cosSigma;\n    double cos2Alpha, cos2SigmaM;\n    \n    double lambda = L;\n    double iters = 100;\n\n    do {\n      final double sinLambda = Math.sin(lambda);\n      final double cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cU2 * sinLambda) * (cU2 * sinLambda) + (cU1 * sU2 - sU1 * cU2 * cosLambda)\n          * (cU1 * sU2 - sU1 * cU2 * cosLambda));\n      if (Math.abs(sinSigma) < Vector.MINIMUM_RESOLUTION)\n        return 0.0;\n\n      cosSigma = sU1 * sU2 + cU1 * cU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      final double sinAlpha = cU1 * cU2 * sinLambda / sinSigma;\n      cos2Alpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * sU1 * sU2 / cos2Alpha;\n\n      final double c = this.flattening * 0.625 * cos2Alpha * (4.0 + this.flattening * (4.0 - 3.0 * cos2Alpha));\n      final double lambdaP = lambda;\n      lambda = L + (1.0 - c) * this.flattening * sinAlpha * (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma *\n          (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)));\n      if (Math.abs(lambda - lambdaP) < Vector.MINIMUM_RESOLUTION)\n        break;\n    } while (--iters > 0);\n\n    if (iters == 0)\n      return 0.0;\n\n    final double uSq = cos2Alpha * this.squareRatio;\n    final double A = 1.0 + uSq * 0.00006103515625 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq * 0.0009765625 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B * 0.25 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM) - B * 0.16666666666666666666667 * cos2SigmaM\n            * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return this.c * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9f156572c6e1245055b705603088061b42ab3a1","date":1462449249,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(GeoPoint)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(GeoPoint)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(GeoPoint)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62f22e14715933c1b1b4535049f6a64173e36068","date":1506122941,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) >= Vector.MINIMUM_RESOLUTION && ++iterLimit < 100);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) >= Vector.MINIMUM_RESOLUTION && ++iterLimit < 100);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) > Vector.MINIMUM_RESOLUTION && ++iterLimit < 40);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4218e96184b4af9d31258a45a87da597ea58ac7","date":1512293271,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) >= Vector.MINIMUM_RESOLUTION && ++iterLimit < 100);\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * inverseScale * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) >= Vector.MINIMUM_RESOLUTION && ++iterLimit < 100);\n\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfaceDistance(GeoPoint,GeoPoint).mjava","sourceNew":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0- scaledFlattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0- scaledFlattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = scaledFlattening / 16.0 * cosSqAlpha * (4.0 + scaledFlattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * scaledFlattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) >= Vector.MINIMUM_RESOLUTION && ++iterLimit < 100);\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return zScaling * inverseScale * A * (sigma - deltaSigma);\n  }\n\n","sourceOld":"  /** Compute surface distance between two points.\n   * @param pt1 is the first point.\n   * @param pt2 is the second point.\n   * @return the adjusted angle, when multiplied by the mean earth radius, yields a surface distance.  This will differ\n   * from GeoPoint.arcDistance() only when the planet model is not a sphere. @see {@link GeoPoint#arcDistance(Vector)}\n   */\n  public double surfaceDistance(final GeoPoint pt1, final GeoPoint pt2) {\n    final double L = pt2.getLongitude() - pt1.getLongitude();\n    final double U1 = Math.atan((1.0-flattening) * Math.tan(pt1.getLatitude()));\n    final double U2 = Math.atan((1.0-flattening) * Math.tan(pt2.getLatitude()));\n\n    final double sinU1 = Math.sin(U1);\n    final double cosU1 = Math.cos(U1);\n    final double sinU2 = Math.sin(U2);\n    final double cosU2 = Math.cos(U2);\n\n    final double dCosU1CosU2 = cosU1 * cosU2;\n    final double dCosU1SinU2 = cosU1 * sinU2;\n\n    final double dSinU1SinU2 = sinU1 * sinU2;\n    final double dSinU1CosU2 = sinU1 * cosU2;\n\n\n    double lambda = L;\n    double lambdaP = Math.PI * 2.0;\n    int iterLimit = 0;\n    double cosSqAlpha;\n    double sinSigma;\n    double cos2SigmaM;\n    double cosSigma;\n    double sigma;\n    double sinAlpha;\n    double C;\n    double sinLambda, cosLambda;\n\n    do {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +\n                                    (dCosU1SinU2 - dSinU1CosU2 * cosLambda) * (dCosU1SinU2 - dSinU1CosU2 * cosLambda));\n\n      if (sinSigma==0.0) {\n        return 0.0;\n      }\n      cosSigma = dSinU1SinU2 + dCosU1CosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = dCosU1CosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1.0 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2.0 * dSinU1SinU2 / cosSqAlpha;\n\n      if (Double.isNaN(cos2SigmaM))\n        cos2SigmaM = 0.0;  // equatorial line: cosSqAlpha=0\n      C = flattening / 16.0 * cosSqAlpha * (4.0 + flattening * (4.0 - 3.0 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1.0 - C) * flattening * sinAlpha *\n        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM *cos2SigmaM)));\n    } while (Math.abs(lambda-lambdaP) >= Vector.MINIMUM_RESOLUTION && ++iterLimit < 100);\n    final double uSq = cosSqAlpha * this.squareRatio;\n    final double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    final double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n    final double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4.0 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)-\n                                        B / 6.0 * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma) * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));\n\n    return c * inverseScale * A * (sigma - deltaSigma);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e4218e96184b4af9d31258a45a87da597ea58ac7":["62f22e14715933c1b1b4535049f6a64173e36068"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["f9f156572c6e1245055b705603088061b42ab3a1","62f22e14715933c1b1b4535049f6a64173e36068"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["aa19385d0e0b436df2304541d381046c912096ac","f9f156572c6e1245055b705603088061b42ab3a1"],"f9f156572c6e1245055b705603088061b42ab3a1":["aa19385d0e0b436df2304541d381046c912096ac"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["aa19385d0e0b436df2304541d381046c912096ac","f9f156572c6e1245055b705603088061b42ab3a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"62f22e14715933c1b1b4535049f6a64173e36068":["f9f156572c6e1245055b705603088061b42ab3a1"],"aa19385d0e0b436df2304541d381046c912096ac":["b4e444678504caf66a8060b1d514383aa4feac0c"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["e4218e96184b4af9d31258a45a87da597ea58ac7"],"b4e444678504caf66a8060b1d514383aa4feac0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"]},"commit2Childs":{"e4218e96184b4af9d31258a45a87da597ea58ac7":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":[],"f9f156572c6e1245055b705603088061b42ab3a1":["6240b74b884c5587f2a4062dd27d6c32bf228889","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","62f22e14715933c1b1b4535049f6a64173e36068"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4e444678504caf66a8060b1d514383aa4feac0c"],"62f22e14715933c1b1b4535049f6a64173e36068":["e4218e96184b4af9d31258a45a87da597ea58ac7","6240b74b884c5587f2a4062dd27d6c32bf228889"],"aa19385d0e0b436df2304541d381046c912096ac":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","f9f156572c6e1245055b705603088061b42ab3a1","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b4e444678504caf66a8060b1d514383aa4feac0c":["aa19385d0e0b436df2304541d381046c912096ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}