{"path":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","commits":[{"id":"3cbd743a4843f513f793670e3ab0e272bf824faf","date":1518149529,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive(); // this config is actually # seconds, not # tries\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000); // thus numRetries is roughly number of seconds\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":"  public static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive(); // this config is actually # seconds, not # tries\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000); // thus numRetries is roughly number of seconds\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n    \n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + seconds + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n        \n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                  replica.getCoreUrl(), state);\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          if ((replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount)) return true;\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n   \n      String  error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n    \n  }\n\n","sourceOld":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive(); // this config is actually # seconds, not # tries\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000); // thus numRetries is roughly number of seconds\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":["6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691","b1197d6f54676973038ad402280d80a139dfd27b","344b0840364d990b29b97467bfcc766ff8325d11"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n\n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + seconds + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n\n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                  replica.getCoreUrl(), state);\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          if ((replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount)) return true;\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n\n      String  error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","sourceOld":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n    \n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + seconds + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n        \n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                  replica.getCoreUrl(), state);\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          if ((replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount)) return true;\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n   \n      String  error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n\n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + seconds + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n\n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                  replica.getCoreUrl(), state);\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          if ((replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount)) return true;\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n\n      String error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","sourceOld":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n\n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + seconds + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n\n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                  replica.getCoreUrl(), state);\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          if ((replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount)) return true;\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n\n      String  error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad50218572a7f0b10419586719d6f119f92f17c9","date":1582240385,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n\n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + seconds + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n\n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                  replica.getCoreUrl(), state);\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          return (replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount);\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n\n      String error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","sourceOld":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n\n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + seconds + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n\n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                  replica.getCoreUrl(), state);\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          if ((replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount)) return true;\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n\n      String error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      if (log.isInfoEnabled()) {\n        log.info(\"Not waiting for active collection due to exception: {}\", createCollResponse.getResponse().get(\"exception\"));\n      }\n      return;\n    }\n\n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    if (log.isInfoEnabled()) {\n      log.info(\"Wait for new collection to be active for at most {} seconds. Check all shard {}\"\n          , seconds, (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    }\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n\n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              if (log.isDebugEnabled()) {\n                log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                    replica.getCoreUrl(), state);\n              }\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          return (replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount);\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n\n      String error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","sourceOld":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n\n    int replicaFailCount;\n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      replicaFailCount = ((NamedList) createCollResponse.getResponse().get(\"failure\")).size();\n    } else {\n      replicaFailCount = 0;\n    }\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer seconds = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + seconds + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n\n    try {\n      cc.getZkController().getZkStateReader().waitForState(collectionName, seconds, TimeUnit.SECONDS, (n, c) -> {\n\n        if (c == null) {\n          // the collection was not created, don't wait\n          return true;\n        }\n\n        if (c.getSlices() != null) {\n          Collection<Slice> shards = c.getSlices();\n          int replicaNotAliveCnt = 0;\n          for (Slice shard : shards) {\n            Collection<Replica> replicas;\n            if (!checkLeaderOnly) replicas = shard.getReplicas();\n            else {\n              replicas = new ArrayList<Replica>();\n              replicas.add(shard.getLeader());\n            }\n            for (Replica replica : replicas) {\n              String state = replica.getStr(ZkStateReader.STATE_PROP);\n              log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                  replica.getCoreUrl(), state);\n              if (!n.contains(replica.getNodeName())\n                  || !state.equals(Replica.State.ACTIVE.toString())) {\n                replicaNotAliveCnt++;\n                return false;\n              }\n            }\n          }\n\n          return (replicaNotAliveCnt == 0) || (replicaNotAliveCnt <= replicaFailCount);\n        }\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n\n      String error = \"Timeout waiting for active collection \" + collectionName + \" with timeout=\" + seconds;\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cbd743a4843f513f793670e3ab0e272bf824faf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["b627755385655c7cd3fb296f17593658805cf4d5"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"575e66bd4b2349209027f6801184da7fc3cba13f":["ad50218572a7f0b10419586719d6f119f92f17c9"],"ad50218572a7f0b10419586719d6f119f92f17c9":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"3cbd743a4843f513f793670e3ab0e272bf824faf":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["ad50218572a7f0b10419586719d6f119f92f17c9"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b627755385655c7cd3fb296f17593658805cf4d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"b627755385655c7cd3fb296f17593658805cf4d5":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad50218572a7f0b10419586719d6f119f92f17c9":["575e66bd4b2349209027f6801184da7fc3cba13f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}