{"path":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","commits":[{"id":"4b1444275c93a8051a6fe6158639467a144ae0a4","date":1224502393,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2993c85d947e3191bba14229ea72fd5675d048e2","date":1228593940,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  if (infoStream != null)\n                    message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              if (infoStream != null)\n                message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success && infoStream != null)\n                message(\"hit exception committing segments file\");\n            }\n          } else if (infoStream != null)\n            message(\"sync superseded by newer infos\");\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":["0f44610301174bfb430443d89a88dc1c502feea1","df2e19759ba573689671d3ed4451ede4d92e479a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f44610301174bfb430443d89a88dc1c502feea1","date":1231194664,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              if (infoStream != null)\n                message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success && infoStream != null)\n                message(\"hit exception committing segments file\");\n            }\n          } else if (infoStream != null)\n            message(\"sync superseded by newer infos\");\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  if (infoStream != null)\n                    message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              if (infoStream != null)\n                message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success && infoStream != null)\n                message(\"hit exception committing segments file\");\n            }\n          } else if (infoStream != null)\n            message(\"sync superseded by newer infos\");\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63","2586f96f60332eb97ecd2934b0763791462568b2","2993c85d947e3191bba14229ea72fd5675d048e2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"df2e19759ba573689671d3ed4451ede4d92e479a","date":1235439035,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              if (infoStream != null)\n                message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success && infoStream != null)\n                message(\"hit exception committing segments file\");\n            }\n          } else if (infoStream != null)\n            message(\"sync superseded by newer infos\");\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63","455aeff4fef915340c5b19d71d5e147034e83093","2993c85d947e3191bba14229ea72fd5675d048e2","e82780afe6097066eb5befb86e9432f077667e3d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4ff8864209d2e972cb4393600c26082f9a6533d","date":1239297466,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd488f50316362b01a7f67b11a96796b9652e3e5","date":1241121034,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3ab91f3bb602daf6393fa7f78b11afd3400d669","date":1243282044,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"cd488f50316362b01a7f67b11a96796b9652e3e5":["c4ff8864209d2e972cb4393600c26082f9a6533d"],"0f44610301174bfb430443d89a88dc1c502feea1":["2993c85d947e3191bba14229ea72fd5675d048e2"],"4b1444275c93a8051a6fe6158639467a144ae0a4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d3ab91f3bb602daf6393fa7f78b11afd3400d669":["cd488f50316362b01a7f67b11a96796b9652e3e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c4ff8864209d2e972cb4393600c26082f9a6533d":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["df2e19759ba573689671d3ed4451ede4d92e479a"],"df2e19759ba573689671d3ed4451ede4d92e479a":["0f44610301174bfb430443d89a88dc1c502feea1"],"2993c85d947e3191bba14229ea72fd5675d048e2":["4b1444275c93a8051a6fe6158639467a144ae0a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d3ab91f3bb602daf6393fa7f78b11afd3400d669"]},"commit2Childs":{"cd488f50316362b01a7f67b11a96796b9652e3e5":["d3ab91f3bb602daf6393fa7f78b11afd3400d669"],"0f44610301174bfb430443d89a88dc1c502feea1":["df2e19759ba573689671d3ed4451ede4d92e479a"],"4b1444275c93a8051a6fe6158639467a144ae0a4":["2993c85d947e3191bba14229ea72fd5675d048e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4b1444275c93a8051a6fe6158639467a144ae0a4"],"d3ab91f3bb602daf6393fa7f78b11afd3400d669":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c4ff8864209d2e972cb4393600c26082f9a6533d":["cd488f50316362b01a7f67b11a96796b9652e3e5"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["c4ff8864209d2e972cb4393600c26082f9a6533d"],"df2e19759ba573689671d3ed4451ede4d92e479a":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"2993c85d947e3191bba14229ea72fd5675d048e2":["0f44610301174bfb430443d89a88dc1c502feea1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}