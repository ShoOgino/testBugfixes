{"path":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(Object,SortedDocValues[]).mjava","commits":[{"id":"cf3d78aec0a22d08438820ca1492a3ea4371466e","date":1360105770,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(Object,SortedDocValues[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(SortedDocValues[]).mjava","sourceNew":"    OrdinalMap(Object owner, SortedDocValues subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      this.owner = owner;\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      int segmentOrds[] = new int[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(new SortedDocValuesTermsEnum(subs[i]), i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      int globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          int delta = globalOrd - segmentOrds[subIndex];\n          assert delta >= 0;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(delta);\n          }\n          // for each per-segment ord, map it back to the global term.\n          ordDeltas[subIndex].add(delta);\n          segmentOrds[subIndex]++;\n        }\n        globalOrd++;\n      }\n    }\n\n","sourceOld":"    OrdinalMap(SortedDocValues subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      int segmentOrds[] = new int[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(new SortedDocValuesTermsEnum(subs[i]), i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      int globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          int delta = globalOrd - segmentOrds[subIndex];\n          assert delta >= 0;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(delta);\n          }\n          // for each per-segment ord, map it back to the global term.\n          ordDeltas[subIndex].add(delta);\n          segmentOrds[subIndex]++;\n        }\n        globalOrd++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(Object,SortedDocValues[]).mjava","pathOld":"/dev/null","sourceNew":"    OrdinalMap(Object owner, SortedDocValues subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      this.owner = owner;\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      int segmentOrds[] = new int[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(new SortedDocValuesTermsEnum(subs[i]), i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      int globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          int delta = globalOrd - segmentOrds[subIndex];\n          assert delta >= 0;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(delta);\n          }\n          // for each per-segment ord, map it back to the global term.\n          ordDeltas[subIndex].add(delta);\n          segmentOrds[subIndex]++;\n        }\n        globalOrd++;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f366ce28775e2b8ea4e06355009471328711666d","date":1360551293,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(Object,TermsEnum[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(Object,SortedDocValues[]).mjava","sourceNew":"    public OrdinalMap(Object owner, TermsEnum subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      this.owner = owner;\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      long segmentOrds[] = new long[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(subs[i], i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      long globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          long segmentOrd = matches[i].terms.ord();\n          long delta = globalOrd - segmentOrd;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(delta);\n          }\n          // for each per-segment ord, map it back to the global term.\n          while (segmentOrds[subIndex] <= segmentOrd) {\n            ordDeltas[subIndex].add(delta);\n            segmentOrds[subIndex]++;\n          }\n        }\n        globalOrd++;\n      }\n    }\n\n","sourceOld":"    OrdinalMap(Object owner, SortedDocValues subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      this.owner = owner;\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      int segmentOrds[] = new int[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(new SortedDocValuesTermsEnum(subs[i]), i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      int globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          int delta = globalOrd - segmentOrds[subIndex];\n          assert delta >= 0;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(delta);\n          }\n          // for each per-segment ord, map it back to the global term.\n          ordDeltas[subIndex].add(delta);\n          segmentOrds[subIndex]++;\n        }\n        globalOrd++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(Object,TermsEnum[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(Object,SortedDocValues[]).mjava","sourceNew":"    /** \n     * Creates an ordinal map that allows mapping ords to/from a merged\n     * space from <code>subs</code>.\n     * @param owner a cache key\n     * @param subs TermsEnums that support {@link TermsEnum#ord()}. They need\n     *             not be dense (e.g. can be FilteredTermsEnums}.\n     * @throws IOException if an I/O error occurred.\n     */\n    public OrdinalMap(Object owner, TermsEnum subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      this.owner = owner;\n      globalOrdDeltas = new MonotonicAppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new MonotonicAppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new MonotonicAppendingLongBuffer();\n      }\n      long segmentOrds[] = new long[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(subs[i], i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      long globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          long segmentOrd = matches[i].terms.ord();\n          long delta = globalOrd - segmentOrd;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(delta);\n          }\n          // for each per-segment ord, map it back to the global term.\n          while (segmentOrds[subIndex] <= segmentOrd) {\n            ordDeltas[subIndex].add(delta);\n            segmentOrds[subIndex]++;\n          }\n        }\n        globalOrd++;\n      }\n    }\n\n","sourceOld":"    OrdinalMap(Object owner, SortedDocValues subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      this.owner = owner;\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      int segmentOrds[] = new int[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(new SortedDocValuesTermsEnum(subs[i]), i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      int globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          int delta = globalOrd - segmentOrds[subIndex];\n          assert delta >= 0;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(delta);\n          }\n          // for each per-segment ord, map it back to the global term.\n          ordDeltas[subIndex].add(delta);\n          segmentOrds[subIndex]++;\n        }\n        globalOrd++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cf3d78aec0a22d08438820ca1492a3ea4371466e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cf3d78aec0a22d08438820ca1492a3ea4371466e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f366ce28775e2b8ea4e06355009471328711666d":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["d4d69c535930b5cce125cff868d40f6373dc27d4","f366ce28775e2b8ea4e06355009471328711666d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ddbb72a33557d2b5bc22ee95daf3281c43560502"]},"commit2Childs":{"cf3d78aec0a22d08438820ca1492a3ea4371466e":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["f366ce28775e2b8ea4e06355009471328711666d","ddbb72a33557d2b5bc22ee95daf3281c43560502"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cf3d78aec0a22d08438820ca1492a3ea4371466e","d4d69c535930b5cce125cff868d40f6373dc27d4"],"f366ce28775e2b8ea4e06355009471328711666d":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}