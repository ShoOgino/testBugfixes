{"path":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment indexed any field dimensionally\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getDimensionNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getDimensionNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getDimensionNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b63007489248c99b5cdc766ce55938891f5d969","date":1456737032,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1800b996d8677670482a071dcb7a48b08c423ace","date":1456955558,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLower = new byte[numDims * bytesPerDim];\n        byte[] packedUpper = new byte[numDims * bytesPerDim];\n\n        // Carefully pack lower and upper bounds\n        for(int dim=0;dim<numDims;dim++) {\n          System.arraycopy(lowerPoint[dim], 0, packedLower, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(upperPoint[dim], 0, packedUpper, dim*bytesPerDim, bytesPerDim);\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLower, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpper, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpper, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLower, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLower, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpper, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":["770342641f7b505eaa8dccdc666158bff2419109","1904709ea0185dc04e3d77ea01c79e909caf2796","cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"bugIntro":["606ea169579957651185909e7264798e99e714f9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c422e924212367b334b4938f1fd3e44438e88c40","date":1456962933,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLower = new byte[numDims * bytesPerDim];\n        byte[] packedUpper = new byte[numDims * bytesPerDim];\n\n        // Carefully pack lower and upper bounds\n        for(int dim=0;dim<numDims;dim++) {\n          System.arraycopy(lowerPoint[dim], 0, packedLower, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(upperPoint[dim], 0, packedUpper, dim*bytesPerDim, bytesPerDim);\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLower, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpper, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpper, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLower, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLower, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpper, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLower = new byte[numDims * bytesPerDim];\n        byte[] packedUpper = new byte[numDims * bytesPerDim];\n\n        // Carefully pack lower and upper bounds\n        for(int dim=0;dim<numDims;dim++) {\n          System.arraycopy(lowerPoint[dim], 0, packedLower, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(upperPoint[dim], 0, packedUpper, dim*bytesPerDim, bytesPerDim);\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLower, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpper, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpper, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLower, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLower, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpper, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74c553c860db4d81dbf8ee037edd53f4602be719","date":1457340939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values,\n          byte[] packedLower, byte[] packedUpper) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLower, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpper, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpper, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLower, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLower, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpper, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLower = new byte[numDims * bytesPerDim];\n        byte[] packedUpper = new byte[numDims * bytesPerDim];\n\n        // Carefully pack lower and upper bounds\n        for(int dim=0;dim<numDims;dim++) {\n          System.arraycopy(lowerPoint[dim], 0, packedLower, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(upperPoint[dim], 0, packedUpper, dim*bytesPerDim, bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, packedLower, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, packedUpper, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values, packedLower, packedUpper).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLower = new byte[numDims * bytesPerDim];\n        byte[] packedUpper = new byte[numDims * bytesPerDim];\n\n        // Carefully pack lower and upper bounds\n        for(int dim=0;dim<numDims;dim++) {\n          System.arraycopy(lowerPoint[dim], 0, packedLower, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(upperPoint[dim], 0, packedUpper, dim*bytesPerDim, bytesPerDim);\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLower, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpper, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpper, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLower, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLower, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpper, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["606ea169579957651185909e7264798e99e714f9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5839bca64b33c24668e37476ee168d00dc0bb96d","date":1457536035,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values,\n          byte[] packedLower, byte[] packedUpper) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLower, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpper, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpper, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLower, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLower, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpper, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLower = new byte[numDims * bytesPerDim];\n        byte[] packedUpper = new byte[numDims * bytesPerDim];\n\n        // Carefully pack lower and upper bounds\n        for(int dim=0;dim<numDims;dim++) {\n          System.arraycopy(lowerPoint[dim], 0, packedLower, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(upperPoint[dim], 0, packedUpper, dim*bytesPerDim, bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, packedLower, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, packedUpper, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values, packedLower, packedUpper).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values,\n          byte[] packedLower, byte[] packedUpper) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLower, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpper, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpper, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLower, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLower, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpper, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLower = new byte[numDims * bytesPerDim];\n        byte[] packedUpper = new byte[numDims * bytesPerDim];\n\n        // Carefully pack lower and upper bounds\n        for(int dim=0;dim<numDims;dim++) {\n          System.arraycopy(lowerPoint[dim], 0, packedLower, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(upperPoint[dim], 0, packedUpper, dim*bytesPerDim, bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, packedLower, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, packedUpper, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values, packedLower, packedUpper).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"606ea169579957651185909e7264798e99e714f9","date":1458504317,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values,\n          byte[] packedLower, byte[] packedUpper) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLower, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpper, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpper, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLower, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLower, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpper, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLower = new byte[numDims * bytesPerDim];\n        byte[] packedUpper = new byte[numDims * bytesPerDim];\n\n        // Carefully pack lower and upper bounds\n        for(int dim=0;dim<numDims;dim++) {\n          System.arraycopy(lowerPoint[dim], 0, packedLower, dim*bytesPerDim, bytesPerDim);\n          System.arraycopy(upperPoint[dim], 0, packedUpper, dim*bytesPerDim, bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, packedLower, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, packedUpper, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values, packedLower, packedUpper).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":["1800b996d8677670482a071dcb7a48b08c423ace","1904709ea0185dc04e3d77ea01c79e909caf2796","cab7a79353f33d1a94cd307bf33aa5148601ebe6","74c553c860db4d81dbf8ee037edd53f4602be719"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af","date":1461918927,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e8d5955830d712186a4beb716e797d505af7981","date":1461951189,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9ee4c03e3ee986704eeeb45c571d001905a6430","date":1462194267,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30540ec27130887a9372c159e8fe971200f37727","date":1462223109,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02e175abd2c4c1611c5a9647486ae8ba249a94c1","date":1468327116,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingDocIdSet(reader, values).iterator();\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","2b63007489248c99b5cdc766ce55938891f5d969"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8e8d5955830d712186a4beb716e797d505af7981":["606ea169579957651185909e7264798e99e714f9","3d3eccadf4f2a01d2034c96afe1a5c617b2e85af"],"5839bca64b33c24668e37476ee168d00dc0bb96d":["74c553c860db4d81dbf8ee037edd53f4602be719"],"30540ec27130887a9372c159e8fe971200f37727":["8e8d5955830d712186a4beb716e797d505af7981","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"606ea169579957651185909e7264798e99e714f9":["5839bca64b33c24668e37476ee168d00dc0bb96d"],"74c553c860db4d81dbf8ee037edd53f4602be719":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"c422e924212367b334b4938f1fd3e44438e88c40":["2b63007489248c99b5cdc766ce55938891f5d969","1800b996d8677670482a071dcb7a48b08c423ace"],"1800b996d8677670482a071dcb7a48b08c423ace":["2b63007489248c99b5cdc766ce55938891f5d969"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["606ea169579957651185909e7264798e99e714f9","30540ec27130887a9372c159e8fe971200f37727"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["8e8d5955830d712186a4beb716e797d505af7981"],"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af":["606ea169579957651185909e7264798e99e714f9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b63007489248c99b5cdc766ce55938891f5d969":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["30540ec27130887a9372c159e8fe971200f37727"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["af2638813028b254a88b418ebeafb541afb49653","c422e924212367b334b4938f1fd3e44438e88c40"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["af2638813028b254a88b418ebeafb541afb49653","2b63007489248c99b5cdc766ce55938891f5d969"],"8e8d5955830d712186a4beb716e797d505af7981":["30540ec27130887a9372c159e8fe971200f37727","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"5839bca64b33c24668e37476ee168d00dc0bb96d":["606ea169579957651185909e7264798e99e714f9"],"30540ec27130887a9372c159e8fe971200f37727":["55b50463286869f584cf849d1587a0fcd54d1dfa","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"606ea169579957651185909e7264798e99e714f9":["8e8d5955830d712186a4beb716e797d505af7981","55b50463286869f584cf849d1587a0fcd54d1dfa","3d3eccadf4f2a01d2034c96afe1a5c617b2e85af"],"74c553c860db4d81dbf8ee037edd53f4602be719":["5839bca64b33c24668e37476ee168d00dc0bb96d"],"c422e924212367b334b4938f1fd3e44438e88c40":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"1800b996d8677670482a071dcb7a48b08c423ace":["c422e924212367b334b4938f1fd3e44438e88c40"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["30540ec27130887a9372c159e8fe971200f37727"],"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af":["8e8d5955830d712186a4beb716e797d505af7981"],"2b63007489248c99b5cdc766ce55938891f5d969":["af2638813028b254a88b418ebeafb541afb49653","c422e924212367b334b4938f1fd3e44438e88c40","1800b996d8677670482a071dcb7a48b08c423ace"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["74c553c860db4d81dbf8ee037edd53f4602be719"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}