{"path":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n\n    assert docCount > 0;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pulsed) {\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n      pulsedCount++;\n    } else {\n      nonPulsedCount++;\n      // OK, there were few enough occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n      int lastDocID = 0;\n      for(int i=0;i<pendingDocCount;i++) {\n        final Document doc = pendingDocs[i];\n        final int delta = doc.docID - lastDocID;\n        lastDocID = doc.docID;\n        if (omitTF) {\n          termsOut.writeVInt(delta);\n        } else {\n          assert doc.numPositions == doc.termDocFreq;\n          if (doc.numPositions == 1)\n            termsOut.writeVInt((delta<<1)|1);\n          else {\n            termsOut.writeVInt(delta<<1);\n            termsOut.writeVInt(doc.numPositions);\n          }\n\n          // TODO: we could do better in encoding\n          // payloadLength, eg, if it's always the same\n          // across all terms\n          int lastPosition = 0;\n          int lastPayloadLength = -1;\n\n          for(int j=0;j<doc.numPositions;j++) {\n            final Position pos = doc.positions[j];\n            final int delta2 = pos.pos - lastPosition;\n            lastPosition = pos.pos;\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                termsOut.writeVInt((delta2 << 1)|1);\n                termsOut.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                termsOut.writeVInt(delta2 << 1);\n              }\n\n              if (payloadLength > 0) {\n                termsOut.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              termsOut.writeVInt(delta2);\n            }\n          }\n        }\n      }\n    }\n\n    pendingDocCount = 0;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d53c3f769ca0f9e7434937b792877770271aecf","date":1294785129,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n\n    assert docCount > 0;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pulsed) {\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n      pulsedCount++;\n    } else {\n      nonPulsedCount++;\n      // OK, there were few enough occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n      int lastDocID = 0;\n      for(int i=0;i<pendingDocCount;i++) {\n        final Document doc = pendingDocs[i];\n        final int delta = doc.docID - lastDocID;\n        lastDocID = doc.docID;\n        if (omitTF) {\n          termsOut.writeVInt(delta);\n        } else {\n          assert doc.numPositions == doc.termDocFreq;\n          if (doc.numPositions == 1)\n            termsOut.writeVInt((delta<<1)|1);\n          else {\n            termsOut.writeVInt(delta<<1);\n            termsOut.writeVInt(doc.numPositions);\n          }\n\n          // TODO: we could do better in encoding\n          // payloadLength, eg, if it's always the same\n          // across all terms\n          int lastPosition = 0;\n          int lastPayloadLength = -1;\n\n          for(int j=0;j<doc.numPositions;j++) {\n            final Position pos = doc.positions[j];\n            final int delta2 = pos.pos - lastPosition;\n            lastPosition = pos.pos;\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                termsOut.writeVInt((delta2 << 1)|1);\n                termsOut.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                termsOut.writeVInt(delta2 << 1);\n              }\n\n              if (payloadLength > 0) {\n                termsOut.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              termsOut.writeVInt(delta2);\n            }\n          }\n        }\n      }\n    }\n\n    pendingDocCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n\n    assert docCount > 0;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pulsed) {\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n      pulsedCount++;\n    } else {\n      nonPulsedCount++;\n      // OK, there were few enough occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n      int lastDocID = 0;\n      for(int i=0;i<pendingDocCount;i++) {\n        final Document doc = pendingDocs[i];\n        final int delta = doc.docID - lastDocID;\n        lastDocID = doc.docID;\n        if (omitTF) {\n          termsOut.writeVInt(delta);\n        } else {\n          assert doc.numPositions == doc.termDocFreq;\n          if (doc.numPositions == 1)\n            termsOut.writeVInt((delta<<1)|1);\n          else {\n            termsOut.writeVInt(delta<<1);\n            termsOut.writeVInt(doc.numPositions);\n          }\n\n          // TODO: we could do better in encoding\n          // payloadLength, eg, if it's always the same\n          // across all terms\n          int lastPosition = 0;\n          int lastPayloadLength = -1;\n\n          for(int j=0;j<doc.numPositions;j++) {\n            final Position pos = doc.positions[j];\n            final int delta2 = pos.pos - lastPosition;\n            lastPosition = pos.pos;\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                termsOut.writeVInt((delta2 << 1)|1);\n                termsOut.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                termsOut.writeVInt(delta2 << 1);\n              }\n\n              if (payloadLength > 0) {\n                termsOut.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              termsOut.writeVInt(delta2);\n            }\n          }\n        }\n      }\n    }\n\n    pendingDocCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ecd298fdc085e7eba27afa7fae58df1ba1a2808","date":1295102557,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(stats, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16843358872ed92ba92888ab99df297550b9a36a","date":1295144724,"type":5,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      wrappedPostingsWriter.finishTerm(stats, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","sourceNew":null,"sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n\n    assert docCount > 0;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pulsed) {\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n      pulsedCount++;\n    } else {\n      nonPulsedCount++;\n      // OK, there were few enough occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n      int lastDocID = 0;\n      for(int i=0;i<pendingDocCount;i++) {\n        final Document doc = pendingDocs[i];\n        final int delta = doc.docID - lastDocID;\n        lastDocID = doc.docID;\n        if (omitTF) {\n          termsOut.writeVInt(delta);\n        } else {\n          assert doc.numPositions == doc.termDocFreq;\n          if (doc.numPositions == 1)\n            termsOut.writeVInt((delta<<1)|1);\n          else {\n            termsOut.writeVInt(delta<<1);\n            termsOut.writeVInt(doc.numPositions);\n          }\n\n          // TODO: we could do better in encoding\n          // payloadLength, eg, if it's always the same\n          // across all terms\n          int lastPosition = 0;\n          int lastPayloadLength = -1;\n\n          for(int j=0;j<doc.numPositions;j++) {\n            final Position pos = doc.positions[j];\n            final int delta2 = pos.pos - lastPosition;\n            lastPosition = pos.pos;\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                termsOut.writeVInt((delta2 << 1)|1);\n                termsOut.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                termsOut.writeVInt(delta2 << 1);\n              }\n\n              if (payloadLength > 0) {\n                termsOut.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              termsOut.writeVInt(delta2);\n            }\n          }\n        }\n      }\n    }\n\n    pendingDocCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"29ef99d61cda9641b6250bf9567329a6e65f901d":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","6ecd298fdc085e7eba27afa7fae58df1ba1a2808"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"16843358872ed92ba92888ab99df297550b9a36a":["868da859b43505d9d2a023bfeae6dd0c795f5295","6ecd298fdc085e7eba27afa7fae58df1ba1a2808"],"3d53c3f769ca0f9e7434937b792877770271aecf":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","3d53c3f769ca0f9e7434937b792877770271aecf"],"6ecd298fdc085e7eba27afa7fae58df1ba1a2808":["3d53c3f769ca0f9e7434937b792877770271aecf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6ecd298fdc085e7eba27afa7fae58df1ba1a2808"]},"commit2Childs":{"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"16843358872ed92ba92888ab99df297550b9a36a":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["29ef99d61cda9641b6250bf9567329a6e65f901d","3d53c3f769ca0f9e7434937b792877770271aecf","868da859b43505d9d2a023bfeae6dd0c795f5295"],"3d53c3f769ca0f9e7434937b792877770271aecf":["868da859b43505d9d2a023bfeae6dd0c795f5295","6ecd298fdc085e7eba27afa7fae58df1ba1a2808"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["16843358872ed92ba92888ab99df297550b9a36a"],"6ecd298fdc085e7eba27afa7fae58df1ba1a2808":["29ef99d61cda9641b6250bf9567329a6e65f901d","16843358872ed92ba92888ab99df297550b9a36a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","16843358872ed92ba92888ab99df297550b9a36a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}