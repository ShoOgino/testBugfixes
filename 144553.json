{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}