{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","commits":[{"id":"e0533284bccacfa05d7087da7a815efed9d20212","date":1342444866,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b64a4420c88dd81303e7f7959057baf9f3b45f94","date":1346077333,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2208f43a9be2ac423812bb93060ad3f37910b24","date":1395263322,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.shutdown();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.shutdown();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.shutdown();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.shutdown();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80c55596a764e2d397e982828e75fcac5ce430a0","date":1413987559,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new FixedBitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new FixedBitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new FixedBitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new FixedBitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b012914a8110b2ff1d075ed1ef72aa57084d4897","date":1414685177,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n            final int docBase = context.docBase;\n            final LeafCollector in = topScoreDocCollector.getLeafCollector(context);\n            return new FilterLeafCollector(in) {\n\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                actualResult.set(doc + docBase);\n              }\n              \n              @Override\n              public boolean acceptsDocsOutOfOrder() {\n                return scoreDocsInOrder;\n              }\n            };\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new SimpleCollector() {\n\n          int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.getLeafCollector(context);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return scoreDocsInOrder;\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n            final int docBase = context.docBase;\n            final LeafCollector in = topScoreDocCollector.getLeafCollector(context);\n            return new FilterLeafCollector(in) {\n\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                actualResult.set(doc + docBase);\n              }\n            };\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      final boolean scoreDocsInOrder = TestJoinUtil.random().nextBoolean();\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, scoreDocsInOrder);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n            final int docBase = context.docBase;\n            final LeafCollector in = topScoreDocCollector.getLeafCollector(context);\n            return new FilterLeafCollector(in) {\n\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                actualResult.set(doc + docBase);\n              }\n              \n              @Override\n              public boolean acceptsDocsOutOfOrder() {\n                return scoreDocsInOrder;\n              }\n            };\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n            final int docBase = context.docBase;\n            final LeafCollector in = topScoreDocCollector.getLeafCollector(context);\n            return new FilterLeafCollector(in) {\n\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                actualResult.set(doc + docBase);\n              }\n            };\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return topScoreDocCollector.needsScores();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n            final int docBase = context.docBase;\n            final LeafCollector in = topScoreDocCollector.getLeafCollector(context);\n            return new FilterLeafCollector(in) {\n\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                actualResult.set(doc + docBase);\n              }\n            };\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9359ad4a5596673c3154ffa1133458f00e124234","date":1428012026,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, false);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n            final int docBase = context.docBase;\n            final LeafCollector in = topScoreDocCollector.getLeafCollector(context);\n            return new FilterLeafCollector(in) {\n\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                actualResult.set(doc + docBase);\n              }\n            };\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return topScoreDocCollector.needsScores();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, false);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n            final int docBase = context.docBase;\n            final LeafCollector in = topScoreDocCollector.getLeafCollector(context);\n            return new FilterLeafCollector(in) {\n\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                actualResult.set(doc + docBase);\n              }\n            };\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return topScoreDocCollector.needsScores();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = new BitSetIterator(expectedResult, expectedResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = new BitSetIterator(actualResult, actualResult.cardinality());\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(Locale.ENGLISH, \"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(Locale.ENGLISH, \"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8376c8b9c659015b6e2a23a8c7275ea203eeef3","date":1428508284,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument, false);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","3cd7782b032787117c986a2278d05b25056b2eba","d0ef034a4f10871667ae75181537775ddcf8ade4","9359ad4a5596673c3154ffa1133458f00e124234","54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10","date":1449514606,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals \n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\"; \n          final String toField = from ? \"to\":\"from\"; \n          \n          if (random().nextBoolean()) { // numbers\n            final NumericType numType = random().nextBoolean() ? NumericType.INT: NumericType.LONG ;\n            joinQuery = JoinUtil.createJoinQuery(fromField+numType, muliValsQuery, toField+numType, numType, actualQuery, indexSearcher, scoreMode);\n          } else {\n            joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals \n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\"; \n          final String toField = from ? \"to\":\"from\"; \n          \n          if (random().nextBoolean()) { // numbers\n            final LegacyNumericType numType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n            joinQuery = JoinUtil.createJoinQuery(fromField+numType, muliValsQuery, toField+numType, numType, actualQuery, indexSearcher, scoreMode);\n          } else {\n            joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals \n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\"; \n          final String toField = from ? \"to\":\"from\"; \n          \n          if (random().nextBoolean()) { // numbers\n            final NumericType numType = random().nextBoolean() ? NumericType.INT: NumericType.LONG ;\n            joinQuery = JoinUtil.createJoinQuery(fromField+numType, muliValsQuery, toField+numType, numType, actualQuery, indexSearcher, scoreMode);\n          } else {\n            joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0a97513a3a796fa8e709a0dcfec8a2e628e721b","date":1458922983,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals \n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\"; \n          final String toField = from ? \"to\":\"from\"; \n\n          int surpriseMe = random().nextInt(3);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              final LegacyNumericType legacyNumType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n              joinQuery = JoinUtil.createJoinQuery(fromField+legacyNumType, muliValsQuery, toField+legacyNumType, legacyNumType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 2:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals \n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\"; \n          final String toField = from ? \"to\":\"from\"; \n          \n          if (random().nextBoolean()) { // numbers\n            final LegacyNumericType numType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n            joinQuery = JoinUtil.createJoinQuery(fromField+numType, muliValsQuery, toField+numType, numType, actualQuery, indexSearcher, scoreMode);\n          } else {\n            joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":["770342641f7b505eaa8dccdc666158bff2419109","af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"bugIntro":["50b8410419cbbe9d8e1a96c918a951976bffe680"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(3);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              final LegacyNumericType legacyNumType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n              joinQuery = JoinUtil.createJoinQuery(fromField+legacyNumType, muliValsQuery, toField+legacyNumType, legacyNumType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 2:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals \n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\"; \n          final String toField = from ? \"to\":\"from\"; \n\n          int surpriseMe = random().nextInt(3);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              final LegacyNumericType legacyNumType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n              joinQuery = JoinUtil.createJoinQuery(fromField+legacyNumType, muliValsQuery, toField+legacyNumType, legacyNumType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 2:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50b8410419cbbe9d8e1a96c918a951976bffe680","date":1471869553,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(3);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              final LegacyNumericType legacyNumType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n              joinQuery = JoinUtil.createJoinQuery(fromField+legacyNumType, muliValsQuery, toField+legacyNumType, legacyNumType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 2:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c82557b0a8c9d4012f208e5de912ae7500ea351","date":1471888093,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(3);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              final LegacyNumericType legacyNumType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n              joinQuery = JoinUtil.createJoinQuery(fromField+legacyNumType, muliValsQuery, toField+legacyNumType, legacyNumType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 2:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(3);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              final LegacyNumericType legacyNumType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n              joinQuery = JoinUtil.createJoinQuery(fromField+legacyNumType, muliValsQuery, toField+legacyNumType, legacyNumType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 2:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals \n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\"; \n          final String toField = from ? \"to\":\"from\"; \n\n          int surpriseMe = random().nextInt(3);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              final LegacyNumericType legacyNumType = random().nextBoolean() ? LegacyNumericType.INT: LegacyNumericType.LONG ;\n              joinQuery = JoinUtil.createJoinQuery(fromField+legacyNumType, muliValsQuery, toField+legacyNumType, legacyNumType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 2:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: indexIter=\" + indexIter + \" numDocs=\" + numberOfDocumentsToIndex);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      if (VERBOSE) {\n        System.out.println(\"TEST: got searcher=\" + indexSearcher);\n      }\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: indexIter=\" + indexIter + \" numDocs=\" + numberOfDocumentsToIndex);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      if (VERBOSE) {\n        System.out.println(\"TEST: got searcher=\" + indexSearcher);\n      }\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: indexIter=\" + indexIter + \" numDocs=\" + numberOfDocumentsToIndex);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      if (VERBOSE) {\n        System.out.println(\"TEST: got searcher=\" + indexSearcher);\n      }\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: indexIter=\" + indexIter + \" numDocs=\" + numberOfDocumentsToIndex);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      if (VERBOSE) {\n        System.out.println(\"TEST: got searcher=\" + indexSearcher);\n      }\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, Integer.MAX_VALUE);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: indexIter=\" + indexIter + \" numDocs=\" + numberOfDocumentsToIndex);\n      }\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, multipleValuesPerDocument, false);\n      IndexSearcher indexSearcher = context.searcher;\n      if (VERBOSE) {\n        System.out.println(\"TEST: got searcher=\" + indexSearcher);\n      }\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        BitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        {\n          // single val can be handled by multiple-vals\n          final boolean muliValsQuery = multipleValuesPerDocument || random().nextBoolean();\n          final String fromField = from ? \"from\":\"to\";\n          final String toField = from ? \"to\":\"from\";\n\n          int surpriseMe = random().nextInt(2);\n          switch (surpriseMe) {\n            case 0:\n              Class<? extends Number> numType;\n              String suffix;\n              if (random().nextBoolean()) {\n                numType = Integer.class;\n                suffix = \"INT\";\n              } else if (random().nextBoolean()) {\n                numType = Float.class;\n                suffix = \"FLOAT\";\n              } else if (random().nextBoolean()) {\n                numType = Long.class;\n                suffix = \"LONG\";\n              } else {\n                numType = Double.class;\n                suffix = \"DOUBLE\";\n              }\n              joinQuery = JoinUtil.createJoinQuery(fromField + suffix, muliValsQuery, toField + suffix, numType, actualQuery, indexSearcher, scoreMode);\n              break;\n            case 1:\n              joinQuery = JoinUtil.createJoinQuery(fromField, muliValsQuery, toField, actualQuery, indexSearcher, scoreMode);\n              break;\n            default:\n              throw new RuntimeException(\"unexpected value \" + surpriseMe);\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final BitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10);\n        indexSearcher.search(joinQuery, MultiCollector.wrap(new BitSetCollector(actualResult), topScoreDocCollector));\n        // Asserting bit set...\n        assertBitSet(expectedResult, actualResult, indexSearcher);\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertTopDocs(expectedTopDocs, actualTopDocs, scoreMode, indexSearcher, joinQuery);\n      }\n      context.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b64a4420c88dd81303e7f7959057baf9f3b45f94","7530de27b87b961b51f01bd1299b7004d46e8823"],"e0533284bccacfa05d7087da7a815efed9d20212":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9359ad4a5596673c3154ffa1133458f00e124234":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"b012914a8110b2ff1d075ed1ef72aa57084d4897":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"0c82557b0a8c9d4012f208e5de912ae7500ea351":["0e7bc21595222ae4f75509300fbb7726691f387f","50b8410419cbbe9d8e1a96c918a951976bffe680"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e0533284bccacfa05d7087da7a815efed9d20212"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["b2208f43a9be2ac423812bb93060ad3f37910b24","ae73da626f97850c922c42736f808d0378e165f0"],"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["781239fc84d36be12b84e4d3e2618f5f07a182e3","9359ad4a5596673c3154ffa1133458f00e124234"],"80c55596a764e2d397e982828e75fcac5ce430a0":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["ae73da626f97850c922c42736f808d0378e165f0"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["0e7bc21595222ae4f75509300fbb7726691f387f","0c82557b0a8c9d4012f208e5de912ae7500ea351"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["28288370235ed02234a64753cdbf0c6ec096304a"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"50b8410419cbbe9d8e1a96c918a951976bffe680":["0e7bc21595222ae4f75509300fbb7726691f387f"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"b2208f43a9be2ac423812bb93060ad3f37910b24":["7530de27b87b961b51f01bd1299b7004d46e8823"],"901e951cec2e6af4e503209a6721c8834db23279":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["aba371508186796cc6151d8223a5b4e16d02e26e","b64a4420c88dd81303e7f7959057baf9f3b45f94"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"770342641f7b505eaa8dccdc666158bff2419109":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"28288370235ed02234a64753cdbf0c6ec096304a":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"c8376c8b9c659015b6e2a23a8c7275ea203eeef3":["9359ad4a5596673c3154ffa1133458f00e124234"],"b64a4420c88dd81303e7f7959057baf9f3b45f94":["e0533284bccacfa05d7087da7a815efed9d20212"],"a0a97513a3a796fa8e709a0dcfec8a2e628e721b":["770342641f7b505eaa8dccdc666158bff2419109"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["901e951cec2e6af4e503209a6721c8834db23279"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e0533284bccacfa05d7087da7a815efed9d20212"],"0e7bc21595222ae4f75509300fbb7726691f387f":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae73da626f97850c922c42736f808d0378e165f0":["b2208f43a9be2ac423812bb93060ad3f37910b24"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["80c55596a764e2d397e982828e75fcac5ce430a0"],"7530de27b87b961b51f01bd1299b7004d46e8823":["b64a4420c88dd81303e7f7959057baf9f3b45f94"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fe3c6364bed04a73ad0884b05401d80ce96027a9"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"e0533284bccacfa05d7087da7a815efed9d20212":["aba371508186796cc6151d8223a5b4e16d02e26e","b64a4420c88dd81303e7f7959057baf9f3b45f94","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"9359ad4a5596673c3154ffa1133458f00e124234":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"b012914a8110b2ff1d075ed1ef72aa57084d4897":["901e951cec2e6af4e503209a6721c8834db23279"],"0c82557b0a8c9d4012f208e5de912ae7500ea351":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["80c55596a764e2d397e982828e75fcac5ce430a0"],"aba371508186796cc6151d8223a5b4e16d02e26e":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e0533284bccacfa05d7087da7a815efed9d20212","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10":["770342641f7b505eaa8dccdc666158bff2419109"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"80c55596a764e2d397e982828e75fcac5ce430a0":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"50b8410419cbbe9d8e1a96c918a951976bffe680":["0c82557b0a8c9d4012f208e5de912ae7500ea351"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["9359ad4a5596673c3154ffa1133458f00e124234","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"b2208f43a9be2ac423812bb93060ad3f37910b24":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"901e951cec2e6af4e503209a6721c8834db23279":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"770342641f7b505eaa8dccdc666158bff2419109":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"b64a4420c88dd81303e7f7959057baf9f3b45f94":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","05a14b2611ead08655a2b2bdc61632eb31316e57","7530de27b87b961b51f01bd1299b7004d46e8823"],"c8376c8b9c659015b6e2a23a8c7275ea203eeef3":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"a0a97513a3a796fa8e709a0dcfec8a2e628e721b":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"0e7bc21595222ae4f75509300fbb7726691f387f":["0c82557b0a8c9d4012f208e5de912ae7500ea351","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","50b8410419cbbe9d8e1a96c918a951976bffe680"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ae73da626f97850c922c42736f808d0378e165f0":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b2208f43a9be2ac423812bb93060ad3f37910b24"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","15e323346eac5e4685c0a9f2df85eb96b4239bbb","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","05a14b2611ead08655a2b2bdc61632eb31316e57","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}