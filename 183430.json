{"path":"lucene/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","commits":[{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      final int code = _TestUtil.nextInt(r, startCode, endCode);\n      if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n          (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n        iter--;\n        continue;\n      }\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d90f6725e0dcb9d05a0953b2d96c8642684d57ef"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d90f6725e0dcb9d05a0953b2d96c8642684d57ef","date":1280179847,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","sourceNew":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    final int nonSurrogateCount;\n    final boolean ovSurStart;\n    if (endCode < UnicodeUtil.UNI_SUR_HIGH_START ||\n        startCode > UnicodeUtil.UNI_SUR_LOW_END) {\n      // no overlap w/ surrogates\n      nonSurrogateCount = endCode - startCode + 1;\n      ovSurStart = false;\n    } else if (isSurrogate(startCode)) {\n      // start of range overlaps surrogates\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - startCode + 1);\n      ovSurStart = false;\n    } else if (isSurrogate(endCode)) {\n      // end of range overlaps surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (endCode - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    } else {\n      // range completely subsumes surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    }\n\n    assert nonSurrogateCount > 0;\n        \n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      int code = startCode + r.nextInt(nonSurrogateCount);\n      if (isSurrogate(code)) {\n        if (ovSurStart) {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - UnicodeUtil.UNI_SUR_HIGH_START);\n        } else {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - startCode);\n        }\n      }\n\n      assert code >= startCode && code <= endCode: \"code=\" + code + \" start=\" + startCode + \" end=\" + endCode;\n      assert !isSurrogate(code);\n\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","sourceOld":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      final int code = _TestUtil.nextInt(r, startCode, endCode);\n      if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n          (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n        iter--;\n        continue;\n      }\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","bugFix":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","sourceNew":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    final int nonSurrogateCount;\n    final boolean ovSurStart;\n    if (endCode < UnicodeUtil.UNI_SUR_HIGH_START ||\n        startCode > UnicodeUtil.UNI_SUR_LOW_END) {\n      // no overlap w/ surrogates\n      nonSurrogateCount = endCode - startCode + 1;\n      ovSurStart = false;\n    } else if (isSurrogate(startCode)) {\n      // start of range overlaps surrogates\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - startCode + 1);\n      ovSurStart = false;\n    } else if (isSurrogate(endCode)) {\n      // end of range overlaps surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (endCode - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    } else {\n      // range completely subsumes surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    }\n\n    assert nonSurrogateCount > 0;\n        \n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      int code = startCode + r.nextInt(nonSurrogateCount);\n      if (isSurrogate(code)) {\n        if (ovSurStart) {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - UnicodeUtil.UNI_SUR_HIGH_START);\n        } else {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - startCode);\n        }\n      }\n\n      assert code >= startCode && code <= endCode: \"code=\" + code + \" start=\" + startCode + \" end=\" + endCode;\n      assert !isSurrogate(code);\n\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","sourceOld":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      final int code = _TestUtil.nextInt(r, startCode, endCode);\n      if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n          (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n        iter--;\n        continue;\n      }\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","sourceNew":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    final int nonSurrogateCount;\n    final boolean ovSurStart;\n    if (endCode < UnicodeUtil.UNI_SUR_HIGH_START ||\n        startCode > UnicodeUtil.UNI_SUR_LOW_END) {\n      // no overlap w/ surrogates\n      nonSurrogateCount = endCode - startCode + 1;\n      ovSurStart = false;\n    } else if (isSurrogate(startCode)) {\n      // start of range overlaps surrogates\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - startCode + 1);\n      ovSurStart = false;\n    } else if (isSurrogate(endCode)) {\n      // end of range overlaps surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (endCode - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    } else {\n      // range completely subsumes surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    }\n\n    assert nonSurrogateCount > 0;\n        \n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      int code = startCode + r.nextInt(nonSurrogateCount);\n      if (isSurrogate(code)) {\n        if (ovSurStart) {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - UnicodeUtil.UNI_SUR_HIGH_START);\n        } else {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - startCode);\n        }\n      }\n\n      assert code >= startCode && code <= endCode: \"code=\" + code + \" start=\" + startCode + \" end=\" + endCode;\n      assert !isSurrogate(code);\n\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","sourceOld":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    final int nonSurrogateCount;\n    final boolean ovSurStart;\n    if (endCode < UnicodeUtil.UNI_SUR_HIGH_START ||\n        startCode > UnicodeUtil.UNI_SUR_LOW_END) {\n      // no overlap w/ surrogates\n      nonSurrogateCount = endCode - startCode + 1;\n      ovSurStart = false;\n    } else if (isSurrogate(startCode)) {\n      // start of range overlaps surrogates\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - startCode + 1);\n      ovSurStart = false;\n    } else if (isSurrogate(endCode)) {\n      // end of range overlaps surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (endCode - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    } else {\n      // range completely subsumes surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    }\n\n    assert nonSurrogateCount > 0;\n        \n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      int code = startCode + r.nextInt(nonSurrogateCount);\n      if (isSurrogate(code)) {\n        if (ovSurStart) {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - UnicodeUtil.UNI_SUR_HIGH_START);\n        } else {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - startCode);\n        }\n      }\n\n      assert code >= startCode && code <= endCode: \"code=\" + code + \" start=\" + startCode + \" end=\" + endCode;\n      assert !isSurrogate(code);\n\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3242a09f703274d3b9283f2064a1a33064b53a1b":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","d90f6725e0dcb9d05a0953b2d96c8642684d57ef"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d90f6725e0dcb9d05a0953b2d96c8642684d57ef"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d90f6725e0dcb9d05a0953b2d96c8642684d57ef":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3242a09f703274d3b9283f2064a1a33064b53a1b":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["3242a09f703274d3b9283f2064a1a33064b53a1b","d90f6725e0dcb9d05a0953b2d96c8642684d57ef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"d90f6725e0dcb9d05a0953b2d96c8642684d57ef":["3242a09f703274d3b9283f2064a1a33064b53a1b","3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3242a09f703274d3b9283f2064a1a33064b53a1b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}