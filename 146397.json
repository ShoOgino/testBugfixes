{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterAbort#testBasics().mjava","commits":[{"id":"4ec6b9b0b65e94f26d4e4b6eb93c1fd17c3a7480","date":1417331153,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterAbort#testBasics().mjava","pathOld":"/dev/null","sourceNew":"  // just one thread, serial merge policy, hopefully debuggable\n  public void testBasics() throws Exception {\n    // use an explicit RAMDirectory, we will act-like windows,\n    // but no virus scanner (real or fake).\n    // TODO: use MDW's check instead of TestIW.assertNoUnreferencedFiles,\n    // then turn it all back on\n\n    MockDirectoryWrapper dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n    dir.setEnableVirusScanner(false); // assert that we actually delete files.\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    // wrap the actual codec with one that throws random exceptions\n    Codec codec = new CrankyCodec(Codec.getDefault(), new Random(random().nextLong()));\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(codec);\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      for (int i = 0; i < numDocs; i++) {\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"dv\", i));\n        doc.add(new BinaryDocValuesField(\"dv2\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedDocValuesField(\"dv3\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedSetDocValuesField(\"dv4\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedSetDocValuesField(\"dv4\", new BytesRef(Integer.toString(i-1))));\n        doc.add(new SortedNumericDocValuesField(\"dv5\", i));\n        doc.add(new SortedNumericDocValuesField(\"dv5\", i-1));\n        doc.add(newTextField(\"text1\", TestUtil.randomAnalysisString(random(), 20, true), Field.Store.NO));\n        // ensure we store something\n        doc.add(new StoredField(\"stored1\", \"foo\"));\n        doc.add(new StoredField(\"stored1\", \"bar\"));    \n        // ensure we get some payloads\n        doc.add(newTextField(\"text_payloads\", TestUtil.randomAnalysisString(random(), 6, true), Field.Store.NO));\n        // ensure we get some vectors\n        FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n        ft.setStoreTermVectors(true);\n        doc.add(newField(\"text_vectors\", TestUtil.randomAnalysisString(random(), 6, true), ft));\n        \n        if (random().nextInt(10) > 0) {\n          // single doc\n          try {\n            iw.addDocument(doc);\n            // we made it, sometimes delete our doc, or update a dv\n            int thingToDo = random().nextInt(4);\n            if (thingToDo == 0) {\n              iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n            } else if (thingToDo == 1) {\n              iw.updateNumericDocValue(new Term(\"id\", Integer.toString(i)), \"dv\", i+1L);\n            } else if (thingToDo == 2) {\n              iw.updateBinaryDocValue(new Term(\"id\", Integer.toString(i)), \"dv2\", new BytesRef(Integer.toString(i+1)));\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        } else {\n          // block docs\n          Document doc2 = new Document();\n          doc2.add(newStringField(\"id\", Integer.toString(-i), Field.Store.NO));\n          doc2.add(newTextField(\"text1\", TestUtil.randomAnalysisString(random(), 20, true), Field.Store.NO));\n          doc2.add(new StoredField(\"stored1\", \"foo\"));\n          doc2.add(new StoredField(\"stored1\", \"bar\"));\n          doc2.add(newField(\"text_vectors\", TestUtil.randomAnalysisString(random(), 6, true), ft));\n          \n          try {\n            iw.addDocuments(Arrays.asList(doc, doc2));\n            // we made it, sometimes delete our docs\n            if (random().nextBoolean()) {\n              iw.deleteDocuments(new Term(\"id\", Integer.toString(i)), new Term(\"id\", Integer.toString(-i)));\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean());\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              iw.commit();\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      \n      // test that there are no unreferenced files: any deletes we make should have succeeded\n      // TODO: don't use this method, use the MDW one!!!!\n      TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after close()\");\n      // checkindex\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be6aabb5c9c1802022d502b0713268404e22153f","date":1417331463,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterAbort#testBasics().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterAbort#testBasics().mjava","sourceNew":"  // just one thread, serial merge policy, hopefully debuggable\n  public void testBasics() throws Exception {\n    // use an explicit RAMDirectory, we will act-like windows,\n    // but no virus scanner (real or fake).\n    // TODO: use MDW's check instead of TestIW.assertNoUnreferencedFiles,\n    // then turn it all back on\n\n    MockDirectoryWrapper dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n    dir.setEnableVirusScanner(false); // assert that we actually delete files.\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    // wrap the actual codec with one that throws random exceptions\n    Codec codec = new CrankyCodec(Codec.getDefault(), new Random(random().nextLong()));\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(codec);\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      for (int i = 0; i < numDocs; i++) {\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"dv\", i));\n        doc.add(new BinaryDocValuesField(\"dv2\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedDocValuesField(\"dv3\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedSetDocValuesField(\"dv4\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedSetDocValuesField(\"dv4\", new BytesRef(Integer.toString(i-1))));\n        doc.add(new SortedNumericDocValuesField(\"dv5\", i));\n        doc.add(new SortedNumericDocValuesField(\"dv5\", i-1));\n        doc.add(newTextField(\"text1\", TestUtil.randomAnalysisString(random(), 20, true), Field.Store.NO));\n        // ensure we store something\n        doc.add(new StoredField(\"stored1\", \"foo\"));\n        doc.add(new StoredField(\"stored1\", \"bar\"));    \n        // ensure we get some payloads\n        doc.add(newTextField(\"text_payloads\", TestUtil.randomAnalysisString(random(), 6, true), Field.Store.NO));\n        // ensure we get some vectors\n        FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n        ft.setStoreTermVectors(true);\n        doc.add(newField(\"text_vectors\", TestUtil.randomAnalysisString(random(), 6, true), ft));\n        \n        if (random().nextInt(10) > 0) {\n          // single doc\n          try {\n            iw.addDocument(doc);\n            // we made it, sometimes delete our doc, or update a dv\n            int thingToDo = random().nextInt(4);\n            if (thingToDo == 0) {\n              iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n            } else if (thingToDo == 1) {\n              iw.updateNumericDocValue(new Term(\"id\", Integer.toString(i)), \"dv\", i+1L);\n            } else if (thingToDo == 2) {\n              iw.updateBinaryDocValue(new Term(\"id\", Integer.toString(i)), \"dv2\", new BytesRef(Integer.toString(i+1)));\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        } else {\n          // block docs\n          Document doc2 = new Document();\n          doc2.add(newStringField(\"id\", Integer.toString(-i), Field.Store.NO));\n          doc2.add(newTextField(\"text1\", TestUtil.randomAnalysisString(random(), 20, true), Field.Store.NO));\n          doc2.add(new StoredField(\"stored1\", \"foo\"));\n          doc2.add(new StoredField(\"stored1\", \"bar\"));\n          doc2.add(newField(\"text_vectors\", TestUtil.randomAnalysisString(random(), 6, true), ft));\n          \n          try {\n            iw.addDocuments(Arrays.asList(doc, doc2));\n            // we made it, sometimes delete our docs\n            if (random().nextBoolean()) {\n              iw.deleteDocuments(new Term(\"id\", Integer.toString(i)), new Term(\"id\", Integer.toString(-i)));\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean());\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              iw.commit();\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      \n      // test that there are no unreferenced files: any deletes we make should have succeeded\n      // TODO: don't use this method, use the MDW one!!!!\n      TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after close()\");\n      // checkindex\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  // just one thread, serial merge policy, hopefully debuggable\n  public void testBasics() throws Exception {\n    // use an explicit RAMDirectory, we will act-like windows,\n    // but no virus scanner (real or fake).\n    // TODO: use MDW's check instead of TestIW.assertNoUnreferencedFiles,\n    // then turn it all back on\n\n    MockDirectoryWrapper dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n    dir.setEnableVirusScanner(false); // assert that we actually delete files.\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    // wrap the actual codec with one that throws random exceptions\n    Codec codec = new CrankyCodec(Codec.getDefault(), new Random(random().nextLong()));\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(codec);\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      for (int i = 0; i < numDocs; i++) {\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"dv\", i));\n        doc.add(new BinaryDocValuesField(\"dv2\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedDocValuesField(\"dv3\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedSetDocValuesField(\"dv4\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedSetDocValuesField(\"dv4\", new BytesRef(Integer.toString(i-1))));\n        doc.add(new SortedNumericDocValuesField(\"dv5\", i));\n        doc.add(new SortedNumericDocValuesField(\"dv5\", i-1));\n        doc.add(newTextField(\"text1\", TestUtil.randomAnalysisString(random(), 20, true), Field.Store.NO));\n        // ensure we store something\n        doc.add(new StoredField(\"stored1\", \"foo\"));\n        doc.add(new StoredField(\"stored1\", \"bar\"));    \n        // ensure we get some payloads\n        doc.add(newTextField(\"text_payloads\", TestUtil.randomAnalysisString(random(), 6, true), Field.Store.NO));\n        // ensure we get some vectors\n        FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n        ft.setStoreTermVectors(true);\n        doc.add(newField(\"text_vectors\", TestUtil.randomAnalysisString(random(), 6, true), ft));\n        \n        if (random().nextInt(10) > 0) {\n          // single doc\n          try {\n            iw.addDocument(doc);\n            // we made it, sometimes delete our doc, or update a dv\n            int thingToDo = random().nextInt(4);\n            if (thingToDo == 0) {\n              iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n            } else if (thingToDo == 1) {\n              iw.updateNumericDocValue(new Term(\"id\", Integer.toString(i)), \"dv\", i+1L);\n            } else if (thingToDo == 2) {\n              iw.updateBinaryDocValue(new Term(\"id\", Integer.toString(i)), \"dv2\", new BytesRef(Integer.toString(i+1)));\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        } else {\n          // block docs\n          Document doc2 = new Document();\n          doc2.add(newStringField(\"id\", Integer.toString(-i), Field.Store.NO));\n          doc2.add(newTextField(\"text1\", TestUtil.randomAnalysisString(random(), 20, true), Field.Store.NO));\n          doc2.add(new StoredField(\"stored1\", \"foo\"));\n          doc2.add(new StoredField(\"stored1\", \"bar\"));\n          doc2.add(newField(\"text_vectors\", TestUtil.randomAnalysisString(random(), 6, true), ft));\n          \n          try {\n            iw.addDocuments(Arrays.asList(doc, doc2));\n            // we made it, sometimes delete our docs\n            if (random().nextBoolean()) {\n              iw.deleteDocuments(new Term(\"id\", Integer.toString(i)), new Term(\"id\", Integer.toString(-i)));\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean());\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              iw.commit();\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      \n      // test that there are no unreferenced files: any deletes we make should have succeeded\n      // TODO: don't use this method, use the MDW one!!!!\n      TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after close()\");\n      // checkindex\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterAbort#testBasics().mjava","sourceNew":null,"sourceOld":"  // just one thread, serial merge policy, hopefully debuggable\n  public void testBasics() throws Exception {\n    // use an explicit RAMDirectory, we will act-like windows,\n    // but no virus scanner (real or fake).\n    // TODO: use MDW's check instead of TestIW.assertNoUnreferencedFiles,\n    // then turn it all back on\n\n    MockDirectoryWrapper dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n    dir.setEnableVirusScanner(false); // assert that we actually delete files.\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    // wrap the actual codec with one that throws random exceptions\n    Codec codec = new CrankyCodec(Codec.getDefault(), new Random(random().nextLong()));\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(codec);\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      for (int i = 0; i < numDocs; i++) {\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"dv\", i));\n        doc.add(new BinaryDocValuesField(\"dv2\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedDocValuesField(\"dv3\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedSetDocValuesField(\"dv4\", new BytesRef(Integer.toString(i))));\n        doc.add(new SortedSetDocValuesField(\"dv4\", new BytesRef(Integer.toString(i-1))));\n        doc.add(new SortedNumericDocValuesField(\"dv5\", i));\n        doc.add(new SortedNumericDocValuesField(\"dv5\", i-1));\n        doc.add(newTextField(\"text1\", TestUtil.randomAnalysisString(random(), 20, true), Field.Store.NO));\n        // ensure we store something\n        doc.add(new StoredField(\"stored1\", \"foo\"));\n        doc.add(new StoredField(\"stored1\", \"bar\"));    \n        // ensure we get some payloads\n        doc.add(newTextField(\"text_payloads\", TestUtil.randomAnalysisString(random(), 6, true), Field.Store.NO));\n        // ensure we get some vectors\n        FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n        ft.setStoreTermVectors(true);\n        doc.add(newField(\"text_vectors\", TestUtil.randomAnalysisString(random(), 6, true), ft));\n        \n        if (random().nextInt(10) > 0) {\n          // single doc\n          try {\n            iw.addDocument(doc);\n            // we made it, sometimes delete our doc, or update a dv\n            int thingToDo = random().nextInt(4);\n            if (thingToDo == 0) {\n              iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n            } else if (thingToDo == 1) {\n              iw.updateNumericDocValue(new Term(\"id\", Integer.toString(i)), \"dv\", i+1L);\n            } else if (thingToDo == 2) {\n              iw.updateBinaryDocValue(new Term(\"id\", Integer.toString(i)), \"dv2\", new BytesRef(Integer.toString(i+1)));\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        } else {\n          // block docs\n          Document doc2 = new Document();\n          doc2.add(newStringField(\"id\", Integer.toString(-i), Field.Store.NO));\n          doc2.add(newTextField(\"text1\", TestUtil.randomAnalysisString(random(), 20, true), Field.Store.NO));\n          doc2.add(new StoredField(\"stored1\", \"foo\"));\n          doc2.add(new StoredField(\"stored1\", \"bar\"));\n          doc2.add(newField(\"text_vectors\", TestUtil.randomAnalysisString(random(), 6, true), ft));\n          \n          try {\n            iw.addDocuments(Arrays.asList(doc, doc2));\n            // we made it, sometimes delete our docs\n            if (random().nextBoolean()) {\n              iw.deleteDocuments(new Term(\"id\", Integer.toString(i)), new Term(\"id\", Integer.toString(-i)));\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean());\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              iw.commit();\n            }\n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"Fake IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      \n      // test that there are no unreferenced files: any deletes we make should have succeeded\n      // TODO: don't use this method, use the MDW one!!!!\n      TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after close()\");\n      // checkindex\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"be6aabb5c9c1802022d502b0713268404e22153f":["4ec6b9b0b65e94f26d4e4b6eb93c1fd17c3a7480"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["be6aabb5c9c1802022d502b0713268404e22153f"],"4ec6b9b0b65e94f26d4e4b6eb93c1fd17c3a7480":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9299079153fd7895bf3cf6835cf7019af2ba89b3"]},"commit2Childs":{"be6aabb5c9c1802022d502b0713268404e22153f":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4ec6b9b0b65e94f26d4e4b6eb93c1fd17c3a7480"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ec6b9b0b65e94f26d4e4b6eb93c1fd17c3a7480":["be6aabb5c9c1802022d502b0713268404e22153f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}