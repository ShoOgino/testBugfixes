{"path":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","sourceNew":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","sourceNew":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","sourceNew":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.shutdown();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","sourceNew":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.shutdown();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","sourceNew":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      LeafCollector leafCollector = tdc.getLeafCollector(reader.leaves().get(0));\n      assertEquals(!inOrder[i], leafCollector.acceptsDocsOutOfOrder());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    String[] actualTSDCClass = new String[] {\n        \"OutOfOrderTopScoreDocCollector\", \n        \"InOrderTopScoreDocCollector\" \n    };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      assertEquals(\"org.apache.lucene.search.TopScoreDocCollector$\" + actualTSDCClass[i], tdc.getClass().getName());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopScoreDocCollector#testOutOfOrderCollection().mjava","sourceNew":null,"sourceOld":"  public void testOutOfOrderCollection() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n    for (int i = 0; i < 10; i++) {\n      writer.addDocument(new Document());\n    }\n    \n    boolean[] inOrder = new boolean[] { false, true };\n    \n    BooleanQuery bq = new BooleanQuery();\n    // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n    // which delegates to BS if there are no mandatory clauses.\n    bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n    // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n    // the clause instead of BQ.\n    bq.setMinimumNumberShouldMatch(1);\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    for (int i = 0; i < inOrder.length; i++) {\n      TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(3, inOrder[i]);\n      LeafCollector leafCollector = tdc.getLeafCollector(reader.leaves().get(0));\n      assertEquals(!inOrder[i], leafCollector.acceptsDocsOutOfOrder());\n      \n      searcher.search(new MatchAllDocsQuery(), tdc);\n      \n      ScoreDoc[] sd = tdc.topDocs().scoreDocs;\n      assertEquals(3, sd.length);\n      for (int j = 0; j < sd.length; j++) {\n        assertEquals(\"expected doc Id \" + j + \" found \" + sd[j].doc, j, sd[j].doc);\n      }\n    }\n    writer.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["901e951cec2e6af4e503209a6721c8834db23279"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"901e951cec2e6af4e503209a6721c8834db23279":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"]},"commit2Childs":{"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["901e951cec2e6af4e503209a6721c8834db23279"],"901e951cec2e6af4e503209a6721c8834db23279":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}