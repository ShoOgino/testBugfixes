{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","commits":[{"id":"8b316f82baae88f5e279893a9cb7eee51fd8902f","date":1415131390,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","sourceNew":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min,\n          max);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomaton(automata, automaton_provider),\n            exp2.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","sourceNew":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min,\n          max);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min,\n          max);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","sourceNew":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min,\n          max);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min,\n          max);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54297202372099824b9eb2d6897335b221455496","date":1501840968,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","sourceNew":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minNumStates = (a.getNumStates() - 1) * min;\n        if (minNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minNumStates);\n        }\n        a = Operations.repeat(a, min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minMaxNumStates = (a.getNumStates() - 1) * max;\n        if (minMaxNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minMaxNumStates);\n        }\n        a = Operations.repeat(a, min, max);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min,\n          max);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","sourceNew":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minNumStates = (a.getNumStates() - 1) * min;\n        if (minNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minNumStates);\n        }\n        a = Operations.repeat(a, min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minMaxNumStates = (a.getNumStates() - 1) * max;\n        if (minMaxNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minMaxNumStates);\n        }\n        a = Operations.repeat(a, min, max);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min,\n          max);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"074f544130034fba3e820179fe98defcf2e5c165","date":1589447065,"type":3,"author":"markharwood","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","sourceNew":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_PRE_CLASS:\n        RegExp expanded = expandPredefined();\n        a = expanded.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        break;\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minNumStates = (a.getNumStates() - 1) * min;\n        if (minNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minNumStates);\n        }\n        a = Operations.repeat(a, min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minMaxNumStates = (a.getNumStates() - 1) * max;\n        if (minMaxNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minMaxNumStates);\n        }\n        a = Operations.repeat(a, min, max);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minNumStates = (a.getNumStates() - 1) * min;\n        if (minNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minNumStates);\n        }\n        a = Operations.repeat(a, min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minMaxNumStates = (a.getNumStates() - 1) * max;\n        if (minMaxNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minMaxNumStates);\n        }\n        a = Operations.repeat(a, min, max);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601","date":1594220892,"type":3,"author":"markharwood","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","sourceNew":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_PRE_CLASS:\n        RegExp expanded = expandPredefined();\n        a = expanded.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        break;\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minNumStates = (a.getNumStates() - 1) * min;\n        if (minNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minNumStates);\n        }\n        a = Operations.repeat(a, min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minMaxNumStates = (a.getNumStates() - 1) * max;\n        if (minMaxNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minMaxNumStates);\n        }\n        a = Operations.repeat(a, min, max);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        if (check(ASCII_CASE_INSENSITIVE)) {\n          a = toCaseInsensitiveChar(c, maxDeterminizedStates);\n        } else {\n          a = Automata.makeChar(c);          \n        }\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        if (check(ASCII_CASE_INSENSITIVE)) {\n          a = toCaseInsensitiveString(maxDeterminizedStates);\n        } else {\n          a = Automata.makeString(s);\n        }\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_PRE_CLASS:\n        RegExp expanded = expandPredefined();\n        a = expanded.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        break;\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minNumStates = (a.getNumStates() - 1) * min;\n        if (minNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minNumStates);\n        }\n        a = Operations.repeat(a, min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomatonInternal(automata, automaton_provider, maxDeterminizedStates);\n        int minMaxNumStates = (a.getNumStates() - 1) * max;\n        if (minMaxNumStates > maxDeterminizedStates) {\n          throw new TooComplexToDeterminizeException(a, minMaxNumStates);\n        }\n        a = Operations.repeat(a, min, max);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeDecimalInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"074f544130034fba3e820179fe98defcf2e5c165":["54297202372099824b9eb2d6897335b221455496"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["3e8715d826e588419327562287d5d6a8040d63d6","54297202372099824b9eb2d6897335b221455496"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["8b316f82baae88f5e279893a9cb7eee51fd8902f","3e8715d826e588419327562287d5d6a8040d63d6"],"0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601":["074f544130034fba3e820179fe98defcf2e5c165"],"54297202372099824b9eb2d6897335b221455496":["3e8715d826e588419327562287d5d6a8040d63d6"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3e8715d826e588419327562287d5d6a8040d63d6":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601"]},"commit2Childs":{"074f544130034fba3e820179fe98defcf2e5c165":["0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"54297202372099824b9eb2d6897335b221455496":["074f544130034fba3e820179fe98defcf2e5c165","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","d2638f781be724518ff6c2263d14a48cf6e68017","54297202372099824b9eb2d6897335b221455496"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}