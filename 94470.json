{"path":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(Path,Class[#-extends-LineParser],int,String).mjava","commits":[{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(Path,Class[#-extends-LineParser],int,String).mjava","pathOld":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","sourceNew":"  private void doIndexAndSearchTestWithRepeats(Path file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.toAbsolutePath().toString());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","sourceOld":"  private void doIndexAndSearchTestWithRepeats(File file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.getAbsolutePath());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(Path,Class[#-extends-LineParser],int,String).mjava","pathOld":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(Path,Class[#-extends-LineParser],int,String).mjava","sourceNew":"  private void doIndexAndSearchTestWithRepeats(Path file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.toAbsolutePath().toString());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits.value);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","sourceOld":"  private void doIndexAndSearchTestWithRepeats(Path file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.toAbsolutePath().toString());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(Path,Class[#-extends-LineParser],int,String).mjava","pathOld":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(Path,Class[#-extends-LineParser],int,String).mjava","sourceNew":"  private void doIndexAndSearchTestWithRepeats(Path file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.toAbsolutePath().toString());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"ByteBuffersDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits.value);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","sourceOld":"  private void doIndexAndSearchTestWithRepeats(Path file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.toAbsolutePath().toString());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits.value);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d77dafd89756a5161d244985903e3487ca109182":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["f4abec28b874149a7223e32cc7a01704c27790de"],"f4abec28b874149a7223e32cc7a01704c27790de":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d77dafd89756a5161d244985903e3487ca109182"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f4abec28b874149a7223e32cc7a01704c27790de"],"d77dafd89756a5161d244985903e3487ca109182":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["d77dafd89756a5161d244985903e3487ca109182"],"f4abec28b874149a7223e32cc7a01704c27790de":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}