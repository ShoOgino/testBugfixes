{"path":"src/java/org/apache/solr/util/VersionedFile#getLatestFile(String,String).mjava","commits":[{"id":"5391288921372c32bf6096df320497ad2d05757f","date":1200634221,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/VersionedFile#getLatestFile(String,String).mjava","pathOld":"src/java/org/apache/solr/search/function/FileFloatSource#getLatestFile(String,String).mjava","sourceNew":"  /* Open the latest version of a file... fileName if that exists, or\n   * the last fileName.* after being sorted lexicographically.\n   * Older versions of the file are deleted (and queued for deletion if\n   * that fails).\n   */\n  public static InputStream getLatestFile(String dirName, String fileName) throws FileNotFoundException \n  {\n    Collection<File> oldFiles=null;\n    final String prefix = fileName+'.';\n    File f = new File(dirName, fileName);\n    InputStream is = null;\n\n    // there can be a race between checking for a file and opening it...\n    // the user may have just put a new version in and deleted an old version.\n    // try multiple times in a row.\n    for (int retry=0; retry<10 && is==null; retry++) {\n      try {\n        if (!f.exists()) {\n          File dir = new File(dirName);\n          String[] names = dir.list(new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n              return name.startsWith(prefix);\n            }\n          });\n          Arrays.sort(names);\n          f = new File(dir, names[names.length-1]);\n          oldFiles = new ArrayList<File>();\n          for (int i=0; i<names.length-1; i++) {\n            oldFiles.add(new File(dir, names[i]));\n          }\n        }\n\n        is = new FileInputStream(f);\n      } catch (Exception e) {\n        // swallow exception for now\n      }\n    }\n\n    // allow exception to be thrown from the final try.\n    if (is == null) {\n      is = new FileInputStream(f);\n    }\n\n    // delete old files only after we have successfuly opened the newest\n    if (oldFiles != null) {\n      delete(oldFiles);\n    }\n\n    return is;\n  }\n\n","sourceOld":"  /* Open the latest version of a file... fileName if that exists, or\n   * the last fileName.* after being sorted lexicographically.\n   * Older versions of the file are deleted (and queued for deletion if\n   * that fails).\n   */\n  private static InputStream getLatestFile(String dirName, String fileName) throws FileNotFoundException {\n    Collection<File> oldFiles=null;\n    final String prefix = fileName+'.';\n    File f = new File(dirName, fileName);\n    InputStream is = null;\n\n    // there can be a race between checking for a file and opening it...\n    // the user may have just put a new version in and deleted an old version.\n    // try multiple times in a row.\n    for (int retry=0; retry<10; retry++) {\n      try {\n        if (!f.exists()) {\n          File dir = new File(dirName);\n          String[] names = dir.list(new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n              return name.startsWith(prefix);\n            }\n          });\n          Arrays.sort(names);\n          f = new File(dir, names[names.length-1]);\n          oldFiles = new ArrayList<File>();\n          for (int i=0; i<names.length-1; i++) {\n            oldFiles.add(new File(dir, names[i]));\n          }\n        }\n\n        is = new FileInputStream(f);\n      } catch (Exception e) {\n        // swallow exception for now\n      }\n    }\n\n    // allow exception to be thrown from the final try.\n    is = new FileInputStream(f);\n\n    // delete old files only after we have successfuly opened the newest\n    if (oldFiles != null) {\n      delete(oldFiles);\n    }\n\n    return is;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/util/VersionedFile#getLatestFile(String,String).mjava","pathOld":"src/java/org/apache/solr/util/VersionedFile#getLatestFile(String,String).mjava","sourceNew":"  /* Open the latest version of a file... fileName if that exists, or\n   * the last fileName.* after being sorted lexicographically.\n   * Older versions of the file are deleted (and queued for deletion if\n   * that fails).\n   */\n  public static InputStream getLatestFile(String dirName, String fileName) throws FileNotFoundException \n  {\n    Collection<File> oldFiles=null;\n    final String prefix = fileName+'.';\n    File f = new File(dirName, fileName);\n    InputStream is = null;\n\n    // there can be a race between checking for a file and opening it...\n    // the user may have just put a new version in and deleted an old version.\n    // try multiple times in a row.\n    for (int retry=0; retry<10 && is==null; retry++) {\n      try {\n        if (!f.exists()) {\n          File dir = new File(dirName);\n          String[] names = dir.list(new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n              return name.startsWith(prefix);\n            }\n          });\n          Arrays.sort(names);\n          f = new File(dir, names[names.length-1]);\n          oldFiles = new ArrayList<File>();\n          for (int i=0; i<names.length-1; i++) {\n            oldFiles.add(new File(dir, names[i]));\n          }\n        }\n\n        is = new FileInputStream(f);\n      } catch (Exception e) {\n        // swallow exception for now\n      }\n    }\n\n    // allow exception to be thrown from the final try.\n    if (is == null) {\n      is = new FileInputStream(f);\n    }\n\n    // delete old files only after we have successfuly opened the newest\n    if (oldFiles != null) {\n      delete(oldFiles);\n    }\n\n    return is;\n  }\n\n","sourceOld":"  /* Open the latest version of a file... fileName if that exists, or\n   * the last fileName.* after being sorted lexicographically.\n   * Older versions of the file are deleted (and queued for deletion if\n   * that fails).\n   */\n  public static InputStream getLatestFile(String dirName, String fileName) throws FileNotFoundException \n  {\n    Collection<File> oldFiles=null;\n    final String prefix = fileName+'.';\n    File f = new File(dirName, fileName);\n    InputStream is = null;\n\n    // there can be a race between checking for a file and opening it...\n    // the user may have just put a new version in and deleted an old version.\n    // try multiple times in a row.\n    for (int retry=0; retry<10 && is==null; retry++) {\n      try {\n        if (!f.exists()) {\n          File dir = new File(dirName);\n          String[] names = dir.list(new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n              return name.startsWith(prefix);\n            }\n          });\n          Arrays.sort(names);\n          f = new File(dir, names[names.length-1]);\n          oldFiles = new ArrayList<File>();\n          for (int i=0; i<names.length-1; i++) {\n            oldFiles.add(new File(dir, names[i]));\n          }\n        }\n\n        is = new FileInputStream(f);\n      } catch (Exception e) {\n        // swallow exception for now\n      }\n    }\n\n    // allow exception to be thrown from the final try.\n    if (is == null) {\n      is = new FileInputStream(f);\n    }\n\n    // delete old files only after we have successfuly opened the newest\n    if (oldFiles != null) {\n      delete(oldFiles);\n    }\n\n    return is;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5391288921372c32bf6096df320497ad2d05757f":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["5391288921372c32bf6096df320497ad2d05757f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5391288921372c32bf6096df320497ad2d05757f":["ad94625fb8d088209f46650c8097196fec67f00c"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["5391288921372c32bf6096df320497ad2d05757f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}