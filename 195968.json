{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream#replaceSep(Automaton,boolean,int).mjava","commits":[{"id":"07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a","date":1427495869,"type":0,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream#replaceSep(Automaton,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream#replaceSep(Automaton,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"363efd5f833e8e194f8c9b8a3199eca1bc684c38","date":1435941197,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream#replaceSep(Automaton,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream#replaceSep(Automaton,boolean,int).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a","date":1528168051,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ConcatenateGraphFilter#replaceSep(Automaton,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream#replaceSep(Automaton,boolean,int).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":5,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ConcatenateGraphFilter#replaceSep(Automaton,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream#replaceSep(Automaton,boolean,int).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":5,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ConcatenateGraphFilter#replaceSep(Automaton,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream#replaceSep(Automaton,boolean,int).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private static Automaton replaceSep(Automaton a, boolean preserveSep, int sepLabel) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for (int s = 0; s < numStates; s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for (int i = 0; i < topoSortStates.length; i++) {\n      int state = topoSortStates[topoSortStates.length - 1 - i];\n      int count = a.initTransition(state, t);\n      for (int j = 0; j < count; j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, sepLabel);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"363efd5f833e8e194f8c9b8a3199eca1bc684c38":["07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a"],"07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["363efd5f833e8e194f8c9b8a3199eca1bc684c38","9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a"],"9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a":["363efd5f833e8e194f8c9b8a3199eca1bc684c38"],"f592209545c71895260367152601e9200399776d":["363efd5f833e8e194f8c9b8a3199eca1bc684c38","9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a"]},"commit2Childs":{"363efd5f833e8e194f8c9b8a3199eca1bc684c38":["b70042a8a492f7054d480ccdd2be9796510d4327","9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a","f592209545c71895260367152601e9200399776d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a":["363efd5f833e8e194f8c9b8a3199eca1bc684c38","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"9e45ad199e1b1a4bbc15c1c08dcd73dc08fa927a":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}