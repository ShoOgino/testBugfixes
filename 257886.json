{"path":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#next().mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#next().mjava","sourceNew":"      @Override\n      public BytesRef next() throws IOException {\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n        //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        // }\n\n        nextTerm:\n        while(true) {\n          // Pop finished frames\n          while (currentFrame.nextEnt == currentFrame.entCount) {\n            if (!currentFrame.isLastInFloor) {\n              //if (DEBUG) System.out.println(\"    next-floor-block\");\n              currentFrame.loadNextFloorBlock();\n              //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n            } else {\n              //if (DEBUG) System.out.println(\"  pop frame\");\n              if (currentFrame.ord == 0) {\n                return null;\n              }\n              final long lastFP = currentFrame.fpOrig;\n              currentFrame = stack[currentFrame.ord-1];\n              assert currentFrame.lastSubFP == lastFP;\n              //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n            }\n          }\n\n          final boolean isSubBlock = currentFrame.next();\n          // if (DEBUG) {\n          //   final BytesRef suffixRef = new BytesRef();\n          //   suffixRef.bytes = currentFrame.suffixBytes;\n          //   suffixRef.offset = currentFrame.startBytePos;\n          //   suffixRef.length = currentFrame.suffix;\n          //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n          // }\n\n          if (currentFrame.suffix != 0) {\n            final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n            while (label > currentFrame.curTransitionMax) {\n              if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n                // Stop processing this frame -- no further\n                // matches are possible because we've moved\n                // beyond what the max transition will allow\n                //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n                // sneaky!  forces a pop above\n                currentFrame.isLastInFloor = true;\n                currentFrame.nextEnt = currentFrame.entCount;\n                continue nextTerm;\n              }\n              currentFrame.transitionIndex++;\n              currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n              //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n            }\n          }\n\n          // First test the common suffix, if set:\n          if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n            final int termLen = currentFrame.prefix + currentFrame.suffix;\n            if (termLen < compiledAutomaton.commonSuffixRef.length) {\n              // No match\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix length\");\n              // }\n              continue nextTerm;\n            }\n\n            final byte[] suffixBytes = currentFrame.suffixBytes;\n            final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n            final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n            assert compiledAutomaton.commonSuffixRef.offset == 0;\n            int suffixBytesPos;\n            int commonSuffixBytesPos = 0;\n\n            if (lenInPrefix > 0) {\n              // A prefix of the common suffix overlaps with\n              // the suffix of the block prefix so we first\n              // test whether the prefix part matches:\n              final byte[] termBytes = term.bytes;\n              int termBytesPos = currentFrame.prefix - lenInPrefix;\n              assert termBytesPos >= 0;\n              final int termBytesPosEnd = currentFrame.prefix;\n              while (termBytesPos < termBytesPosEnd) {\n                if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n                  // }\n                  continue nextTerm;\n                }\n              }\n              suffixBytesPos = currentFrame.startBytePos;\n            } else {\n              suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n            }\n\n            // Test overlapping suffix part:\n            final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n            while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n              if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                // if (DEBUG) {\n                //   System.out.println(\"      skip: common suffix mismatch\");\n                // }\n                continue nextTerm;\n              }\n            }\n          }\n\n          // TODO: maybe we should do the same linear test\n          // that AutomatonTermsEnum does, so that if we\n          // reach a part of the automaton where .* is\n          // \"temporarily\" accepted, we just blindly .next()\n          // until the limit\n\n          // See if the term prefix matches the automaton:\n          int state = currentFrame.state;\n          for (int idx=0;idx<currentFrame.suffix;idx++) {\n            state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n            if (state == -1) {\n              // No match\n              //System.out.println(\"    no s=\" + state);\n              continue nextTerm;\n            } else {\n              //System.out.println(\"    c s=\" + state);\n            }\n          }\n\n          if (isSubBlock) {\n            // Match!  Recurse:\n            //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n            copyTerm();\n            currentFrame = pushFrame(state);\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n          } else if (runAutomaton.isAccept(state)) {\n            copyTerm();\n            //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n            assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n            return term;\n          } else {\n            //System.out.println(\"    no s=\" + state);\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public BytesRef next() throws IOException {\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n        //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        // }\n\n        nextTerm:\n        while(true) {\n          // Pop finished frames\n          while (currentFrame.nextEnt == currentFrame.entCount) {\n            if (!currentFrame.isLastInFloor) {\n              //if (DEBUG) System.out.println(\"    next-floor-block\");\n              currentFrame.loadNextFloorBlock();\n              //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n            } else {\n              //if (DEBUG) System.out.println(\"  pop frame\");\n              if (currentFrame.ord == 0) {\n                return null;\n              }\n              final long lastFP = currentFrame.fpOrig;\n              currentFrame = stack[currentFrame.ord-1];\n              assert currentFrame.lastSubFP == lastFP;\n              //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n            }\n          }\n\n          final boolean isSubBlock = currentFrame.next();\n          // if (DEBUG) {\n          //   final BytesRef suffixRef = new BytesRef();\n          //   suffixRef.bytes = currentFrame.suffixBytes;\n          //   suffixRef.offset = currentFrame.startBytePos;\n          //   suffixRef.length = currentFrame.suffix;\n          //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n          // }\n\n          if (currentFrame.suffix != 0) {\n            final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n            while (label > currentFrame.curTransitionMax) {\n              if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n                // Stop processing this frame -- no further\n                // matches are possible because we've moved\n                // beyond what the max transition will allow\n                //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n                // sneaky!  forces a pop above\n                currentFrame.isLastInFloor = true;\n                currentFrame.nextEnt = currentFrame.entCount;\n                continue nextTerm;\n              }\n              currentFrame.transitionIndex++;\n              currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n              //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n            }\n          }\n\n          // First test the common suffix, if set:\n          if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n            final int termLen = currentFrame.prefix + currentFrame.suffix;\n            if (termLen < compiledAutomaton.commonSuffixRef.length) {\n              // No match\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix length\");\n              // }\n              continue nextTerm;\n            }\n\n            final byte[] suffixBytes = currentFrame.suffixBytes;\n            final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n            final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n            assert compiledAutomaton.commonSuffixRef.offset == 0;\n            int suffixBytesPos;\n            int commonSuffixBytesPos = 0;\n\n            if (lenInPrefix > 0) {\n              // A prefix of the common suffix overlaps with\n              // the suffix of the block prefix so we first\n              // test whether the prefix part matches:\n              final byte[] termBytes = term.bytes;\n              int termBytesPos = currentFrame.prefix - lenInPrefix;\n              assert termBytesPos >= 0;\n              final int termBytesPosEnd = currentFrame.prefix;\n              while (termBytesPos < termBytesPosEnd) {\n                if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n                  // }\n                  continue nextTerm;\n                }\n              }\n              suffixBytesPos = currentFrame.startBytePos;\n            } else {\n              suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n            }\n\n            // Test overlapping suffix part:\n            final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n            while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n              if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                // if (DEBUG) {\n                //   System.out.println(\"      skip: common suffix mismatch\");\n                // }\n                continue nextTerm;\n              }\n            }\n          }\n\n          // TODO: maybe we should do the same linear test\n          // that AutomatonTermsEnum does, so that if we\n          // reach a part of the automaton where .* is\n          // \"temporarily\" accepted, we just blindly .next()\n          // until the limit\n\n          // See if the term prefix matches the automaton:\n          int state = currentFrame.state;\n          for (int idx=0;idx<currentFrame.suffix;idx++) {\n            state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n            if (state == -1) {\n              // No match\n              //System.out.println(\"    no s=\" + state);\n              continue nextTerm;\n            } else {\n              //System.out.println(\"    c s=\" + state);\n            }\n          }\n\n          if (isSubBlock) {\n            // Match!  Recurse:\n            //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n            copyTerm();\n            currentFrame = pushFrame(state);\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n          } else if (runAutomaton.isAccept(state)) {\n            copyTerm();\n            //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n            assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n            return term;\n          } else {\n            //System.out.println(\"    no s=\" + state);\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#next().mjava","sourceNew":"      @Override\n      public BytesRef next() throws IOException {\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n        //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        // }\n\n        nextTerm:\n        while(true) {\n          // Pop finished frames\n          while (currentFrame.nextEnt == currentFrame.entCount) {\n            if (!currentFrame.isLastInFloor) {\n              //if (DEBUG) System.out.println(\"    next-floor-block\");\n              currentFrame.loadNextFloorBlock();\n              //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n            } else {\n              //if (DEBUG) System.out.println(\"  pop frame\");\n              if (currentFrame.ord == 0) {\n                return null;\n              }\n              final long lastFP = currentFrame.fpOrig;\n              currentFrame = stack[currentFrame.ord-1];\n              assert currentFrame.lastSubFP == lastFP;\n              //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n            }\n          }\n\n          final boolean isSubBlock = currentFrame.next();\n          // if (DEBUG) {\n          //   final BytesRef suffixRef = new BytesRef();\n          //   suffixRef.bytes = currentFrame.suffixBytes;\n          //   suffixRef.offset = currentFrame.startBytePos;\n          //   suffixRef.length = currentFrame.suffix;\n          //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n          // }\n\n          if (currentFrame.suffix != 0) {\n            final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n            while (label > currentFrame.curTransitionMax) {\n              if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n                // Stop processing this frame -- no further\n                // matches are possible because we've moved\n                // beyond what the max transition will allow\n                //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n                // sneaky!  forces a pop above\n                currentFrame.isLastInFloor = true;\n                currentFrame.nextEnt = currentFrame.entCount;\n                continue nextTerm;\n              }\n              currentFrame.transitionIndex++;\n              currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n              //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n            }\n          }\n\n          // First test the common suffix, if set:\n          if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n            final int termLen = currentFrame.prefix + currentFrame.suffix;\n            if (termLen < compiledAutomaton.commonSuffixRef.length) {\n              // No match\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix length\");\n              // }\n              continue nextTerm;\n            }\n\n            final byte[] suffixBytes = currentFrame.suffixBytes;\n            final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n            final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n            assert compiledAutomaton.commonSuffixRef.offset == 0;\n            int suffixBytesPos;\n            int commonSuffixBytesPos = 0;\n\n            if (lenInPrefix > 0) {\n              // A prefix of the common suffix overlaps with\n              // the suffix of the block prefix so we first\n              // test whether the prefix part matches:\n              final byte[] termBytes = term.bytes;\n              int termBytesPos = currentFrame.prefix - lenInPrefix;\n              assert termBytesPos >= 0;\n              final int termBytesPosEnd = currentFrame.prefix;\n              while (termBytesPos < termBytesPosEnd) {\n                if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n                  // }\n                  continue nextTerm;\n                }\n              }\n              suffixBytesPos = currentFrame.startBytePos;\n            } else {\n              suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n            }\n\n            // Test overlapping suffix part:\n            final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n            while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n              if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                // if (DEBUG) {\n                //   System.out.println(\"      skip: common suffix mismatch\");\n                // }\n                continue nextTerm;\n              }\n            }\n          }\n\n          // TODO: maybe we should do the same linear test\n          // that AutomatonTermsEnum does, so that if we\n          // reach a part of the automaton where .* is\n          // \"temporarily\" accepted, we just blindly .next()\n          // until the limit\n\n          // See if the term prefix matches the automaton:\n          int state = currentFrame.state;\n          for (int idx=0;idx<currentFrame.suffix;idx++) {\n            state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n            if (state == -1) {\n              // No match\n              //System.out.println(\"    no s=\" + state);\n              continue nextTerm;\n            } else {\n              //System.out.println(\"    c s=\" + state);\n            }\n          }\n\n          if (isSubBlock) {\n            // Match!  Recurse:\n            //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n            copyTerm();\n            currentFrame = pushFrame(state);\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n          } else if (runAutomaton.isAccept(state)) {\n            copyTerm();\n            //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n            assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n            return term;\n          } else {\n            //System.out.println(\"    no s=\" + state);\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public BytesRef next() throws IOException {\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n        //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        // }\n\n        nextTerm:\n        while(true) {\n          // Pop finished frames\n          while (currentFrame.nextEnt == currentFrame.entCount) {\n            if (!currentFrame.isLastInFloor) {\n              //if (DEBUG) System.out.println(\"    next-floor-block\");\n              currentFrame.loadNextFloorBlock();\n              //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n            } else {\n              //if (DEBUG) System.out.println(\"  pop frame\");\n              if (currentFrame.ord == 0) {\n                return null;\n              }\n              final long lastFP = currentFrame.fpOrig;\n              currentFrame = stack[currentFrame.ord-1];\n              assert currentFrame.lastSubFP == lastFP;\n              //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n            }\n          }\n\n          final boolean isSubBlock = currentFrame.next();\n          // if (DEBUG) {\n          //   final BytesRef suffixRef = new BytesRef();\n          //   suffixRef.bytes = currentFrame.suffixBytes;\n          //   suffixRef.offset = currentFrame.startBytePos;\n          //   suffixRef.length = currentFrame.suffix;\n          //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n          // }\n\n          if (currentFrame.suffix != 0) {\n            final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n            while (label > currentFrame.curTransitionMax) {\n              if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n                // Stop processing this frame -- no further\n                // matches are possible because we've moved\n                // beyond what the max transition will allow\n                //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n                // sneaky!  forces a pop above\n                currentFrame.isLastInFloor = true;\n                currentFrame.nextEnt = currentFrame.entCount;\n                continue nextTerm;\n              }\n              currentFrame.transitionIndex++;\n              currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n              //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n            }\n          }\n\n          // First test the common suffix, if set:\n          if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n            final int termLen = currentFrame.prefix + currentFrame.suffix;\n            if (termLen < compiledAutomaton.commonSuffixRef.length) {\n              // No match\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix length\");\n              // }\n              continue nextTerm;\n            }\n\n            final byte[] suffixBytes = currentFrame.suffixBytes;\n            final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n            final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n            assert compiledAutomaton.commonSuffixRef.offset == 0;\n            int suffixBytesPos;\n            int commonSuffixBytesPos = 0;\n\n            if (lenInPrefix > 0) {\n              // A prefix of the common suffix overlaps with\n              // the suffix of the block prefix so we first\n              // test whether the prefix part matches:\n              final byte[] termBytes = term.bytes;\n              int termBytesPos = currentFrame.prefix - lenInPrefix;\n              assert termBytesPos >= 0;\n              final int termBytesPosEnd = currentFrame.prefix;\n              while (termBytesPos < termBytesPosEnd) {\n                if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n                  // }\n                  continue nextTerm;\n                }\n              }\n              suffixBytesPos = currentFrame.startBytePos;\n            } else {\n              suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n            }\n\n            // Test overlapping suffix part:\n            final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n            while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n              if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                // if (DEBUG) {\n                //   System.out.println(\"      skip: common suffix mismatch\");\n                // }\n                continue nextTerm;\n              }\n            }\n          }\n\n          // TODO: maybe we should do the same linear test\n          // that AutomatonTermsEnum does, so that if we\n          // reach a part of the automaton where .* is\n          // \"temporarily\" accepted, we just blindly .next()\n          // until the limit\n\n          // See if the term prefix matches the automaton:\n          int state = currentFrame.state;\n          for (int idx=0;idx<currentFrame.suffix;idx++) {\n            state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n            if (state == -1) {\n              // No match\n              //System.out.println(\"    no s=\" + state);\n              continue nextTerm;\n            } else {\n              //System.out.println(\"    c s=\" + state);\n            }\n          }\n\n          if (isSubBlock) {\n            // Match!  Recurse:\n            //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n            copyTerm();\n            currentFrame = pushFrame(state);\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n          } else if (runAutomaton.isAccept(state)) {\n            copyTerm();\n            //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n            assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n            return term;\n          } else {\n            //System.out.println(\"    no s=\" + state);\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}