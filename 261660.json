{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint#newPolygonQuery(String,double[],double[]).mjava","commits":[{"id":"c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b","date":1459439641,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint#newPolygonQuery(String,double[],double[]).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Create a query for matching a polygon.\n   * <p>\n   * The supplied {@code polyLatitudes}/{@code polyLongitudes} must be clockwise or counter-clockwise.\n   * @param field field name. must not be null.\n   * @param polyLatitudes latitude values for points of the polygon: must be within standard +/-90 coordinate bounds.\n   * @param polyLongitudes longitude values for points of the polygon: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this polygon\n   */\n  public static Query newPolygonQuery(final String field, final double[] polyLatitudes, final double[] polyLongitudes) {\n    if (polyLatitudes.length != polyLongitudes.length) {\n      throw new IllegalArgumentException(\"same number of latitudes and longitudes required\");\n    }\n    if (polyLatitudes.length < 4) {\n      throw new IllegalArgumentException(\"need three or more points\");\n    }\n    if (polyLatitudes[0] != polyLatitudes[polyLatitudes.length-1] || polyLongitudes[0] != polyLongitudes[polyLongitudes.length-1]) {\n      throw new IllegalArgumentException(\"last point must equal first point\");\n    }\n    \n    final List<GeoPoint> polyPoints = new ArrayList<>(polyLatitudes.length-1);\n    for (int i = 0; i < polyLatitudes.length-1; i++) {\n      final double latitude = polyLatitudes[i];\n      final double longitude = polyLongitudes[i];\n      checkLatitude(latitude);\n      checkLongitude(longitude);\n      polyPoints.add(new GeoPoint(PlanetModel.WGS84, fromDegrees(latitude), fromDegrees(longitude)));\n    }\n    // We don't know what the sense of the polygon is without providing the index of one vertex we know to be convex.\n    // Since that doesn't fit with the \"super-simple API\" requirements, we just use the index of the first one, and people have to just\n    // know to do it that way.\n    final int convexPointIndex = 0;\n    final GeoShape shape = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, polyPoints, convexPointIndex);\n    return newShapeQuery(field, shape);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40aa98241c87d86a0077beb8023713d93a0becfe","date":1459784560,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint#newPolygonQuery(String,double[],double[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint#newPolygonQuery(String,double[],double[]).mjava","sourceNew":"  /** \n   * Create a query for matching a polygon.\n   * <p>\n   * The supplied {@code polyLatitudes}/{@code polyLongitudes} must be clockwise or counter-clockwise.\n   * @param field field name. must not be null.\n   * @param polyLatitudes latitude values for points of the polygon: must be within standard +/-90 coordinate bounds.\n   * @param polyLongitudes longitude values for points of the polygon: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this polygon\n   */\n  public static Query newPolygonQuery(final String field, final double[] polyLatitudes, final double[] polyLongitudes) {\n    if (polyLatitudes.length != polyLongitudes.length) {\n      throw new IllegalArgumentException(\"same number of latitudes and longitudes required\");\n    }\n    if (polyLatitudes.length < 4) {\n      throw new IllegalArgumentException(\"need three or more points\");\n    }\n    if (polyLatitudes[0] != polyLatitudes[polyLatitudes.length-1] || polyLongitudes[0] != polyLongitudes[polyLongitudes.length-1]) {\n      throw new IllegalArgumentException(\"last point must equal first point\");\n    }\n    \n    final List<GeoPoint> polyPoints = new ArrayList<>(polyLatitudes.length-1);\n    for (int i = 0; i < polyLatitudes.length-1; i++) {\n      final double latitude = polyLatitudes[i];\n      final double longitude = polyLongitudes[i];\n      checkLatitude(latitude);\n      checkLongitude(longitude);\n      polyPoints.add(new GeoPoint(PlanetModel.WGS84, fromDegrees(latitude), fromDegrees(longitude)));\n    }\n    // We use the polygon constructor that looks at point order.\n    final GeoShape shape = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, polyPoints, null);\n    return newShapeQuery(field, shape);\n  }\n\n","sourceOld":"  /** \n   * Create a query for matching a polygon.\n   * <p>\n   * The supplied {@code polyLatitudes}/{@code polyLongitudes} must be clockwise or counter-clockwise.\n   * @param field field name. must not be null.\n   * @param polyLatitudes latitude values for points of the polygon: must be within standard +/-90 coordinate bounds.\n   * @param polyLongitudes longitude values for points of the polygon: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this polygon\n   */\n  public static Query newPolygonQuery(final String field, final double[] polyLatitudes, final double[] polyLongitudes) {\n    if (polyLatitudes.length != polyLongitudes.length) {\n      throw new IllegalArgumentException(\"same number of latitudes and longitudes required\");\n    }\n    if (polyLatitudes.length < 4) {\n      throw new IllegalArgumentException(\"need three or more points\");\n    }\n    if (polyLatitudes[0] != polyLatitudes[polyLatitudes.length-1] || polyLongitudes[0] != polyLongitudes[polyLongitudes.length-1]) {\n      throw new IllegalArgumentException(\"last point must equal first point\");\n    }\n    \n    final List<GeoPoint> polyPoints = new ArrayList<>(polyLatitudes.length-1);\n    for (int i = 0; i < polyLatitudes.length-1; i++) {\n      final double latitude = polyLatitudes[i];\n      final double longitude = polyLongitudes[i];\n      checkLatitude(latitude);\n      checkLongitude(longitude);\n      polyPoints.add(new GeoPoint(PlanetModel.WGS84, fromDegrees(latitude), fromDegrees(longitude)));\n    }\n    // We don't know what the sense of the polygon is without providing the index of one vertex we know to be convex.\n    // Since that doesn't fit with the \"super-simple API\" requirements, we just use the index of the first one, and people have to just\n    // know to do it that way.\n    final int convexPointIndex = 0;\n    final GeoShape shape = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, polyPoints, convexPointIndex);\n    return newShapeQuery(field, shape);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7593e6c5cc33e73fa12f7d1b0035d218d3a36309","date":1459810619,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint#newPolygonQuery(String,double[],double[]).mjava","sourceNew":null,"sourceOld":"  /** \n   * Create a query for matching a polygon.\n   * <p>\n   * The supplied {@code polyLatitudes}/{@code polyLongitudes} must be clockwise or counter-clockwise.\n   * @param field field name. must not be null.\n   * @param polyLatitudes latitude values for points of the polygon: must be within standard +/-90 coordinate bounds.\n   * @param polyLongitudes longitude values for points of the polygon: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this polygon\n   */\n  public static Query newPolygonQuery(final String field, final double[] polyLatitudes, final double[] polyLongitudes) {\n    if (polyLatitudes.length != polyLongitudes.length) {\n      throw new IllegalArgumentException(\"same number of latitudes and longitudes required\");\n    }\n    if (polyLatitudes.length < 4) {\n      throw new IllegalArgumentException(\"need three or more points\");\n    }\n    if (polyLatitudes[0] != polyLatitudes[polyLatitudes.length-1] || polyLongitudes[0] != polyLongitudes[polyLongitudes.length-1]) {\n      throw new IllegalArgumentException(\"last point must equal first point\");\n    }\n    \n    final List<GeoPoint> polyPoints = new ArrayList<>(polyLatitudes.length-1);\n    for (int i = 0; i < polyLatitudes.length-1; i++) {\n      final double latitude = polyLatitudes[i];\n      final double longitude = polyLongitudes[i];\n      checkLatitude(latitude);\n      checkLongitude(longitude);\n      polyPoints.add(new GeoPoint(PlanetModel.WGS84, fromDegrees(latitude), fromDegrees(longitude)));\n    }\n    // We use the polygon constructor that looks at point order.\n    final GeoShape shape = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, polyPoints, null);\n    return newShapeQuery(field, shape);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint#newPolygonQuery(String,double[],double[]).mjava","sourceNew":null,"sourceOld":"  /** \n   * Create a query for matching a polygon.\n   * <p>\n   * The supplied {@code polyLatitudes}/{@code polyLongitudes} must be clockwise or counter-clockwise.\n   * @param field field name. must not be null.\n   * @param polyLatitudes latitude values for points of the polygon: must be within standard +/-90 coordinate bounds.\n   * @param polyLongitudes longitude values for points of the polygon: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this polygon\n   */\n  public static Query newPolygonQuery(final String field, final double[] polyLatitudes, final double[] polyLongitudes) {\n    if (polyLatitudes.length != polyLongitudes.length) {\n      throw new IllegalArgumentException(\"same number of latitudes and longitudes required\");\n    }\n    if (polyLatitudes.length < 4) {\n      throw new IllegalArgumentException(\"need three or more points\");\n    }\n    if (polyLatitudes[0] != polyLatitudes[polyLatitudes.length-1] || polyLongitudes[0] != polyLongitudes[polyLongitudes.length-1]) {\n      throw new IllegalArgumentException(\"last point must equal first point\");\n    }\n    \n    final List<GeoPoint> polyPoints = new ArrayList<>(polyLatitudes.length-1);\n    for (int i = 0; i < polyLatitudes.length-1; i++) {\n      final double latitude = polyLatitudes[i];\n      final double longitude = polyLongitudes[i];\n      checkLatitude(latitude);\n      checkLongitude(longitude);\n      polyPoints.add(new GeoPoint(PlanetModel.WGS84, fromDegrees(latitude), fromDegrees(longitude)));\n    }\n    // We don't know what the sense of the polygon is without providing the index of one vertex we know to be convex.\n    // Since that doesn't fit with the \"super-simple API\" requirements, we just use the index of the first one, and people have to just\n    // know to do it that way.\n    final int convexPointIndex = 0;\n    final GeoShape shape = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, polyPoints, convexPointIndex);\n    return newShapeQuery(field, shape);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":["c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b","7593e6c5cc33e73fa12f7d1b0035d218d3a36309"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"40aa98241c87d86a0077beb8023713d93a0becfe":["c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7593e6c5cc33e73fa12f7d1b0035d218d3a36309"],"7593e6c5cc33e73fa12f7d1b0035d218d3a36309":["40aa98241c87d86a0077beb8023713d93a0becfe"]},"commit2Childs":{"c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b":["09af2c9610ce53a4b25fd99344299b40318a4a1a","40aa98241c87d86a0077beb8023713d93a0becfe"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b"],"40aa98241c87d86a0077beb8023713d93a0becfe":["7593e6c5cc33e73fa12f7d1b0035d218d3a36309"],"7593e6c5cc33e73fa12f7d1b0035d218d3a36309":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}