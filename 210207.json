{"path":"lucene/classification/src/java/org/apache/lucene/classification/utils/NearestFuzzyQuery#rewrite(IndexReader).mjava","commits":[{"id":"b9626938d906e220bc834fca668189e7cdf4985d","date":1498723309,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/NearestFuzzyQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    ScoreTermQueue q = new ScoreTermQueue(MAX_NUM_TERMS);\n    //load up the list of possible terms\n    for (FieldVals f : fieldVals) {\n      addTerms(reader, f, q);\n    }\n\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n    //create BooleanQueries to hold the variants for each token/field pair and ensure it\n    // has no coord factor\n    //Step 1: sort the termqueries by term/field\n    HashMap<Term, ArrayList<ScoreTerm>> variantQueries = new HashMap<>();\n    int size = q.size();\n    for (int i = 0; i < size; i++) {\n      ScoreTerm st = q.pop();\n      if (st != null) {\n        ArrayList<ScoreTerm> l = variantQueries.computeIfAbsent(st.fuzziedSourceTerm, k -> new ArrayList<>());\n        l.add(st);\n      }\n    }\n    //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n    for (ArrayList<ScoreTerm> variants : variantQueries.values()) {\n      if (variants.size() == 1) {\n        //optimize where only one selected variant\n        ScoreTerm st = variants.get(0);\n        Query tq = newTermQuery(reader, st.term);\n        // set the boost to a mix of IDF and score\n        bq.add(new BoostQuery(tq, st.score), BooleanClause.Occur.SHOULD);\n      } else {\n        BooleanQuery.Builder termVariants = new BooleanQuery.Builder();\n        for (ScoreTerm st : variants) {\n          // found a match\n          Query tq = newTermQuery(reader, st.term);\n          // set the boost using the ScoreTerm's score\n          termVariants.add(new BoostQuery(tq, st.score), BooleanClause.Occur.SHOULD);          // add to query\n        }\n        bq.add(termVariants.build(), BooleanClause.Occur.SHOULD);          // add to query\n      }\n    }\n    //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n    // booleans with a minimum-should-match of NumFields-1?\n    return bq.build();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/NearestFuzzyQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    ScoreTermQueue q = new ScoreTermQueue(MAX_NUM_TERMS);\n    //load up the list of possible terms\n    for (FieldVals f : fieldVals) {\n      addTerms(reader, f, q);\n    }\n\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n    //create BooleanQueries to hold the variants for each token/field pair and ensure it\n    // has no coord factor\n    //Step 1: sort the termqueries by term/field\n    HashMap<Term, ArrayList<ScoreTerm>> variantQueries = new HashMap<>();\n    int size = q.size();\n    for (int i = 0; i < size; i++) {\n      ScoreTerm st = q.pop();\n      if (st != null) {\n        ArrayList<ScoreTerm> l = variantQueries.computeIfAbsent(st.fuzziedSourceTerm, k -> new ArrayList<>());\n        l.add(st);\n      }\n    }\n    //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n    for (ArrayList<ScoreTerm> variants : variantQueries.values()) {\n      if (variants.size() == 1) {\n        //optimize where only one selected variant\n        ScoreTerm st = variants.get(0);\n        Query tq = newTermQuery(reader, st.term);\n        // set the boost to a mix of IDF and score\n        bq.add(new BoostQuery(tq, st.score), BooleanClause.Occur.SHOULD);\n      } else {\n        BooleanQuery.Builder termVariants = new BooleanQuery.Builder();\n        for (ScoreTerm st : variants) {\n          // found a match\n          Query tq = newTermQuery(reader, st.term);\n          // set the boost using the ScoreTerm's score\n          termVariants.add(new BoostQuery(tq, st.score), BooleanClause.Occur.SHOULD);          // add to query\n        }\n        bq.add(termVariants.build(), BooleanClause.Occur.SHOULD);          // add to query\n      }\n    }\n    //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n    // booleans with a minimum-should-match of NumFields-1?\n    return bq.build();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/NearestFuzzyQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    ScoreTermQueue q = new ScoreTermQueue(MAX_NUM_TERMS);\n    //load up the list of possible terms\n    for (FieldVals f : fieldVals) {\n      addTerms(reader, f, q);\n    }\n\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n    //create BooleanQueries to hold the variants for each token/field pair and ensure it\n    // has no coord factor\n    //Step 1: sort the termqueries by term/field\n    HashMap<Term, ArrayList<ScoreTerm>> variantQueries = new HashMap<>();\n    int size = q.size();\n    for (int i = 0; i < size; i++) {\n      ScoreTerm st = q.pop();\n      if (st != null) {\n        ArrayList<ScoreTerm> l = variantQueries.computeIfAbsent(st.fuzziedSourceTerm, k -> new ArrayList<>());\n        l.add(st);\n      }\n    }\n    //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n    for (ArrayList<ScoreTerm> variants : variantQueries.values()) {\n      if (variants.size() == 1) {\n        //optimize where only one selected variant\n        ScoreTerm st = variants.get(0);\n        Query tq = newTermQuery(reader, st.term);\n        // set the boost to a mix of IDF and score\n        bq.add(new BoostQuery(tq, st.score), BooleanClause.Occur.SHOULD);\n      } else {\n        BooleanQuery.Builder termVariants = new BooleanQuery.Builder();\n        for (ScoreTerm st : variants) {\n          // found a match\n          Query tq = newTermQuery(reader, st.term);\n          // set the boost using the ScoreTerm's score\n          termVariants.add(new BoostQuery(tq, st.score), BooleanClause.Occur.SHOULD);          // add to query\n        }\n        bq.add(termVariants.build(), BooleanClause.Occur.SHOULD);          // add to query\n      }\n    }\n    //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n    // booleans with a minimum-should-match of NumFields-1?\n    return bq.build();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b9626938d906e220bc834fca668189e7cdf4985d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30c8e5574b55d57947e989443dfde611646530ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b9626938d906e220bc834fca668189e7cdf4985d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"b9626938d906e220bc834fca668189e7cdf4985d":["28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b9626938d906e220bc834fca668189e7cdf4985d","30c8e5574b55d57947e989443dfde611646530ee","28288370235ed02234a64753cdbf0c6ec096304a"],"30c8e5574b55d57947e989443dfde611646530ee":[],"28288370235ed02234a64753cdbf0c6ec096304a":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}