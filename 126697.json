{"path":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnoughStoredOnly(BytesRef,Object).mjava","commits":[{"id":"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0","date":1383246815,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnoughStoredOnly(BytesRef,Object).mjava","pathOld":"/dev/null","sourceNew":"    private boolean isVersionNewEnoughStoredOnly(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n\n      // :TODO: would be nice if a full RTG was not always needed here, ideas...\n      //  - first check fieldCache/docVals - if a versionField exists\n      //    in index that is already greater then this cmd, fail fast \n      //    (no need to check updateLog, new version already too low)\n      //  - first check if docId is in the updateLog w/o doing the full get, if \n      //    it's not then check fieldCache/docVals\n      //  - track versionField externally from updateLog (or as a special case \n      //    that can be looked up by itself - similar to how _version_ is dealt with)\n      //\n      // Depending on if/when/how this is changed, what we assert about\n      // versionField on init will need updated.\n\n\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n\n\n      SolrInputDocument oldDoc =\n        RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n      if (null == oldDoc) {\n        return true;\n      }\n      \n      oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n                                \"Doc exists in index, but has null versionField: \"\n                                + versionFieldName);\n      }\n\n      // Make the FieldType resolve any conversion we need.\n      oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST, \n                                \"old version and new version are not comparable: \" +\n                                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n      \n      try { \n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // since we're going to proceed with this update, we need to find the _version_\n          // so we can use optimistic concurrency.\n\n          Object o = oldDoc.getFieldValue(VersionInfo.VERSION_FIELD);\n          if (o == null) {\n            throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n          }\n          oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          return false;\n        } else {\n          throw new SolrException(CONFLICT,\n                                  \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST, \n                                \"old version and new version are not comparable: \" +\n                                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                                \": \" + e.getMessage(), e);\n                                \n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a094a3cf22dfb1f022ba368c1605239343aa873","date":1384012589,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnoughStoredOnly(BytesRef,Object).mjava","sourceNew":null,"sourceOld":"    private boolean isVersionNewEnoughStoredOnly(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n\n      // :TODO: would be nice if a full RTG was not always needed here, ideas...\n      //  - first check fieldCache/docVals - if a versionField exists\n      //    in index that is already greater then this cmd, fail fast \n      //    (no need to check updateLog, new version already too low)\n      //  - first check if docId is in the updateLog w/o doing the full get, if \n      //    it's not then check fieldCache/docVals\n      //  - track versionField externally from updateLog (or as a special case \n      //    that can be looked up by itself - similar to how _version_ is dealt with)\n      //\n      // Depending on if/when/how this is changed, what we assert about\n      // versionField on init will need updated.\n\n\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n\n\n      SolrInputDocument oldDoc =\n        RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n      if (null == oldDoc) {\n        return true;\n      }\n      \n      oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n                                \"Doc exists in index, but has null versionField: \"\n                                + versionFieldName);\n      }\n\n      // Make the FieldType resolve any conversion we need.\n      oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST, \n                                \"old version and new version are not comparable: \" +\n                                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n      \n      try { \n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // since we're going to proceed with this update, we need to find the _version_\n          // so we can use optimistic concurrency.\n\n          Object o = oldDoc.getFieldValue(VersionInfo.VERSION_FIELD);\n          if (o == null) {\n            throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n          }\n          oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          return false;\n        } else {\n          throw new SolrException(CONFLICT,\n                                  \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST, \n                                \"old version and new version are not comparable: \" +\n                                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                                \": \" + e.getMessage(), e);\n                                \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9a094a3cf22dfb1f022ba368c1605239343aa873":["45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9a094a3cf22dfb1f022ba368c1605239343aa873"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0"],"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0":["9a094a3cf22dfb1f022ba368c1605239343aa873"],"9a094a3cf22dfb1f022ba368c1605239343aa873":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}