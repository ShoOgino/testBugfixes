{"path":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","commits":[{"id":"125b5699f11b58d9be0820c6ce8b1648812902e8","date":1190273227,"type":0,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if(hasChanges){\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if(hasChanges){\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n\n          // Sync all files we just wrote\n          for(int i=0;i<segmentInfos.size();i++) {\n            final SegmentInfo info = segmentInfos.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (!synced.contains(fileName)) {\n                assert directory.fileExists(fileName);\n                directory.sync(fileName);\n                synced.add(fileName);\n              }\n            }\n          }\n\n          segmentInfos.commit(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if(hasChanges){\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":["0f44610301174bfb430443d89a88dc1c502feea1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac785906c92e4048ffc28f7c23a45541d3cca9bf","date":1214322066,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if (hasChanges) {\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n\n          // Sync all files we just wrote\n          for(int i=0;i<segmentInfos.size();i++) {\n            final SegmentInfo info = segmentInfos.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (!synced.contains(fileName)) {\n                assert directory.fileExists(fileName);\n                directory.sync(fileName);\n                synced.add(fileName);\n              }\n            }\n          }\n\n          segmentInfos.commit(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if(hasChanges){\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n\n          // Sync all files we just wrote\n          for(int i=0;i<segmentInfos.size();i++) {\n            final SegmentInfo info = segmentInfos.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (!synced.contains(fileName)) {\n                assert directory.fileExists(fileName);\n                directory.sync(fileName);\n                synced.add(fileName);\n              }\n            }\n          }\n\n          segmentInfos.commit(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d99092e7a9892440b9da55d5b75d3d77206ee80e","date":1224496135,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if (hasChanges) {\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n\n          // Sync all files we just wrote\n          for(int i=0;i<segmentInfos.size();i++) {\n            final SegmentInfo info = segmentInfos.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (!synced.contains(fileName)) {\n                assert directory.fileExists(fileName);\n                directory.sync(fileName);\n                synced.add(fileName);\n              }\n            }\n          }\n\n          segmentInfos.commit(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n        deleter.close();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if (hasChanges) {\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n\n          // Sync all files we just wrote\n          for(int i=0;i<segmentInfos.size();i++) {\n            final SegmentInfo info = segmentInfos.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (!synced.contains(fileName)) {\n                assert directory.fileExists(fileName);\n                directory.sync(fileName);\n                synced.add(fileName);\n              }\n            }\n          }\n\n          segmentInfos.commit(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f44610301174bfb430443d89a88dc1c502feea1","date":1231194664,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if (hasChanges) {\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n\n          // Sync all files we just wrote\n          Iterator it = segmentInfos.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (!synced.contains(fileName)) {\n              assert directory.fileExists(fileName);\n              directory.sync(fileName);\n              synced.add(fileName);\n            }\n          }\n\n          segmentInfos.commit(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n        deleter.close();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if (hasChanges) {\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n\n          // Sync all files we just wrote\n          for(int i=0;i<segmentInfos.size();i++) {\n            final SegmentInfo info = segmentInfos.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (!synced.contains(fileName)) {\n                assert directory.fileExists(fileName);\n                directory.sync(fileName);\n                synced.add(fileName);\n              }\n            }\n          }\n\n          segmentInfos.commit(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n        deleter.close();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":["e82780afe6097066eb5befb86e9432f077667e3d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f664ea05e4a031c766b6bff0cefcd6f3833fbb81","date":1235737223,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected void doCommit() throws IOException {\n    if (hasChanges) {\n      if (segmentInfos != null) {\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          commitChanges();\n\n          // Sync all files we just wrote\n          Iterator it = segmentInfos.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (!synced.contains(fileName)) {\n              assert directory.fileExists(fileName);\n              directory.sync(fileName);\n              synced.add(fileName);\n            }\n          }\n\n          segmentInfos.commit(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n        deleter.close();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        commitChanges();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"511186b21e7c1fe96d5f683f9dbe923e139115af","date":1239144769,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  /** @deprecated */\n  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","sourceOld":"  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1","date":1244392278,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  /** @deprecated  */\n  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","sourceOld":"  /** @deprecated */\n  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1","date":1244392278,"type":6,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  /** @deprecated  */\n  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","sourceOld":"  /** @deprecated */\n  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["511186b21e7c1fe96d5f683f9dbe923e139115af"],"125b5699f11b58d9be0820c6ce8b1648812902e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f44610301174bfb430443d89a88dc1c502feea1":["d99092e7a9892440b9da55d5b75d3d77206ee80e"],"f664ea05e4a031c766b6bff0cefcd6f3833fbb81":["0f44610301174bfb430443d89a88dc1c502feea1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e82780afe6097066eb5befb86e9432f077667e3d":["125b5699f11b58d9be0820c6ce8b1648812902e8"],"511186b21e7c1fe96d5f683f9dbe923e139115af":["f664ea05e4a031c766b6bff0cefcd6f3833fbb81"],"ac785906c92e4048ffc28f7c23a45541d3cca9bf":["e82780afe6097066eb5befb86e9432f077667e3d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"d99092e7a9892440b9da55d5b75d3d77206ee80e":["ac785906c92e4048ffc28f7c23a45541d3cca9bf"]},"commit2Childs":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"125b5699f11b58d9be0820c6ce8b1648812902e8":["e82780afe6097066eb5befb86e9432f077667e3d"],"0f44610301174bfb430443d89a88dc1c502feea1":["f664ea05e4a031c766b6bff0cefcd6f3833fbb81"],"f664ea05e4a031c766b6bff0cefcd6f3833fbb81":["511186b21e7c1fe96d5f683f9dbe923e139115af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["125b5699f11b58d9be0820c6ce8b1648812902e8"],"e82780afe6097066eb5befb86e9432f077667e3d":["ac785906c92e4048ffc28f7c23a45541d3cca9bf"],"511186b21e7c1fe96d5f683f9dbe923e139115af":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"ac785906c92e4048ffc28f7c23a45541d3cca9bf":["d99092e7a9892440b9da55d5b75d3d77206ee80e"],"d99092e7a9892440b9da55d5b75d3d77206ee80e":["0f44610301174bfb430443d89a88dc1c502feea1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}