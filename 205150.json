{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","commits":[{"id":"dd6be878365e339c75cc43ad7d5df95ab4ea21e5","date":1435762101,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Filter,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Query filter, FieldDoc after, int topN, Sort sort, boolean doDocScores,\n                                    boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      topN = Math.min(topN, limit);\n      final TopFieldCollector hitCollector = TopFieldCollector.create(sort,\n                                                                      topN,\n                                                                      after,\n                                                                      true,\n                                                                      doDocScores,\n                                                                      doMaxScore);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Filter filter, FieldDoc after, int topN, Sort sort, boolean doDocScores,\n                                    boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      topN = Math.min(topN, limit);\n      final TopFieldCollector hitCollector = TopFieldCollector.create(sort,\n                                                                      topN,\n                                                                      after,\n                                                                      true,\n                                                                      doDocScores,\n                                                                      doMaxScore);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91eb857a56b1a3a6659c666f88e2398347fc1c5a","date":1483442809,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n                  }\n\n                  @Override\n                  public TopDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(topN, topDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Query filter, FieldDoc after, int topN, Sort sort, boolean doDocScores,\n                                    boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      topN = Math.min(topN, limit);\n      final TopFieldCollector hitCollector = TopFieldCollector.create(sort,\n                                                                      topN,\n                                                                      after,\n                                                                      true,\n                                                                      doDocScores,\n                                                                      doMaxScore);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n                  }\n\n                  @Override\n                  public TopDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(topN, topDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Query filter, FieldDoc after, int topN, Sort sort, boolean doDocScores,\n                                    boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      topN = Math.min(topN, limit);\n      final TopFieldCollector hitCollector = TopFieldCollector.create(sort,\n                                                                      topN,\n                                                                      after,\n                                                                      true,\n                                                                      doDocScores,\n                                                                      doMaxScore);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aef61e6c567737ae563bd9fa260d9103b1f3afa","date":1483874643,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n                  }\n\n                  @Override\n                  public TopDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(topN, topDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n                  }\n\n                  @Override\n                  public TopDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(topN, topDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":4,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8aef61e6c567737ae563bd9fa260d9103b1f3afa":["91eb857a56b1a3a6659c666f88e2398347fc1c5a"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["8aef61e6c567737ae563bd9fa260d9103b1f3afa","404d1ab7f6f396235047017c88d545fec15dafb7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["1aad05eeff7818b0833c02ac6b743aa72054963b","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"404d1ab7f6f396235047017c88d545fec15dafb7":["8aef61e6c567737ae563bd9fa260d9103b1f3afa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["f03e4bed5023ec3ef93a771b8888cae991cf448d","8aef61e6c567737ae563bd9fa260d9103b1f3afa"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"dd6be878365e339c75cc43ad7d5df95ab4ea21e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5","91eb857a56b1a3a6659c666f88e2398347fc1c5a"]},"commit2Childs":{"8aef61e6c567737ae563bd9fa260d9103b1f3afa":["1aad05eeff7818b0833c02ac6b743aa72054963b","404d1ab7f6f396235047017c88d545fec15dafb7","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["8aef61e6c567737ae563bd9fa260d9103b1f3afa","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dd6be878365e339c75cc43ad7d5df95ab4ea21e5":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}