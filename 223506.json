{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","commits":[{"id":"bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c","date":1396634612,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","pathOld":"/dev/null","sourceNew":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n    MockDirectoryWrapper dir = newMockDirectory();\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c97899690439b2eb38ca8376053c2c0467af66e","date":1396638634,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","sourceNew":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n    MockDirectoryWrapper dir = newMockDirectory();\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","pathOld":"/dev/null","sourceNew":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","sourceNew":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","sourceNew":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    \n    // don't act like windows either, or the test won't simulate the condition\n    dir.setEnableVirusScanner(false);\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29da7866bbda42f56cc116ef1161a534d4333a9c","date":1417031242,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","sourceNew":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    if (TestUtil.isWindowsFS(dir)) {\n      dir.close();\n      assumeFalse(\"this test can't run on Windows\", true);\n    }\n    \n    // don't act like windows either, or the test won't simulate the condition\n    dir.setEnableVirusScanner(false);\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    \n    // don't act like windows either, or the test won't simulate the condition\n    dir.setEnableVirusScanner(false);\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0cd782528ad78bb9c443f1a591c793be90d627d3","date":1417510244,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","sourceNew":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    if (TestUtil.isWindowsFS(dir)) {\n      dir.close();\n      assumeFalse(\"this test can't run on simulated windows (WindowsFS)\", true);\n    }\n    \n    // don't act like windows either, or the test won't simulate the condition\n    dir.setEnableVirusScanner(false);\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    if (TestUtil.isWindowsFS(dir)) {\n      dir.close();\n      assumeFalse(\"this test can't run on Windows\", true);\n    }\n    \n    // don't act like windows either, or the test won't simulate the condition\n    dir.setEnableVirusScanner(false);\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b185840df853cd910fb9ef34e8ad534560d3ce5a","date":1424440830,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNRTReaderCleanup#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testClosingNRTReaderDoesNotCorruptYourIndex().mjava","sourceNew":"  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    \n    // don't act like windows either, or the test won't simulate the condition\n    dir.setEnableVirusScanner(false);\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5574\n  public void testClosingNRTReaderDoesNotCorruptYourIndex() throws IOException {\n\n    // Windows disallows deleting & overwriting files still\n    // open for reading:\n    assumeFalse(\"this test can't run on Windows\", Constants.WINDOWS);\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    if (TestUtil.isWindowsFS(dir)) {\n      dir.close();\n      assumeFalse(\"this test can't run on simulated windows (WindowsFS)\", true);\n    }\n    \n    // don't act like windows either, or the test won't simulate the condition\n    dir.setEnableVirusScanner(false);\n\n    // Allow deletion of still open files:\n    dir.setNoDeleteOpenFile(false);\n\n    // Allow writing to same file more than once:\n    dir.setPreventDoubleWrite(false);\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    LogMergePolicy lmp = new LogDocMergePolicy();\n    lmp.setMergeFactor(2);\n    iwc.setMergePolicy(lmp);\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    doc.add(new TextField(\"a\", \"foo\", Field.Store.NO));\n    w.addDocument(doc);\n    w.commit();\n    w.addDocument(doc);\n\n    // Get a new reader, but this also sets off a merge:\n    IndexReader r = w.getReader();\n    w.close();\n\n    // Blow away index and make a new writer:\n    for(String fileName : dir.listAll()) {\n      dir.deleteFile(fileName);\n    }\n\n    w = new RandomIndexWriter(random(), dir);\n    w.addDocument(doc);\n    w.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"29da7866bbda42f56cc116ef1161a534d4333a9c":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["3c97899690439b2eb38ca8376053c2c0467af66e"],"3c97899690439b2eb38ca8376053c2c0467af66e":["bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c"],"b185840df853cd910fb9ef34e8ad534560d3ce5a":["0cd782528ad78bb9c443f1a591c793be90d627d3"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3c97899690439b2eb38ca8376053c2c0467af66e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0cd782528ad78bb9c443f1a591c793be90d627d3":["29da7866bbda42f56cc116ef1161a534d4333a9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b185840df853cd910fb9ef34e8ad534560d3ce5a"]},"commit2Childs":{"29da7866bbda42f56cc116ef1161a534d4333a9c":["0cd782528ad78bb9c443f1a591c793be90d627d3"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"3c97899690439b2eb38ca8376053c2c0467af66e":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"b185840df853cd910fb9ef34e8ad534560d3ce5a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["29da7866bbda42f56cc116ef1161a534d4333a9c"],"bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c":["3c97899690439b2eb38ca8376053c2c0467af66e"],"0cd782528ad78bb9c443f1a591c793be90d627d3":["b185840df853cd910fb9ef34e8ad534560d3ce5a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}