{"path":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","commits":[{"id":"c5f61d6a2927b52517a31a8bf022549d33b1dfec","date":1305652854,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3ce36a160d1241ae9c70e109dc3fdfdfb009674a","date":1307033216,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d62f5453a200cec2cbb60148de159dbf55591e9d","date":1307049300,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fa60a501961bce2ff07ee1cde7c78699025547e","date":1307054117,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c715a0f99152be7566591f323c6c5a25725a1bcb","date":1307118449,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b861c0fdfa4d005c70848c9121655e9dc704f96","date":1307129511,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c03daa6ddcb4768a702115ec63799cab5fff3d92","date":1307140842,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e7c99bd45fa88a3d93a03fdd773053bef72268e","date":1307218088,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups slowGrouping(GroupDoc[] groupDocs,\n                                 String searchTerm,\n                                 boolean fillFields,\n                                 boolean getScores,\n                                 boolean getMaxScores,\n                                 boolean doAllGroups,\n                                 Sort groupSort,\n                                 Sort docSort,\n                                 int topNGroups,\n                                 int docsPerGroup,\n                                 int groupOffset,\n                                 int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.equals(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    final GroupDocs[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, 0.0f, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, 0.0f);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups(\n          new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6005b05c19356dfca18f39979caeeb6b85bc88bb","date":1331204804,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#slowGrouping(GroupDoc[],String,boolean,boolean,boolean,boolean,Sort,Sort,int,int,int,int).mjava","sourceNew":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","sourceOld":"  private TopGroups<BytesRef> slowGrouping(GroupDoc[] groupDocs,\n                                           String searchTerm,\n                                           boolean fillFields,\n                                           boolean getScores,\n                                           boolean getMaxScores,\n                                           boolean doAllGroups,\n                                           Sort groupSort,\n                                           Sort docSort,\n                                           int topNGroups,\n                                           int docsPerGroup,\n                                           int groupOffset,\n                                           int docOffset) {\n\n    final Comparator<GroupDoc> groupSortComp = getComparator(groupSort);\n\n    Arrays.sort(groupDocs, groupSortComp);\n    final HashMap<BytesRef,List<GroupDoc>> groups = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> sortedGroups = new ArrayList<BytesRef>();\n    final List<Comparable<?>[]> sortedGroupFields = new ArrayList<Comparable<?>[]>();\n\n    int totalHitCount = 0;\n    Set<BytesRef> knownGroups = new HashSet<BytesRef>();\n\n    //System.out.println(\"TEST: slowGrouping\");\n    for(GroupDoc d : groupDocs) {\n      // TODO: would be better to filter by searchTerm before sorting!\n      if (!d.content.startsWith(searchTerm)) {\n        continue;\n      }\n      totalHitCount++;\n      //System.out.println(\"  match id=\" + d.id + \" score=\" + d.score);\n\n      if (doAllGroups) {\n        if (!knownGroups.contains(d.group)) {\n          knownGroups.add(d.group);\n          //System.out.println(\"    add group=\" + groupToString(d.group));\n        }\n      }\n\n      List<GroupDoc> l = groups.get(d.group);\n      if (l == null) {\n        //System.out.println(\"    add sortedGroup=\" + groupToString(d.group));\n        sortedGroups.add(d.group);\n        if (fillFields) {\n          sortedGroupFields.add(fillFields(d, groupSort));\n        }\n        l = new ArrayList<GroupDoc>();\n        groups.put(d.group, l);\n      }\n      l.add(d);\n    }\n\n    if (groupOffset >= sortedGroups.size()) {\n      // slice is out of bounds\n      return null;\n    }\n\n    final int limit = Math.min(groupOffset + topNGroups, groups.size());\n\n    final Comparator<GroupDoc> docSortComp = getComparator(docSort);\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<BytesRef>[] result = new GroupDocs[limit-groupOffset];\n    int totalGroupedHitCount = 0;\n    for(int idx=groupOffset;idx < limit;idx++) {\n      final BytesRef group = sortedGroups.get(idx);\n      final List<GroupDoc> docs = groups.get(group);\n      totalGroupedHitCount += docs.size();\n      Collections.sort(docs, docSortComp);\n      final ScoreDoc[] hits;\n      if (docs.size() > docOffset) {\n        final int docIDXLimit = Math.min(docOffset + docsPerGroup, docs.size());\n        hits = new ScoreDoc[docIDXLimit - docOffset];\n        for(int docIDX=docOffset; docIDX < docIDXLimit; docIDX++) {\n          final GroupDoc d = docs.get(docIDX);\n          final FieldDoc fd;\n          if (fillFields) {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN, fillFields(d, docSort));\n          } else {\n            fd = new FieldDoc(d.id, getScores ? d.score : Float.NaN);\n          }\n          hits[docIDX-docOffset] = fd;\n        }\n      } else  {\n        hits = new ScoreDoc[0];\n      }\n\n      result[idx-groupOffset] = new GroupDocs<BytesRef>(0.0f,\n                                              docs.size(),\n                                              hits,\n                                              group,\n                                              fillFields ? sortedGroupFields.get(idx) : null);\n    }\n\n    if (doAllGroups) {\n      return new TopGroups<BytesRef>(\n          new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result),\n          knownGroups.size()\n      );\n    } else {\n      return new TopGroups<BytesRef>(groupSort.getSort(), docSort.getSort(), totalHitCount, totalGroupedHitCount, result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c5f61d6a2927b52517a31a8bf022549d33b1dfec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["6b861c0fdfa4d005c70848c9121655e9dc704f96","6005b05c19356dfca18f39979caeeb6b85bc88bb"],"6b861c0fdfa4d005c70848c9121655e9dc704f96":["1fa60a501961bce2ff07ee1cde7c78699025547e"],"3ce36a160d1241ae9c70e109dc3fdfdfb009674a":["c5f61d6a2927b52517a31a8bf022549d33b1dfec"],"6005b05c19356dfca18f39979caeeb6b85bc88bb":["6b861c0fdfa4d005c70848c9121655e9dc704f96"],"c715a0f99152be7566591f323c6c5a25725a1bcb":["c3a8a449466c1ff7ce2274fe73dab487256964b4","1fa60a501961bce2ff07ee1cde7c78699025547e"],"d62f5453a200cec2cbb60148de159dbf55591e9d":["a3776dccca01c11e7046323cfad46a3b4a471233","3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"1fa60a501961bce2ff07ee1cde7c78699025547e":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":["d62f5453a200cec2cbb60148de159dbf55591e9d","6b861c0fdfa4d005c70848c9121655e9dc704f96"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["6005b05c19356dfca18f39979caeeb6b85bc88bb"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5f61d6a2927b52517a31a8bf022549d33b1dfec"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5f61d6a2927b52517a31a8bf022549d33b1dfec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c03daa6ddcb4768a702115ec63799cab5fff3d92":["c715a0f99152be7566591f323c6c5a25725a1bcb","6b861c0fdfa4d005c70848c9121655e9dc704f96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"c5f61d6a2927b52517a31a8bf022549d33b1dfec":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"6b861c0fdfa4d005c70848c9121655e9dc704f96":["38e3b736c7ca086d61b7dbb841c905ee115490da","6005b05c19356dfca18f39979caeeb6b85bc88bb","1e7c99bd45fa88a3d93a03fdd773053bef72268e","c03daa6ddcb4768a702115ec63799cab5fff3d92"],"3ce36a160d1241ae9c70e109dc3fdfdfb009674a":["d62f5453a200cec2cbb60148de159dbf55591e9d","1fa60a501961bce2ff07ee1cde7c78699025547e"],"6005b05c19356dfca18f39979caeeb6b85bc88bb":["38e3b736c7ca086d61b7dbb841c905ee115490da","b89678825b68eccaf09e6ab71675fc0b0af1e099"],"c715a0f99152be7566591f323c6c5a25725a1bcb":["c03daa6ddcb4768a702115ec63799cab5fff3d92"],"d62f5453a200cec2cbb60148de159dbf55591e9d":["1e7c99bd45fa88a3d93a03fdd773053bef72268e"],"1fa60a501961bce2ff07ee1cde7c78699025547e":["6b861c0fdfa4d005c70848c9121655e9dc704f96","c715a0f99152be7566591f323c6c5a25725a1bcb"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["c715a0f99152be7566591f323c6c5a25725a1bcb"],"a3776dccca01c11e7046323cfad46a3b4a471233":["d62f5453a200cec2cbb60148de159dbf55591e9d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5f61d6a2927b52517a31a8bf022549d33b1dfec","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"c03daa6ddcb4768a702115ec63799cab5fff3d92":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","1e7c99bd45fa88a3d93a03fdd773053bef72268e","c03daa6ddcb4768a702115ec63799cab5fff3d92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}