{"path":"lucene/backward-codecs/src/java/org/apache/lucene/codecs/blocktree/Lucene40BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","commits":[{"id":"0628077afea69a2955260949478afabab8e500d8","date":1413915332,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/backward-codecs/src/java/org/apache/lucene/codecs/blocktree/Lucene40BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","pathOld":"/dev/null","sourceNew":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      /*\n      if (DEBUG) {\n        BytesRef br = new BytesRef(lastTerm.bytes);\n        br.offset = lastTerm.offset;\n        br.length = prefixLength;\n        System.out.println(\"writeBlocks: \" + br.utf8ToString() + \" count=\" + count);\n      }\n      */\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6d238816bcdf9bbe4ec886226d89bd93834eb7e","date":1413925889,"type":5,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/blocktree/Lucene40BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","pathOld":"lucene/backward-codecs/src/java/org/apache/lucene/codecs/blocktree/Lucene40BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","sourceNew":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      /*\n      if (DEBUG) {\n        BytesRef br = new BytesRef(lastTerm.bytes);\n        br.offset = lastTerm.offset;\n        br.length = prefixLength;\n        System.out.println(\"writeBlocks: \" + br.utf8ToString() + \" count=\" + count);\n      }\n      */\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","sourceOld":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      /*\n      if (DEBUG) {\n        BytesRef br = new BytesRef(lastTerm.bytes);\n        br.offset = lastTerm.offset;\n        br.length = prefixLength;\n        System.out.println(\"writeBlocks: \" + br.utf8ToString() + \" count=\" + count);\n      }\n      */\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c6d238816bcdf9bbe4ec886226d89bd93834eb7e":["0628077afea69a2955260949478afabab8e500d8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0628077afea69a2955260949478afabab8e500d8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c6d238816bcdf9bbe4ec886226d89bd93834eb7e":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0628077afea69a2955260949478afabab8e500d8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0628077afea69a2955260949478afabab8e500d8":["c6d238816bcdf9bbe4ec886226d89bd93834eb7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c6d238816bcdf9bbe4ec886226d89bd93834eb7e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}