{"path":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","commits":[{"id":"283ff02f401ec3e7a2fad73643970f052383fb0c","date":1411407953,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n      this.localParams = localParams;\n\n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    \n    this.calcDistinct = null == schemaField\n      ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n      : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["73037b76a70b4cad490b616ea90220b3cc2a6fd8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","sourceNew":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n      this.localParams = localParams;\n\n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    \n    this.calcDistinct = null == schemaField\n      ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n      : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","sourceOld":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n      this.localParams = localParams;\n\n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    \n    this.calcDistinct = null == schemaField\n      ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n      : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d12bbc45d641864ffe03291bc30f178eb34e434c","date":1426001646,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","sourceNew":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      isShard = params.getBool(\"isShard\", false);\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n\n      this.localParams = localParams;\n      \n\n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    this.topLevelCalcDistinct = null == schemaField\n        ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n        : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n        \n    populateStatsSets();\n        \n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","sourceOld":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n      this.localParams = localParams;\n\n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    \n    this.calcDistinct = null == schemaField\n      ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n      : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1002283cfd29923d517db7c33e07bb54aac7acd4","date":1427211199,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","sourceNew":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      isShard = params.getBool(\"isShard\", false);\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n\n      this.localParams = localParams;\n      \n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    this.topLevelCalcDistinct = null == schemaField\n        ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n        : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    populateStatsSets();\n        \n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","sourceOld":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      isShard = params.getBool(\"isShard\", false);\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n\n      this.localParams = localParams;\n      \n\n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    this.topLevelCalcDistinct = null == schemaField\n        ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n        : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n        \n    populateStatsSets();\n        \n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","sourceNew":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      isShard = params.getBool(\"isShard\", false);\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n\n      this.localParams = localParams;\n      \n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    this.topLevelCalcDistinct = null == schemaField\n        ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n        : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    populateStatsSets();\n        \n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","sourceOld":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n      this.localParams = localParams;\n\n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    \n    this.calcDistinct = null == schemaField\n      ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n      : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73037b76a70b4cad490b616ea90220b3cc2a6fd8","date":1561396119,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField#StatsField(ResponseBuilder,String).mjava","sourceNew":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      isShard = params.getBool(\"isShard\", false);\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n\n      this.localParams = localParams;\n      \n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundantly\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        if (qplug == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"invalid query parser '\" + parserName +\n              (originalParam == null? \"'\": \"' for query '\" + originalParam + \"'\"));\n        }\n        QParser qp = qplug.createParser(localParams.get(QueryParsing.V),\n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corresponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    this.topLevelCalcDistinct = null == schemaField\n        ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n        : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    populateStatsSets();\n        \n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","sourceOld":"  /**\n   * @param rb the current request/response\n   * @param statsParam the raw {@link StatsParams#STATS_FIELD} string\n   */\n  public StatsField(ResponseBuilder rb, String statsParam) { \n    this.rb = rb;\n    this.searcher = rb.req.getSearcher();\n    this.originalParam = statsParam;\n\n    SolrParams params = rb.req.getParams();\n    try {\n      isShard = params.getBool(\"isShard\", false);\n      SolrParams localParams = QueryParsing.getLocalParams(originalParam, params);\n      if (null == localParams) {\n        // simplest possible input: bare string (field name)\n        ModifiableSolrParams customParams = new ModifiableSolrParams();\n        customParams.add(QueryParsing.V, originalParam);\n        localParams = customParams;\n      }\n\n      this.localParams = localParams;\n      \n      String parserName = localParams.get(QueryParsing.TYPE);\n      SchemaField sf = null;\n      ValueSource vs = null;\n\n      if ( StringUtils.isBlank(parserName) ) {\n\n        // basic request for field stats\n        sf = searcher.getSchema().getField(localParams.get(QueryParsing.V));\n\n      } else {\n        // we have a non trivial request to compute stats over a query (or function)\n\n        // NOTE we could use QParser.getParser(...) here, but that would redundently\n        // reparse everything.  ( TODO: refactor a common method in QParser ?)\n        QParserPlugin qplug = rb.req.getCore().getQueryPlugin(parserName);\n        QParser qp =  qplug.createParser(localParams.get(QueryParsing.V), \n                                         localParams, params, rb.req);\n\n        // figure out what type of query we are dealing, get the most direct ValueSource\n        vs = extractValueSource(qp.parse());\n\n        // if this ValueSource directly corrisponds to a SchemaField, act as if\n        // we were asked to compute stats on it directly\n        // ie:  \"stats.field={!func key=foo}field(foo)\" == \"stats.field=foo\"\n        sf = extractSchemaField(vs, searcher.getSchema());\n        if (null != sf) {\n          vs = null;\n        }\n      }\n      \n      assert ( (null == vs) ^ (null == sf) ) : \"exactly one of vs & sf must be null\";\n      \n      this.schemaField = sf;\n      this.valueSource = vs;\n\n    } catch (SyntaxError e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Unable to parse \" + \n                              StatsParams.STATS_FIELD + \": \" + originalParam + \" due to: \"\n                              + e.getMessage(), e);\n    }\n\n    // allow explicit setting of the response key via localparams...\n    this.key = localParams.get(CommonParams.OUTPUT_KEY, \n                               // default to the main param value...\n                               localParams.get(CommonParams.VALUE, \n                                               // default to entire original param str.\n                                               originalParam));\n\n    this.topLevelCalcDistinct = null == schemaField\n        ? params.getBool(StatsParams.STATS_CALC_DISTINCT, false) \n        : params.getFieldBool(schemaField.getName(), StatsParams.STATS_CALC_DISTINCT, false);\n\n    populateStatsSets();\n        \n    String[] facets = params.getFieldParams(key, StatsParams.STATS_FACET);\n    this.facets = (null == facets) ? new String[0] : facets;\n    String tagStr = localParams.get(CommonParams.TAG);\n    this.tagList = (null == tagStr)\n        ? Collections.<String>emptyList()\n        : StrUtils.splitSmart(tagStr,',');\n\n    // figure out if we need a special base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    this.excludeTagList = (null == excludeStr) \n      ? Collections.<String>emptyList()\n      : StrUtils.splitSmart(excludeStr,',');\n\n    assert ( (null == this.valueSource) ^ (null == this.schemaField) ) \n      : \"exactly one of valueSource & schemaField must be null\";\n  }\n\n","bugFix":["283ff02f401ec3e7a2fad73643970f052383fb0c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"283ff02f401ec3e7a2fad73643970f052383fb0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["4c18a95e9168a30be855f5d5e7d61a863186fdc5","1002283cfd29923d517db7c33e07bb54aac7acd4"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["283ff02f401ec3e7a2fad73643970f052383fb0c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d12bbc45d641864ffe03291bc30f178eb34e434c":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"73037b76a70b4cad490b616ea90220b3cc2a6fd8":["1002283cfd29923d517db7c33e07bb54aac7acd4"],"1002283cfd29923d517db7c33e07bb54aac7acd4":["d12bbc45d641864ffe03291bc30f178eb34e434c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73037b76a70b4cad490b616ea90220b3cc2a6fd8"]},"commit2Childs":{"283ff02f401ec3e7a2fad73643970f052383fb0c":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d12bbc45d641864ffe03291bc30f178eb34e434c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["283ff02f401ec3e7a2fad73643970f052383fb0c"],"d12bbc45d641864ffe03291bc30f178eb34e434c":["1002283cfd29923d517db7c33e07bb54aac7acd4"],"1002283cfd29923d517db7c33e07bb54aac7acd4":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","73037b76a70b4cad490b616ea90220b3cc2a6fd8"],"73037b76a70b4cad490b616ea90220b3cc2a6fd8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}