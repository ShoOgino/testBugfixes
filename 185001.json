{"path":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // TEST: Uncomment the following line when testing to supress over-requesting facets and\n          // thus cause more facet refinement queries.\n          // if (dff.limit > 0) dff.initialLimit = dff.offset + dff.limit;\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // TEST: Uncomment the following line when testing to supress over-requesting facets and\n          // thus cause more facet refinement queries.\n          // if (dff.limit > 0) dff.initialLimit = dff.offset + dff.limit;\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // TEST: Uncomment the following line when testing to supress over-requesting facets and\n          // thus cause more facet refinement queries.\n          // if (dff.limit > 0) dff.initialLimit = dff.offset + dff.limit;\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // TEST: Uncomment the following line when testing to supress over-requesting facets and\n          // thus cause more facet refinement queries.\n          // if (dff.limit > 0) dff.initialLimit = dff.offset + dff.limit;\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // TEST: Uncomment the following line when testing to supress over-requesting facets and\n          // thus cause more facet refinement queries.\n          // if (dff.limit > 0) dff.initialLimit = dff.offset + dff.limit;\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef02613bb5b67b98ca5caf41e8d6e016a0158923","date":1283980033,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // TEST: Uncomment the following line when testing to supress over-requesting facets and\n          // thus cause more facet refinement queries.\n          // if (dff.limit > 0) dff.initialLimit = dff.offset + dff.limit;\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":["4db78c8781346b675fa5f1a6db8adcb96889c2ca","a1ab02b73dc61b51bca98e09b5b72926c4580ecb","5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // TEST: Uncomment the following line when testing to supress over-requesting facets and\n          // thus cause more facet refinement queries.\n          // if (dff.limit > 0) dff.initialLimit = dff.offset + dff.limit;\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55e80c3a6a9734c50aa4fa3bf2f240690e12ba42","date":1298586575,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.offset + dff.limit;\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":["4db78c8781346b675fa5f1a6db8adcb96889c2ca"],"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2dfd60688653855da1a42cd89a1df4e6738ac079","date":1298618289,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.offset + dff.limit;\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.offset + dff.limit;\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = dff.offset + dff.limit;\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          } else {\n            dff.initialLimit = dff.limit;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1c5c000a4f7db9f84794088342aa428d80dfa37","date":1303079085,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.offset + dff.limit;\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":["55e80c3a6a9734c50aa4fa3bf2f240690e12ba42","4db78c8781346b675fa5f1a6db8adcb96889c2ca","718ab708b1705aae7831111fcddfc834665eee61","9397de64b7287396e2394079a925761a83ceeca2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d493718201f0d0c54c773fb323d87bbd2fbffe41","date":1303546048,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.offset + dff.limit;\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.offset + dff.limit;\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.offset + dff.limit;\n\n          if(dff.sort.equals(FacetParams.FACET_SORT_COUNT) && dff.limit > 0) {\n            // set the initial limit higher to increase accuracy\n            dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ef02613bb5b67b98ca5caf41e8d6e016a0158923":["1da8d55113b689b06716246649de6f62430f15c0"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["d1c5c000a4f7db9f84794088342aa428d80dfa37","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","d1c5c000a4f7db9f84794088342aa428d80dfa37"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":["2dfd60688653855da1a42cd89a1df4e6738ac079","d1c5c000a4f7db9f84794088342aa428d80dfa37"],"55e80c3a6a9734c50aa4fa3bf2f240690e12ba42":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a3776dccca01c11e7046323cfad46a3b4a471233"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["ef02613bb5b67b98ca5caf41e8d6e016a0158923","55e80c3a6a9734c50aa4fa3bf2f240690e12ba42"],"a3776dccca01c11e7046323cfad46a3b4a471233":["55e80c3a6a9734c50aa4fa3bf2f240690e12ba42","d1c5c000a4f7db9f84794088342aa428d80dfa37"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"2dfd60688653855da1a42cd89a1df4e6738ac079":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","55e80c3a6a9734c50aa4fa3bf2f240690e12ba42"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"d1c5c000a4f7db9f84794088342aa428d80dfa37":["55e80c3a6a9734c50aa4fa3bf2f240690e12ba42"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"ef02613bb5b67b98ca5caf41e8d6e016a0158923":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","55e80c3a6a9734c50aa4fa3bf2f240690e12ba42","d619839baa8ce5503e496b94a9e42ad6f079293f"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["2dfd60688653855da1a42cd89a1df4e6738ac079"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":[],"55e80c3a6a9734c50aa4fa3bf2f240690e12ba42":["d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233","2dfd60688653855da1a42cd89a1df4e6738ac079","d1c5c000a4f7db9f84794088342aa428d80dfa37"],"1da8d55113b689b06716246649de6f62430f15c0":["ef02613bb5b67b98ca5caf41e8d6e016a0158923","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"2dfd60688653855da1a42cd89a1df4e6738ac079":["d493718201f0d0c54c773fb323d87bbd2fbffe41"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"d1c5c000a4f7db9f84794088342aa428d80dfa37":["c26f00b574427b55127e869b935845554afde1fa","135621f3a0670a9394eb563224a3b76cc4dddc0f","d493718201f0d0c54c773fb323d87bbd2fbffe41","a3776dccca01c11e7046323cfad46a3b4a471233","a258fbb26824fd104ed795e5d9033d2d040049ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","d493718201f0d0c54c773fb323d87bbd2fbffe41","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}