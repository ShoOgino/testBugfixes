{"path":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","commits":[{"id":"23e55c29de60130e8a1226800b66c5f6d7e16e8a","date":1447950053,"type":1,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"304ef848381e39ff6cf3e7af6127733a6f4db389","date":1482353305,"type":5,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"043df2e9a841864922c32756a44c939ed768cb89":["23e55c29de60130e8a1226800b66c5f6d7e16e8a"],"b6284684320a9808c41a5e43de958b2da22f89bd":["23e55c29de60130e8a1226800b66c5f6d7e16e8a","043df2e9a841864922c32756a44c939ed768cb89"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["b6284684320a9808c41a5e43de958b2da22f89bd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["b6284684320a9808c41a5e43de958b2da22f89bd","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"304ef848381e39ff6cf3e7af6127733a6f4db389":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"23e55c29de60130e8a1226800b66c5f6d7e16e8a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["304ef848381e39ff6cf3e7af6127733a6f4db389"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","304ef848381e39ff6cf3e7af6127733a6f4db389"]},"commit2Childs":{"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"b6284684320a9808c41a5e43de958b2da22f89bd":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["23e55c29de60130e8a1226800b66c5f6d7e16e8a"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["304ef848381e39ff6cf3e7af6127733a6f4db389","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"23e55c29de60130e8a1226800b66c5f6d7e16e8a":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"304ef848381e39ff6cf3e7af6127733a6f4db389":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}