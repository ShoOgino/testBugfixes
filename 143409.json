{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","commits":[{"id":"607428da722dcb3e86bbd11c63de8986e6275c36","date":1360334150,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<FacetLabel,CategoryListParams> clps = new HashMap<FacetLabel,CategoryListParams>();\n    for (String dim : dimensions) {\n      FacetLabel cp = new FacetLabel(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<FacetLabel> categories = new ArrayList<FacetLabel>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new FacetLabel(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new FacetLabel(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          FacetLabel cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca39562b2d7687143fdb601d5de1b8f7b778f1db","date":1385299806,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<FacetLabel,CategoryListParams> clps = new HashMap<FacetLabel,CategoryListParams>();\n    for (String dim : dimensions) {\n      FacetLabel cp = new FacetLabel(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<FacetLabel> categories = new ArrayList<FacetLabel>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new FacetLabel(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new FacetLabel(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          FacetLabel cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"607428da722dcb3e86bbd11c63de8986e6275c36":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["607428da722dcb3e86bbd11c63de8986e6275c36","ca39562b2d7687143fdb601d5de1b8f7b778f1db"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"ca39562b2d7687143fdb601d5de1b8f7b778f1db":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["607428da722dcb3e86bbd11c63de8986e6275c36"]},"commit2Childs":{"607428da722dcb3e86bbd11c63de8986e6275c36":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["607428da722dcb3e86bbd11c63de8986e6275c36"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ca39562b2d7687143fdb601d5de1b8f7b778f1db":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["ca39562b2d7687143fdb601d5de1b8f7b778f1db"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}