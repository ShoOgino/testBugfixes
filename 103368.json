{"path":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader],Map[String,String]).mjava","commits":[{"id":"763da4a9605e47013078edc323b9d4b608f0f9e0","date":1555353576,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader],Map[String,String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders, Map<String, String> readerAttributes) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ, readerAttributes);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false, readerAttributes);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4e83191a3e02851a0b67e5335e6922f3e9ea86d","date":1583489709,"type":5,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader#open(Directory,SegmentInfos,List[#-extends-LeafReader],Map[String,String]).mjava","sourceNew":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);\n  }\n\n","sourceOld":"  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.\n   *\n   *  @lucene.internal */\n  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders, Map<String, String> readerAttributes) throws IOException {\n\n    // we put the old SegmentReaders in a map, that allows us\n    // to lookup a reader using its segment name\n    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));\n\n    if (oldReaders != null) {\n      // create a Map SegmentName->SegmentReader\n      for (int i = 0, c = oldReaders.size(); i < c; i++) {\n        final SegmentReader sr = (SegmentReader) oldReaders.get(i);\n        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));\n      }\n    }\n    \n    SegmentReader[] newReaders = new SegmentReader[infos.size()];\n    for (int i = infos.size() - 1; i>=0; i--) {\n      SegmentCommitInfo commitInfo = infos.info(i);\n\n      // find SegmentReader for this segment\n      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);\n      SegmentReader oldReader;\n      if (oldReaderIndex == null) {\n        // this is a new segment, no old SegmentReader can be reused\n        oldReader = null;\n      } else {\n        // there is an old reader for this segment - we'll try to reopen it\n        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());\n      }\n\n      // Make a best effort to detect when the app illegally \"rm -rf\" their\n      // index while a reader was open, and then called openIfChanged:\n      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {\n        throw new IllegalStateException(\"same segment \" + commitInfo.info.name + \" has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead\");\n      }\n\n      boolean success = false;\n      try {\n        SegmentReader newReader;\n        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {\n          // this is a new reader; in case we hit an exception we can decRef it safely\n          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ, readerAttributes);\n          newReaders[i] = newReader;\n        } else {\n          if (oldReader.isNRT) {\n            // We must load liveDocs/DV updates from disk:\n            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n          } else {\n            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()\n                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {\n              // No change; this reader will be shared between\n              // the old and the new one, so we must incRef\n              // it:\n              oldReader.incRef();\n              newReaders[i] = oldReader;\n            } else {\n              // Steal the ref returned by SegmentReader ctor:\n              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;\n\n              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {\n                // only DV updates\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),\n                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!\n              } else {\n                // both DV and liveDocs have changed\n                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()\n                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;\n                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,\n                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);\n              }\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          decRefWhileHandlingException(newReaders);\n        }\n      }\n    }    \n    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false, readerAttributes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"763da4a9605e47013078edc323b9d4b608f0f9e0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["763da4a9605e47013078edc323b9d4b608f0f9e0"]},"commit2Childs":{"763da4a9605e47013078edc323b9d4b608f0f9e0":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}