{"path":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","commits":[{"id":"dad6a48950aafc9c2f5dc54740f8c6ab81304203","date":1552999379,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    JettySolrRunner overseerNode = null;\n    int index = -1;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        index = i;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    cluster.stopJettySolrRunner(index);\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7966b40769a3ff0bc1b524c2a1c1fce09d4b2794","date":1576800896,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","sourceNew":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    log.info(\"Overseer Status indicates that the overseer is: {}\");\n    JettySolrRunner overseerNode = null;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    log.info(\"Stopping Overseer Node: {} ({})\", overseerNode.getNodeName(), overseerNode.getLocalPort());\n    cluster.stopJettySolrRunner(overseerNode);\n    log.info(\"Waiting for new overseer election...\");\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        log.info(\"...new overseer is: {}\", newLeader);\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n\n    // TODO: replace this polling logic with a LogWatcher that uses a queue we can await() on...\n    log.info(\"Polling for log watcher to detect expected log messages...\");\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          log.info(\"Found re-indexing message: {}\", doc.getFieldValue(\"message\"));\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          log.info(\"Found timestamp message: {}\", doc.getFieldValue(\"message\"));\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    log.info(\"Done polling log watcher: foundWarning={} foundSchemaWarning={}\", foundWarning, foundSchemaWarning);\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n  }\n\n","sourceOld":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    JettySolrRunner overseerNode = null;\n    int index = -1;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        index = i;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    cluster.stopJettySolrRunner(index);\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n\n  }\n\n","bugFix":null,"bugIntro":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c66470e527299cc148ad0b3441d08dfb7cb9e03","date":1576859740,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","sourceNew":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    log.info(\"Overseer Status indicates that the overseer is: {}\");\n    JettySolrRunner overseerNode = null;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    log.info(\"Stopping Overseer Node: {} ({})\", overseerNode.getNodeName(), overseerNode.getLocalPort());\n    cluster.stopJettySolrRunner(overseerNode);\n    log.info(\"Waiting for new overseer election...\");\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        log.info(\"...new overseer is: {}\", newLeader);\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n\n    // TODO: replace this polling logic with a LogWatcher that uses a queue we can await() on...\n    log.info(\"Polling for log watcher to detect expected log messages...\");\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          log.info(\"Found re-indexing message: {}\", doc.getFieldValue(\"message\"));\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          log.info(\"Found timestamp message: {}\", doc.getFieldValue(\"message\"));\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    log.info(\"Done polling log watcher: foundWarning={} foundSchemaWarning={}\", foundWarning, foundSchemaWarning);\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n  }\n\n","sourceOld":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    JettySolrRunner overseerNode = null;\n    int index = -1;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        index = i;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    cluster.stopJettySolrRunner(index);\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6afb0ba86024b96e8b34cfc2e15562239dc36360","date":1579768208,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","sourceNew":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    log.info(\"Overseer Status indicates that the overseer is: {}\", leader);\n    JettySolrRunner overseerNode = null;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    log.info(\"Stopping Overseer Node: {} ({})\", overseerNode.getNodeName(), overseerNode.getLocalPort());\n    cluster.stopJettySolrRunner(overseerNode);\n    log.info(\"Waiting for new overseer election...\");\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        log.info(\"...new overseer is: {}\", newLeader);\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n\n    // TODO: replace this polling logic with a LogWatcher that uses a queue we can await() on...\n    log.info(\"Polling for log watcher to detect expected log messages...\");\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          log.info(\"Found re-indexing message: {}\", doc.getFieldValue(\"message\"));\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          log.info(\"Found timestamp message: {}\", doc.getFieldValue(\"message\"));\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    log.info(\"Done polling log watcher: foundWarning={} foundSchemaWarning={}\", foundWarning, foundSchemaWarning);\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n  }\n\n","sourceOld":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    log.info(\"Overseer Status indicates that the overseer is: {}\");\n    JettySolrRunner overseerNode = null;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    log.info(\"Stopping Overseer Node: {} ({})\", overseerNode.getNodeName(), overseerNode.getLocalPort());\n    cluster.stopJettySolrRunner(overseerNode);\n    log.info(\"Waiting for new overseer election...\");\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        log.info(\"...new overseer is: {}\", newLeader);\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n\n    // TODO: replace this polling logic with a LogWatcher that uses a queue we can await() on...\n    log.info(\"Polling for log watcher to detect expected log messages...\");\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          log.info(\"Found re-indexing message: {}\", doc.getFieldValue(\"message\"));\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          log.info(\"Found timestamp message: {}\", doc.getFieldValue(\"message\"));\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    log.info(\"Done polling log watcher: foundWarning={} foundSchemaWarning={}\", foundWarning, foundSchemaWarning);\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n  }\n\n","bugFix":["7966b40769a3ff0bc1b524c2a1c1fce09d4b2794"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","sourceNew":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    log.info(\"Overseer Status indicates that the overseer is: {}\", leader);\n    JettySolrRunner overseerNode = null;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    if (log.isInfoEnabled()) {\n      log.info(\"Stopping Overseer Node: {} ({})\", overseerNode.getNodeName(), overseerNode.getLocalPort());\n    }\n    cluster.stopJettySolrRunner(overseerNode);\n    log.info(\"Waiting for new overseer election...\");\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        log.info(\"...new overseer is: {}\", newLeader);\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n\n    // TODO: replace this polling logic with a LogWatcher that uses a queue we can await() on...\n    log.info(\"Polling for log watcher to detect expected log messages...\");\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Found re-indexing message: {}\", doc.getFieldValue(\"message\"));\n          }\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Found timestamp message: {}\", doc.getFieldValue(\"message\"));\n          }\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    log.info(\"Done polling log watcher: foundWarning={} foundSchemaWarning={}\", foundWarning, foundSchemaWarning);\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n  }\n\n","sourceOld":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    log.info(\"Overseer Status indicates that the overseer is: {}\", leader);\n    JettySolrRunner overseerNode = null;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    log.info(\"Stopping Overseer Node: {} ({})\", overseerNode.getNodeName(), overseerNode.getLocalPort());\n    cluster.stopJettySolrRunner(overseerNode);\n    log.info(\"Waiting for new overseer election...\");\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        log.info(\"...new overseer is: {}\", newLeader);\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n\n    // TODO: replace this polling logic with a LogWatcher that uses a queue we can await() on...\n    log.info(\"Polling for log watcher to detect expected log messages...\");\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          log.info(\"Found re-indexing message: {}\", doc.getFieldValue(\"message\"));\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          log.info(\"Found timestamp message: {}\", doc.getFieldValue(\"message\"));\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    log.info(\"Done polling log watcher: foundWarning={} foundSchemaWarning={}\", foundWarning, foundSchemaWarning);\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SystemCollectionCompatTest#testBackCompat().mjava","sourceNew":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    log.info(\"Overseer Status indicates that the overseer is: {}\", leader);\n    JettySolrRunner overseerNode = null;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    @SuppressWarnings({\"rawtypes\"})\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    if (log.isInfoEnabled()) {\n      log.info(\"Stopping Overseer Node: {} ({})\", overseerNode.getNodeName(), overseerNode.getLocalPort());\n    }\n    cluster.stopJettySolrRunner(overseerNode);\n    log.info(\"Waiting for new overseer election...\");\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        log.info(\"...new overseer is: {}\", newLeader);\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n\n    // TODO: replace this polling logic with a LogWatcher that uses a queue we can await() on...\n    log.info(\"Polling for log watcher to detect expected log messages...\");\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Found re-indexing message: {}\", doc.getFieldValue(\"message\"));\n          }\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Found timestamp message: {}\", doc.getFieldValue(\"message\"));\n          }\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    log.info(\"Done polling log watcher: foundWarning={} foundSchemaWarning={}\", foundWarning, foundSchemaWarning);\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n  }\n\n","sourceOld":"  @Test\n  public void testBackCompat() throws Exception {\n    CollectionAdminRequest.OverseerStatus status = new CollectionAdminRequest.OverseerStatus();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminResponse adminResponse = status.process(solrClient);\n    NamedList<Object> response = adminResponse.getResponse();\n    String leader = (String) response.get(\"leader\");\n    log.info(\"Overseer Status indicates that the overseer is: {}\", leader);\n    JettySolrRunner overseerNode = null;\n    List<JettySolrRunner> jettySolrRunners = cluster.getJettySolrRunners();\n    for (int i = 0; i < jettySolrRunners.size(); i++) {\n      JettySolrRunner runner = jettySolrRunners.get(i);\n      if (runner.getNodeName().equals(leader)) {\n        overseerNode = runner;\n        break;\n      }\n    }\n    assertNotNull(overseerNode);\n    LogWatcherConfig watcherCfg = new LogWatcherConfig(true, null, \"WARN\", 100);\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(watcherCfg, null);\n\n    watcher.reset();\n\n    // restart Overseer to trigger the back-compat check\n    if (log.isInfoEnabled()) {\n      log.info(\"Stopping Overseer Node: {} ({})\", overseerNode.getNodeName(), overseerNode.getLocalPort());\n    }\n    cluster.stopJettySolrRunner(overseerNode);\n    log.info(\"Waiting for new overseer election...\");\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    while (!timeOut.hasTimedOut()) {\n      adminResponse = status.process(solrClient);\n      response = adminResponse.getResponse();\n      String newLeader = (String) response.get(\"leader\");\n      if (newLeader != null && !leader.equals(newLeader)) {\n        log.info(\"...new overseer is: {}\", newLeader);\n        break;\n      }\n      timeOut.sleep(200);\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"time out waiting for new Overseer leader\");\n    }\n\n    TimeOut timeOut1 = new TimeOut(60, TimeUnit.SECONDS, cloudManager.getTimeSource());\n    boolean foundWarning = false;\n    boolean foundSchemaWarning = false;\n\n    // TODO: replace this polling logic with a LogWatcher that uses a queue we can await() on...\n    log.info(\"Polling for log watcher to detect expected log messages...\");\n    while (!timeOut1.hasTimedOut()) {\n      timeOut1.sleep(1000);\n      SolrDocumentList history = watcher.getHistory(-1, null);\n      for (SolrDocument doc : history) {\n        if (!Overseer.class.getName().equals(doc.getFieldValue(\"logger\"))) {\n          continue;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"re-indexing\")) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Found re-indexing message: {}\", doc.getFieldValue(\"message\"));\n          }\n          foundWarning = true;\n        }\n        if (doc.getFieldValue(\"message\").toString().contains(\"timestamp\")) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Found timestamp message: {}\", doc.getFieldValue(\"message\"));\n          }\n          foundSchemaWarning = true;\n        }\n      }\n      if (foundWarning && foundSchemaWarning) {\n        break;\n      }\n    }\n    log.info(\"Done polling log watcher: foundWarning={} foundSchemaWarning={}\", foundWarning, foundSchemaWarning);\n    assertTrue(\"re-indexing warning not found\", foundWarning);\n    assertTrue(\"timestamp field incompatibility warning not found\", foundSchemaWarning);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7966b40769a3ff0bc1b524c2a1c1fce09d4b2794":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["7966b40769a3ff0bc1b524c2a1c1fce09d4b2794"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":["dad6a48950aafc9c2f5dc54740f8c6ab81304203","7966b40769a3ff0bc1b524c2a1c1fce09d4b2794"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"]},"commit2Childs":{"7966b40769a3ff0bc1b524c2a1c1fce09d4b2794":["6afb0ba86024b96e8b34cfc2e15562239dc36360","4c66470e527299cc148ad0b3441d08dfb7cb9e03"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["7966b40769a3ff0bc1b524c2a1c1fce09d4b2794","4c66470e527299cc148ad0b3441d08dfb7cb9e03"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}