{"path":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","commits":[{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n\n          if (arc.label == FST.END_LABEL) {\n            // Skip it -- prior recursion took this into account already\n            assert !arc.isLast();\n            fst.readNextArc(arc);\n          }\n\n          while (true) {\n\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n               stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), arc.isFinal() ? finalStateShape : stateShape, stateColor, finalOutput);\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n\n          if (arc.label == FST.END_LABEL) {\n            // Skip it -- prior recursion took this into account already\n            assert !arc.isLast();\n            fst.readNextArc(arc);\n          }\n\n          while (true) {\n\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n               stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), arc.isFinal() ? finalStateShape : stateShape, stateColor, finalOutput);\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n\n          if (arc.label == FST.END_LABEL) {\n            // Skip it -- prior recursion took this into account already\n            assert !arc.isLast();\n            fst.readNextArc(arc);\n          }\n\n          while (true) {\n\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n               stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), arc.isFinal() ? finalStateShape : stateShape, stateColor, finalOutput);\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n\n          if (arc.label == FST.END_LABEL) {\n            // Skip it -- prior recursion took this into account already\n            assert !arc.isLast();\n            fst.readNextArc(arc);\n          }\n\n          while (true) {\n\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n               stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), arc.isFinal() ? finalStateShape : stateShape, stateColor, finalOutput);\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["60ba444201d2570214b6fcf1d15600dc1a01f548","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["60ba444201d2570214b6fcf1d15600dc1a01f548","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["60ba444201d2570214b6fcf1d15600dc1a01f548","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["817882884229bace7dc5d1b75f6b0e4aa1e47122","3a119bbc8703c10faa329ec201c654b3a35a1e3e","5b6fdfce35d0adb18836cf8711abe487a934df33"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8be6e1e4fbbc94d90b78f175c03ff389b6949373","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","5b6fdfce35d0adb18836cf8711abe487a934df33","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}