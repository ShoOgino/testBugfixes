{"path":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByMapReduce(String,String,Properties,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String).mjava","commits":[{"id":"36b1ce25b5b465615c00f409ce694664abbe7bd2","date":1481836328,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByMapReduce(String,String,Properties,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String).mjava","pathOld":"/dev/null","sourceNew":"  private TupleStream handleGroupByMapReduce(String zk,\n                                             String collection,\n                                             Properties properties,\n                                             final List<Map.Entry<String, Class>> fields,\n                                             final String query,\n                                             final List<Pair<String, String>> orders,\n                                             final List<String> _buckets,\n                                             final List<Pair<String, String>> metricPairs,\n                                             final String limit) throws IOException {\n\n    int numWorkers = Integer.parseInt(properties.getProperty(\"numWorkers\", \"1\"));\n\n    Bucket[] buckets = buildBuckets(_buckets, fields);\n    Metric[] metrics = buildMetrics(metricPairs).toArray(new Metric[0]);\n\n    Set<String> fieldSet = getFieldSet(metrics, fields);\n\n    if(metrics.length == 0) {\n      throw new IOException(\"Group by queries must include atleast one aggregate function.\");\n    }\n\n    String fl = getFields(fieldSet);\n    String sortDirection = getSortDirection(orders);\n    String sort = bucketSort(buckets, sortDirection);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    params.set(CommonParams.FL, fl);\n    params.set(CommonParams.Q, query);\n    //Always use the /export handler for Group By Queries because it requires exporting full result sets.\n    params.set(CommonParams.QT, \"/export\");\n\n    if(numWorkers > 1) {\n      params.set(\"partitionKeys\", getPartitionKeys(buckets));\n    }\n\n    params.set(\"sort\", sort);\n\n    TupleStream tupleStream = null;\n\n    CloudSolrStream cstream = new CloudSolrStream(zk, collection, params);\n    tupleStream = new RollupStream(cstream, buckets, metrics);\n\n    if(numWorkers > 1) {\n      // Do the rollups in parallel\n      // Maintain the sort of the Tuples coming from the workers.\n      StreamComparator comp = bucketSortComp(buckets, sortDirection);\n      ParallelStream parallelStream = new ParallelStream(zk, collection, tupleStream, numWorkers, comp);\n\n      StreamFactory factory = new StreamFactory()\n          .withFunctionName(\"search\", CloudSolrStream.class)\n          .withFunctionName(\"parallel\", ParallelStream.class)\n          .withFunctionName(\"rollup\", RollupStream.class)\n          .withFunctionName(\"sum\", SumMetric.class)\n          .withFunctionName(\"min\", MinMetric.class)\n          .withFunctionName(\"max\", MaxMetric.class)\n          .withFunctionName(\"avg\", MeanMetric.class)\n          .withFunctionName(\"count\", CountMetric.class);\n\n      parallelStream.setStreamFactory(factory);\n      tupleStream = parallelStream;\n    }\n\n    //TODO: This should be done on the workers, but it won't serialize because it relies on Presto classes.\n    // Once we make this a Expressionable the problem will be solved.\n\n\n    if(orders != null && orders.size() > 0) {\n      int lim = limit == null ? 100 : Integer.parseInt(limit);\n      if(!sortsEqual(buckets, sortDirection, orders)) {\n        StreamComparator comp = getComp(orders);\n        //Rank the Tuples\n        //If parallel stream is used ALL the Rolled up tuples from the workers will be ranked\n        //Providing a true Top or Bottom.\n        tupleStream = new RankStream(tupleStream, lim, comp);\n      } else {\n        // Sort is the same as the same as the underlying stream\n        // Only need to limit the result, not Rank the result\n        if(lim > -1) {\n          tupleStream = new LimitStream(tupleStream, lim);\n        }\n      }\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e4e643056790ca1e73898892ffb5b50ae883232","date":1486576891,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByMapReduce(String,String,Properties,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByMapReduce(String,String,Properties,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String).mjava","sourceNew":"  private TupleStream handleGroupByMapReduce(String zk,\n                                             String collection,\n                                             Properties properties,\n                                             final List<Map.Entry<String, Class>> fields,\n                                             final String query,\n                                             final List<Pair<String, String>> orders,\n                                             final List<String> _buckets,\n                                             final List<Pair<String, String>> metricPairs,\n                                             final String limit) throws IOException {\n\n    int numWorkers = Integer.parseInt(properties.getProperty(\"numWorkers\", \"1\"));\n\n    Bucket[] buckets = buildBuckets(_buckets, fields);\n    Metric[] metrics = buildMetrics(metricPairs).toArray(new Metric[0]);\n\n    Set<String> fieldSet = getFieldSet(metrics, fields);\n\n    if(metrics.length == 0) {\n      throw new IOException(\"Group by queries must include atleast one aggregate function.\");\n    }\n\n    String fl = getFields(fieldSet);\n    String sortDirection = getSortDirection(orders);\n    String sort = bucketSort(buckets, sortDirection);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    params.set(CommonParams.FL, fl);\n    params.set(CommonParams.Q, query);\n    //Always use the /export handler for Group By Queries because it requires exporting full result sets.\n    params.set(CommonParams.QT, \"/export\");\n\n    if(numWorkers > 1) {\n      params.set(\"partitionKeys\", getPartitionKeys(buckets));\n    }\n\n    params.set(\"sort\", sort);\n\n    TupleStream tupleStream = null;\n\n    CloudSolrStream cstream = new CloudSolrStream(zk, collection, params);\n    tupleStream = new RollupStream(cstream, buckets, metrics);\n\n    if(numWorkers > 1) {\n      // Do the rollups in parallel\n      // Maintain the sort of the Tuples coming from the workers.\n      StreamComparator comp = bucketSortComp(buckets, sortDirection);\n      ParallelStream parallelStream = new ParallelStream(zk, collection, tupleStream, numWorkers, comp);\n\n      StreamFactory factory = new StreamFactory()\n          .withFunctionName(\"search\", CloudSolrStream.class)\n          .withFunctionName(\"parallel\", ParallelStream.class)\n          .withFunctionName(\"rollup\", RollupStream.class)\n          .withFunctionName(\"sum\", SumMetric.class)\n          .withFunctionName(\"min\", MinMetric.class)\n          .withFunctionName(\"max\", MaxMetric.class)\n          .withFunctionName(\"avg\", MeanMetric.class)\n          .withFunctionName(\"count\", CountMetric.class);\n\n      parallelStream.setStreamFactory(factory);\n      tupleStream = parallelStream;\n    }\n\n    //TODO: Currently we are not pushing down the having clause.\n    //      We need to push down the having clause to ensure that LIMIT does not cut off records prior to the having filter.\n\n    if(orders != null && orders.size() > 0) {\n      if(!sortsEqual(buckets, sortDirection, orders)) {\n        int lim = (limit == null) ? 100 : Integer.parseInt(limit);\n        StreamComparator comp = getComp(orders);\n        //Rank the Tuples\n        //If parallel stream is used ALL the Rolled up tuples from the workers will be ranked\n        //Providing a true Top or Bottom.\n        tupleStream = new RankStream(tupleStream, lim, comp);\n      } else {\n        // Sort is the same as the same as the underlying stream\n        // Only need to limit the result, not Rank the result\n        if(limit != null) {\n          tupleStream = new LimitStream(tupleStream, Integer.parseInt(limit));\n        }\n      }\n    } else {\n      //No order by, check for limit\n      if(limit != null) {\n        tupleStream = new LimitStream(tupleStream, Integer.parseInt(limit));\n      }\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByMapReduce(String zk,\n                                             String collection,\n                                             Properties properties,\n                                             final List<Map.Entry<String, Class>> fields,\n                                             final String query,\n                                             final List<Pair<String, String>> orders,\n                                             final List<String> _buckets,\n                                             final List<Pair<String, String>> metricPairs,\n                                             final String limit) throws IOException {\n\n    int numWorkers = Integer.parseInt(properties.getProperty(\"numWorkers\", \"1\"));\n\n    Bucket[] buckets = buildBuckets(_buckets, fields);\n    Metric[] metrics = buildMetrics(metricPairs).toArray(new Metric[0]);\n\n    Set<String> fieldSet = getFieldSet(metrics, fields);\n\n    if(metrics.length == 0) {\n      throw new IOException(\"Group by queries must include atleast one aggregate function.\");\n    }\n\n    String fl = getFields(fieldSet);\n    String sortDirection = getSortDirection(orders);\n    String sort = bucketSort(buckets, sortDirection);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    params.set(CommonParams.FL, fl);\n    params.set(CommonParams.Q, query);\n    //Always use the /export handler for Group By Queries because it requires exporting full result sets.\n    params.set(CommonParams.QT, \"/export\");\n\n    if(numWorkers > 1) {\n      params.set(\"partitionKeys\", getPartitionKeys(buckets));\n    }\n\n    params.set(\"sort\", sort);\n\n    TupleStream tupleStream = null;\n\n    CloudSolrStream cstream = new CloudSolrStream(zk, collection, params);\n    tupleStream = new RollupStream(cstream, buckets, metrics);\n\n    if(numWorkers > 1) {\n      // Do the rollups in parallel\n      // Maintain the sort of the Tuples coming from the workers.\n      StreamComparator comp = bucketSortComp(buckets, sortDirection);\n      ParallelStream parallelStream = new ParallelStream(zk, collection, tupleStream, numWorkers, comp);\n\n      StreamFactory factory = new StreamFactory()\n          .withFunctionName(\"search\", CloudSolrStream.class)\n          .withFunctionName(\"parallel\", ParallelStream.class)\n          .withFunctionName(\"rollup\", RollupStream.class)\n          .withFunctionName(\"sum\", SumMetric.class)\n          .withFunctionName(\"min\", MinMetric.class)\n          .withFunctionName(\"max\", MaxMetric.class)\n          .withFunctionName(\"avg\", MeanMetric.class)\n          .withFunctionName(\"count\", CountMetric.class);\n\n      parallelStream.setStreamFactory(factory);\n      tupleStream = parallelStream;\n    }\n\n    //TODO: This should be done on the workers, but it won't serialize because it relies on Presto classes.\n    // Once we make this a Expressionable the problem will be solved.\n\n\n    if(orders != null && orders.size() > 0) {\n      int lim = limit == null ? 100 : Integer.parseInt(limit);\n      if(!sortsEqual(buckets, sortDirection, orders)) {\n        StreamComparator comp = getComp(orders);\n        //Rank the Tuples\n        //If parallel stream is used ALL the Rolled up tuples from the workers will be ranked\n        //Providing a true Top or Bottom.\n        tupleStream = new RankStream(tupleStream, lim, comp);\n      } else {\n        // Sort is the same as the same as the underlying stream\n        // Only need to limit the result, not Rank the result\n        if(lim > -1) {\n          tupleStream = new LimitStream(tupleStream, lim);\n        }\n      }\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5cb41f0427fb7a75b0bfefe992561738c11fd80","date":1486576891,"type":5,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByMapReduce(String,String,Properties,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByMapReduce(String,String,Properties,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String).mjava","sourceNew":"  private TupleStream handleGroupByMapReduce(String zk,\n                                             String collection,\n                                             Properties properties,\n                                             final List<Map.Entry<String, Class>> fields,\n                                             final String query,\n                                             final List<Pair<String, String>> orders,\n                                             final List<String> _buckets,\n                                             final List<Pair<String, String>> metricPairs,\n                                             final String limit,\n                                             final String havingPredicate) throws IOException {\n\n    int numWorkers = Integer.parseInt(properties.getProperty(\"numWorkers\", \"1\"));\n\n    Bucket[] buckets = buildBuckets(_buckets, fields);\n    Metric[] metrics = buildMetrics(metricPairs).toArray(new Metric[0]);\n\n    Set<String> fieldSet = getFieldSet(metrics, fields);\n\n    if(metrics.length == 0) {\n      throw new IOException(\"Group by queries must include atleast one aggregate function.\");\n    }\n\n    String fl = getFields(fieldSet);\n    String sortDirection = getSortDirection(orders);\n    String sort = bucketSort(buckets, sortDirection);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    params.set(CommonParams.FL, fl);\n    params.set(CommonParams.Q, query);\n    //Always use the /export handler for Group By Queries because it requires exporting full result sets.\n    params.set(CommonParams.QT, \"/export\");\n\n    if(numWorkers > 1) {\n      params.set(\"partitionKeys\", getPartitionKeys(buckets));\n    }\n\n    params.set(\"sort\", sort);\n\n    TupleStream tupleStream = null;\n\n    CloudSolrStream cstream = new CloudSolrStream(zk, collection, params);\n    tupleStream = new RollupStream(cstream, buckets, metrics);\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndOperation.class)\n        .withFunctionName(\"or\", OrOperation.class)\n        .withFunctionName(\"not\", NotOperation.class)\n        .withFunctionName(\"eq\", EqualsOperation.class)\n        .withFunctionName(\"gt\", GreaterThanOperation.class)\n        .withFunctionName(\"lt\", LessThanOperation.class)\n        .withFunctionName(\"lteq\", LessThanEqualToOperation.class)\n        .withFunctionName(\"having\", HavingStream.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToOperation.class);\n\n    if(havingPredicate != null) {\n      BooleanOperation booleanOperation = (BooleanOperation)factory.constructOperation(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(numWorkers > 1) {\n      // Do the rollups in parallel\n      // Maintain the sort of the Tuples coming from the workers.\n      StreamComparator comp = bucketSortComp(buckets, sortDirection);\n      ParallelStream parallelStream = new ParallelStream(zk, collection, tupleStream, numWorkers, comp);\n\n\n      parallelStream.setStreamFactory(factory);\n      tupleStream = parallelStream;\n    }\n\n    //TODO: Currently we are not pushing down the having clause.\n    //      We need to push down the having clause to ensure that LIMIT does not cut off records prior to the having filter.\n\n    if(orders != null && orders.size() > 0) {\n      if(!sortsEqual(buckets, sortDirection, orders)) {\n        int lim = (limit == null) ? 100 : Integer.parseInt(limit);\n        StreamComparator comp = getComp(orders);\n        //Rank the Tuples\n        //If parallel stream is used ALL the Rolled up tuples from the workers will be ranked\n        //Providing a true Top or Bottom.\n        tupleStream = new RankStream(tupleStream, lim, comp);\n      } else {\n        // Sort is the same as the same as the underlying stream\n        // Only need to limit the result, not Rank the result\n        if(limit != null) {\n          tupleStream = new LimitStream(tupleStream, Integer.parseInt(limit));\n        }\n      }\n    } else {\n      //No order by, check for limit\n      if(limit != null) {\n        tupleStream = new LimitStream(tupleStream, Integer.parseInt(limit));\n      }\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByMapReduce(String zk,\n                                             String collection,\n                                             Properties properties,\n                                             final List<Map.Entry<String, Class>> fields,\n                                             final String query,\n                                             final List<Pair<String, String>> orders,\n                                             final List<String> _buckets,\n                                             final List<Pair<String, String>> metricPairs,\n                                             final String limit) throws IOException {\n\n    int numWorkers = Integer.parseInt(properties.getProperty(\"numWorkers\", \"1\"));\n\n    Bucket[] buckets = buildBuckets(_buckets, fields);\n    Metric[] metrics = buildMetrics(metricPairs).toArray(new Metric[0]);\n\n    Set<String> fieldSet = getFieldSet(metrics, fields);\n\n    if(metrics.length == 0) {\n      throw new IOException(\"Group by queries must include atleast one aggregate function.\");\n    }\n\n    String fl = getFields(fieldSet);\n    String sortDirection = getSortDirection(orders);\n    String sort = bucketSort(buckets, sortDirection);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    params.set(CommonParams.FL, fl);\n    params.set(CommonParams.Q, query);\n    //Always use the /export handler for Group By Queries because it requires exporting full result sets.\n    params.set(CommonParams.QT, \"/export\");\n\n    if(numWorkers > 1) {\n      params.set(\"partitionKeys\", getPartitionKeys(buckets));\n    }\n\n    params.set(\"sort\", sort);\n\n    TupleStream tupleStream = null;\n\n    CloudSolrStream cstream = new CloudSolrStream(zk, collection, params);\n    tupleStream = new RollupStream(cstream, buckets, metrics);\n\n    if(numWorkers > 1) {\n      // Do the rollups in parallel\n      // Maintain the sort of the Tuples coming from the workers.\n      StreamComparator comp = bucketSortComp(buckets, sortDirection);\n      ParallelStream parallelStream = new ParallelStream(zk, collection, tupleStream, numWorkers, comp);\n\n      StreamFactory factory = new StreamFactory()\n          .withFunctionName(\"search\", CloudSolrStream.class)\n          .withFunctionName(\"parallel\", ParallelStream.class)\n          .withFunctionName(\"rollup\", RollupStream.class)\n          .withFunctionName(\"sum\", SumMetric.class)\n          .withFunctionName(\"min\", MinMetric.class)\n          .withFunctionName(\"max\", MaxMetric.class)\n          .withFunctionName(\"avg\", MeanMetric.class)\n          .withFunctionName(\"count\", CountMetric.class);\n\n      parallelStream.setStreamFactory(factory);\n      tupleStream = parallelStream;\n    }\n\n    //TODO: Currently we are not pushing down the having clause.\n    //      We need to push down the having clause to ensure that LIMIT does not cut off records prior to the having filter.\n\n    if(orders != null && orders.size() > 0) {\n      if(!sortsEqual(buckets, sortDirection, orders)) {\n        int lim = (limit == null) ? 100 : Integer.parseInt(limit);\n        StreamComparator comp = getComp(orders);\n        //Rank the Tuples\n        //If parallel stream is used ALL the Rolled up tuples from the workers will be ranked\n        //Providing a true Top or Bottom.\n        tupleStream = new RankStream(tupleStream, lim, comp);\n      } else {\n        // Sort is the same as the same as the underlying stream\n        // Only need to limit the result, not Rank the result\n        if(limit != null) {\n          tupleStream = new LimitStream(tupleStream, Integer.parseInt(limit));\n        }\n      }\n    } else {\n      //No order by, check for limit\n      if(limit != null) {\n        tupleStream = new LimitStream(tupleStream, Integer.parseInt(limit));\n      }\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d5cb41f0427fb7a75b0bfefe992561738c11fd80":["3e4e643056790ca1e73898892ffb5b50ae883232"],"3e4e643056790ca1e73898892ffb5b50ae883232":["36b1ce25b5b465615c00f409ce694664abbe7bd2"],"36b1ce25b5b465615c00f409ce694664abbe7bd2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"d5cb41f0427fb7a75b0bfefe992561738c11fd80":[],"3e4e643056790ca1e73898892ffb5b50ae883232":["d5cb41f0427fb7a75b0bfefe992561738c11fd80"],"36b1ce25b5b465615c00f409ce694664abbe7bd2":["3e4e643056790ca1e73898892ffb5b50ae883232"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["36b1ce25b5b465615c00f409ce694664abbe7bd2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d5cb41f0427fb7a75b0bfefe992561738c11fd80","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}