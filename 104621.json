{"path":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","commits":[{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        initDataOut(context);\n        success = true;\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String).mjava","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        initDataOut(context);\n        success = true;\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n      }\n    }\n  }\n\n","sourceOld":"  IndexOutput createOutput(String name) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        initDataOut();\n        success = true;\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String).mjava","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        initDataOut(context);\n        success = true;\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n      }\n    }\n  }\n\n","sourceOld":"  IndexOutput createOutput(String name) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        initDataOut();\n        success = true;\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb18dddc5f47fbf80dac395dde293655d5ad74db","date":1310299358,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n        outputLocked = true;\n        success = true;\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        initDataOut(context);\n        success = true;\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["192b1af72d46f8ec1d673363fec4d005e9a53c83"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n        outputLocked = true;\n        success = true;\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n        outputLocked = true;\n        success = true;\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f6e3376a314fcc2b31bc46d399c2ff23552b78d6","date":1325780477,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        out = new DirectCFSIndexOutput(getOutput(), entry, false);\n        outputLocked = true;\n        success = true;\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        out = new DirectCFSIndexOutput(dataOut, entry, false);\n        outputLocked = true;\n        success = true;\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"192b1af72d46f8ec1d673363fec4d005e9a53c83","date":1327173041,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if ((outputLocked = outputTaken.compareAndSet(false, true))) {\n        out = new DirectCFSIndexOutput(getOutput(), entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        out = new DirectCFSIndexOutput(getOutput(), entry, false);\n        outputLocked = true;\n        success = true;\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","bugFix":["0aab6e810b4b0d3743d6a048be0602801f4b3920","bb18dddc5f47fbf80dac395dde293655d5ad74db"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if ((outputLocked = outputTaken.compareAndSet(false, true))) {\n        out = new DirectCFSIndexOutput(getOutput(), entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if (outputTaken.compareAndSet(false, true)) {\n        out = new DirectCFSIndexOutput(getOutput(), entry, false);\n        outputLocked = true;\n        success = true;\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileWriter#createOutput(String,IOContext).mjava","sourceNew":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if ((outputLocked = outputTaken.compareAndSet(false, true))) {\n        out = new DirectCFSIndexOutput(getOutput(), entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  IndexOutput createOutput(String name, IOContext context) throws IOException {\n    ensureOpen();\n    boolean success = false;\n    boolean outputLocked = false;\n    try {\n      assert name != null : \"name must not be null\";\n      if (entries.containsKey(name)) {\n        throw new IllegalArgumentException(\"File \" + name + \" already exists\");\n      }\n      final FileEntry entry = new FileEntry();\n      entry.file = name;\n      entries.put(name, entry);\n      final String id = IndexFileNames.stripSegmentName(name);\n      assert !seenIDs.contains(id): \"file=\\\"\" + name + \"\\\" maps to id=\\\"\" + id + \"\\\", which was already written\";\n      seenIDs.add(id);\n      final DirectCFSIndexOutput out;\n      if ((outputLocked = outputTaken.compareAndSet(false, true))) {\n        out = new DirectCFSIndexOutput(getOutput(), entry, false);\n      } else {\n        entry.dir = this.directory;\n        if (directory.fileExists(name)) {\n          throw new IOException(\"File already exists\");\n        }\n        out = new DirectCFSIndexOutput(directory.createOutput(name, context), entry,\n            true);\n      }\n      success = true;\n      return out;\n    } finally {\n      if (!success) {\n        entries.remove(name);\n        if (outputLocked) { // release the output lock if not successful\n          assert outputTaken.get();\n          releaseOutputLock();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["bb18dddc5f47fbf80dac395dde293655d5ad74db"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["192b1af72d46f8ec1d673363fec4d005e9a53c83"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["f6e3376a314fcc2b31bc46d399c2ff23552b78d6","192b1af72d46f8ec1d673363fec4d005e9a53c83"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"bb18dddc5f47fbf80dac395dde293655d5ad74db":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"f6e3376a314fcc2b31bc46d399c2ff23552b78d6":["7b91922b55d15444d554721b352861d028eb8278"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"192b1af72d46f8ec1d673363fec4d005e9a53c83":["f6e3376a314fcc2b31bc46d399c2ff23552b78d6"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["f6e3376a314fcc2b31bc46d399c2ff23552b78d6"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5d004d0e0b3f65bb40da76d476d659d7888270e8","ddc4c914be86e34b54f70023f45a60fa7f04e929","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["5d004d0e0b3f65bb40da76d476d659d7888270e8","bb18dddc5f47fbf80dac395dde293655d5ad74db"],"bb18dddc5f47fbf80dac395dde293655d5ad74db":["7b91922b55d15444d554721b352861d028eb8278"],"f6e3376a314fcc2b31bc46d399c2ff23552b78d6":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","192b1af72d46f8ec1d673363fec4d005e9a53c83"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"192b1af72d46f8ec1d673363fec4d005e9a53c83":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}