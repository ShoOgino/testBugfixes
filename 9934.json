{"path":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","commits":[{"id":"954ae83b7dfacaa33d48ea056448ae11f7745a93","date":1571867711,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","pathOld":"/dev/null","sourceNew":"    @Command(name = \"add\")\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN).add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"856d72a5f63c995cad4c6fd92b7c121aa140285c","date":1572845901,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","pathOld":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","sourceNew":"    @Command(name = \"add\")\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN).add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() ;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","sourceOld":"    @Command(name = \"add\")\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN).add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc09d7c591d6661c79bcdfd1c661da97e638804d","date":1574295916,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","pathOld":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","sourceNew":"    @Command(name = \"add\")\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          List list = packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN);\n          for (Object o : list) {\n            if (o instanceof PkgVersion) {\n              PkgVersion version = (PkgVersion) o;\n              if (Objects.equals(version.version, add.version)) {\n                payload.addError(\"Version '\" + add.version + \"' exists already\");\n                return null;\n              }\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","sourceOld":"    @Command(name = \"add\")\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN).add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() ;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","pathOld":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","sourceNew":"    @Command(name = \"add\")\n    @SuppressWarnings({\"unchecked\"})\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          @SuppressWarnings({\"rawtypes\"})\n          List list = packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN);\n          for (Object o : list) {\n            if (o instanceof PkgVersion) {\n              PkgVersion version = (PkgVersion) o;\n              if (Objects.equals(version.version, add.version)) {\n                payload.addError(\"Version '\" + add.version + \"' exists already\");\n                return null;\n              }\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","sourceOld":"    @Command(name = \"add\")\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          List list = packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN);\n          for (Object o : list) {\n            if (o instanceof PkgVersion) {\n              PkgVersion version = (PkgVersion) o;\n              if (Objects.equals(version.version, add.version)) {\n                payload.addError(\"Version '\" + add.version + \"' exists already\");\n                return null;\n              }\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fbcc7055e8c549bce2c868275542860dba71a0e","date":1593065764,"type":5,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(PayloadObj[Package.AddVersion]).mjava","pathOld":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","sourceNew":"    @Command(name = \"add\")\n    @SuppressWarnings({\"unchecked\"})\n    public void add(PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          @SuppressWarnings({\"rawtypes\"})\n          List list = packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN);\n          for (Object o : list) {\n            if (o instanceof PkgVersion) {\n              PkgVersion version = (PkgVersion) o;\n              if (Objects.equals(version.version, add.version)) {\n                payload.addError(\"Version '\" + add.version + \"' exists already\");\n                return null;\n              }\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","sourceOld":"    @Command(name = \"add\")\n    @SuppressWarnings({\"unchecked\"})\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          @SuppressWarnings({\"rawtypes\"})\n          List list = packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN);\n          for (Object o : list) {\n            if (o instanceof PkgVersion) {\n              PkgVersion version = (PkgVersion) o;\n              if (Objects.equals(version.version, add.version)) {\n                payload.addError(\"Version '\" + add.version + \"' exists already\");\n                return null;\n              }\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fbcc7055e8c549bce2c868275542860dba71a0e":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"856d72a5f63c995cad4c6fd92b7c121aa140285c":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fc09d7c591d6661c79bcdfd1c661da97e638804d":["856d72a5f63c995cad4c6fd92b7c121aa140285c"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["fc09d7c591d6661c79bcdfd1c661da97e638804d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9fbcc7055e8c549bce2c868275542860dba71a0e"]},"commit2Childs":{"9fbcc7055e8c549bce2c868275542860dba71a0e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["856d72a5f63c995cad4c6fd92b7c121aa140285c"],"856d72a5f63c995cad4c6fd92b7c121aa140285c":["fc09d7c591d6661c79bcdfd1c661da97e638804d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"fc09d7c591d6661c79bcdfd1c661da97e638804d":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["9fbcc7055e8c549bce2c868275542860dba71a0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}