{"path":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/kuromoji/util/BinaryDictionaryWriter#put(String[]).mjava","commits":[{"id":"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2","date":1326399048,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/kuromoji/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    String pos = sb.toString();\n    Integer posIndex = posDictLookup.get(pos);\n    if (posIndex == null) {\n      posIndex = posDict.size();\n      posDict.add(pos);\n      posDictLookup.put(pos, posIndex);\n      assert posDict.size() == posDictLookup.size();\n    }\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(entry[8]));\n    sb.append(',');\n    sb.append(CSVUtil.quoteEscape(entry[9]));\n    String inflData = sb.toString();\n    \n    Integer inflIndex = Integer.MAX_VALUE;\n    int hasInflData;\n    if (\"*,*\".equals(inflData)) {\n      hasInflData = 0; // no inflection data\n    } else {\n      hasInflData = 1;\n      inflIndex = inflDictLookup.get(inflData);\n      if (inflIndex == null) {\n        inflIndex = inflDict.size();\n        inflDict.add(inflData);\n        inflDictLookup.put(inflData, inflIndex);\n        assert inflDict.size() == inflDictLookup.size();\n      }\n    }\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: three short, 4 bytes, one vint and features (all as utf-16)\n    int worstCase = 6 + 4 + 2 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n    \n    buffer.putShort(leftId);\n    buffer.putShort(rightId);\n    buffer.putShort(wordCost);\n    assert posIndex.intValue() < 128;\n    buffer.put((byte) (posIndex.intValue() << 1 | hasInflData));\n    \n    int pronunciationIsReading = pronunciation.equals(reading) ? 1 : 0;\n    \n    if (\"*\".equals(baseForm) || baseForm.equals(entry[0])) {\n      buffer.put((byte)pronunciationIsReading); // base form is the same as surface form\n    } else {\n      assert baseForm.length() < 128;\n      buffer.put((byte)(baseForm.length() << 1 | pronunciationIsReading));\n      for (int i = 0; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if (isKatakana(reading)) {\n      buffer.put((byte) (reading.length() << 1 | 1));\n      writeKatakana(reading);\n    } else {\n      buffer.put((byte) (reading.length() << 1));\n      for (int i = 0; i < reading.length(); i++) {\n        buffer.putChar(reading.charAt(i));\n      }\n    }\n    \n    if (pronunciationIsReading == 0) {\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    if (hasInflData > 0) {\n      int key = inflIndex.intValue();\n      assert key < 32768; // note there are really like 300 of these...\n      if (key < 128) {\n        buffer.put((byte) key);\n      } else {\n        buffer.put((byte) ((key & 0x7f) | 0x80));\n        buffer.put((byte) (key >>> 7));\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a904819476fbc333a72b5914d82b948e7dab0205","date":1326741588,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/kuromoji/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/kuromoji/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 8192; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      buffer.put((byte) baseForm.length());\n      for (int i = 0; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if (isKatakana(reading)) {\n      buffer.put((byte) (reading.length() << 1 | 1));\n      writeKatakana(reading);\n    } else {\n      buffer.put((byte) (reading.length() << 1));\n      for (int i = 0; i < reading.length(); i++) {\n        buffer.putChar(reading.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    String pos = sb.toString();\n    Integer posIndex = posDictLookup.get(pos);\n    if (posIndex == null) {\n      posIndex = posDict.size();\n      posDict.add(pos);\n      posDictLookup.put(pos, posIndex);\n      assert posDict.size() == posDictLookup.size();\n    }\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(entry[8]));\n    sb.append(',');\n    sb.append(CSVUtil.quoteEscape(entry[9]));\n    String inflData = sb.toString();\n    \n    Integer inflIndex = Integer.MAX_VALUE;\n    int hasInflData;\n    if (\"*,*\".equals(inflData)) {\n      hasInflData = 0; // no inflection data\n    } else {\n      hasInflData = 1;\n      inflIndex = inflDictLookup.get(inflData);\n      if (inflIndex == null) {\n        inflIndex = inflDict.size();\n        inflDict.add(inflData);\n        inflDictLookup.put(inflData, inflIndex);\n        assert inflDict.size() == inflDictLookup.size();\n      }\n    }\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: three short, 4 bytes, one vint and features (all as utf-16)\n    int worstCase = 6 + 4 + 2 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n    \n    buffer.putShort(leftId);\n    buffer.putShort(rightId);\n    buffer.putShort(wordCost);\n    assert posIndex.intValue() < 128;\n    buffer.put((byte) (posIndex.intValue() << 1 | hasInflData));\n    \n    int pronunciationIsReading = pronunciation.equals(reading) ? 1 : 0;\n    \n    if (\"*\".equals(baseForm) || baseForm.equals(entry[0])) {\n      buffer.put((byte)pronunciationIsReading); // base form is the same as surface form\n    } else {\n      assert baseForm.length() < 128;\n      buffer.put((byte)(baseForm.length() << 1 | pronunciationIsReading));\n      for (int i = 0; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if (isKatakana(reading)) {\n      buffer.put((byte) (reading.length() << 1 | 1));\n      writeKatakana(reading);\n    } else {\n      buffer.put((byte) (reading.length() << 1));\n      for (int i = 0; i < reading.length(); i++) {\n        buffer.putChar(reading.charAt(i));\n      }\n    }\n    \n    if (pronunciationIsReading == 0) {\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    if (hasInflData > 0) {\n      int key = inflIndex.intValue();\n      assert key < 32768; // note there are really like 300 of these...\n      if (key < 128) {\n        buffer.put((byte) key);\n      } else {\n        buffer.put((byte) ((key & 0x7f) | 0x80));\n        buffer.put((byte) (key >>> 7));\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df594fa0daea908bb30c4f3a453f2bd0a55f9a1e","date":1326766347,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/kuromoji/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/kuromoji/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 4096; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      assert baseForm.length() < 16;\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 8192; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      buffer.put((byte) baseForm.length());\n      for (int i = 0; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if (isKatakana(reading)) {\n      buffer.put((byte) (reading.length() << 1 | 1));\n      writeKatakana(reading);\n    } else {\n      buffer.put((byte) (reading.length() << 1));\n      for (int i = 0; i < reading.length(); i++) {\n        buffer.putChar(reading.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d45c1ff2c99694b6de2201175f9b8b8b27b597","date":1332757908,"type":5,"author":"Christian Moen","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/kuromoji/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 4096; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      assert baseForm.length() < 16;\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 4096; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      assert baseForm.length() < 16;\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df594fa0daea908bb30c4f3a453f2bd0a55f9a1e":["a904819476fbc333a72b5914d82b948e7dab0205"],"a904819476fbc333a72b5914d82b948e7dab0205":["6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["df594fa0daea908bb30c4f3a453f2bd0a55f9a1e"],"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["98d45c1ff2c99694b6de2201175f9b8b8b27b597"]},"commit2Childs":{"df594fa0daea908bb30c4f3a453f2bd0a55f9a1e":["98d45c1ff2c99694b6de2201175f9b8b8b27b597"],"a904819476fbc333a72b5914d82b948e7dab0205":["df594fa0daea908bb30c4f3a453f2bd0a55f9a1e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2"],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2":["a904819476fbc333a72b5914d82b948e7dab0205"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}