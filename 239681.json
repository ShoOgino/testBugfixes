{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","commits":[{"id":"a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214","date":1442387183,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,long).mjava","sourceNew":"  public RouteResponse condenseResponse(NamedList response, int timeMillis) {\n    RouteResponse condensed = new RouteResponse();\n    int status = 0;\n    Integer rf = null;\n    Integer minRf = null;\n    for(int i=0; i<response.size(); i++) {\n      NamedList shardResponse = (NamedList)response.getVal(i);\n      NamedList header = (NamedList)shardResponse.get(\"responseHeader\");      \n      Integer shardStatus = (Integer)header.get(\"status\");\n      int s = shardStatus.intValue();\n      if(s > 0) {\n          status = s;\n      }\n      Object rfObj = header.get(UpdateRequest.REPFACT);\n      if (rfObj != null && rfObj instanceof Integer) {\n        Integer routeRf = (Integer)rfObj;\n        if (rf == null || routeRf < rf)\n          rf = routeRf;\n      }\n      minRf = (Integer)header.get(UpdateRequest.MIN_REPFACT);\n    }\n\n    NamedList cheader = new NamedList();\n    cheader.add(\"status\", status);\n    cheader.add(\"QTime\", timeMillis);\n    if (rf != null)\n      cheader.add(UpdateRequest.REPFACT, rf);\n    if (minRf != null)\n      cheader.add(UpdateRequest.MIN_REPFACT, minRf);\n    \n    condensed.add(\"responseHeader\", cheader);\n    return condensed;\n  }\n\n","sourceOld":"  public RouteResponse condenseResponse(NamedList response, long timeMillis) {\n    RouteResponse condensed = new RouteResponse();\n    int status = 0;\n    Integer rf = null;\n    Integer minRf = null;\n    for(int i=0; i<response.size(); i++) {\n      NamedList shardResponse = (NamedList)response.getVal(i);\n      NamedList header = (NamedList)shardResponse.get(\"responseHeader\");      \n      Integer shardStatus = (Integer)header.get(\"status\");\n      int s = shardStatus.intValue();\n      if(s > 0) {\n          status = s;\n      }\n      Object rfObj = header.get(UpdateRequest.REPFACT);\n      if (rfObj != null && rfObj instanceof Integer) {\n        Integer routeRf = (Integer)rfObj;\n        if (rf == null || routeRf < rf)\n          rf = routeRf;\n      }\n      minRf = (Integer)header.get(UpdateRequest.MIN_REPFACT);\n    }\n\n    NamedList cheader = new NamedList();\n    cheader.add(\"status\", status);\n    cheader.add(\"QTime\", timeMillis);\n    if (rf != null)\n      cheader.add(UpdateRequest.REPFACT, rf);\n    if (minRf != null)\n      cheader.add(UpdateRequest.MIN_REPFACT, minRf);\n    \n    condensed.add(\"responseHeader\", cheader);\n    return condensed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","sourceNew":"  public RouteResponse condenseResponse(NamedList response, int timeMillis) {\n    RouteResponse condensed = new RouteResponse();\n    int status = 0;\n    Integer rf = null;\n    Integer minRf = null;\n    \n    // TolerantUpdateProcessor\n    List<SimpleOrderedMap<String>> toleratedErrors = null; \n    int maxToleratedErrors = Integer.MAX_VALUE;\n      \n    for(int i=0; i<response.size(); i++) {\n      NamedList shardResponse = (NamedList)response.getVal(i);\n      NamedList header = (NamedList)shardResponse.get(\"responseHeader\");      \n      Integer shardStatus = (Integer)header.get(\"status\");\n      int s = shardStatus.intValue();\n      if(s > 0) {\n          status = s;\n      }\n      Object rfObj = header.get(UpdateRequest.REPFACT);\n      if (rfObj != null && rfObj instanceof Integer) {\n        Integer routeRf = (Integer)rfObj;\n        if (rf == null || routeRf < rf)\n          rf = routeRf;\n      }\n      minRf = (Integer)header.get(UpdateRequest.MIN_REPFACT);\n\n      List<SimpleOrderedMap<String>> shardTolerantErrors = \n        (List<SimpleOrderedMap<String>>) header.get(\"errors\");\n      if (null != shardTolerantErrors) {\n        Integer shardMaxToleratedErrors = (Integer) header.get(\"maxErrors\");\n        assert null != shardMaxToleratedErrors : \"TolerantUpdateProcessor reported errors but not maxErrors\";\n        // if we get into some weird state where the nodes disagree about the effective maxErrors,\n        // assume the min value seen to decide if we should fail.\n        maxToleratedErrors = Math.min(maxToleratedErrors,\n                                      ToleratedUpdateError.getEffectiveMaxErrors(shardMaxToleratedErrors.intValue()));\n        \n        if (null == toleratedErrors) {\n          toleratedErrors = new ArrayList<SimpleOrderedMap<String>>(shardTolerantErrors.size());\n        }\n        for (SimpleOrderedMap<String> err : shardTolerantErrors) {\n          toleratedErrors.add(err);\n        }\n      }\n    }\n\n    NamedList cheader = new NamedList();\n    cheader.add(\"status\", status);\n    cheader.add(\"QTime\", timeMillis);\n    if (rf != null)\n      cheader.add(UpdateRequest.REPFACT, rf);\n    if (minRf != null)\n      cheader.add(UpdateRequest.MIN_REPFACT, minRf);\n    if (null != toleratedErrors) {\n      cheader.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxToleratedErrors));\n      cheader.add(\"errors\", toleratedErrors);\n      if (maxToleratedErrors < toleratedErrors.size()) {\n        // cumulative errors are too high, we need to throw a client exception w/correct metadata\n\n        // NOTE: it shouldn't be possible for 1 == toleratedErrors.size(), because if that were the case\n        // then at least one shard should have thrown a real error before this, so we don't worry\n        // about having a more \"singular\" exception msg for that situation\n        StringBuilder msgBuf =  new StringBuilder()\n          .append(toleratedErrors.size()).append(\" Async failures during distributed update: \");\n          \n        NamedList metadata = new NamedList<String>();\n        for (SimpleOrderedMap<String> err : toleratedErrors) {\n          ToleratedUpdateError te = ToleratedUpdateError.parseMap(err);\n          metadata.add(te.getMetadataKey(), te.getMetadataValue());\n          \n          msgBuf.append(\"\\n\").append(te.getMessage());\n        }\n        \n        SolrException toThrow = new SolrException(ErrorCode.BAD_REQUEST, msgBuf.toString());\n        toThrow.setMetadata(metadata);\n        throw toThrow;\n      }\n    }\n    condensed.add(\"responseHeader\", cheader);\n    return condensed;\n  }\n\n","sourceOld":"  public RouteResponse condenseResponse(NamedList response, int timeMillis) {\n    RouteResponse condensed = new RouteResponse();\n    int status = 0;\n    Integer rf = null;\n    Integer minRf = null;\n    for(int i=0; i<response.size(); i++) {\n      NamedList shardResponse = (NamedList)response.getVal(i);\n      NamedList header = (NamedList)shardResponse.get(\"responseHeader\");      \n      Integer shardStatus = (Integer)header.get(\"status\");\n      int s = shardStatus.intValue();\n      if(s > 0) {\n          status = s;\n      }\n      Object rfObj = header.get(UpdateRequest.REPFACT);\n      if (rfObj != null && rfObj instanceof Integer) {\n        Integer routeRf = (Integer)rfObj;\n        if (rf == null || routeRf < rf)\n          rf = routeRf;\n      }\n      minRf = (Integer)header.get(UpdateRequest.MIN_REPFACT);\n    }\n\n    NamedList cheader = new NamedList();\n    cheader.add(\"status\", status);\n    cheader.add(\"QTime\", timeMillis);\n    if (rf != null)\n      cheader.add(UpdateRequest.REPFACT, rf);\n    if (minRf != null)\n      cheader.add(UpdateRequest.MIN_REPFACT, minRf);\n    \n    condensed.add(\"responseHeader\", cheader);\n    return condensed;\n  }\n\n","bugFix":null,"bugIntro":["ce70fb0114c35565dd8553457fb16b8cb9d7c755"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce70fb0114c35565dd8553457fb16b8cb9d7c755","date":1489415002,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","sourceNew":"  public RouteResponse condenseResponse(NamedList response, int timeMillis) {\n    RouteResponse condensed = new RouteResponse();\n    int status = 0;\n    Integer rf = null;\n    Integer minRf = null;\n    \n    // TolerantUpdateProcessor\n    List<SimpleOrderedMap<String>> toleratedErrors = null; \n    int maxToleratedErrors = Integer.MAX_VALUE;\n\n    // For \"adds\", \"deletes\", \"deleteByQuery\" etc.\n    Map<String, NamedList> versions = new HashMap<>();\n\n    for(int i=0; i<response.size(); i++) {\n      NamedList shardResponse = (NamedList)response.getVal(i);\n      NamedList header = (NamedList)shardResponse.get(\"responseHeader\");      \n      Integer shardStatus = (Integer)header.get(\"status\");\n      int s = shardStatus.intValue();\n      if(s > 0) {\n          status = s;\n      }\n      Object rfObj = header.get(UpdateRequest.REPFACT);\n      if (rfObj != null && rfObj instanceof Integer) {\n        Integer routeRf = (Integer)rfObj;\n        if (rf == null || routeRf < rf)\n          rf = routeRf;\n      }\n      minRf = (Integer)header.get(UpdateRequest.MIN_REPFACT);\n\n      List<SimpleOrderedMap<String>> shardTolerantErrors = \n        (List<SimpleOrderedMap<String>>) header.get(\"errors\");\n      if (null != shardTolerantErrors) {\n        Integer shardMaxToleratedErrors = (Integer) header.get(\"maxErrors\");\n        assert null != shardMaxToleratedErrors : \"TolerantUpdateProcessor reported errors but not maxErrors\";\n        // if we get into some weird state where the nodes disagree about the effective maxErrors,\n        // assume the min value seen to decide if we should fail.\n        maxToleratedErrors = Math.min(maxToleratedErrors,\n                                      ToleratedUpdateError.getEffectiveMaxErrors(shardMaxToleratedErrors.intValue()));\n        \n        if (null == toleratedErrors) {\n          toleratedErrors = new ArrayList<SimpleOrderedMap<String>>(shardTolerantErrors.size());\n        }\n        for (SimpleOrderedMap<String> err : shardTolerantErrors) {\n          toleratedErrors.add(err);\n        }\n      }\n      for (String updateType: Arrays.asList(\"adds\", \"deletes\", \"deleteByQuery\")) {\n        Object obj = shardResponse.get(updateType);\n        if (obj instanceof NamedList) {\n          NamedList versionsList = versions.containsKey(updateType) ?\n              versions.get(updateType): new NamedList();\n          versionsList.addAll((NamedList)obj);\n          versions.put(updateType, versionsList);\n        }\n      }\n    }\n\n    NamedList cheader = new NamedList();\n    cheader.add(\"status\", status);\n    cheader.add(\"QTime\", timeMillis);\n    if (rf != null)\n      cheader.add(UpdateRequest.REPFACT, rf);\n    if (minRf != null)\n      cheader.add(UpdateRequest.MIN_REPFACT, minRf);\n    if (null != toleratedErrors) {\n      cheader.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxToleratedErrors));\n      cheader.add(\"errors\", toleratedErrors);\n      if (maxToleratedErrors < toleratedErrors.size()) {\n        // cumulative errors are too high, we need to throw a client exception w/correct metadata\n\n        // NOTE: it shouldn't be possible for 1 == toleratedErrors.size(), because if that were the case\n        // then at least one shard should have thrown a real error before this, so we don't worry\n        // about having a more \"singular\" exception msg for that situation\n        StringBuilder msgBuf =  new StringBuilder()\n          .append(toleratedErrors.size()).append(\" Async failures during distributed update: \");\n          \n        NamedList metadata = new NamedList<String>();\n        for (SimpleOrderedMap<String> err : toleratedErrors) {\n          ToleratedUpdateError te = ToleratedUpdateError.parseMap(err);\n          metadata.add(te.getMetadataKey(), te.getMetadataValue());\n          \n          msgBuf.append(\"\\n\").append(te.getMessage());\n        }\n        \n        SolrException toThrow = new SolrException(ErrorCode.BAD_REQUEST, msgBuf.toString());\n        toThrow.setMetadata(metadata);\n        throw toThrow;\n      }\n    }\n    for (String updateType: versions.keySet()) {\n      condensed.add(updateType, versions.get(updateType));\n    }\n    condensed.add(\"responseHeader\", cheader);\n    return condensed;\n  }\n\n","sourceOld":"  public RouteResponse condenseResponse(NamedList response, int timeMillis) {\n    RouteResponse condensed = new RouteResponse();\n    int status = 0;\n    Integer rf = null;\n    Integer minRf = null;\n    \n    // TolerantUpdateProcessor\n    List<SimpleOrderedMap<String>> toleratedErrors = null; \n    int maxToleratedErrors = Integer.MAX_VALUE;\n      \n    for(int i=0; i<response.size(); i++) {\n      NamedList shardResponse = (NamedList)response.getVal(i);\n      NamedList header = (NamedList)shardResponse.get(\"responseHeader\");      \n      Integer shardStatus = (Integer)header.get(\"status\");\n      int s = shardStatus.intValue();\n      if(s > 0) {\n          status = s;\n      }\n      Object rfObj = header.get(UpdateRequest.REPFACT);\n      if (rfObj != null && rfObj instanceof Integer) {\n        Integer routeRf = (Integer)rfObj;\n        if (rf == null || routeRf < rf)\n          rf = routeRf;\n      }\n      minRf = (Integer)header.get(UpdateRequest.MIN_REPFACT);\n\n      List<SimpleOrderedMap<String>> shardTolerantErrors = \n        (List<SimpleOrderedMap<String>>) header.get(\"errors\");\n      if (null != shardTolerantErrors) {\n        Integer shardMaxToleratedErrors = (Integer) header.get(\"maxErrors\");\n        assert null != shardMaxToleratedErrors : \"TolerantUpdateProcessor reported errors but not maxErrors\";\n        // if we get into some weird state where the nodes disagree about the effective maxErrors,\n        // assume the min value seen to decide if we should fail.\n        maxToleratedErrors = Math.min(maxToleratedErrors,\n                                      ToleratedUpdateError.getEffectiveMaxErrors(shardMaxToleratedErrors.intValue()));\n        \n        if (null == toleratedErrors) {\n          toleratedErrors = new ArrayList<SimpleOrderedMap<String>>(shardTolerantErrors.size());\n        }\n        for (SimpleOrderedMap<String> err : shardTolerantErrors) {\n          toleratedErrors.add(err);\n        }\n      }\n    }\n\n    NamedList cheader = new NamedList();\n    cheader.add(\"status\", status);\n    cheader.add(\"QTime\", timeMillis);\n    if (rf != null)\n      cheader.add(UpdateRequest.REPFACT, rf);\n    if (minRf != null)\n      cheader.add(UpdateRequest.MIN_REPFACT, minRf);\n    if (null != toleratedErrors) {\n      cheader.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxToleratedErrors));\n      cheader.add(\"errors\", toleratedErrors);\n      if (maxToleratedErrors < toleratedErrors.size()) {\n        // cumulative errors are too high, we need to throw a client exception w/correct metadata\n\n        // NOTE: it shouldn't be possible for 1 == toleratedErrors.size(), because if that were the case\n        // then at least one shard should have thrown a real error before this, so we don't worry\n        // about having a more \"singular\" exception msg for that situation\n        StringBuilder msgBuf =  new StringBuilder()\n          .append(toleratedErrors.size()).append(\" Async failures during distributed update: \");\n          \n        NamedList metadata = new NamedList<String>();\n        for (SimpleOrderedMap<String> err : toleratedErrors) {\n          ToleratedUpdateError te = ToleratedUpdateError.parseMap(err);\n          metadata.add(te.getMetadataKey(), te.getMetadataValue());\n          \n          msgBuf.append(\"\\n\").append(te.getMessage());\n        }\n        \n        SolrException toThrow = new SolrException(ErrorCode.BAD_REQUEST, msgBuf.toString());\n        toThrow.setMetadata(metadata);\n        throw toThrow;\n      }\n    }\n    condensed.add(\"responseHeader\", cheader);\n    return condensed;\n  }\n\n","bugFix":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","sourceNew":"  /**\n   * @deprecated since Solr 8.0\n   */\n  @Deprecated\n  public RouteResponse condenseResponse(NamedList response, int timeMillis) {\n    return condenseResponse(response, timeMillis, RouteResponse::new);\n  }\n\n","sourceOld":"  public RouteResponse condenseResponse(NamedList response, int timeMillis) {\n    RouteResponse condensed = new RouteResponse();\n    int status = 0;\n    Integer rf = null;\n    Integer minRf = null;\n    \n    // TolerantUpdateProcessor\n    List<SimpleOrderedMap<String>> toleratedErrors = null; \n    int maxToleratedErrors = Integer.MAX_VALUE;\n\n    // For \"adds\", \"deletes\", \"deleteByQuery\" etc.\n    Map<String, NamedList> versions = new HashMap<>();\n\n    for(int i=0; i<response.size(); i++) {\n      NamedList shardResponse = (NamedList)response.getVal(i);\n      NamedList header = (NamedList)shardResponse.get(\"responseHeader\");      \n      Integer shardStatus = (Integer)header.get(\"status\");\n      int s = shardStatus.intValue();\n      if(s > 0) {\n          status = s;\n      }\n      Object rfObj = header.get(UpdateRequest.REPFACT);\n      if (rfObj != null && rfObj instanceof Integer) {\n        Integer routeRf = (Integer)rfObj;\n        if (rf == null || routeRf < rf)\n          rf = routeRf;\n      }\n      minRf = (Integer)header.get(UpdateRequest.MIN_REPFACT);\n\n      List<SimpleOrderedMap<String>> shardTolerantErrors = \n        (List<SimpleOrderedMap<String>>) header.get(\"errors\");\n      if (null != shardTolerantErrors) {\n        Integer shardMaxToleratedErrors = (Integer) header.get(\"maxErrors\");\n        assert null != shardMaxToleratedErrors : \"TolerantUpdateProcessor reported errors but not maxErrors\";\n        // if we get into some weird state where the nodes disagree about the effective maxErrors,\n        // assume the min value seen to decide if we should fail.\n        maxToleratedErrors = Math.min(maxToleratedErrors,\n                                      ToleratedUpdateError.getEffectiveMaxErrors(shardMaxToleratedErrors.intValue()));\n        \n        if (null == toleratedErrors) {\n          toleratedErrors = new ArrayList<SimpleOrderedMap<String>>(shardTolerantErrors.size());\n        }\n        for (SimpleOrderedMap<String> err : shardTolerantErrors) {\n          toleratedErrors.add(err);\n        }\n      }\n      for (String updateType: Arrays.asList(\"adds\", \"deletes\", \"deleteByQuery\")) {\n        Object obj = shardResponse.get(updateType);\n        if (obj instanceof NamedList) {\n          NamedList versionsList = versions.containsKey(updateType) ?\n              versions.get(updateType): new NamedList();\n          versionsList.addAll((NamedList)obj);\n          versions.put(updateType, versionsList);\n        }\n      }\n    }\n\n    NamedList cheader = new NamedList();\n    cheader.add(\"status\", status);\n    cheader.add(\"QTime\", timeMillis);\n    if (rf != null)\n      cheader.add(UpdateRequest.REPFACT, rf);\n    if (minRf != null)\n      cheader.add(UpdateRequest.MIN_REPFACT, minRf);\n    if (null != toleratedErrors) {\n      cheader.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxToleratedErrors));\n      cheader.add(\"errors\", toleratedErrors);\n      if (maxToleratedErrors < toleratedErrors.size()) {\n        // cumulative errors are too high, we need to throw a client exception w/correct metadata\n\n        // NOTE: it shouldn't be possible for 1 == toleratedErrors.size(), because if that were the case\n        // then at least one shard should have thrown a real error before this, so we don't worry\n        // about having a more \"singular\" exception msg for that situation\n        StringBuilder msgBuf =  new StringBuilder()\n          .append(toleratedErrors.size()).append(\" Async failures during distributed update: \");\n          \n        NamedList metadata = new NamedList<String>();\n        for (SimpleOrderedMap<String> err : toleratedErrors) {\n          ToleratedUpdateError te = ToleratedUpdateError.parseMap(err);\n          metadata.add(te.getMetadataKey(), te.getMetadataValue());\n          \n          msgBuf.append(\"\\n\").append(te.getMessage());\n        }\n        \n        SolrException toThrow = new SolrException(ErrorCode.BAD_REQUEST, msgBuf.toString());\n        toThrow.setMetadata(metadata);\n        throw toThrow;\n      }\n    }\n    for (String updateType: versions.keySet()) {\n      condensed.add(updateType, versions.get(updateType));\n    }\n    condensed.add(\"responseHeader\", cheader);\n    return condensed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d","date":1592006776,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#condenseResponse(NamedList,int).mjava","sourceNew":"  /**\n   * @deprecated since Solr 8.0\n   */\n  @Deprecated\n  public RouteResponse condenseResponse(@SuppressWarnings({\"rawtypes\"})NamedList response, int timeMillis) {\n    return condenseResponse(response, timeMillis, RouteResponse::new);\n  }\n\n","sourceOld":"  /**\n   * @deprecated since Solr 8.0\n   */\n  @Deprecated\n  public RouteResponse condenseResponse(NamedList response, int timeMillis) {\n    return condenseResponse(response, timeMillis, RouteResponse::new);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["ce70fb0114c35565dd8553457fb16b8cb9d7c755"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214"],"ce70fb0114c35565dd8553457fb16b8cb9d7c755":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"]},"commit2Childs":{"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["ce70fb0114c35565dd8553457fb16b8cb9d7c755"],"ce70fb0114c35565dd8553457fb16b8cb9d7c755":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}