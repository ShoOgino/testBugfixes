{"path":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"/dev/null","sourceNew":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n\tthrow new IOException(\"couldn't delete \" + to);\n\n    if (!old.renameTo(nu))\n      throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0416817b4dc5c68e6e8ec63531bca2ef934355e2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb362078b1a76896cbcd6f561b0eea6011fedabe","date":1046540304,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n\tthrow new IOException(\"couldn't delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n           out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n      }\n      finally {\n\tif (in != null) {\n          try {\n            in.close();\n\t  } catch (IOException e) {\n            // what can we do?\n\t  }\n\t}\n\tif (out != null) {\n          try {\n            out.close();\n\t  } catch (IOException e) {\n            // what can we do?\n\t  }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n\tthrow new IOException(\"couldn't delete \" + to);\n\n    if (!old.renameTo(nu))\n      throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n  }\n\n","bugFix":null,"bugIntro":["24bbd3f28dd662276112996a70353455fff5753f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42d2483c9780aaee0c0d6f11484ebab263803eec","date":1046724410,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n\tthrow new IOException(\"couldn't delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n           out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n      }\n      finally {\n\tif (in != null) {\n          try {\n            in.close();\n\t  } catch (IOException e) {\n            // what can we do?\n\t  }\n\t}\n\tif (out != null) {\n          try {\n            out.close();\n\t  } catch (IOException e) {\n            throw new RuntimeException(\"could not close output stream\", e);\n\t  }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n\tthrow new IOException(\"couldn't delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n           out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n      }\n      finally {\n\tif (in != null) {\n          try {\n            in.close();\n\t  } catch (IOException e) {\n            // what can we do?\n\t  }\n\t}\n\tif (out != null) {\n          try {\n            out.close();\n\t  } catch (IOException e) {\n            // what can we do?\n\t  }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5256e856e1442a6e1250d26f1236a33380632dc2","date":1046725105,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"couldn't delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"could not close input stream\", e);\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"could not close output stream\", e);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n\tthrow new IOException(\"couldn't delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n           out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n      }\n      finally {\n\tif (in != null) {\n          try {\n            in.close();\n\t  } catch (IOException e) {\n            // what can we do?\n\t  }\n\t}\n\tif (out != null) {\n          try {\n            out.close();\n\t  } catch (IOException e) {\n            throw new RuntimeException(\"could not close output stream\", e);\n\t  }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["24bbd3f28dd662276112996a70353455fff5753f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bf393a849bc597828893956ea8ceec59acc832c","date":1048044053,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"couldn't delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"could not close input stream: \" + e.getMessage());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"could not close output stream: \" + e.getMessage());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"couldn't delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"could not close input stream\", e);\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"could not close output stream\", e);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a626a6760d7df571ac4f6a0b4d5a7c9446b0a4e5","date":1084887750,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"Cannot rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.getMessage());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.getMessage());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"couldn't delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"could not close input stream: \" + e.getMessage());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"could not close output stream: \" + e.getMessage());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4b73bc272a820ddda9d6f3e9017fdc565b5891c","date":1094580376,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"Cannot rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.getMessage());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.getMessage());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"Cannot rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.getMessage());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.getMessage());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2686878db3f624ddbeed9eb286f872c48b74a97d","date":1100803073,"type":3,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"Cannot rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.toString());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.toString());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"Cannot rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.getMessage());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.getMessage());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4050c0cac07cbf55be818b8a552cfab55d0ddf4b","date":1117731430,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"Cannot rename \" + old + \" to \" + nu);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.toString());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.toString());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + to);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"Cannot rename \" + from + \" to \" + to);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.toString());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.toString());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d61f4c23cc2cce8021776edaf50078c935f8d4aa","date":1147464779,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        IOException newExc = new IOException(\"Cannot rename \" + old + \" to \" + nu);\n        newExc.initCause(ioe);\n        throw newExc;\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.toString(), e);\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.toString(), e);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        throw new IOException(\"Cannot rename \" + old + \" to \" + nu);\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.toString());\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.toString());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["24bbd3f28dd662276112996a70353455fff5753f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24bbd3f28dd662276112996a70353455fff5753f","date":1154166888,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        IOException newExc = new IOException(\"Cannot rename \" + old + \" to \" + nu);\n        newExc.initCause(ioe);\n        throw newExc;\n      }\n      finally {\n        try {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close input stream: \" + e.toString(), e);\n            }\n          }\n        } finally {\n          if (out != null) {\n            try {\n              out.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close output stream: \" + e.toString(), e);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        IOException newExc = new IOException(\"Cannot rename \" + old + \" to \" + nu);\n        newExc.initCause(ioe);\n        throw newExc;\n      }\n      finally {\n        if (in != null) {\n          try {\n            in.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close input stream: \" + e.toString(), e);\n          }\n        }\n        if (out != null) {\n          try {\n            out.close();\n          } catch (IOException e) {\n            throw new RuntimeException(\"Cannot close output stream: \" + e.toString(), e);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["eb362078b1a76896cbcd6f561b0eea6011fedabe","5256e856e1442a6e1250d26f1236a33380632dc2","d61f4c23cc2cce8021776edaf50078c935f8d4aa"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0416817b4dc5c68e6e8ec63531bca2ef934355e2","date":1170715782,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. \n   * Warning: This is not atomic.\n   * @deprecated \n   */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        IOException newExc = new IOException(\"Cannot rename \" + old + \" to \" + nu);\n        newExc.initCause(ioe);\n        throw newExc;\n      }\n      finally {\n        try {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close input stream: \" + e.toString(), e);\n            }\n          }\n        } finally {\n          if (out != null) {\n            try {\n              out.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close output stream: \" + e.toString(), e);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        IOException newExc = new IOException(\"Cannot rename \" + old + \" to \" + nu);\n        newExc.initCause(ioe);\n        throw newExc;\n      }\n      finally {\n        try {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close input stream: \" + e.toString(), e);\n            }\n          }\n        } finally {\n          if (out != null) {\n            try {\n              out.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close output stream: \" + e.toString(), e);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0bf957228b21d5093ca182ac6e90ce6da3eab00","date":1215682064,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":"  /** Renames an existing file in the directory. \n   * Warning: This is not atomic.\n   * @deprecated \n   */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    ensureOpen();\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        IOException newExc = new IOException(\"Cannot rename \" + old + \" to \" + nu);\n        newExc.initCause(ioe);\n        throw newExc;\n      }\n      finally {\n        try {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close input stream: \" + e.toString(), e);\n            }\n          }\n        } finally {\n          if (out != null) {\n            try {\n              out.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close output stream: \" + e.toString(), e);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Renames an existing file in the directory. \n   * Warning: This is not atomic.\n   * @deprecated \n   */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        IOException newExc = new IOException(\"Cannot rename \" + old + \" to \" + nu);\n        newExc.initCause(ioe);\n        throw newExc;\n      }\n      finally {\n        try {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close input stream: \" + e.toString(), e);\n            }\n          }\n        } finally {\n          if (out != null) {\n            try {\n              out.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close output stream: \" + e.toString(), e);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eaea03be31988a41275d45a429ac71ff0ad740fb","date":1254612554,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/store/FSDirectory#renameFile(String,String).mjava","sourceNew":null,"sourceOld":"  /** Renames an existing file in the directory. \n   * Warning: This is not atomic.\n   * @deprecated \n   */\n  public synchronized void renameFile(String from, String to)\n      throws IOException {\n    ensureOpen();\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n        throw new IOException(\"Cannot delete \" + nu);\n\n    // Rename the old file to the new one. Unfortunately, the renameTo()\n    // method does not work reliably under some JVMs.  Therefore, if the\n    // rename fails, we manually rename by copying the old file to the new one\n    if (!old.renameTo(nu)) {\n      java.io.InputStream in = null;\n      java.io.OutputStream out = null;\n      try {\n        in = new FileInputStream(old);\n        out = new FileOutputStream(nu);\n        // see if the buffer needs to be initialized. Initialization is\n        // only done on-demand since many VM's will never run into the renameTo\n        // bug and hence shouldn't waste 1K of mem for no reason.\n        if (buffer == null) {\n          buffer = new byte[1024];\n        }\n        int len;\n        while ((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n\n        // delete the old file.\n        old.delete();\n      }\n      catch (IOException ioe) {\n        IOException newExc = new IOException(\"Cannot rename \" + old + \" to \" + nu);\n        newExc.initCause(ioe);\n        throw newExc;\n      }\n      finally {\n        try {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close input stream: \" + e.toString(), e);\n            }\n          }\n        } finally {\n          if (out != null) {\n            try {\n              out.close();\n            } catch (IOException e) {\n              throw new RuntimeException(\"Cannot close output stream: \" + e.toString(), e);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eaea03be31988a41275d45a429ac71ff0ad740fb":["d0bf957228b21d5093ca182ac6e90ce6da3eab00"],"d4b73bc272a820ddda9d6f3e9017fdc565b5891c":["a626a6760d7df571ac4f6a0b4d5a7c9446b0a4e5"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4050c0cac07cbf55be818b8a552cfab55d0ddf4b":["2686878db3f624ddbeed9eb286f872c48b74a97d"],"0bf393a849bc597828893956ea8ceec59acc832c":["5256e856e1442a6e1250d26f1236a33380632dc2"],"0416817b4dc5c68e6e8ec63531bca2ef934355e2":["24bbd3f28dd662276112996a70353455fff5753f"],"eb362078b1a76896cbcd6f561b0eea6011fedabe":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"42d2483c9780aaee0c0d6f11484ebab263803eec":["eb362078b1a76896cbcd6f561b0eea6011fedabe"],"d61f4c23cc2cce8021776edaf50078c935f8d4aa":["4050c0cac07cbf55be818b8a552cfab55d0ddf4b"],"a626a6760d7df571ac4f6a0b4d5a7c9446b0a4e5":["0bf393a849bc597828893956ea8ceec59acc832c"],"5256e856e1442a6e1250d26f1236a33380632dc2":["42d2483c9780aaee0c0d6f11484ebab263803eec"],"24bbd3f28dd662276112996a70353455fff5753f":["d61f4c23cc2cce8021776edaf50078c935f8d4aa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0bf957228b21d5093ca182ac6e90ce6da3eab00":["0416817b4dc5c68e6e8ec63531bca2ef934355e2"],"2686878db3f624ddbeed9eb286f872c48b74a97d":["d4b73bc272a820ddda9d6f3e9017fdc565b5891c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eaea03be31988a41275d45a429ac71ff0ad740fb"]},"commit2Childs":{"eaea03be31988a41275d45a429ac71ff0ad740fb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4b73bc272a820ddda9d6f3e9017fdc565b5891c":["2686878db3f624ddbeed9eb286f872c48b74a97d"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["eb362078b1a76896cbcd6f561b0eea6011fedabe"],"4050c0cac07cbf55be818b8a552cfab55d0ddf4b":["d61f4c23cc2cce8021776edaf50078c935f8d4aa"],"0bf393a849bc597828893956ea8ceec59acc832c":["a626a6760d7df571ac4f6a0b4d5a7c9446b0a4e5"],"0416817b4dc5c68e6e8ec63531bca2ef934355e2":["d0bf957228b21d5093ca182ac6e90ce6da3eab00"],"eb362078b1a76896cbcd6f561b0eea6011fedabe":["42d2483c9780aaee0c0d6f11484ebab263803eec"],"42d2483c9780aaee0c0d6f11484ebab263803eec":["5256e856e1442a6e1250d26f1236a33380632dc2"],"d61f4c23cc2cce8021776edaf50078c935f8d4aa":["24bbd3f28dd662276112996a70353455fff5753f"],"a626a6760d7df571ac4f6a0b4d5a7c9446b0a4e5":["d4b73bc272a820ddda9d6f3e9017fdc565b5891c"],"5256e856e1442a6e1250d26f1236a33380632dc2":["0bf393a849bc597828893956ea8ceec59acc832c"],"24bbd3f28dd662276112996a70353455fff5753f":["0416817b4dc5c68e6e8ec63531bca2ef934355e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"d0bf957228b21d5093ca182ac6e90ce6da3eab00":["eaea03be31988a41275d45a429ac71ff0ad740fb"],"2686878db3f624ddbeed9eb286f872c48b74a97d":["4050c0cac07cbf55be818b8a552cfab55d0ddf4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}