{"path":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","commits":[{"id":"ff6fd241dc6610f7f81b62e3ba4cedf105939623","date":1307331653,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReader#testReopenChangeReadonly().mjava","sourceNew":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79c2cb24929f2649a8875fb629086171f914d5ce","date":1307332717,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReader#testReopenChangeReadonly().mjava","sourceNew":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReader#testReopenChangeReadonly().mjava","sourceNew":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","sourceNew":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", StringField.TYPE_UNSTORED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a8259c922a83abc544609227a60d48e5ee93e7e","date":1317679620,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","sourceNew":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", StringField.TYPE_UNSTORED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r3);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r2);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", StringField.TYPE_UNSTORED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = r.reopen(true);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = r.reopen(true);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"382fe3a6ca9745891afebda9b9a57cc158305545","date":1320952430,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","sourceNew":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", StringField.TYPE_UNSTORED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\", false);\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r3);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r2);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\", false);\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", StringField.TYPE_UNSTORED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\");\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r3);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r2);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\");\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ec62bd7d903ac435fcc4ad1f5a67ccc5700d9a3","date":1322958335,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","sourceNew":null,"sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", StringField.TYPE_UNSTORED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\", false);\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r3);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r2);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\", false);\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","sourceNew":null,"sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", StringField.TYPE_UNSTORED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\", false);\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r3);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r2);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\", false);\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testReopenChangeReadonly().mjava","sourceNew":null,"sourceOld":"  // LUCENE-1579: Make sure all SegmentReaders are new when\n  // reopen switches readOnly\n  public void testReopenChangeReadonly() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n            setMaxBufferedDocs(-1).\n            setMergePolicy(newLogMergePolicy(10))\n    );\n    Document doc = new Document();\n    doc.add(newField(\"number\", \"17\", StringField.TYPE_UNSTORED));\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Open reader1\n    IndexReader r = IndexReader.open(dir, false);\n    assertTrue(r instanceof DirectoryReader);\n    IndexReader r1 = getOnlySegmentReader(r);\n    final int[] ints = FieldCache.DEFAULT.getInts(r1, \"number\", false);\n    assertEquals(1, ints.length);\n    assertEquals(17, ints[0]);\n\n    // Reopen to readonly w/ no chnages\n    IndexReader r3 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r3);\n    assertTrue(((DirectoryReader) r3).readOnly);\n    r3.close();\n\n    // Add new segment\n    writer.addDocument(doc);\n    writer.commit();\n\n    // Reopen reader1 --> reader2\n    IndexReader r2 = IndexReader.openIfChanged(r, true);\n    assertNotNull(r2);\n    r.close();\n    assertTrue(((DirectoryReader) r2).readOnly);\n    IndexReader[] subs = r2.getSequentialSubReaders();\n    final int[] ints2 = FieldCache.DEFAULT.getInts(subs[0], \"number\", false);\n    r2.close();\n\n    assertTrue(((SegmentReader) subs[0]).readOnly);\n    assertTrue(((SegmentReader) subs[1]).readOnly);\n    assertTrue(ints == ints2);\n\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8a8259c922a83abc544609227a60d48e5ee93e7e":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"ff6fd241dc6610f7f81b62e3ba4cedf105939623":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2ec62bd7d903ac435fcc4ad1f5a67ccc5700d9a3":["382fe3a6ca9745891afebda9b9a57cc158305545"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["382fe3a6ca9745891afebda9b9a57cc158305545","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"79c2cb24929f2649a8875fb629086171f914d5ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ff6fd241dc6610f7f81b62e3ba4cedf105939623"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ff6fd241dc6610f7f81b62e3ba4cedf105939623"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["382fe3a6ca9745891afebda9b9a57cc158305545","2ec62bd7d903ac435fcc4ad1f5a67ccc5700d9a3"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["ff6fd241dc6610f7f81b62e3ba4cedf105939623"],"382fe3a6ca9745891afebda9b9a57cc158305545":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3615ce4a1f785ae1b779244de52c6a7d99227e60"]},"commit2Childs":{"8a8259c922a83abc544609227a60d48e5ee93e7e":["382fe3a6ca9745891afebda9b9a57cc158305545"],"ff6fd241dc6610f7f81b62e3ba4cedf105939623":["79c2cb24929f2649a8875fb629086171f914d5ce","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"2ec62bd7d903ac435fcc4ad1f5a67ccc5700d9a3":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"79c2cb24929f2649a8875fb629086171f914d5ce":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ff6fd241dc6610f7f81b62e3ba4cedf105939623","79c2cb24929f2649a8875fb629086171f914d5ce","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"382fe3a6ca9745891afebda9b9a57cc158305545":["2ec62bd7d903ac435fcc4ad1f5a67ccc5700d9a3","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","79c2cb24929f2649a8875fb629086171f914d5ce","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}