{"path":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.termBuffer(), 0, token.termLength());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.termBuffer(), 0, token.termLength());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.termBuffer(), 0, token.termLength());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.termBuffer(), 0, token.termLength());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.termBuffer(), 0, token.termLength());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7347509fad0711ac30cb15a746e9a3830a38ebd","date":1275388513,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.termBuffer(), 0, token.termLength());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d76ab9983349b199b0e6f65776c0087b0c08a10d","date":1282230089,"type":5,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = (int) Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d6aab5206b894bf0ea232b059a45cf2de460726f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d76ab9983349b199b0e6f65776c0087b0c08a10d":["a7347509fad0711ac30cb15a746e9a3830a38ebd"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a7347509fad0711ac30cb15a746e9a3830a38ebd","d76ab9983349b199b0e6f65776c0087b0c08a10d"],"a7347509fad0711ac30cb15a746e9a3830a38ebd":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d76ab9983349b199b0e6f65776c0087b0c08a10d"]},"commit2Childs":{"d76ab9983349b199b0e6f65776c0087b0c08a10d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1da8d55113b689b06716246649de6f62430f15c0":["a7347509fad0711ac30cb15a746e9a3830a38ebd"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"a7347509fad0711ac30cb15a746e9a3830a38ebd":["d76ab9983349b199b0e6f65776c0087b0c08a10d","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}