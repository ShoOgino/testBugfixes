{"path":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testBKDRandom().mjava","commits":[{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testBKDRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testBKDRandom() throws Exception {\n    List<Point> points = new ArrayList<>();\n    int numPoints = atLeast(10000);\n    Directory dir = newDirectory();\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048); \n\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n\n    PlanetModel planetModel;\n    if (random().nextBoolean()) {\n      planetModel = PlanetModel.WGS84;\n    } else {\n      planetModel = PlanetModel.SPHERE;\n    }\n    final double planetMax = planetModel.getMaximumMagnitude();\n    \n    BKD3DTreeWriter w = new BKD3DTreeWriter(maxPointsInLeaf, maxPointsSortInHeap);\n    for(int docID=0;docID<numPoints;docID++) {\n      Point point;\n      if (docID > 0 && random().nextInt(30) == 17) {\n        // Dup point\n        point = points.get(random().nextInt(points.size()));\n      } else {\n        point = new Point(randomCoord(planetModel),\n                          randomCoord(planetModel),\n                          randomCoord(planetModel));\n      }\n\n      if (VERBOSE) {\n        System.err.println(\"  docID=\" + docID + \" point=\" + point);\n        System.err.println(\"    x=\" + encodeValue(planetMax, point.x) +\n                           \" y=\" + encodeValue(planetMax, point.y) +\n                           \" z=\" + encodeValue(planetMax, point.z));\n      }\n\n      points.add(point);\n      w.add(encodeValue(planetMax, point.x),\n            encodeValue(planetMax, point.y),\n            encodeValue(planetMax, point.z),\n            docID);\n    }\n\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKD3DTreeReader r = new BKD3DTreeReader(in, numPoints);\n\n    int numIters = atLeast(100);\n    for(int iter=0;iter<numIters;iter++) {\n      // bbox\n      Range x = randomRange(planetModel);\n      Range y = randomRange(planetModel);\n      Range z = randomRange(planetModel);\n\n      int xMinEnc = encodeValue(planetMax, x.min);\n      int xMaxEnc = encodeValue(planetMax, x.max);\n      int yMinEnc = encodeValue(planetMax, y.min);\n      int yMaxEnc = encodeValue(planetMax, y.max);\n      int zMinEnc = encodeValue(planetMax, z.min);\n      int zMaxEnc = encodeValue(planetMax, z.max);\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" bbox: x=\" + x + \" (\" + xMinEnc + \" TO \" + xMaxEnc+ \")\" + \" y=\" + y + \" (\" + yMinEnc + \" TO \" + yMaxEnc + \")\"  + \" z=\" + z + \" (\" + zMinEnc + \" TO \" + zMaxEnc + \")\" );\n      }\n\n      DocIdSet hits = r.intersect(xMinEnc, xMaxEnc,\n                                  yMinEnc, yMaxEnc,\n                                  zMinEnc, zMaxEnc,\n\n                                  new BKD3DTreeReader.ValueFilter() {\n\n                                    @Override\n                                    public boolean accept(int docID) {\n                                      Point point = points.get(docID);\n                                      //System.out.println(\"  accept docID=\" + docID + \" point=\" + point + \" (x=\" + encodeValue(point.x) + \" y=\" + encodeValue(point.y) + \" z=\" + encodeValue(point.z) + \")\");\n\n                                      // System.out.println(\"  accept docID=\" + docID + \" point: x=\" + point.x + \" y=\" + point.y + \" z=\" + point.z);\n                                      int xEnc = encodeValue(planetMax, point.x);\n                                      int yEnc = encodeValue(planetMax, point.y);\n                                      int zEnc = encodeValue(planetMax, point.z);\n\n                                      boolean accept = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n                                        yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n                                        zEnc >= zMinEnc && zEnc <= zMaxEnc;\n                                      //System.out.println(\"    \" + accept);\n\n                                      return accept;\n                                    }\n\n                                    @Override\n                                    public BKD3DTreeReader.Relation compare(int cellXMin, int cellXMax,\n                                                                            int cellYMin, int cellYMax,\n                                                                            int cellZMin, int cellZMax) {\n                                      if (cellXMin > xMaxEnc || cellXMax < xMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellYMin > yMaxEnc || cellYMax < yMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellZMin > zMaxEnc || cellZMax < zMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n\n                                      if (cellXMin >= xMinEnc && cellXMax <= xMaxEnc &&\n                                          cellYMin >= yMinEnc && cellYMax <= yMaxEnc &&\n                                          cellZMin >= zMinEnc && cellZMax <= zMaxEnc) {\n                                        return BKD3DTreeReader.Relation.CELL_INSIDE_SHAPE;\n                                      }\n\n                                      if (xMinEnc >= cellXMin && xMaxEnc <= cellXMax &&\n                                          yMinEnc >= cellYMin && yMaxEnc <= cellYMax &&\n                                          zMinEnc >= cellZMin && zMaxEnc <= cellZMax) {\n                                        return BKD3DTreeReader.Relation.SHAPE_INSIDE_CELL;\n                                      }\n\n                                      return BKD3DTreeReader.Relation.SHAPE_CROSSES_CELL;\n                                    }\n                                  });\n\n      DocIdSetIterator disi = hits.iterator();\n      FixedBitSet matches = new FixedBitSet(numPoints);\n      while (true) {\n        int nextHit = disi.nextDoc();\n        if (nextHit == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n        matches.set(nextHit);\n      }\n      if (VERBOSE) {\n        System.err.println(\"  total hits: \" + matches.cardinality());\n      }\n\n      for(int docID=0;docID<numPoints;docID++) {\n        Point point = points.get(docID);\n        boolean actual = matches.get(docID);\n\n        // We must quantize exactly as BKD tree does else we'll get false failures\n        int xEnc = encodeValue(planetMax, point.x);\n        int yEnc = encodeValue(planetMax, point.y);\n        int zEnc = encodeValue(planetMax, point.z);\n\n        boolean expected = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n          yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n          zEnc >= zMinEnc && zEnc <= zMaxEnc;\n\n        if (expected != actual) {\n          System.out.println(\"docID=\" + docID + \" is wrong: expected=\" + expected + \" actual=\" + actual);\n          System.out.println(\"  x=\" + point.x + \" (\" + xEnc + \")\" + \" y=\" + point.y + \" (\" + yEnc + \")\" + \" z=\" + point.z + \" (\" + zEnc + \")\");\n          fail(\"wrong match\");\n        }\n      }\n    }\n\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d8f71af177fad4bbfdf462d318247e573faac27f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8f71af177fad4bbfdf462d318247e573faac27f","date":1441729530,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testBKDRandom().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testBKDRandom().mjava","sourceNew":"  public void testBKDRandom() throws Exception {\n    List<Point> points = new ArrayList<>();\n    int numPoints = atLeast(10000);\n    Directory dir = newDirectory();\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048); \n\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n\n    PlanetModel planetModel = getPlanetModel();\n    final double planetMax = planetModel.getMaximumMagnitude();\n    \n    BKD3DTreeWriter w = new BKD3DTreeWriter(maxPointsInLeaf, maxPointsSortInHeap);\n    for(int docID=0;docID<numPoints;docID++) {\n      Point point;\n      if (docID > 0 && random().nextInt(30) == 17) {\n        // Dup point\n        point = points.get(random().nextInt(points.size()));\n      } else {\n        point = new Point(randomCoord(planetModel),\n                          randomCoord(planetModel),\n                          randomCoord(planetModel));\n      }\n\n      if (VERBOSE) {\n        System.err.println(\"  docID=\" + docID + \" point=\" + point);\n        System.err.println(\"    x=\" + encodeValue(planetMax, point.x) +\n                           \" y=\" + encodeValue(planetMax, point.y) +\n                           \" z=\" + encodeValue(planetMax, point.z));\n      }\n\n      points.add(point);\n      w.add(encodeValue(planetMax, point.x),\n            encodeValue(planetMax, point.y),\n            encodeValue(planetMax, point.z),\n            docID);\n    }\n\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKD3DTreeReader r = new BKD3DTreeReader(in, numPoints);\n\n    int numIters = atLeast(100);\n    for(int iter=0;iter<numIters;iter++) {\n      // bbox\n      Range x = randomRange(planetModel);\n      Range y = randomRange(planetModel);\n      Range z = randomRange(planetModel);\n\n      int xMinEnc = encodeValue(planetMax, x.min);\n      int xMaxEnc = encodeValue(planetMax, x.max);\n      int yMinEnc = encodeValue(planetMax, y.min);\n      int yMaxEnc = encodeValue(planetMax, y.max);\n      int zMinEnc = encodeValue(planetMax, z.min);\n      int zMaxEnc = encodeValue(planetMax, z.max);\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" bbox: x=\" + x + \" (\" + xMinEnc + \" TO \" + xMaxEnc+ \")\" + \" y=\" + y + \" (\" + yMinEnc + \" TO \" + yMaxEnc + \")\"  + \" z=\" + z + \" (\" + zMinEnc + \" TO \" + zMaxEnc + \")\" );\n      }\n\n      DocIdSet hits = r.intersect(xMinEnc, xMaxEnc,\n                                  yMinEnc, yMaxEnc,\n                                  zMinEnc, zMaxEnc,\n\n                                  new BKD3DTreeReader.ValueFilter() {\n\n                                    @Override\n                                    public boolean accept(int docID) {\n                                      Point point = points.get(docID);\n                                      //System.out.println(\"  accept docID=\" + docID + \" point=\" + point + \" (x=\" + encodeValue(point.x) + \" y=\" + encodeValue(point.y) + \" z=\" + encodeValue(point.z) + \")\");\n\n                                      // System.out.println(\"  accept docID=\" + docID + \" point: x=\" + point.x + \" y=\" + point.y + \" z=\" + point.z);\n                                      int xEnc = encodeValue(planetMax, point.x);\n                                      int yEnc = encodeValue(planetMax, point.y);\n                                      int zEnc = encodeValue(planetMax, point.z);\n\n                                      boolean accept = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n                                        yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n                                        zEnc >= zMinEnc && zEnc <= zMaxEnc;\n                                      //System.out.println(\"    \" + accept);\n\n                                      return accept;\n                                    }\n\n                                    @Override\n                                    public BKD3DTreeReader.Relation compare(int cellXMin, int cellXMax,\n                                                                            int cellYMin, int cellYMax,\n                                                                            int cellZMin, int cellZMax) {\n                                      if (cellXMin > xMaxEnc || cellXMax < xMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellYMin > yMaxEnc || cellYMax < yMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellZMin > zMaxEnc || cellZMax < zMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n\n                                      if (cellXMin >= xMinEnc && cellXMax <= xMaxEnc &&\n                                          cellYMin >= yMinEnc && cellYMax <= yMaxEnc &&\n                                          cellZMin >= zMinEnc && cellZMax <= zMaxEnc) {\n                                        return BKD3DTreeReader.Relation.CELL_INSIDE_SHAPE;\n                                      }\n\n                                      if (xMinEnc >= cellXMin && xMaxEnc <= cellXMax &&\n                                          yMinEnc >= cellYMin && yMaxEnc <= cellYMax &&\n                                          zMinEnc >= cellZMin && zMaxEnc <= cellZMax) {\n                                        return BKD3DTreeReader.Relation.SHAPE_INSIDE_CELL;\n                                      }\n\n                                      return BKD3DTreeReader.Relation.SHAPE_CROSSES_CELL;\n                                    }\n                                  });\n\n      DocIdSetIterator disi = hits.iterator();\n      FixedBitSet matches = new FixedBitSet(numPoints);\n      while (true) {\n        int nextHit = disi.nextDoc();\n        if (nextHit == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n        matches.set(nextHit);\n      }\n      if (VERBOSE) {\n        System.err.println(\"  total hits: \" + matches.cardinality());\n      }\n\n      for(int docID=0;docID<numPoints;docID++) {\n        Point point = points.get(docID);\n        boolean actual = matches.get(docID);\n\n        // We must quantize exactly as BKD tree does else we'll get false failures\n        int xEnc = encodeValue(planetMax, point.x);\n        int yEnc = encodeValue(planetMax, point.y);\n        int zEnc = encodeValue(planetMax, point.z);\n\n        boolean expected = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n          yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n          zEnc >= zMinEnc && zEnc <= zMaxEnc;\n\n        if (expected != actual) {\n          System.out.println(\"docID=\" + docID + \" is wrong: expected=\" + expected + \" actual=\" + actual);\n          System.out.println(\"  x=\" + point.x + \" (\" + xEnc + \")\" + \" y=\" + point.y + \" (\" + yEnc + \")\" + \" z=\" + point.z + \" (\" + zEnc + \")\");\n          fail(\"wrong match\");\n        }\n      }\n    }\n\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBKDRandom() throws Exception {\n    List<Point> points = new ArrayList<>();\n    int numPoints = atLeast(10000);\n    Directory dir = newDirectory();\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048); \n\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n\n    PlanetModel planetModel;\n    if (random().nextBoolean()) {\n      planetModel = PlanetModel.WGS84;\n    } else {\n      planetModel = PlanetModel.SPHERE;\n    }\n    final double planetMax = planetModel.getMaximumMagnitude();\n    \n    BKD3DTreeWriter w = new BKD3DTreeWriter(maxPointsInLeaf, maxPointsSortInHeap);\n    for(int docID=0;docID<numPoints;docID++) {\n      Point point;\n      if (docID > 0 && random().nextInt(30) == 17) {\n        // Dup point\n        point = points.get(random().nextInt(points.size()));\n      } else {\n        point = new Point(randomCoord(planetModel),\n                          randomCoord(planetModel),\n                          randomCoord(planetModel));\n      }\n\n      if (VERBOSE) {\n        System.err.println(\"  docID=\" + docID + \" point=\" + point);\n        System.err.println(\"    x=\" + encodeValue(planetMax, point.x) +\n                           \" y=\" + encodeValue(planetMax, point.y) +\n                           \" z=\" + encodeValue(planetMax, point.z));\n      }\n\n      points.add(point);\n      w.add(encodeValue(planetMax, point.x),\n            encodeValue(planetMax, point.y),\n            encodeValue(planetMax, point.z),\n            docID);\n    }\n\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKD3DTreeReader r = new BKD3DTreeReader(in, numPoints);\n\n    int numIters = atLeast(100);\n    for(int iter=0;iter<numIters;iter++) {\n      // bbox\n      Range x = randomRange(planetModel);\n      Range y = randomRange(planetModel);\n      Range z = randomRange(planetModel);\n\n      int xMinEnc = encodeValue(planetMax, x.min);\n      int xMaxEnc = encodeValue(planetMax, x.max);\n      int yMinEnc = encodeValue(planetMax, y.min);\n      int yMaxEnc = encodeValue(planetMax, y.max);\n      int zMinEnc = encodeValue(planetMax, z.min);\n      int zMaxEnc = encodeValue(planetMax, z.max);\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" bbox: x=\" + x + \" (\" + xMinEnc + \" TO \" + xMaxEnc+ \")\" + \" y=\" + y + \" (\" + yMinEnc + \" TO \" + yMaxEnc + \")\"  + \" z=\" + z + \" (\" + zMinEnc + \" TO \" + zMaxEnc + \")\" );\n      }\n\n      DocIdSet hits = r.intersect(xMinEnc, xMaxEnc,\n                                  yMinEnc, yMaxEnc,\n                                  zMinEnc, zMaxEnc,\n\n                                  new BKD3DTreeReader.ValueFilter() {\n\n                                    @Override\n                                    public boolean accept(int docID) {\n                                      Point point = points.get(docID);\n                                      //System.out.println(\"  accept docID=\" + docID + \" point=\" + point + \" (x=\" + encodeValue(point.x) + \" y=\" + encodeValue(point.y) + \" z=\" + encodeValue(point.z) + \")\");\n\n                                      // System.out.println(\"  accept docID=\" + docID + \" point: x=\" + point.x + \" y=\" + point.y + \" z=\" + point.z);\n                                      int xEnc = encodeValue(planetMax, point.x);\n                                      int yEnc = encodeValue(planetMax, point.y);\n                                      int zEnc = encodeValue(planetMax, point.z);\n\n                                      boolean accept = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n                                        yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n                                        zEnc >= zMinEnc && zEnc <= zMaxEnc;\n                                      //System.out.println(\"    \" + accept);\n\n                                      return accept;\n                                    }\n\n                                    @Override\n                                    public BKD3DTreeReader.Relation compare(int cellXMin, int cellXMax,\n                                                                            int cellYMin, int cellYMax,\n                                                                            int cellZMin, int cellZMax) {\n                                      if (cellXMin > xMaxEnc || cellXMax < xMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellYMin > yMaxEnc || cellYMax < yMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellZMin > zMaxEnc || cellZMax < zMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n\n                                      if (cellXMin >= xMinEnc && cellXMax <= xMaxEnc &&\n                                          cellYMin >= yMinEnc && cellYMax <= yMaxEnc &&\n                                          cellZMin >= zMinEnc && cellZMax <= zMaxEnc) {\n                                        return BKD3DTreeReader.Relation.CELL_INSIDE_SHAPE;\n                                      }\n\n                                      if (xMinEnc >= cellXMin && xMaxEnc <= cellXMax &&\n                                          yMinEnc >= cellYMin && yMaxEnc <= cellYMax &&\n                                          zMinEnc >= cellZMin && zMaxEnc <= cellZMax) {\n                                        return BKD3DTreeReader.Relation.SHAPE_INSIDE_CELL;\n                                      }\n\n                                      return BKD3DTreeReader.Relation.SHAPE_CROSSES_CELL;\n                                    }\n                                  });\n\n      DocIdSetIterator disi = hits.iterator();\n      FixedBitSet matches = new FixedBitSet(numPoints);\n      while (true) {\n        int nextHit = disi.nextDoc();\n        if (nextHit == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n        matches.set(nextHit);\n      }\n      if (VERBOSE) {\n        System.err.println(\"  total hits: \" + matches.cardinality());\n      }\n\n      for(int docID=0;docID<numPoints;docID++) {\n        Point point = points.get(docID);\n        boolean actual = matches.get(docID);\n\n        // We must quantize exactly as BKD tree does else we'll get false failures\n        int xEnc = encodeValue(planetMax, point.x);\n        int yEnc = encodeValue(planetMax, point.y);\n        int zEnc = encodeValue(planetMax, point.z);\n\n        boolean expected = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n          yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n          zEnc >= zMinEnc && zEnc <= zMaxEnc;\n\n        if (expected != actual) {\n          System.out.println(\"docID=\" + docID + \" is wrong: expected=\" + expected + \" actual=\" + actual);\n          System.out.println(\"  x=\" + point.x + \" (\" + xEnc + \")\" + \" y=\" + point.y + \" (\" + yEnc + \")\" + \" z=\" + point.z + \" (\" + zEnc + \")\");\n          fail(\"wrong match\");\n        }\n      }\n    }\n\n    in.close();\n    dir.close();\n  }\n\n","bugFix":["f64b7098768253180859cd8faeae6b1a185b06ed"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testBKDRandom().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testBKDRandom().mjava","sourceNew":"  public void testBKDRandom() throws Exception {\n    List<Point> points = new ArrayList<>();\n    int numPoints = atLeast(10000);\n    Directory dir = getDirectory();\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048); \n\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n\n    PlanetModel planetModel = getPlanetModel();\n    final double planetMax = planetModel.getMaximumMagnitude();\n    \n    BKD3DTreeWriter w = new BKD3DTreeWriter(dir, \"bkd3d\", maxPointsInLeaf, maxPointsSortInHeap);\n    for(int docID=0;docID<numPoints;docID++) {\n      Point point;\n      if (docID > 0 && random().nextInt(30) == 17) {\n        // Dup point\n        point = points.get(random().nextInt(points.size()));\n      } else {\n        point = new Point(randomCoord(planetModel),\n                          randomCoord(planetModel),\n                          randomCoord(planetModel));\n      }\n\n      if (VERBOSE) {\n        System.err.println(\"  docID=\" + docID + \" point=\" + point);\n        System.err.println(\"    x=\" + encodeValue(planetMax, point.x) +\n                           \" y=\" + encodeValue(planetMax, point.y) +\n                           \" z=\" + encodeValue(planetMax, point.z));\n      }\n\n      points.add(point);\n      w.add(encodeValue(planetMax, point.x),\n            encodeValue(planetMax, point.y),\n            encodeValue(planetMax, point.z),\n            docID);\n    }\n\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKD3DTreeReader r = new BKD3DTreeReader(in, numPoints);\n\n    int numIters = atLeast(100);\n    for(int iter=0;iter<numIters;iter++) {\n      // bbox\n      Range x = randomRange(planetModel);\n      Range y = randomRange(planetModel);\n      Range z = randomRange(planetModel);\n\n      int xMinEnc = encodeValue(planetMax, x.min);\n      int xMaxEnc = encodeValue(planetMax, x.max);\n      int yMinEnc = encodeValue(planetMax, y.min);\n      int yMaxEnc = encodeValue(planetMax, y.max);\n      int zMinEnc = encodeValue(planetMax, z.min);\n      int zMaxEnc = encodeValue(planetMax, z.max);\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" bbox: x=\" + x + \" (\" + xMinEnc + \" TO \" + xMaxEnc+ \")\" + \" y=\" + y + \" (\" + yMinEnc + \" TO \" + yMaxEnc + \")\"  + \" z=\" + z + \" (\" + zMinEnc + \" TO \" + zMaxEnc + \")\" );\n      }\n\n      DocIdSet hits = r.intersect(xMinEnc, xMaxEnc,\n                                  yMinEnc, yMaxEnc,\n                                  zMinEnc, zMaxEnc,\n\n                                  new BKD3DTreeReader.ValueFilter() {\n\n                                    @Override\n                                    public boolean accept(int docID) {\n                                      Point point = points.get(docID);\n                                      //System.out.println(\"  accept docID=\" + docID + \" point=\" + point + \" (x=\" + encodeValue(point.x) + \" y=\" + encodeValue(point.y) + \" z=\" + encodeValue(point.z) + \")\");\n\n                                      // System.out.println(\"  accept docID=\" + docID + \" point: x=\" + point.x + \" y=\" + point.y + \" z=\" + point.z);\n                                      int xEnc = encodeValue(planetMax, point.x);\n                                      int yEnc = encodeValue(planetMax, point.y);\n                                      int zEnc = encodeValue(planetMax, point.z);\n\n                                      boolean accept = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n                                        yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n                                        zEnc >= zMinEnc && zEnc <= zMaxEnc;\n                                      //System.out.println(\"    \" + accept);\n\n                                      return accept;\n                                    }\n\n                                    @Override\n                                    public BKD3DTreeReader.Relation compare(int cellXMin, int cellXMax,\n                                                                            int cellYMin, int cellYMax,\n                                                                            int cellZMin, int cellZMax) {\n                                      if (cellXMin > xMaxEnc || cellXMax < xMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellYMin > yMaxEnc || cellYMax < yMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellZMin > zMaxEnc || cellZMax < zMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n\n                                      if (cellXMin >= xMinEnc && cellXMax <= xMaxEnc &&\n                                          cellYMin >= yMinEnc && cellYMax <= yMaxEnc &&\n                                          cellZMin >= zMinEnc && cellZMax <= zMaxEnc) {\n                                        return BKD3DTreeReader.Relation.CELL_INSIDE_SHAPE;\n                                      }\n\n                                      if (xMinEnc >= cellXMin && xMaxEnc <= cellXMax &&\n                                          yMinEnc >= cellYMin && yMaxEnc <= cellYMax &&\n                                          zMinEnc >= cellZMin && zMaxEnc <= cellZMax) {\n                                        return BKD3DTreeReader.Relation.SHAPE_INSIDE_CELL;\n                                      }\n\n                                      return BKD3DTreeReader.Relation.SHAPE_CROSSES_CELL;\n                                    }\n                                  });\n\n      DocIdSetIterator disi = hits.iterator();\n      FixedBitSet matches = new FixedBitSet(numPoints);\n      while (true) {\n        int nextHit = disi.nextDoc();\n        if (nextHit == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n        matches.set(nextHit);\n      }\n      if (VERBOSE) {\n        System.err.println(\"  total hits: \" + matches.cardinality());\n      }\n\n      for(int docID=0;docID<numPoints;docID++) {\n        Point point = points.get(docID);\n        boolean actual = matches.get(docID);\n\n        // We must quantize exactly as BKD tree does else we'll get false failures\n        int xEnc = encodeValue(planetMax, point.x);\n        int yEnc = encodeValue(planetMax, point.y);\n        int zEnc = encodeValue(planetMax, point.z);\n\n        boolean expected = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n          yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n          zEnc >= zMinEnc && zEnc <= zMaxEnc;\n\n        if (expected != actual) {\n          System.out.println(\"docID=\" + docID + \" is wrong: expected=\" + expected + \" actual=\" + actual);\n          System.out.println(\"  x=\" + point.x + \" (\" + xEnc + \")\" + \" y=\" + point.y + \" (\" + yEnc + \")\" + \" z=\" + point.z + \" (\" + zEnc + \")\");\n          fail(\"wrong match\");\n        }\n      }\n    }\n\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBKDRandom() throws Exception {\n    List<Point> points = new ArrayList<>();\n    int numPoints = atLeast(10000);\n    Directory dir = newDirectory();\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048); \n\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n\n    PlanetModel planetModel = getPlanetModel();\n    final double planetMax = planetModel.getMaximumMagnitude();\n    \n    BKD3DTreeWriter w = new BKD3DTreeWriter(maxPointsInLeaf, maxPointsSortInHeap);\n    for(int docID=0;docID<numPoints;docID++) {\n      Point point;\n      if (docID > 0 && random().nextInt(30) == 17) {\n        // Dup point\n        point = points.get(random().nextInt(points.size()));\n      } else {\n        point = new Point(randomCoord(planetModel),\n                          randomCoord(planetModel),\n                          randomCoord(planetModel));\n      }\n\n      if (VERBOSE) {\n        System.err.println(\"  docID=\" + docID + \" point=\" + point);\n        System.err.println(\"    x=\" + encodeValue(planetMax, point.x) +\n                           \" y=\" + encodeValue(planetMax, point.y) +\n                           \" z=\" + encodeValue(planetMax, point.z));\n      }\n\n      points.add(point);\n      w.add(encodeValue(planetMax, point.x),\n            encodeValue(planetMax, point.y),\n            encodeValue(planetMax, point.z),\n            docID);\n    }\n\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKD3DTreeReader r = new BKD3DTreeReader(in, numPoints);\n\n    int numIters = atLeast(100);\n    for(int iter=0;iter<numIters;iter++) {\n      // bbox\n      Range x = randomRange(planetModel);\n      Range y = randomRange(planetModel);\n      Range z = randomRange(planetModel);\n\n      int xMinEnc = encodeValue(planetMax, x.min);\n      int xMaxEnc = encodeValue(planetMax, x.max);\n      int yMinEnc = encodeValue(planetMax, y.min);\n      int yMaxEnc = encodeValue(planetMax, y.max);\n      int zMinEnc = encodeValue(planetMax, z.min);\n      int zMaxEnc = encodeValue(planetMax, z.max);\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" bbox: x=\" + x + \" (\" + xMinEnc + \" TO \" + xMaxEnc+ \")\" + \" y=\" + y + \" (\" + yMinEnc + \" TO \" + yMaxEnc + \")\"  + \" z=\" + z + \" (\" + zMinEnc + \" TO \" + zMaxEnc + \")\" );\n      }\n\n      DocIdSet hits = r.intersect(xMinEnc, xMaxEnc,\n                                  yMinEnc, yMaxEnc,\n                                  zMinEnc, zMaxEnc,\n\n                                  new BKD3DTreeReader.ValueFilter() {\n\n                                    @Override\n                                    public boolean accept(int docID) {\n                                      Point point = points.get(docID);\n                                      //System.out.println(\"  accept docID=\" + docID + \" point=\" + point + \" (x=\" + encodeValue(point.x) + \" y=\" + encodeValue(point.y) + \" z=\" + encodeValue(point.z) + \")\");\n\n                                      // System.out.println(\"  accept docID=\" + docID + \" point: x=\" + point.x + \" y=\" + point.y + \" z=\" + point.z);\n                                      int xEnc = encodeValue(planetMax, point.x);\n                                      int yEnc = encodeValue(planetMax, point.y);\n                                      int zEnc = encodeValue(planetMax, point.z);\n\n                                      boolean accept = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n                                        yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n                                        zEnc >= zMinEnc && zEnc <= zMaxEnc;\n                                      //System.out.println(\"    \" + accept);\n\n                                      return accept;\n                                    }\n\n                                    @Override\n                                    public BKD3DTreeReader.Relation compare(int cellXMin, int cellXMax,\n                                                                            int cellYMin, int cellYMax,\n                                                                            int cellZMin, int cellZMax) {\n                                      if (cellXMin > xMaxEnc || cellXMax < xMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellYMin > yMaxEnc || cellYMax < yMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellZMin > zMaxEnc || cellZMax < zMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n\n                                      if (cellXMin >= xMinEnc && cellXMax <= xMaxEnc &&\n                                          cellYMin >= yMinEnc && cellYMax <= yMaxEnc &&\n                                          cellZMin >= zMinEnc && cellZMax <= zMaxEnc) {\n                                        return BKD3DTreeReader.Relation.CELL_INSIDE_SHAPE;\n                                      }\n\n                                      if (xMinEnc >= cellXMin && xMaxEnc <= cellXMax &&\n                                          yMinEnc >= cellYMin && yMaxEnc <= cellYMax &&\n                                          zMinEnc >= cellZMin && zMaxEnc <= cellZMax) {\n                                        return BKD3DTreeReader.Relation.SHAPE_INSIDE_CELL;\n                                      }\n\n                                      return BKD3DTreeReader.Relation.SHAPE_CROSSES_CELL;\n                                    }\n                                  });\n\n      DocIdSetIterator disi = hits.iterator();\n      FixedBitSet matches = new FixedBitSet(numPoints);\n      while (true) {\n        int nextHit = disi.nextDoc();\n        if (nextHit == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n        matches.set(nextHit);\n      }\n      if (VERBOSE) {\n        System.err.println(\"  total hits: \" + matches.cardinality());\n      }\n\n      for(int docID=0;docID<numPoints;docID++) {\n        Point point = points.get(docID);\n        boolean actual = matches.get(docID);\n\n        // We must quantize exactly as BKD tree does else we'll get false failures\n        int xEnc = encodeValue(planetMax, point.x);\n        int yEnc = encodeValue(planetMax, point.y);\n        int zEnc = encodeValue(planetMax, point.z);\n\n        boolean expected = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n          yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n          zEnc >= zMinEnc && zEnc <= zMaxEnc;\n\n        if (expected != actual) {\n          System.out.println(\"docID=\" + docID + \" is wrong: expected=\" + expected + \" actual=\" + actual);\n          System.out.println(\"  x=\" + point.x + \" (\" + xEnc + \")\" + \" y=\" + point.y + \" (\" + yEnc + \")\" + \" z=\" + point.z + \" (\" + zEnc + \")\");\n          fail(\"wrong match\");\n        }\n      }\n    }\n\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testBKDRandom().mjava","sourceNew":null,"sourceOld":"  public void testBKDRandom() throws Exception {\n    List<Point> points = new ArrayList<>();\n    int numPoints = atLeast(10000);\n    Directory dir = getDirectory();\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048); \n\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n\n    PlanetModel planetModel = getPlanetModel();\n    final double planetMax = planetModel.getMaximumMagnitude();\n    \n    BKD3DTreeWriter w = new BKD3DTreeWriter(dir, \"bkd3d\", maxPointsInLeaf, maxPointsSortInHeap);\n    for(int docID=0;docID<numPoints;docID++) {\n      Point point;\n      if (docID > 0 && random().nextInt(30) == 17) {\n        // Dup point\n        point = points.get(random().nextInt(points.size()));\n      } else {\n        point = new Point(randomCoord(planetModel),\n                          randomCoord(planetModel),\n                          randomCoord(planetModel));\n      }\n\n      if (VERBOSE) {\n        System.err.println(\"  docID=\" + docID + \" point=\" + point);\n        System.err.println(\"    x=\" + encodeValue(planetMax, point.x) +\n                           \" y=\" + encodeValue(planetMax, point.y) +\n                           \" z=\" + encodeValue(planetMax, point.z));\n      }\n\n      points.add(point);\n      w.add(encodeValue(planetMax, point.x),\n            encodeValue(planetMax, point.y),\n            encodeValue(planetMax, point.z),\n            docID);\n    }\n\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKD3DTreeReader r = new BKD3DTreeReader(in, numPoints);\n\n    int numIters = atLeast(100);\n    for(int iter=0;iter<numIters;iter++) {\n      // bbox\n      Range x = randomRange(planetModel);\n      Range y = randomRange(planetModel);\n      Range z = randomRange(planetModel);\n\n      int xMinEnc = encodeValue(planetMax, x.min);\n      int xMaxEnc = encodeValue(planetMax, x.max);\n      int yMinEnc = encodeValue(planetMax, y.min);\n      int yMaxEnc = encodeValue(planetMax, y.max);\n      int zMinEnc = encodeValue(planetMax, z.min);\n      int zMaxEnc = encodeValue(planetMax, z.max);\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" bbox: x=\" + x + \" (\" + xMinEnc + \" TO \" + xMaxEnc+ \")\" + \" y=\" + y + \" (\" + yMinEnc + \" TO \" + yMaxEnc + \")\"  + \" z=\" + z + \" (\" + zMinEnc + \" TO \" + zMaxEnc + \")\" );\n      }\n\n      DocIdSet hits = r.intersect(xMinEnc, xMaxEnc,\n                                  yMinEnc, yMaxEnc,\n                                  zMinEnc, zMaxEnc,\n\n                                  new BKD3DTreeReader.ValueFilter() {\n\n                                    @Override\n                                    public boolean accept(int docID) {\n                                      Point point = points.get(docID);\n                                      //System.out.println(\"  accept docID=\" + docID + \" point=\" + point + \" (x=\" + encodeValue(point.x) + \" y=\" + encodeValue(point.y) + \" z=\" + encodeValue(point.z) + \")\");\n\n                                      // System.out.println(\"  accept docID=\" + docID + \" point: x=\" + point.x + \" y=\" + point.y + \" z=\" + point.z);\n                                      int xEnc = encodeValue(planetMax, point.x);\n                                      int yEnc = encodeValue(planetMax, point.y);\n                                      int zEnc = encodeValue(planetMax, point.z);\n\n                                      boolean accept = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n                                        yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n                                        zEnc >= zMinEnc && zEnc <= zMaxEnc;\n                                      //System.out.println(\"    \" + accept);\n\n                                      return accept;\n                                    }\n\n                                    @Override\n                                    public BKD3DTreeReader.Relation compare(int cellXMin, int cellXMax,\n                                                                            int cellYMin, int cellYMax,\n                                                                            int cellZMin, int cellZMax) {\n                                      if (cellXMin > xMaxEnc || cellXMax < xMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellYMin > yMaxEnc || cellYMax < yMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n                                      if (cellZMin > zMaxEnc || cellZMax < zMinEnc) {\n                                        return BKD3DTreeReader.Relation.SHAPE_OUTSIDE_CELL;\n                                      }\n\n                                      if (cellXMin >= xMinEnc && cellXMax <= xMaxEnc &&\n                                          cellYMin >= yMinEnc && cellYMax <= yMaxEnc &&\n                                          cellZMin >= zMinEnc && cellZMax <= zMaxEnc) {\n                                        return BKD3DTreeReader.Relation.CELL_INSIDE_SHAPE;\n                                      }\n\n                                      if (xMinEnc >= cellXMin && xMaxEnc <= cellXMax &&\n                                          yMinEnc >= cellYMin && yMaxEnc <= cellYMax &&\n                                          zMinEnc >= cellZMin && zMaxEnc <= cellZMax) {\n                                        return BKD3DTreeReader.Relation.SHAPE_INSIDE_CELL;\n                                      }\n\n                                      return BKD3DTreeReader.Relation.SHAPE_CROSSES_CELL;\n                                    }\n                                  });\n\n      DocIdSetIterator disi = hits.iterator();\n      FixedBitSet matches = new FixedBitSet(numPoints);\n      while (true) {\n        int nextHit = disi.nextDoc();\n        if (nextHit == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n        matches.set(nextHit);\n      }\n      if (VERBOSE) {\n        System.err.println(\"  total hits: \" + matches.cardinality());\n      }\n\n      for(int docID=0;docID<numPoints;docID++) {\n        Point point = points.get(docID);\n        boolean actual = matches.get(docID);\n\n        // We must quantize exactly as BKD tree does else we'll get false failures\n        int xEnc = encodeValue(planetMax, point.x);\n        int yEnc = encodeValue(planetMax, point.y);\n        int zEnc = encodeValue(planetMax, point.z);\n\n        boolean expected = xEnc >= xMinEnc && xEnc <= xMaxEnc &&\n          yEnc >= yMinEnc && yEnc <= yMaxEnc &&\n          zEnc >= zMinEnc && zEnc <= zMaxEnc;\n\n        if (expected != actual) {\n          System.out.println(\"docID=\" + docID + \" is wrong: expected=\" + expected + \" actual=\" + actual);\n          System.out.println(\"  x=\" + point.x + \" (\" + xEnc + \")\" + \" y=\" + point.y + \" (\" + yEnc + \")\" + \" z=\" + point.z + \" (\" + zEnc + \")\");\n          fail(\"wrong match\");\n        }\n      }\n    }\n\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d8f71af177fad4bbfdf462d318247e573faac27f":["f64b7098768253180859cd8faeae6b1a185b06ed"],"f64b7098768253180859cd8faeae6b1a185b06ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["d8f71af177fad4bbfdf462d318247e573faac27f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"d8f71af177fad4bbfdf462d318247e573faac27f":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"f64b7098768253180859cd8faeae6b1a185b06ed":["d8f71af177fad4bbfdf462d318247e573faac27f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f64b7098768253180859cd8faeae6b1a185b06ed"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}