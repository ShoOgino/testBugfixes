{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","commits":[{"id":"f7fb1186f5b61e0b74289e6786df8cbecfa471bc","date":1545308188,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}\", markerPath, delta, cleanupTTL);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne.toString());\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}\", markerPath, delta, cleanupTTL);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... ({}}\", markerPath, e.getMessage());\n      }\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["98d4af357762468d37df7424f81785cd89b49a7b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98d4af357762468d37df7424f81785cd89b49a7b","date":1570534862,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","sourceNew":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        boolean activeMarker = payload.getOrDefault(MARKER_STATE, MARKER_ACTIVE)\n            .equals(MARKER_ACTIVE);\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL || !activeMarker) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne.toString());\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... ({}}\", markerPath, e.getMessage());\n      }\n    });\n  }\n\n","sourceOld":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}\", markerPath, delta, cleanupTTL);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne.toString());\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}\", markerPath, delta, cleanupTTL);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... ({}}\", markerPath, e.getMessage());\n      }\n    });\n  }\n\n","bugFix":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","sourceNew":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        boolean activeMarker = payload.getOrDefault(MARKER_STATE, MARKER_ACTIVE)\n            .equals(MARKER_ACTIVE);\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL || !activeMarker) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne.toString());\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... ({}}\", markerPath, e.getMessage());\n      }\n    });\n  }\n\n","sourceOld":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}\", markerPath, delta, cleanupTTL);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne.toString());\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}\", markerPath, delta, cleanupTTL);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... ({}}\", markerPath, e.getMessage());\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","sourceNew":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        boolean activeMarker = payload.getOrDefault(MARKER_STATE, MARKER_ACTIVE)\n            .equals(MARKER_ACTIVE);\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL || !activeMarker) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne);\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... ({}}\", markerPath, e.getMessage());\n      }\n    });\n  }\n\n","sourceOld":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        boolean activeMarker = payload.getOrDefault(MARKER_STATE, MARKER_ACTIVE)\n            .equals(MARKER_ACTIVE);\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL || !activeMarker) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne.toString());\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... ({}}\", markerPath, e.getMessage());\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","sourceNew":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        boolean activeMarker = payload.getOrDefault(MARKER_STATE, MARKER_ACTIVE)\n            .equals(MARKER_ACTIVE);\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL || !activeMarker) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne);\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... \", markerPath, e);\n      }\n    });\n  }\n\n","sourceOld":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        boolean activeMarker = payload.getOrDefault(MARKER_STATE, MARKER_ACTIVE)\n            .equals(MARKER_ACTIVE);\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL || !activeMarker) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne);\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... ({}}\", markerPath, e.getMessage());\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/InactiveMarkersPlanAction#cleanupMarkers(String,long,Set[String]).mjava","sourceNew":null,"sourceOld":"  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {\n    DistribStateManager stateManager = cloudManager.getDistribStateManager();\n    if (!stateManager.hasData(path)) {\n      return;\n    }\n    List<String> markers = stateManager.listData(path);\n    markers.forEach(m -> {\n      String markerPath = path + \"/\" + m;\n      try {\n        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);\n        if (payload.isEmpty()) {\n          log.trace(\" -- ignore {}: either missing or unsupported format\", markerPath);\n          return;\n        }\n        boolean activeMarker = payload.getOrDefault(MARKER_STATE, MARKER_ACTIVE)\n            .equals(MARKER_ACTIVE);\n        long timestamp = ((Number)payload.get(\"timestamp\")).longValue();\n        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);\n        if (delta > cleanupTTL || !activeMarker) {\n          try {\n            stateManager.removeData(markerPath, -1);\n            log.trace(\" -- remove {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n            cleanedUp.add(m);\n          } catch (NoSuchElementException nse) {\n            // someone already removed it - ignore\n            return;\n          } catch (BadVersionException be) {\n            throw new RuntimeException(\"should never happen\", be);\n          } catch (NotEmptyException ne) {\n            log.error(\"Marker znode should be empty but it's not! Ignoring {} ({})\", markerPath, ne);\n          }\n        } else {\n          log.trace(\" -- keep {}, delta={}, ttl={}, active={}\", markerPath, delta, cleanupTTL, activeMarker);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      } catch (IOException | KeeperException e) {\n        log.warn(\"Could not cleanup marker at {}, skipping... \", markerPath, e);\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f7fb1186f5b61e0b74289e6786df8cbecfa471bc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"98d4af357762468d37df7424f81785cd89b49a7b":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57c238f5fb83803b49b37b3a1a12224a64d47542":["e35f2dde06b35aa9904949a3a93fabd090371077"],"e35f2dde06b35aa9904949a3a93fabd090371077":["98d4af357762468d37df7424f81785cd89b49a7b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"b0b597c65628ca9e73913a07e81691f8229bae35":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc","98d4af357762468d37df7424f81785cd89b49a7b"]},"commit2Childs":{"f7fb1186f5b61e0b74289e6786df8cbecfa471bc":["98d4af357762468d37df7424f81785cd89b49a7b","b0b597c65628ca9e73913a07e81691f8229bae35"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"98d4af357762468d37df7424f81785cd89b49a7b":["e35f2dde06b35aa9904949a3a93fabd090371077","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["3f504512a03d978990cbff30db0522b354e846db"],"e35f2dde06b35aa9904949a3a93fabd090371077":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}