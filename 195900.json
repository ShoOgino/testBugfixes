{"path":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b80ad3438ccc68d1ef441add711ed2143324f14","date":1293087175,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc5ecd93bcd50b2199757091d526fc1bcbce0db1","date":1293154244,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecc11368dc265bfdad90214f8bf5da99016ab1e2","date":1294144090,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":null,"sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":5,"author":"Michael Busch","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["9454a6510e2db155fb01faa5c049b06ece95fab9","ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"ecc11368dc265bfdad90214f8bf5da99016ab1e2":["9b80ad3438ccc68d1ef441add711ed2143324f14"],"dc5ecd93bcd50b2199757091d526fc1bcbce0db1":["9454a6510e2db155fb01faa5c049b06ece95fab9","9b80ad3438ccc68d1ef441add711ed2143324f14"],"9b80ad3438ccc68d1ef441add711ed2143324f14":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["dc5ecd93bcd50b2199757091d526fc1bcbce0db1","ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":[],"ecc11368dc265bfdad90214f8bf5da99016ab1e2":["70ad682703b8585f5d0a637efec044d57ec05efb","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dc5ecd93bcd50b2199757091d526fc1bcbce0db1":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"9b80ad3438ccc68d1ef441add711ed2143324f14":["ecc11368dc265bfdad90214f8bf5da99016ab1e2","dc5ecd93bcd50b2199757091d526fc1bcbce0db1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["70ad682703b8585f5d0a637efec044d57ec05efb","dc5ecd93bcd50b2199757091d526fc1bcbce0db1","9b80ad3438ccc68d1ef441add711ed2143324f14"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["70ad682703b8585f5d0a637efec044d57ec05efb","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}