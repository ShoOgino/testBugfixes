{"path":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase#compareData(List[ControlData],List[ControlData]).mjava","commits":[{"id":"3337b86edd36607f0208321f1deee79c55e5fd21","date":1321266471,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase#compareData(List[ControlData],List[ControlData]).mjava","pathOld":"/dev/null","sourceNew":"\tprotected void compareData(List<ControlData> theControl, List<ControlData> test) {\n\t\t// The test data should come back primarily in Key order and secondarily in insertion order.\n\t\tList<ControlData> control = new ArrayList<ControlData>(theControl);\n\t\tCollections.sort(control);\n\n\t\tStringBuilder errors = new StringBuilder();\n\t\tif (test.size() != control.size()) {\n\t\t\terrors.append(\"-Returned data has \" + test.size() + \" records.  expected: \" + control.size() + \"\\n\");\n\t\t}\n\t\tfor (int i = 0; i < control.size() && i < test.size(); i++) {\n\t\t\tObject[] controlRec = control.get(i).data;\n\t\t\tObject[] testRec = test.get(i).data;\n\t\t\tif (testRec.length != controlRec.length) {\n\t\t\t\terrors.append(\"-Record indexAt=\" + i + \" has \" + testRec.length + \" data elements.  extpected: \" + controlRec.length + \"\\n\");\n\t\t\t}\n\t\t\tfor (int j = 0; j < controlRec.length && j < testRec.length; j++) {\n\t\t\t\tObject controlObj = controlRec[j];\n\t\t\t\tObject testObj = testRec[j];\n\t\t\t\tif (controlObj == null && testObj != null) {\n\t\t\t\t\terrors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is not NULL as expected.\\n\");\n\t\t\t\t} else if (controlObj != null && testObj == null) {\n\t\t\t\t\terrors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is NULL.  Expected: \" + controlObj + \" (class=\"\n\t\t\t\t\t\t\t+ controlObj.getClass().getName() + \")\\n\");\n\t\t\t\t} else if (controlObj != null && testObj != null && controlObj instanceof Clob) {\n\t\t\t\t\tString controlString = clobToString((Clob) controlObj);\n\t\t\t\t\tString testString = clobToString((Clob) testObj);\n\t\t\t\t\tif (!controlString.equals(testString)) {\n\t\t\t\t\t\terrors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testString + \" (class=Clob) ... Expected: \" + controlString\n\t\t\t\t\t\t\t\t+ \" (class=Clob)\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else if (controlObj != null && !controlObj.equals(testObj)) {\n\t\t\t\t\terrors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testObj + \" (class=\" + testObj.getClass().getName()\n\t\t\t\t\t\t\t+ \") ... Expected: \" + controlObj + \" (class=\" + controlObj.getClass().getName() + \")\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (errors.length() > 0) {\n\t\t\tAssert.fail(errors.toString());\n\t\t}\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase#compareData(List[ControlData],List[ControlData]).mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase#compareData(List[ControlData],List[ControlData]).mjava","sourceNew":"  protected void compareData(List<ControlData> theControl, List<ControlData> test) {\n    // The test data should come back primarily in Key order and secondarily in insertion order.\n    List<ControlData> control = new ArrayList<ControlData>(theControl);\n    Collections.sort(control);\n\n    StringBuilder errors = new StringBuilder();\n    if (test.size() != control.size()) {\n      errors.append(\"-Returned data has \" + test.size() + \" records.  expected: \" + control.size() + \"\\n\");\n    }\n    for (int i = 0; i < control.size() && i < test.size(); i++) {\n      Object[] controlRec = control.get(i).data;\n      Object[] testRec = test.get(i).data;\n      if (testRec.length != controlRec.length) {\n        errors.append(\"-Record indexAt=\" + i + \" has \" + testRec.length + \" data elements.  extpected: \" + controlRec.length + \"\\n\");\n      }\n      for (int j = 0; j < controlRec.length && j < testRec.length; j++) {\n        Object controlObj = controlRec[j];\n        Object testObj = testRec[j];\n        if (controlObj == null && testObj != null) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is not NULL as expected.\\n\");\n        } else if (controlObj != null && testObj == null) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is NULL.  Expected: \" + controlObj + \" (class=\"\n              + controlObj.getClass().getName() + \")\\n\");\n        } else if (controlObj != null && testObj != null && controlObj instanceof Clob) {\n          String controlString = clobToString((Clob) controlObj);\n          String testString = clobToString((Clob) testObj);\n          if (!controlString.equals(testString)) {\n            errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testString + \" (class=Clob) ... Expected: \" + controlString\n                + \" (class=Clob)\\n\");\n          }\n        } else if (controlObj != null && !controlObj.equals(testObj)) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testObj + \" (class=\" + testObj.getClass().getName()\n              + \") ... Expected: \" + controlObj + \" (class=\" + controlObj.getClass().getName() + \")\\n\");\n        }\n      }\n    }\n    if (errors.length() > 0) {\n      Assert.fail(errors.toString());\n    }\n  }\n\n","sourceOld":"\tprotected void compareData(List<ControlData> theControl, List<ControlData> test) {\n\t\t// The test data should come back primarily in Key order and secondarily in insertion order.\n\t\tList<ControlData> control = new ArrayList<ControlData>(theControl);\n\t\tCollections.sort(control);\n\n\t\tStringBuilder errors = new StringBuilder();\n\t\tif (test.size() != control.size()) {\n\t\t\terrors.append(\"-Returned data has \" + test.size() + \" records.  expected: \" + control.size() + \"\\n\");\n\t\t}\n\t\tfor (int i = 0; i < control.size() && i < test.size(); i++) {\n\t\t\tObject[] controlRec = control.get(i).data;\n\t\t\tObject[] testRec = test.get(i).data;\n\t\t\tif (testRec.length != controlRec.length) {\n\t\t\t\terrors.append(\"-Record indexAt=\" + i + \" has \" + testRec.length + \" data elements.  extpected: \" + controlRec.length + \"\\n\");\n\t\t\t}\n\t\t\tfor (int j = 0; j < controlRec.length && j < testRec.length; j++) {\n\t\t\t\tObject controlObj = controlRec[j];\n\t\t\t\tObject testObj = testRec[j];\n\t\t\t\tif (controlObj == null && testObj != null) {\n\t\t\t\t\terrors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is not NULL as expected.\\n\");\n\t\t\t\t} else if (controlObj != null && testObj == null) {\n\t\t\t\t\terrors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is NULL.  Expected: \" + controlObj + \" (class=\"\n\t\t\t\t\t\t\t+ controlObj.getClass().getName() + \")\\n\");\n\t\t\t\t} else if (controlObj != null && testObj != null && controlObj instanceof Clob) {\n\t\t\t\t\tString controlString = clobToString((Clob) controlObj);\n\t\t\t\t\tString testString = clobToString((Clob) testObj);\n\t\t\t\t\tif (!controlString.equals(testString)) {\n\t\t\t\t\t\terrors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testString + \" (class=Clob) ... Expected: \" + controlString\n\t\t\t\t\t\t\t\t+ \" (class=Clob)\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else if (controlObj != null && !controlObj.equals(testObj)) {\n\t\t\t\t\terrors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testObj + \" (class=\" + testObj.getClass().getName()\n\t\t\t\t\t\t\t+ \") ... Expected: \" + controlObj + \" (class=\" + controlObj.getClass().getName() + \")\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (errors.length() > 0) {\n\t\t\tAssert.fail(errors.toString());\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase#compareData(List[ControlData],List[ControlData]).mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase#compareData(List[ControlData],List[ControlData]).mjava","sourceNew":"  protected void compareData(List<ControlData> theControl, List<ControlData> test) {\n    // The test data should come back primarily in Key order and secondarily in insertion order.\n    List<ControlData> control = new ArrayList<>(theControl);\n    Collections.sort(control);\n\n    StringBuilder errors = new StringBuilder();\n    if (test.size() != control.size()) {\n      errors.append(\"-Returned data has \" + test.size() + \" records.  expected: \" + control.size() + \"\\n\");\n    }\n    for (int i = 0; i < control.size() && i < test.size(); i++) {\n      Object[] controlRec = control.get(i).data;\n      Object[] testRec = test.get(i).data;\n      if (testRec.length != controlRec.length) {\n        errors.append(\"-Record indexAt=\" + i + \" has \" + testRec.length + \" data elements.  extpected: \" + controlRec.length + \"\\n\");\n      }\n      for (int j = 0; j < controlRec.length && j < testRec.length; j++) {\n        Object controlObj = controlRec[j];\n        Object testObj = testRec[j];\n        if (controlObj == null && testObj != null) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is not NULL as expected.\\n\");\n        } else if (controlObj != null && testObj == null) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is NULL.  Expected: \" + controlObj + \" (class=\"\n              + controlObj.getClass().getName() + \")\\n\");\n        } else if (controlObj != null && testObj != null && controlObj instanceof Clob) {\n          String controlString = clobToString((Clob) controlObj);\n          String testString = clobToString((Clob) testObj);\n          if (!controlString.equals(testString)) {\n            errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testString + \" (class=Clob) ... Expected: \" + controlString\n                + \" (class=Clob)\\n\");\n          }\n        } else if (controlObj != null && !controlObj.equals(testObj)) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testObj + \" (class=\" + testObj.getClass().getName()\n              + \") ... Expected: \" + controlObj + \" (class=\" + controlObj.getClass().getName() + \")\\n\");\n        }\n      }\n    }\n    if (errors.length() > 0) {\n      Assert.fail(errors.toString());\n    }\n  }\n\n","sourceOld":"  protected void compareData(List<ControlData> theControl, List<ControlData> test) {\n    // The test data should come back primarily in Key order and secondarily in insertion order.\n    List<ControlData> control = new ArrayList<ControlData>(theControl);\n    Collections.sort(control);\n\n    StringBuilder errors = new StringBuilder();\n    if (test.size() != control.size()) {\n      errors.append(\"-Returned data has \" + test.size() + \" records.  expected: \" + control.size() + \"\\n\");\n    }\n    for (int i = 0; i < control.size() && i < test.size(); i++) {\n      Object[] controlRec = control.get(i).data;\n      Object[] testRec = test.get(i).data;\n      if (testRec.length != controlRec.length) {\n        errors.append(\"-Record indexAt=\" + i + \" has \" + testRec.length + \" data elements.  extpected: \" + controlRec.length + \"\\n\");\n      }\n      for (int j = 0; j < controlRec.length && j < testRec.length; j++) {\n        Object controlObj = controlRec[j];\n        Object testObj = testRec[j];\n        if (controlObj == null && testObj != null) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is not NULL as expected.\\n\");\n        } else if (controlObj != null && testObj == null) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is NULL.  Expected: \" + controlObj + \" (class=\"\n              + controlObj.getClass().getName() + \")\\n\");\n        } else if (controlObj != null && testObj != null && controlObj instanceof Clob) {\n          String controlString = clobToString((Clob) controlObj);\n          String testString = clobToString((Clob) testObj);\n          if (!controlString.equals(testString)) {\n            errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testString + \" (class=Clob) ... Expected: \" + controlString\n                + \" (class=Clob)\\n\");\n          }\n        } else if (controlObj != null && !controlObj.equals(testObj)) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testObj + \" (class=\" + testObj.getClass().getName()\n              + \") ... Expected: \" + controlObj + \" (class=\" + controlObj.getClass().getName() + \")\\n\");\n        }\n      }\n    }\n    if (errors.length() > 0) {\n      Assert.fail(errors.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b","date":1598712724,"type":4,"author":"Alexandre Rafalovitch","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase#compareData(List[ControlData],List[ControlData]).mjava","sourceNew":null,"sourceOld":"  protected void compareData(List<ControlData> theControl, List<ControlData> test) {\n    // The test data should come back primarily in Key order and secondarily in insertion order.\n    List<ControlData> control = new ArrayList<>(theControl);\n    Collections.sort(control);\n\n    StringBuilder errors = new StringBuilder();\n    if (test.size() != control.size()) {\n      errors.append(\"-Returned data has \" + test.size() + \" records.  expected: \" + control.size() + \"\\n\");\n    }\n    for (int i = 0; i < control.size() && i < test.size(); i++) {\n      Object[] controlRec = control.get(i).data;\n      Object[] testRec = test.get(i).data;\n      if (testRec.length != controlRec.length) {\n        errors.append(\"-Record indexAt=\" + i + \" has \" + testRec.length + \" data elements.  extpected: \" + controlRec.length + \"\\n\");\n      }\n      for (int j = 0; j < controlRec.length && j < testRec.length; j++) {\n        Object controlObj = controlRec[j];\n        Object testObj = testRec[j];\n        if (controlObj == null && testObj != null) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is not NULL as expected.\\n\");\n        } else if (controlObj != null && testObj == null) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" is NULL.  Expected: \" + controlObj + \" (class=\"\n              + controlObj.getClass().getName() + \")\\n\");\n        } else if (controlObj != null && testObj != null && controlObj instanceof Clob) {\n          String controlString = clobToString((Clob) controlObj);\n          String testString = clobToString((Clob) testObj);\n          if (!controlString.equals(testString)) {\n            errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testString + \" (class=Clob) ... Expected: \" + controlString\n                + \" (class=Clob)\\n\");\n          }\n        } else if (controlObj != null && !controlObj.equals(testObj)) {\n          errors.append(\"-Record indexAt=\" + i + \", Data Element indexAt=\" + j + \" has: \" + testObj + \" (class=\" + testObj.getClass().getName()\n              + \") ... Expected: \" + controlObj + \" (class=\" + controlObj.getClass().getName() + \")\\n\");\n        }\n      }\n    }\n    if (errors.length() > 0) {\n      Assert.fail(errors.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3337b86edd36607f0208321f1deee79c55e5fd21":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["3337b86edd36607f0208321f1deee79c55e5fd21"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3337b86edd36607f0208321f1deee79c55e5fd21":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3337b86edd36607f0208321f1deee79c55e5fd21"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}