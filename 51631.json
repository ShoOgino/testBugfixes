{"path":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#reflectFieldSize(long,Field).mjava","commits":[{"id":"dd6c9e9b1251473f465b0443b56046b2658402da","date":1332082750,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#reflectFieldSize(long,Field).mjava","pathOld":"/dev/null","sourceNew":"  private static long reflectFieldSize(long size, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (useUnsafe) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(size, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      return size + fsize;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9139c54cd548a746e88dfa944497dccef7629321"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10cd47aac3c4e8c583740a750335f8aab14555b3","date":1332522358,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#reflectFieldSize(long,Field).mjava","sourceNew":"  /**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code>\n   * is the object's size measured so far. <code>f</code> is the field being probed.\n   * \n   * <p>The returned offset will be the maximum of whatever was measured so far and \n   * <code>f</code> field's offset and representation size (unaligned).\n   */\n  private static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (objectFieldOffsetMethod != null) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(sizeSoFar, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      // TODO: No alignments based on field type/ subclass fields alignments?\n      return sizeSoFar + fsize;\n    }\n  }\n\n","sourceOld":"  private static long reflectFieldSize(long size, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (useUnsafe) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(size, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      return size + fsize;\n    }\n  }\n\n","bugFix":null,"bugIntro":["9139c54cd548a746e88dfa944497dccef7629321"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd6c9e9b1251473f465b0443b56046b2658402da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"10cd47aac3c4e8c583740a750335f8aab14555b3":["dd6c9e9b1251473f465b0443b56046b2658402da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["10cd47aac3c4e8c583740a750335f8aab14555b3"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd6c9e9b1251473f465b0443b56046b2658402da"],"dd6c9e9b1251473f465b0443b56046b2658402da":["10cd47aac3c4e8c583740a750335f8aab14555b3"],"10cd47aac3c4e8c583740a750335f8aab14555b3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}