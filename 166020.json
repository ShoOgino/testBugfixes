{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","commits":[{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    external = getInt(STATE_FORMAT,1)>1;\n\n    assert name != null && slices != null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    external = getInt(STATE_FORMAT,1)>1;\n\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":1,"author":"murblanc","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   * @param zkVersion The version of the Collection node in Zookeeper (used for conditional updates).\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   * @param zkVersion The version of the Collection node in Zookeeper (used for conditional updates).\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   * @param zkVersion The version of the Collection node in Zookeeper (used for conditional updates).\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   * @param zkVersion The version of the Collection node in Zookeeper (used for conditional updates).\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   * @param zkVersion The version of the Collection node in Zookeeper (used for conditional updates).\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"9279b175e5e66258442d2123a50f052219a9cc1b":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["9279b175e5e66258442d2123a50f052219a9cc1b"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"9279b175e5e66258442d2123a50f052219a9cc1b":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}