{"path":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","commits":[{"id":"8c12c43c449a172df0f2b122918f0f5fc0e9a470","date":1438415333,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","pathOld":"/dev/null","sourceNew":"  private static void verify(Bits missing, long[] values) throws Exception {\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048);\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = new RangeTreeDocValuesFormat(maxPointsInLeaf, maxPointsSortInHeap);\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the NumericTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcb51fecc8dab4f1ea6aadb9cb87c27d50918b74","date":1438421983,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  private static void verify(Bits missing, long[] values) throws Exception {\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048);\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = new RangeTreeDocValuesFormat(maxPointsInLeaf, maxPointsSortInHeap);\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048);\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = new RangeTreeDocValuesFormat(maxPointsInLeaf, maxPointsSortInHeap);\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the NumericTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4c5fa5f082c708f32344b3919b9b4bc8eba0d9","date":1438508718,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  private static void verify(Bits missing, long[] values) throws Exception {\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048);\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = new RangeTreeDocValuesFormat(maxPointsInLeaf, maxPointsSortInHeap);\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048);\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = new RangeTreeDocValuesFormat(maxPointsInLeaf, maxPointsSortInHeap);\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89a0e70ecaf27e127004b7fbfad2e02d52ea1f8f","date":1439766922,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048);\n    int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = new RangeTreeDocValuesFormat(maxPointsInLeaf, maxPointsSortInHeap);\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a6fe0cad9503f2c3eaca4de8c4f80a9eb14f0","date":1445351343,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestRangeTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestRangeTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a870f9917149dc600c4ad4417d615c1795de5864","date":1445975387,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene54Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestRangeTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene53Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestRangeTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eee4175312c41f89aa23427f9e4edfc00deeaac","date":1446373190,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene60Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestRangeTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene54Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestRangeTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":6,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestDimensionalRangeQuery#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestDimensionalRangeQuery\")));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new DimensionalField(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && BKDUtil.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new DimensionalRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene60Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestRangeTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":["5e2673c41503db59fb58c2e183343e434cf4204e","1800b996d8677670482a071dcb7a48b08c423ace","5e2673c41503db59fb58c2e183343e434cf4204e","1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestDimensionalRangeQuery#verifyLongs(long[],int[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/rangetree/TestRangeTree#verify(Bits,long[]).mjava","sourceNew":"  // verify for long values\n  private static void verifyLongs(long[] values, int[] ids) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (values.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestRangeTree\")));\n    } else {\n      dir = getDirectory();\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int ord=0;ord<values.length;ord++) {\n\n      int id;\n      if (ids == null) {\n        id = ord;\n      } else {\n        id = ids[ord];\n      }\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new DimensionalField(\"sn_value\", values[id]));\n        byte[] bytes = new byte[8];\n        BKDUtil.longToBytes(values[id], bytes, 0);\n        doc.add(new DimensionalField(\"ss_value\", bytes));\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              Long lower = randomValue(true);\n              Long upper = randomValue(true);\n\n              if (lower != null && upper != null && upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" (inclusive?=\" + includeLower + \") TO \" + upper + \" (inclusive?=\" + includeUpper + \")\");\n                byte[] tmp = new byte[8];\n                if (lower != null) {\n                  BKDUtil.longToBytes(lower, tmp, 0);\n                  System.out.println(\"  lower bytes=\" + Arrays.toString(tmp));\n                }\n                if (upper != null) {\n                  BKDUtil.longToBytes(upper, tmp, 0);\n                  System.out.println(\"  upper bytes=\" + Arrays.toString(tmp));\n                }\n              }\n\n              if (random().nextBoolean()) {\n                query = new DimensionalRangeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                byte[] lowerBytes;\n                if (lower == null) {\n                  lowerBytes = null;\n                } else {\n                  lowerBytes = new byte[8];\n                  BKDUtil.longToBytes(lower, lowerBytes, 0);\n                }\n                byte[] upperBytes;\n                if (upper == null) {\n                  upperBytes = null;\n                } else {\n                  upperBytes = new byte[8];\n                  BKDUtil.longToBytes(upper, upperBytes, 0);\n                }\n                query = new DimensionalRangeQuery(\"ss_value\", lowerBytes, includeLower, upperBytes, includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.get(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(Bits missing, long[] values) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < values.length/100) {\n      iwc.setMaxBufferedDocs(values.length/100);\n    }\n    final DocValuesFormat dvFormat = getDocValuesFormat();\n    Codec codec = new Lucene60Codec() {\n        @Override\n        public DocValuesFormat getDocValuesFormatForField(String field) {\n          if (field.equals(\"sn_value\") || field.equals(\"ss_value\")) {\n            return dvFormat;\n          } else {\n            return super.getDocValuesFormatForField(field);\n          }\n        }\n      };\n    iwc.setCodec(codec);\n    Directory dir;\n    if (values.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestRangeTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<values.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (missing.get(id) == false) {\n        doc.add(new SortedNumericDocValuesField(\"sn_value\", values[id]));\n        doc.add(new SortedSetDocValuesField(\"ss_value\", longToBytes(values[id])));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the NumericRangeTreeQuery must see the RangeTreeDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads\");\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n              long lower = randomValue();\n              long upper = randomValue();\n\n              if (upper < lower) {\n                long x = lower;\n                lower = upper;\n                upper = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" value=\" + lower + \" TO \" + upper);\n              }\n\n              boolean includeLower = random().nextBoolean();\n              boolean includeUpper = random().nextBoolean();\n              Query query;\n              if (random().nextBoolean()) {\n                query = new NumericRangeTreeQuery(\"sn_value\", lower, includeLower, upper, includeUpper);\n              } else {\n                query = new SortedSetRangeTreeQuery(\"ss_value\", longToBytes(lower), includeLower, longToBytes(upper), includeUpper);\n              }\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                boolean expected = missing.get(id) == false && deleted.contains(id) == false && matches(lower, includeLower, upper, includeUpper, values[id]);\n                if (hits.get(docID) != expected) {\n                  // We do exact quantized comparison so the bbox query should never disagree:\n                  fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" value=\" + values[id] + \" (range: \" + lower + \" TO \" + upper + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                  }\n                }\n              }\n            }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":["5e2673c41503db59fb58c2e183343e434cf4204e","1800b996d8677670482a071dcb7a48b08c423ace","5e2673c41503db59fb58c2e183343e434cf4204e","1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"bcb51fecc8dab4f1ea6aadb9cb87c27d50918b74":["8c12c43c449a172df0f2b122918f0f5fc0e9a470"],"8c12c43c449a172df0f2b122918f0f5fc0e9a470":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cb4c5fa5f082c708f32344b3919b9b4bc8eba0d9":["bcb51fecc8dab4f1ea6aadb9cb87c27d50918b74"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eee4175312c41f89aa23427f9e4edfc00deeaac":["a870f9917149dc600c4ad4417d615c1795de5864"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["1eee4175312c41f89aa23427f9e4edfc00deeaac"],"a870f9917149dc600c4ad4417d615c1795de5864":["cf1a6fe0cad9503f2c3eaca4de8c4f80a9eb14f0"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["89a0e70ecaf27e127004b7fbfad2e02d52ea1f8f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"cf1a6fe0cad9503f2c3eaca4de8c4f80a9eb14f0":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"89a0e70ecaf27e127004b7fbfad2e02d52ea1f8f":["cb4c5fa5f082c708f32344b3919b9b4bc8eba0d9"]},"commit2Childs":{"bcb51fecc8dab4f1ea6aadb9cb87c27d50918b74":["cb4c5fa5f082c708f32344b3919b9b4bc8eba0d9"],"8c12c43c449a172df0f2b122918f0f5fc0e9a470":["bcb51fecc8dab4f1ea6aadb9cb87c27d50918b74"],"cb4c5fa5f082c708f32344b3919b9b4bc8eba0d9":["89a0e70ecaf27e127004b7fbfad2e02d52ea1f8f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c12c43c449a172df0f2b122918f0f5fc0e9a470"],"1eee4175312c41f89aa23427f9e4edfc00deeaac":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a870f9917149dc600c4ad4417d615c1795de5864":["1eee4175312c41f89aa23427f9e4edfc00deeaac"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["cf1a6fe0cad9503f2c3eaca4de8c4f80a9eb14f0"],"cf1a6fe0cad9503f2c3eaca4de8c4f80a9eb14f0":["a870f9917149dc600c4ad4417d615c1795de5864"],"89a0e70ecaf27e127004b7fbfad2e02d52ea1f8f":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}