{"path":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","commits":[{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"/dev/null","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 30000;\n    boolean found = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n            \n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(50);\n    }\n    if (!found) {\n      fail(\"Could not find new \" + expectedSlices + \" slice collection\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8512200aed2724abd80dbeb686d3412d537b7d8a","date":1342139754,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 30000;\n    boolean found = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n            \n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(50);\n    }\n    if (!found) {\n      fail(\"Could not find new \" + expectedSlices + \" slice collection\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63fce89dfe8a5dcba79c726470441c175441f122","date":1342202709,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 120000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01d7038753e558c19fba37629cb45f9740316fe7","date":1342203005,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 120000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"/dev/null","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 30000;\n    boolean found = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n            \n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(50);\n    }\n    if (!found) {\n      fail(\"Could not find new \" + expectedSlices + \" slice collection\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateCloudState(true);\n      CloudState cloudState = solrj.getZkStateReader().getCloudState();\n      Map<String,Map<String,Slice>> collections = cloudState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,Replica> sliceShards = sliceEntry.getValue()\n                .getReplicasMap();\n            Iterator<Entry<String,Replica>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,Replica> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().getStr(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,ZkNodeProps> sliceShards = sliceEntry.getValue()\n                .getShards();\n            Iterator<Entry<String,ZkNodeProps>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,ZkNodeProps> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().get(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n\n        }\n        found = true;\n        break;\n      }\n      Thread.sleep(500);\n    }\n    if (!found) {\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      solrj.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n          found = true;\n          // also make sure each are active\n          Iterator<Entry<String,Slice>> it = slices.entrySet().iterator();\n          while (it.hasNext()) {\n            Entry<String,Slice> sliceEntry = it.next();\n            Map<String,Replica> sliceShards = sliceEntry.getValue()\n                .getReplicasMap();\n            Iterator<Entry<String,Replica>> shardIt = sliceShards\n                .entrySet().iterator();\n            while (shardIt.hasNext()) {\n              Entry<String,Replica> shardEntry = shardIt.next();\n              if (!shardEntry.getValue().getStr(ZkStateReader.STATE_PROP)\n                  .equals(ZkStateReader.ACTIVE)) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    if (!found) {\n      printLayout();\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      } else {\n        fail(\"Found expected # of slices, but some nodes are not active for collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085","3f767f8c99eaedb984df754fe61f21c5de260f94","fa64435b5902ce266c23755a4a00691a3285dab8","8512200aed2724abd80dbeb686d3412d537b7d8a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,DocCollection> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName).getSlicesMap();\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n\n        }\n        found = true;\n        break;\n      }\n      Thread.sleep(500);\n    }\n    if (!found) {\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      }\n    }\n  }\n\n","sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n\n        }\n        found = true;\n        break;\n      }\n      Thread.sleep(500);\n    }\n    if (!found) {\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c215736a9e29403edd2132d9f0829a287b428df4","date":1354641965,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":null,"sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,DocCollection> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName).getSlicesMap();\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n\n        }\n        found = true;\n        break;\n      }\n      Thread.sleep(500);\n    }\n    if (!found) {\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#checkForCollection(String,int).mjava","sourceNew":null,"sourceOld":"  private void checkForCollection(String collectionName, int expectedSlices)\n      throws Exception {\n    // check for an expectedSlices new collection - we poll the state\n    long timeoutAt = System.currentTimeMillis() + 60000;\n    boolean found = false;\n    boolean sliceMatch = false;\n    while (System.currentTimeMillis() < timeoutAt) {\n      ClusterState clusterState = solrj.getZkStateReader().getClusterState();\n      Map<String,Map<String,Slice>> collections = clusterState\n          .getCollectionStates();\n      if (collections.containsKey(collectionName)) {\n        Map<String,Slice> slices = collections.get(collectionName);\n        // did we find expectedSlices slices/shards?\n        if (slices.size() == expectedSlices) {\n          sliceMatch = true;\n\n        }\n        found = true;\n        break;\n      }\n      Thread.sleep(500);\n    }\n    if (!found) {\n      if (!sliceMatch) {\n        fail(\"Could not find new \" + expectedSlices + \" slice collection called \" + collectionName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"33d0ed80b7b47e34ad3ff033a77544563aba3085":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fa64435b5902ce266c23755a4a00691a3285dab8":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"407687e67faf6e1f02a211ca078d8e3eed631027":["e19067e820b148e8dc0b240da4f2771cf7b68252","c215736a9e29403edd2132d9f0829a287b428df4"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["fa64435b5902ce266c23755a4a00691a3285dab8"],"63fce89dfe8a5dcba79c726470441c175441f122":["8512200aed2724abd80dbeb686d3412d537b7d8a"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["fe33227f6805edab2036cbb80645cc4e2d1fa424","3f767f8c99eaedb984df754fe61f21c5de260f94"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["01d7038753e558c19fba37629cb45f9740316fe7"],"aba371508186796cc6151d8223a5b4e16d02e26e":["33d0ed80b7b47e34ad3ff033a77544563aba3085","01d7038753e558c19fba37629cb45f9740316fe7"],"c215736a9e29403edd2132d9f0829a287b428df4":["c5a558d54519c651068ddb202f03befefb1514a7"],"8512200aed2724abd80dbeb686d3412d537b7d8a":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","01d7038753e558c19fba37629cb45f9740316fe7"],"c5a558d54519c651068ddb202f03befefb1514a7":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"01d7038753e558c19fba37629cb45f9740316fe7":["63fce89dfe8a5dcba79c726470441c175441f122"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","3f767f8c99eaedb984df754fe61f21c5de260f94"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c215736a9e29403edd2132d9f0829a287b428df4"]},"commit2Childs":{"33d0ed80b7b47e34ad3ff033a77544563aba3085":["aba371508186796cc6151d8223a5b4e16d02e26e","8512200aed2724abd80dbeb686d3412d537b7d8a"],"fa64435b5902ce266c23755a4a00691a3285dab8":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"e19067e820b148e8dc0b240da4f2771cf7b68252":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"63fce89dfe8a5dcba79c726470441c175441f122":["01d7038753e558c19fba37629cb45f9740316fe7"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"3f767f8c99eaedb984df754fe61f21c5de260f94":["fa64435b5902ce266c23755a4a00691a3285dab8","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"c215736a9e29403edd2132d9f0829a287b428df4":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8512200aed2724abd80dbeb686d3412d537b7d8a":["63fce89dfe8a5dcba79c726470441c175441f122"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"01d7038753e558c19fba37629cb45f9740316fe7":["3f767f8c99eaedb984df754fe61f21c5de260f94","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"c5a558d54519c651068ddb202f03befefb1514a7":["c215736a9e29403edd2132d9f0829a287b428df4"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}