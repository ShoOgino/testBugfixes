{"path":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef).mjava","sourceNew":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        if (versionReturned != null) {\n          versionReturned.set((long)entry.get(UpdateLog.VERSION_IDX));\n        }\n        switch (oper) {\n          case UpdateLog.UPDATE_INPLACE:\n            assert entry.size() == 5;\n\n            if (resolveFullDocument) {\n              SolrInputDocument doc = (SolrInputDocument)entry.get(entry.size()-1);\n              try {\n                // For in-place update case, we have obtained the partial document till now. We need to\n                // resolve it to a full document to be returned to the user.\n                SolrDocument sdoc = resolveFullDocument(core, idBytes, new SolrReturnFields(), doc, entry, onlyTheseNonStoredDVs);\n                if (sdoc == null) {\n                  return DELETED;\n                }\n                doc = toSolrInputDocument(sdoc, core.getLatestSchema());\n                return doc;\n              } catch (IOException ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, \"Error while resolving full document. \", ex);\n              }\n            } else {\n              // fall through to ADD, so as to get only the partial document\n            }\n          case UpdateLog.ADD:\n            return (SolrInputDocument) entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   */\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        switch (oper) {\n          case UpdateLog.ADD:\n            return (SolrInputDocument)entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef).mjava","sourceNew":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        if (versionReturned != null) {\n          versionReturned.set((long)entry.get(UpdateLog.VERSION_IDX));\n        }\n        switch (oper) {\n          case UpdateLog.UPDATE_INPLACE:\n            assert entry.size() == 5;\n\n            if (resolveFullDocument) {\n              SolrInputDocument doc = (SolrInputDocument)entry.get(entry.size()-1);\n              try {\n                // For in-place update case, we have obtained the partial document till now. We need to\n                // resolve it to a full document to be returned to the user.\n                SolrDocument sdoc = resolveFullDocument(core, idBytes, new SolrReturnFields(), doc, entry, onlyTheseNonStoredDVs);\n                if (sdoc == null) {\n                  return DELETED;\n                }\n                doc = toSolrInputDocument(sdoc, core.getLatestSchema());\n                return doc;\n              } catch (IOException ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, \"Error while resolving full document. \", ex);\n              }\n            } else {\n              // fall through to ADD, so as to get only the partial document\n            }\n          case UpdateLog.ADD:\n            return (SolrInputDocument) entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   */\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        switch (oper) {\n          case UpdateLog.ADD:\n            return (SolrInputDocument)entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e1bfbfa5a260860e3f12522fca45ec1240752f","date":1521057510,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","sourceNew":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        if (versionReturned != null) {\n          versionReturned.set((long)entry.get(UpdateLog.VERSION_IDX));\n        }\n        switch (oper) {\n          case UpdateLog.UPDATE_INPLACE:\n            if (ulog instanceof CdcrUpdateLog) {\n              assert entry.size() == 6;\n            } else {\n              assert entry.size() == 5;\n            }\n\n            if (resolveFullDocument) {\n              SolrInputDocument doc = (SolrInputDocument)entry.get(entry.size()-1);\n              try {\n                // For in-place update case, we have obtained the partial document till now. We need to\n                // resolve it to a full document to be returned to the user.\n                SolrDocument sdoc = resolveFullDocument(core, idBytes, new SolrReturnFields(), doc, entry, onlyTheseNonStoredDVs);\n                if (sdoc == null) {\n                  return DELETED;\n                }\n                doc = toSolrInputDocument(sdoc, core.getLatestSchema());\n                return doc;\n              } catch (IOException ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, \"Error while resolving full document. \", ex);\n              }\n            } else {\n              // fall through to ADD, so as to get only the partial document\n            }\n          case UpdateLog.ADD:\n            return (SolrInputDocument) entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        if (versionReturned != null) {\n          versionReturned.set((long)entry.get(UpdateLog.VERSION_IDX));\n        }\n        switch (oper) {\n          case UpdateLog.UPDATE_INPLACE:\n            assert entry.size() == 5;\n\n            if (resolveFullDocument) {\n              SolrInputDocument doc = (SolrInputDocument)entry.get(entry.size()-1);\n              try {\n                // For in-place update case, we have obtained the partial document till now. We need to\n                // resolve it to a full document to be returned to the user.\n                SolrDocument sdoc = resolveFullDocument(core, idBytes, new SolrReturnFields(), doc, entry, onlyTheseNonStoredDVs);\n                if (sdoc == null) {\n                  return DELETED;\n                }\n                doc = toSolrInputDocument(sdoc, core.getLatestSchema());\n                return doc;\n              } catch (IOException ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, \"Error while resolving full document. \", ex);\n              }\n            } else {\n              // fall through to ADD, so as to get only the partial document\n            }\n          case UpdateLog.ADD:\n            return (SolrInputDocument) entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","sourceNew":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  @SuppressWarnings({\"fallthrough\"})\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        @SuppressWarnings({\"rawtypes\"})\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        if (versionReturned != null) {\n          versionReturned.set((long)entry.get(UpdateLog.VERSION_IDX));\n        }\n        switch (oper) {\n          case UpdateLog.UPDATE_INPLACE:\n            if (ulog instanceof CdcrUpdateLog) {\n              assert entry.size() == 6;\n            } else {\n              assert entry.size() == 5;\n            }\n\n            if (resolveFullDocument) {\n              SolrInputDocument doc = (SolrInputDocument)entry.get(entry.size()-1);\n              try {\n                // For in-place update case, we have obtained the partial document till now. We need to\n                // resolve it to a full document to be returned to the user.\n                SolrDocument sdoc = resolveFullDocument(core, idBytes, new SolrReturnFields(), doc, entry, onlyTheseNonStoredDVs);\n                if (sdoc == null) {\n                  return DELETED;\n                }\n                doc = toSolrInputDocument(sdoc, core.getLatestSchema());\n                return doc;\n              } catch (IOException ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, \"Error while resolving full document. \", ex);\n              }\n            } else {\n              // fall through to ADD, so as to get only the partial document\n            }\n          case UpdateLog.ADD:\n            return (SolrInputDocument) entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        if (versionReturned != null) {\n          versionReturned.set((long)entry.get(UpdateLog.VERSION_IDX));\n        }\n        switch (oper) {\n          case UpdateLog.UPDATE_INPLACE:\n            if (ulog instanceof CdcrUpdateLog) {\n              assert entry.size() == 6;\n            } else {\n              assert entry.size() == 5;\n            }\n\n            if (resolveFullDocument) {\n              SolrInputDocument doc = (SolrInputDocument)entry.get(entry.size()-1);\n              try {\n                // For in-place update case, we have obtained the partial document till now. We need to\n                // resolve it to a full document to be returned to the user.\n                SolrDocument sdoc = resolveFullDocument(core, idBytes, new SolrReturnFields(), doc, entry, onlyTheseNonStoredDVs);\n                if (sdoc == null) {\n                  return DELETED;\n                }\n                doc = toSolrInputDocument(sdoc, core.getLatestSchema());\n                return doc;\n              } catch (IOException ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, \"Error while resolving full document. \", ex);\n              }\n            } else {\n              // fall through to ADD, so as to get only the partial document\n            }\n          case UpdateLog.ADD:\n            return (SolrInputDocument) entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1","date":1598647393,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocumentFromTlog(SolrCore,BytesRef,AtomicLong,Set[String],boolean).mjava","sourceNew":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  @SuppressWarnings({\"fallthrough\"})\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        @SuppressWarnings({\"rawtypes\"})\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        if (versionReturned != null) {\n          versionReturned.set((long)entry.get(UpdateLog.VERSION_IDX));\n        }\n        switch (oper) {\n          case UpdateLog.UPDATE_INPLACE:\n            assert entry.size() == 5;\n            \n            if (resolveFullDocument) {\n              SolrInputDocument doc = (SolrInputDocument)entry.get(entry.size()-1);\n              try {\n                // For in-place update case, we have obtained the partial document till now. We need to\n                // resolve it to a full document to be returned to the user.\n                SolrDocument sdoc = resolveFullDocument(core, idBytes, new SolrReturnFields(), doc, entry, onlyTheseNonStoredDVs);\n                if (sdoc == null) {\n                  return DELETED;\n                }\n                doc = toSolrInputDocument(sdoc, core.getLatestSchema());\n                return doc;\n              } catch (IOException ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, \"Error while resolving full document. \", ex);\n              }\n            } else {\n              // fall through to ADD, so as to get only the partial document\n            }\n          case UpdateLog.ADD:\n            return (SolrInputDocument) entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  /** returns the SolrInputDocument from the current tlog, or DELETED if it has been deleted, or\n   * null if there is no record of it in the current update log.  If null is returned, it could\n   * still be in the latest index.\n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  @SuppressWarnings({\"fallthrough\"})\n  public static SolrInputDocument getInputDocumentFromTlog(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) {\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n    if (ulog != null) {\n      Object o = ulog.lookup(idBytes);\n      if (o != null) {\n        // should currently be a List<Oper,Ver,Doc/Id>\n        @SuppressWarnings({\"rawtypes\"})\n        List entry = (List)o;\n        assert entry.size() >= 3;\n        int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n        if (versionReturned != null) {\n          versionReturned.set((long)entry.get(UpdateLog.VERSION_IDX));\n        }\n        switch (oper) {\n          case UpdateLog.UPDATE_INPLACE:\n            if (ulog instanceof CdcrUpdateLog) {\n              assert entry.size() == 6;\n            } else {\n              assert entry.size() == 5;\n            }\n\n            if (resolveFullDocument) {\n              SolrInputDocument doc = (SolrInputDocument)entry.get(entry.size()-1);\n              try {\n                // For in-place update case, we have obtained the partial document till now. We need to\n                // resolve it to a full document to be returned to the user.\n                SolrDocument sdoc = resolveFullDocument(core, idBytes, new SolrReturnFields(), doc, entry, onlyTheseNonStoredDVs);\n                if (sdoc == null) {\n                  return DELETED;\n                }\n                doc = toSolrInputDocument(sdoc, core.getLatestSchema());\n                return doc;\n              } catch (IOException ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, \"Error while resolving full document. \", ex);\n              }\n            } else {\n              // fall through to ADD, so as to get only the partial document\n            }\n          case UpdateLog.ADD:\n            return (SolrInputDocument) entry.get(entry.size()-1);\n          case UpdateLog.DELETE:\n            return DELETED;\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n        }\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"17e1bfbfa5a260860e3f12522fca45ec1240752f":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["17e1bfbfa5a260860e3f12522fca45ec1240752f"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["17e1bfbfa5a260860e3f12522fca45ec1240752f","598b5d23aa7c9732bf473c21a9cd309c44599394"],"17e1bfbfa5a260860e3f12522fca45ec1240752f":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}