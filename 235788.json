{"path":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testParallelElection().mjava","commits":[{"id":"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e","date":1406603075,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testParallelElection().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testParallelElection() throws Exception {\n    final int numShards = 2 + random().nextInt(18);\n    log.info(\"Testing parallel election across \" + numShards + \" shards\");\n\n    List<ClientThread> threads = new ArrayList<>();\n\n    try {\n      List<ClientThread> replica1s = new ArrayList<>();\n      ElectorSetup es1 = new ElectorSetup(null);\n      for (int i = 1; i <= numShards; i++) {\n        ClientThread thread = new ClientThread(es1, \"parshard\" + i, 1, 0 /* don't delay */);\n        threads.add(thread);\n        replica1s.add(thread);\n      }\n      startAndJoinElection(replica1s);\n      log.info(\"First replicas brought up and registered\");\n\n      // bring up second in line\n      List<ClientThread> replica2s = new ArrayList<>();\n      ElectorSetup es2 = new ElectorSetup(null);\n      for (int i = 1; i <= numShards; i++) {\n        ClientThread thread = new ClientThread(es2, \"parshard\" + i, 2, 40000 / (numShards - 1) /* delay enough to timeout or expire */);\n        threads.add(thread);\n        replica2s.add(thread);\n      }\n      startAndJoinElection(replica2s);\n      log.info(\"Second replicas brought up and registered\");\n\n      // disconnect the leaders\n      es1.close();\n\n      for (int i = 1; i <= numShards; i ++) {\n        // if this test fails, getLeaderUrl will more likely throw an exception and fail the test,\n        // but add an assertEquals as well for good measure\n        assertEquals(\"2/\", getLeaderUrl(\"collection1\", \"parshard\" + i));\n      }\n    } finally {\n      // cleanup any threads still running\n      for (ClientThread thread : threads) {\n        thread.close();\n        thread.interrupt();\n      }\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testParallelElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testParallelElection().mjava","sourceNew":"  @Test\n  public void testParallelElection() throws Exception {\n    final int numShards = 2 + random().nextInt(18);\n    log.info(\"Testing parallel election across {} shards\", numShards);\n\n    List<ClientThread> threads = new ArrayList<>();\n\n    try {\n      List<ClientThread> replica1s = new ArrayList<>();\n      ElectorSetup es1 = new ElectorSetup(null);\n      for (int i = 1; i <= numShards; i++) {\n        ClientThread thread = new ClientThread(es1, \"parshard\" + i, 1, 0 /* don't delay */);\n        threads.add(thread);\n        replica1s.add(thread);\n      }\n      startAndJoinElection(replica1s);\n      log.info(\"First replicas brought up and registered\");\n\n      // bring up second in line\n      List<ClientThread> replica2s = new ArrayList<>();\n      ElectorSetup es2 = new ElectorSetup(null);\n      for (int i = 1; i <= numShards; i++) {\n        ClientThread thread = new ClientThread(es2, \"parshard\" + i, 2, 40000 / (numShards - 1) /* delay enough to timeout or expire */);\n        threads.add(thread);\n        replica2s.add(thread);\n      }\n      startAndJoinElection(replica2s);\n      log.info(\"Second replicas brought up and registered\");\n\n      // disconnect the leaders\n      es1.close();\n\n      for (int i = 1; i <= numShards; i ++) {\n        // if this test fails, getLeaderUrl will more likely throw an exception and fail the test,\n        // but add an assertEquals as well for good measure\n        assertEquals(\"2/\", getLeaderUrl(\"collection1\", \"parshard\" + i));\n      }\n    } finally {\n      // cleanup any threads still running\n      for (ClientThread thread : threads) {\n        thread.close();\n        thread.interrupt();\n      }\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testParallelElection() throws Exception {\n    final int numShards = 2 + random().nextInt(18);\n    log.info(\"Testing parallel election across \" + numShards + \" shards\");\n\n    List<ClientThread> threads = new ArrayList<>();\n\n    try {\n      List<ClientThread> replica1s = new ArrayList<>();\n      ElectorSetup es1 = new ElectorSetup(null);\n      for (int i = 1; i <= numShards; i++) {\n        ClientThread thread = new ClientThread(es1, \"parshard\" + i, 1, 0 /* don't delay */);\n        threads.add(thread);\n        replica1s.add(thread);\n      }\n      startAndJoinElection(replica1s);\n      log.info(\"First replicas brought up and registered\");\n\n      // bring up second in line\n      List<ClientThread> replica2s = new ArrayList<>();\n      ElectorSetup es2 = new ElectorSetup(null);\n      for (int i = 1; i <= numShards; i++) {\n        ClientThread thread = new ClientThread(es2, \"parshard\" + i, 2, 40000 / (numShards - 1) /* delay enough to timeout or expire */);\n        threads.add(thread);\n        replica2s.add(thread);\n      }\n      startAndJoinElection(replica2s);\n      log.info(\"Second replicas brought up and registered\");\n\n      // disconnect the leaders\n      es1.close();\n\n      for (int i = 1; i <= numShards; i ++) {\n        // if this test fails, getLeaderUrl will more likely throw an exception and fail the test,\n        // but add an assertEquals as well for good measure\n        assertEquals(\"2/\", getLeaderUrl(\"collection1\", \"parshard\" + i));\n      }\n    } finally {\n      // cleanup any threads still running\n      for (ClientThread thread : threads) {\n        thread.close();\n        thread.interrupt();\n      }\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}