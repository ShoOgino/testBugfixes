{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet).mjava","commits":[{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#isFinite(Transition,LightAutomaton,int,BitSet,BitSet).mjava","sourceNew":"  /**\n   * Checks whether there is a loop containing s. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack\n  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited) {\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Checks whether there is a loop containing s. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack\n  private static boolean isFinite(Transition scratch, LightAutomaton a, int state, BitSet path, BitSet visited) {\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a546f0e920177e9588c7ac5e8c46ce22c43f8ee0","date":1403106109,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet).mjava","sourceNew":"  /**\n   * Checks whether there is a loop containing state. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack\n  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited) {\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Checks whether there is a loop containing s. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack\n  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited) {\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Checks whether there is a loop containing state. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack\n  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited) {\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54297202372099824b9eb2d6897335b221455496","date":1501840968,"type":5,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet).mjava","sourceNew":"  /**\n   * Checks whether there is a loop containing state. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack so the maximum level of recursion is bounded to 1000\n  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited, int level) {\n    if (level > MAX_RECURSION_LEVEL) {\n      throw new IllegalArgumentException(\"input automaton is too large: \" +  level);\n    }\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited, level+1))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Checks whether there is a loop containing state. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack\n  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited) {\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":5,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#isFinite(Transition,Automaton,int,BitSet,BitSet).mjava","sourceNew":"  /**\n   * Checks whether there is a loop containing state. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack so the maximum level of recursion is bounded to 1000\n  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited, int level) {\n    if (level > MAX_RECURSION_LEVEL) {\n      throw new IllegalArgumentException(\"input automaton is too large: \" +  level);\n    }\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited, level+1))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Checks whether there is a loop containing state. (This is sufficient since\n   * there are never transitions to dead states.)\n   */\n  // TODO: not great that this is recursive... in theory a\n  // large automata could exceed java's stack\n  private static boolean isFinite(Transition scratch, Automaton a, int state, BitSet path, BitSet visited) {\n    path.set(state);\n    int numTransitions = a.initTransition(state, scratch);\n    for(int t=0;t<numTransitions;t++) {\n      a.getTransition(state, t, scratch);\n      if (path.get(scratch.dest) || (!visited.get(scratch.dest) && !isFinite(scratch, a, scratch.dest, path, visited))) {\n        return false;\n      }\n    }\n    path.clear(state);\n    visited.set(state);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a546f0e920177e9588c7ac5e8c46ce22c43f8ee0":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["5c84485629d80d203608e8975a1139de9933cc38","54297202372099824b9eb2d6897335b221455496"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"54297202372099824b9eb2d6897335b221455496":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a546f0e920177e9588c7ac5e8c46ce22c43f8ee0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54297202372099824b9eb2d6897335b221455496"]},"commit2Childs":{"a546f0e920177e9588c7ac5e8c46ce22c43f8ee0":["5c84485629d80d203608e8975a1139de9933cc38"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["a546f0e920177e9588c7ac5e8c46ce22c43f8ee0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","5c84485629d80d203608e8975a1139de9933cc38"],"54297202372099824b9eb2d6897335b221455496":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c84485629d80d203608e8975a1139de9933cc38":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","54297202372099824b9eb2d6897335b221455496"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}