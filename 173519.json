{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","commits":[{"id":"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1","date":1353511594,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Implements the opening of a new {@link DirectoryTaxonomyReader} instance if\n   * the taxonomy has changed.\n   * \n   * <p>\n   * <b>NOTE:</b> the returned {@link DirectoryTaxonomyReader} shares the\n   * ordinal and category caches with this reader. This is not expected to cause\n   * any issues, unless the two instances continue to live. The reader\n   * guarantees that the two instances cannot affect each other in terms of\n   * correctness of the caches, however if the size of the cache is changed\n   * through {@link #setCacheSize(int)}, it will affect both reader instances.\n   */\n  @Override\n  protected DirectoryTaxonomyReader doOpenIfChanged() throws IOException {\n    ensureOpen();\n    \n    final DirectoryReader r2;\n    if (taxoWriter == null) {\n      // not NRT\n      r2 = DirectoryReader.openIfChanged(indexReader);\n    } else {\n      // NRT\n      r2 = DirectoryReader.openIfChanged(indexReader, taxoWriter.getInternalIndexWriter(), false);\n    }\n    if (r2 == null) {\n      return null; // no changes, nothing to do\n    }\n\n    // check if the taxonomy was recreated\n    boolean success = false;\n    try {\n      boolean recreated = false;\n      if (taxoWriter == null) {\n        // not NRT, check epoch from commit data\n        String t1 = indexReader.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        String t2 = r2.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        if (t1 == null) {\n          if (t2 != null) {\n            recreated = true;\n          }\n        } else if (!t1.equals(t2)) {\n          // t1 != null and t2 cannot be null b/c DirTaxoWriter always puts the commit data.\n          // it's ok to use String.equals because we require the two epoch values to be the same.\n          recreated = true;\n        }\n      } else {\n        // NRT, compare current taxoWriter.epoch() vs the one that was given at construction\n        if (taxoEpoch != taxoWriter.getTaxonomyEpoch()) {\n          recreated = true;\n        }\n      }\n\n      final DirectoryTaxonomyReader newtr;\n      if (recreated) {\n        // if recreated, do not reuse anything from this instace. the information\n        // will be lazily computed by the new instance when needed.\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, null, null, null, null);\n      } else {\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, ordinalCache, categoryCache, parentArray, childrenArrays);\n      }\n      \n      success = true;\n      return newtr;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(r2);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d58d08788c3fd51172ba34474cca42499d6391b","date":1354802133,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","sourceNew":"  /**\n   * Implements the opening of a new {@link DirectoryTaxonomyReader} instance if\n   * the taxonomy has changed.\n   * \n   * <p>\n   * <b>NOTE:</b> the returned {@link DirectoryTaxonomyReader} shares the\n   * ordinal and category caches with this reader. This is not expected to cause\n   * any issues, unless the two instances continue to live. The reader\n   * guarantees that the two instances cannot affect each other in terms of\n   * correctness of the caches, however if the size of the cache is changed\n   * through {@link #setCacheSize(int)}, it will affect both reader instances.\n   */\n  @Override\n  protected DirectoryTaxonomyReader doOpenIfChanged() throws IOException {\n    ensureOpen();\n    \n    final DirectoryReader r2;\n    if (taxoWriter == null) {\n      // not NRT\n      r2 = DirectoryReader.openIfChanged(indexReader);\n    } else {\n      // NRT\n      r2 = DirectoryReader.openIfChanged(indexReader, taxoWriter.getInternalIndexWriter(), false);\n    }\n    if (r2 == null) {\n      return null; // no changes, nothing to do\n    }\n\n    // check if the taxonomy was recreated\n    boolean success = false;\n    try {\n      boolean recreated = false;\n      if (taxoWriter == null) {\n        // not NRT, check epoch from commit data\n        String t1 = indexReader.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        String t2 = r2.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        if (t1 == null) {\n          if (t2 != null) {\n            recreated = true;\n          }\n        } else if (!t1.equals(t2)) {\n          // t1 != null and t2 cannot be null b/c DirTaxoWriter always puts the commit data.\n          // it's ok to use String.equals because we require the two epoch values to be the same.\n          recreated = true;\n        }\n      } else {\n        // NRT, compare current taxoWriter.epoch() vs the one that was given at construction\n        if (taxoEpoch != taxoWriter.getTaxonomyEpoch()) {\n          recreated = true;\n        }\n      }\n\n      final DirectoryTaxonomyReader newtr;\n      if (recreated) {\n        // if recreated, do not reuse anything from this instace. the information\n        // will be lazily computed by the new instance when needed.\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, null, null, null);\n      } else {\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, ordinalCache, categoryCache, taxoArrays);\n      }\n      \n      success = true;\n      return newtr;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(r2);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Implements the opening of a new {@link DirectoryTaxonomyReader} instance if\n   * the taxonomy has changed.\n   * \n   * <p>\n   * <b>NOTE:</b> the returned {@link DirectoryTaxonomyReader} shares the\n   * ordinal and category caches with this reader. This is not expected to cause\n   * any issues, unless the two instances continue to live. The reader\n   * guarantees that the two instances cannot affect each other in terms of\n   * correctness of the caches, however if the size of the cache is changed\n   * through {@link #setCacheSize(int)}, it will affect both reader instances.\n   */\n  @Override\n  protected DirectoryTaxonomyReader doOpenIfChanged() throws IOException {\n    ensureOpen();\n    \n    final DirectoryReader r2;\n    if (taxoWriter == null) {\n      // not NRT\n      r2 = DirectoryReader.openIfChanged(indexReader);\n    } else {\n      // NRT\n      r2 = DirectoryReader.openIfChanged(indexReader, taxoWriter.getInternalIndexWriter(), false);\n    }\n    if (r2 == null) {\n      return null; // no changes, nothing to do\n    }\n\n    // check if the taxonomy was recreated\n    boolean success = false;\n    try {\n      boolean recreated = false;\n      if (taxoWriter == null) {\n        // not NRT, check epoch from commit data\n        String t1 = indexReader.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        String t2 = r2.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        if (t1 == null) {\n          if (t2 != null) {\n            recreated = true;\n          }\n        } else if (!t1.equals(t2)) {\n          // t1 != null and t2 cannot be null b/c DirTaxoWriter always puts the commit data.\n          // it's ok to use String.equals because we require the two epoch values to be the same.\n          recreated = true;\n        }\n      } else {\n        // NRT, compare current taxoWriter.epoch() vs the one that was given at construction\n        if (taxoEpoch != taxoWriter.getTaxonomyEpoch()) {\n          recreated = true;\n        }\n      }\n\n      final DirectoryTaxonomyReader newtr;\n      if (recreated) {\n        // if recreated, do not reuse anything from this instace. the information\n        // will be lazily computed by the new instance when needed.\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, null, null, null, null);\n      } else {\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, ordinalCache, categoryCache, parentArray, childrenArrays);\n      }\n      \n      success = true;\n      return newtr;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(r2);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Implements the opening of a new {@link DirectoryTaxonomyReader} instance if\n   * the taxonomy has changed.\n   * \n   * <p>\n   * <b>NOTE:</b> the returned {@link DirectoryTaxonomyReader} shares the\n   * ordinal and category caches with this reader. This is not expected to cause\n   * any issues, unless the two instances continue to live. The reader\n   * guarantees that the two instances cannot affect each other in terms of\n   * correctness of the caches, however if the size of the cache is changed\n   * through {@link #setCacheSize(int)}, it will affect both reader instances.\n   */\n  @Override\n  protected DirectoryTaxonomyReader doOpenIfChanged() throws IOException {\n    ensureOpen();\n    \n    final DirectoryReader r2;\n    if (taxoWriter == null) {\n      // not NRT\n      r2 = DirectoryReader.openIfChanged(indexReader);\n    } else {\n      // NRT\n      r2 = DirectoryReader.openIfChanged(indexReader, taxoWriter.getInternalIndexWriter(), false);\n    }\n    if (r2 == null) {\n      return null; // no changes, nothing to do\n    }\n\n    // check if the taxonomy was recreated\n    boolean success = false;\n    try {\n      boolean recreated = false;\n      if (taxoWriter == null) {\n        // not NRT, check epoch from commit data\n        String t1 = indexReader.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        String t2 = r2.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        if (t1 == null) {\n          if (t2 != null) {\n            recreated = true;\n          }\n        } else if (!t1.equals(t2)) {\n          // t1 != null and t2 cannot be null b/c DirTaxoWriter always puts the commit data.\n          // it's ok to use String.equals because we require the two epoch values to be the same.\n          recreated = true;\n        }\n      } else {\n        // NRT, compare current taxoWriter.epoch() vs the one that was given at construction\n        if (taxoEpoch != taxoWriter.getTaxonomyEpoch()) {\n          recreated = true;\n        }\n      }\n\n      final DirectoryTaxonomyReader newtr;\n      if (recreated) {\n        // if recreated, do not reuse anything from this instace. the information\n        // will be lazily computed by the new instance when needed.\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, null, null, null);\n      } else {\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, ordinalCache, categoryCache, taxoArrays);\n      }\n      \n      success = true;\n      return newtr;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(r2);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d696fe8843937db409ebc00175f5b2b388c99cce","date":1363604451,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","sourceNew":"  /**\n   * Implements the opening of a new {@link DirectoryTaxonomyReader} instance if\n   * the taxonomy has changed.\n   * \n   * <p>\n   * <b>NOTE:</b> the returned {@link DirectoryTaxonomyReader} shares the\n   * ordinal and category caches with this reader. This is not expected to cause\n   * any issues, unless the two instances continue to live. The reader\n   * guarantees that the two instances cannot affect each other in terms of\n   * correctness of the caches, however if the size of the cache is changed\n   * through {@link #setCacheSize(int)}, it will affect both reader instances.\n   */\n  @Override\n  protected DirectoryTaxonomyReader doOpenIfChanged() throws IOException {\n    ensureOpen();\n    \n    // This works for both NRT and non-NRT readers (i.e. an NRT reader remains NRT).\n    final DirectoryReader r2 = DirectoryReader.openIfChanged(indexReader);\n    if (r2 == null) {\n      return null; // no changes, nothing to do\n    }\n\n    // check if the taxonomy was recreated\n    boolean success = false;\n    try {\n      boolean recreated = false;\n      if (taxoWriter == null) {\n        // not NRT, check epoch from commit data\n        String t1 = indexReader.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        String t2 = r2.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        if (t1 == null) {\n          if (t2 != null) {\n            recreated = true;\n          }\n        } else if (!t1.equals(t2)) {\n          // t1 != null and t2 cannot be null b/c DirTaxoWriter always puts the commit data.\n          // it's ok to use String.equals because we require the two epoch values to be the same.\n          recreated = true;\n        }\n      } else {\n        // NRT, compare current taxoWriter.epoch() vs the one that was given at construction\n        if (taxoEpoch != taxoWriter.getTaxonomyEpoch()) {\n          recreated = true;\n        }\n      }\n\n      final DirectoryTaxonomyReader newtr;\n      if (recreated) {\n        // if recreated, do not reuse anything from this instace. the information\n        // will be lazily computed by the new instance when needed.\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, null, null, null);\n      } else {\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, ordinalCache, categoryCache, taxoArrays);\n      }\n      \n      success = true;\n      return newtr;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(r2);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Implements the opening of a new {@link DirectoryTaxonomyReader} instance if\n   * the taxonomy has changed.\n   * \n   * <p>\n   * <b>NOTE:</b> the returned {@link DirectoryTaxonomyReader} shares the\n   * ordinal and category caches with this reader. This is not expected to cause\n   * any issues, unless the two instances continue to live. The reader\n   * guarantees that the two instances cannot affect each other in terms of\n   * correctness of the caches, however if the size of the cache is changed\n   * through {@link #setCacheSize(int)}, it will affect both reader instances.\n   */\n  @Override\n  protected DirectoryTaxonomyReader doOpenIfChanged() throws IOException {\n    ensureOpen();\n    \n    final DirectoryReader r2;\n    if (taxoWriter == null) {\n      // not NRT\n      r2 = DirectoryReader.openIfChanged(indexReader);\n    } else {\n      // NRT\n      r2 = DirectoryReader.openIfChanged(indexReader, taxoWriter.getInternalIndexWriter(), false);\n    }\n    if (r2 == null) {\n      return null; // no changes, nothing to do\n    }\n\n    // check if the taxonomy was recreated\n    boolean success = false;\n    try {\n      boolean recreated = false;\n      if (taxoWriter == null) {\n        // not NRT, check epoch from commit data\n        String t1 = indexReader.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        String t2 = r2.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        if (t1 == null) {\n          if (t2 != null) {\n            recreated = true;\n          }\n        } else if (!t1.equals(t2)) {\n          // t1 != null and t2 cannot be null b/c DirTaxoWriter always puts the commit data.\n          // it's ok to use String.equals because we require the two epoch values to be the same.\n          recreated = true;\n        }\n      } else {\n        // NRT, compare current taxoWriter.epoch() vs the one that was given at construction\n        if (taxoEpoch != taxoWriter.getTaxonomyEpoch()) {\n          recreated = true;\n        }\n      }\n\n      final DirectoryTaxonomyReader newtr;\n      if (recreated) {\n        // if recreated, do not reuse anything from this instace. the information\n        // will be lazily computed by the new instance when needed.\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, null, null, null);\n      } else {\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, ordinalCache, categoryCache, taxoArrays);\n      }\n      \n      success = true;\n      return newtr;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(r2);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad0d09e969f4763b0df4230f8e3f74357872a4e4","date":1459188769,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#doOpenIfChanged().mjava","sourceNew":"  /**\n   * Implements the opening of a new {@link DirectoryTaxonomyReader} instance if\n   * the taxonomy has changed.\n   * \n   * <p>\n   * <b>NOTE:</b> the returned {@link DirectoryTaxonomyReader} shares the\n   * ordinal and category caches with this reader. This is not expected to cause\n   * any issues, unless the two instances continue to live. The reader\n   * guarantees that the two instances cannot affect each other in terms of\n   * correctness of the caches, however if the size of the cache is changed\n   * through {@link #setCacheSize(int)}, it will affect both reader instances.\n   */\n  @Override\n  protected DirectoryTaxonomyReader doOpenIfChanged() throws IOException {\n    ensureOpen();\n    \n    // This works for both NRT and non-NRT readers (i.e. an NRT reader remains NRT).\n    final DirectoryReader r2 = DirectoryReader.openIfChanged(indexReader);\n    if (r2 == null) {\n      return null; // no changes, nothing to do\n    }\n\n    // check if the taxonomy was recreated\n    boolean success = false;\n    try {\n      boolean recreated = false;\n      if (taxoWriter == null) {\n        // not NRT, check epoch from commit data\n        String t1 = indexReader.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        String t2 = r2.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        if (t1 == null) {\n          if (t2 != null) {\n            recreated = true;\n          }\n        } else if (!t1.equals(t2)) {\n          // t1 != null and t2 must not be null b/c DirTaxoWriter always puts the commit data.\n          // it's ok to use String.equals because we require the two epoch values to be the same.\n          recreated = true;\n        }\n      } else {\n        // NRT, compare current taxoWriter.epoch() vs the one that was given at construction\n        if (taxoEpoch != taxoWriter.getTaxonomyEpoch()) {\n          recreated = true;\n        }\n      }\n\n      final DirectoryTaxonomyReader newtr;\n      if (recreated) {\n        // if recreated, do not reuse anything from this instace. the information\n        // will be lazily computed by the new instance when needed.\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, null, null, null);\n      } else {\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, ordinalCache, categoryCache, taxoArrays);\n      }\n      \n      success = true;\n      return newtr;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(r2);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Implements the opening of a new {@link DirectoryTaxonomyReader} instance if\n   * the taxonomy has changed.\n   * \n   * <p>\n   * <b>NOTE:</b> the returned {@link DirectoryTaxonomyReader} shares the\n   * ordinal and category caches with this reader. This is not expected to cause\n   * any issues, unless the two instances continue to live. The reader\n   * guarantees that the two instances cannot affect each other in terms of\n   * correctness of the caches, however if the size of the cache is changed\n   * through {@link #setCacheSize(int)}, it will affect both reader instances.\n   */\n  @Override\n  protected DirectoryTaxonomyReader doOpenIfChanged() throws IOException {\n    ensureOpen();\n    \n    // This works for both NRT and non-NRT readers (i.e. an NRT reader remains NRT).\n    final DirectoryReader r2 = DirectoryReader.openIfChanged(indexReader);\n    if (r2 == null) {\n      return null; // no changes, nothing to do\n    }\n\n    // check if the taxonomy was recreated\n    boolean success = false;\n    try {\n      boolean recreated = false;\n      if (taxoWriter == null) {\n        // not NRT, check epoch from commit data\n        String t1 = indexReader.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        String t2 = r2.getIndexCommit().getUserData().get(DirectoryTaxonomyWriter.INDEX_EPOCH);\n        if (t1 == null) {\n          if (t2 != null) {\n            recreated = true;\n          }\n        } else if (!t1.equals(t2)) {\n          // t1 != null and t2 cannot be null b/c DirTaxoWriter always puts the commit data.\n          // it's ok to use String.equals because we require the two epoch values to be the same.\n          recreated = true;\n        }\n      } else {\n        // NRT, compare current taxoWriter.epoch() vs the one that was given at construction\n        if (taxoEpoch != taxoWriter.getTaxonomyEpoch()) {\n          recreated = true;\n        }\n      }\n\n      final DirectoryTaxonomyReader newtr;\n      if (recreated) {\n        // if recreated, do not reuse anything from this instace. the information\n        // will be lazily computed by the new instance when needed.\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, null, null, null);\n      } else {\n        newtr = new DirectoryTaxonomyReader(r2, taxoWriter, ordinalCache, categoryCache, taxoArrays);\n      }\n      \n      success = true;\n      return newtr;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(r2);\n      }\n    }\n  }\n\n","bugFix":["219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d696fe8843937db409ebc00175f5b2b388c99cce":["3d58d08788c3fd51172ba34474cca42499d6391b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d58d08788c3fd51172ba34474cca42499d6391b"],"3d58d08788c3fd51172ba34474cca42499d6391b":["219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["d696fe8843937db409ebc00175f5b2b388c99cce"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"]},"commit2Childs":{"d696fe8843937db409ebc00175f5b2b388c99cce":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["407687e67faf6e1f02a211ca078d8e3eed631027","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"3d58d08788c3fd51172ba34474cca42499d6391b":["d696fe8843937db409ebc00175f5b2b388c99cce","407687e67faf6e1f02a211ca078d8e3eed631027"],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["3d58d08788c3fd51172ba34474cca42499d6391b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}