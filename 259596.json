{"path":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","commits":[{"id":"8cd2638c91e278a2831e83135b2c895d04defa90","date":1231272033,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      lock.lock();\n\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter( out );\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.info( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        if( !queue.isEmpty() ) {\n          run(); // run again, just in case\n        }\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        lock.unlock();\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["606f4b94e298603cb2c1fdeec1a729f2c960fc0f","22ee5eab9703d27221d8940a0c284b42ce57676c","f0234821f0874a57cda0a32ef52180de16fd0da4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ff45996d42348636af43415c79240faa25bfc73","date":1231360525,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      lock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter( out );\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        if( !queue.isEmpty() ) {\n          run(); // run again, just in case\n        }\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      lock.lock();\n\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter( out );\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.info( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        if( !queue.isEmpty() ) {\n          run(); // run again, just in case\n        }\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        lock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":["606f4b94e298603cb2c1fdeec1a729f2c960fc0f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e4ec22fbb7cdc958a46f7ec41ffbf95f25f7971","date":1231523296,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      lock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter( out );\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      lock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter( out );\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        if( !queue.isEmpty() ) {\n          run(); // run again, just in case\n        }\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        lock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22ee5eab9703d27221d8940a0c284b42ce57676c","date":1257472539,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter( out );\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      lock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter( out );\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        lock.unlock();\n      }\n    }\n\n","bugFix":["8cd2638c91e278a2831e83135b2c895d04defa90"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0234821f0874a57cda0a32ef52180de16fd0da4","date":1259026960,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter( out );\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":["8cd2638c91e278a2831e83135b2c895d04defa90"],"bugIntro":["606f4b94e298603cb2c1fdeec1a729f2c960fc0f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0","date":1264520006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n        }  while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          if(method != null)\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":["606f4b94e298603cb2c1fdeec1a729f2c960fc0f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n        }  while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          if(method != null)\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n        RequestEntity request = new RequestEntity() {\n          // we don't know the length\n          public long getContentLength() { return -1; }\n          public String getContentType() { return ClientUtils.TEXT_XML; }\n          public boolean isRepeatable()  { return false; }\n  \n          public void writeRequest(OutputStream out) throws IOException {\n            try {\n              OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n              writer.append( \"<stream>\" ); // can be anything...\n              UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              while( req != null ) {\n                log.debug( \"sending: {}\" , req );\n                req.writeXML( writer ); \n                \n                // check for commit or optimize\n                SolrParams params = req.getParams();\n                if( params != null ) {\n                  String fmt = null;\n                  if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                    fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                    fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                  }\n                  if( fmt != null ) {\n                    log.info( fmt );\n                    writer.write( String.format( fmt, \n                        params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\",\n                        params.getBool( UpdateParams.WAIT_FLUSH, false )+\"\") );\n                  }\n                }\n                \n                writer.flush();\n                req = queue.poll( 250, TimeUnit.MILLISECONDS );\n              }\n              writer.append( \"</stream>\" );\n              writer.flush();\n            }\n            catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        };\n        \n        method = new PostMethod(_baseURL+updateUrl );\n        method.setRequestEntity( request );\n        method.setFollowRedirects( false );\n        method.addRequestHeader( \"User-Agent\", AGENT );\n        \n        int statusCode = getHttpClient().executeMethod(method);\n        if (statusCode != HttpStatus.SC_OK) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          handleError( new Exception( msg.toString() ) );\n        }\n        }  while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      } \n      finally {\n        try {\n          // make sure to release the connection\n          if(method != null)\n          method.releaseConnection();\n        }\n        catch( Exception ex ){}\n        \n        // remove it from the list of running things...\n        synchronized (runners) {\n          runners.remove( this );\n        }\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0ff45996d42348636af43415c79240faa25bfc73":["8cd2638c91e278a2831e83135b2c895d04defa90"],"6e4ec22fbb7cdc958a46f7ec41ffbf95f25f7971":["0ff45996d42348636af43415c79240faa25bfc73"],"8cd2638c91e278a2831e83135b2c895d04defa90":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0":["f0234821f0874a57cda0a32ef52180de16fd0da4"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"22ee5eab9703d27221d8940a0c284b42ce57676c":["6e4ec22fbb7cdc958a46f7ec41ffbf95f25f7971"],"ad94625fb8d088209f46650c8097196fec67f00c":["dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0"],"f0234821f0874a57cda0a32ef52180de16fd0da4":["22ee5eab9703d27221d8940a0c284b42ce57676c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0ff45996d42348636af43415c79240faa25bfc73":["6e4ec22fbb7cdc958a46f7ec41ffbf95f25f7971"],"8cd2638c91e278a2831e83135b2c895d04defa90":["0ff45996d42348636af43415c79240faa25bfc73"],"6e4ec22fbb7cdc958a46f7ec41ffbf95f25f7971":["22ee5eab9703d27221d8940a0c284b42ce57676c"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["8cd2638c91e278a2831e83135b2c895d04defa90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0":["ad94625fb8d088209f46650c8097196fec67f00c"],"22ee5eab9703d27221d8940a0c284b42ce57676c":["f0234821f0874a57cda0a32ef52180de16fd0da4"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"f0234821f0874a57cda0a32ef52180de16fd0da4":["dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}