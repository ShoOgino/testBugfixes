{"path":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","commits":[{"id":"4d4f1b2c5601680b01c4bb95a43fe6fb73f03103","date":1217446558,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"/dev/null","sourceNew":"  private void createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final String url = initProps.getProperty(URL);\n    String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    try {\n      if (driver != null)\n        Class.forName(driver);\n    } catch (ClassNotFoundException e) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"driver could not be loaded\");\n    }\n    factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = DriverManager.getConnection(url, initProps);\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["61edce935cac7901da5d9d90cdd7103cea022781","61edce935cac7901da5d9d90cdd7103cea022781","8d22c66b0638c82521891318fc352042c5b86e03","e8e3766b37206c683d41cf09b4a544b7b28530d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d22c66b0638c82521891318fc352042c5b86e03","date":1219993248,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  private void createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n    }\n\n    factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          c = DriverManager.getConnection(url, initProps);\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  private void createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final String url = initProps.getProperty(URL);\n    String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    try {\n      if (driver != null)\n        Class.forName(driver);\n    } catch (ClassNotFoundException e) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"driver could not be loaded\");\n    }\n    factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = DriverManager.getConnection(url, initProps);\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":["4d4f1b2c5601680b01c4bb95a43fe6fb73f03103"],"bugIntro":["61edce935cac7901da5d9d90cdd7103cea022781","61edce935cac7901da5d9d90cdd7103cea022781","bb8548d5b6b919c14a179b607ad0c4f7b3136b17"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd42c8ecc9f8a8e590c5526544a77258089ca23f","date":1229189880,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  private void createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          c = DriverManager.getConnection(url, initProps);\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  private void createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n    }\n\n    factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          c = DriverManager.getConnection(url, initProps);\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["61edce935cac7901da5d9d90cdd7103cea022781","61edce935cac7901da5d9d90cdd7103cea022781"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6ff4f117bc6ee20396ca20f0c5b354c2de00d92","date":1237530421,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  private void createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c;\n        try {\n          c = DriverManager.getConnection(url, initProps);\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  private void createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          c = DriverManager.getConnection(url, initProps);\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["17c481d761bb0f02c41f89f608c75949a9c65e74"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8ad45b4ed9e3fd478bb4cd27c6d93a8911126b6e","date":1237545380,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c;\n        try {\n          c = DriverManager.getConnection(url, initProps);\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  private void createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c;\n        try {\n          c = DriverManager.getConnection(url, initProps);\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a90b0c0d735fb9f6839557571eedd4c370c94bf","date":1237721511,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName != null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user != null){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL cannot be null\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c;\n        try {\n          c = DriverManager.getConnection(url, initProps);\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["61edce935cac7901da5d9d90cdd7103cea022781","61edce935cac7901da5d9d90cdd7103cea022781","14aa57a2d9f13bcc41e8b38c52bd1e55f6390576","e8e3766b37206c683d41cf09b4a544b7b28530d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6e1337304d0d6b29c55795414487cf0f595e154","date":1238972812,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName == null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user != null){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName != null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user != null){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5893ca90be29bda741b187c863bb89b4c411d8b","date":1241519051,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName == null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user != null){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName == null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user != null){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8e3766b37206c683d41cf09b4a544b7b28530d0","date":1245905471,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName == null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user != null){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName == null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user != null){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":["4d4f1b2c5601680b01c4bb95a43fe6fb73f03103","6a90b0c0d735fb9f6839557571eedd4c370c94bf"],"bugIntro":["61edce935cac7901da5d9d90cdd7103cea022781","61edce935cac7901da5d9d90cdd7103cea022781"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14aa57a2d9f13bcc41e8b38c52bd1e55f6390576","date":1245907815,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName == null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName == null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user != null){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":["6a90b0c0d735fb9f6839557571eedd4c370c94bf"],"bugIntro":["61edce935cac7901da5d9d90cdd7103cea022781","61edce935cac7901da5d9d90cdd7103cea022781"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f24d87791042430a77c0e6c1e7a59d5840146f5e","date":1252329554,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not load driver: \" + driver, e);\n      }\n    } else {\n      if(jndiName == null){\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Driver must be specified\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb8548d5b6b919c14a179b607ad0c4f7b3136b17","date":1253622224,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":["8d22c66b0638c82521891318fc352042c5b86e03"],"bugIntro":["61edce935cac7901da5d9d90cdd7103cea022781","61edce935cac7901da5d9d90cdd7103cea022781"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ab17db13bd6ba87189b198d11a3c8d5836fa96f","date":1255061169,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["61edce935cac7901da5d9d90cdd7103cea022781","61edce935cac7901da5d9d90cdd7103cea022781"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"153cc06382fdc94d0ea3db127eab860ae4310525","date":1260181667,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(context, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(resolver, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(resolver, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["17c481d761bb0f02c41f89f608c75949a9c65e74"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17c481d761bb0f02c41f89f608c75949a9c65e74","date":1265692819,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        // Resolve variables again because the variables may have changed\n        resolveVariables(context, initProps);\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":["153cc06382fdc94d0ea3db127eab860ae4310525","c6ff4f117bc6ee20396ca20f0c5b354c2de00d92"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a6e1337304d0d6b29c55795414487cf0f595e154":["6a90b0c0d735fb9f6839557571eedd4c370c94bf"],"14aa57a2d9f13bcc41e8b38c52bd1e55f6390576":["e8e3766b37206c683d41cf09b4a544b7b28530d0"],"c6ff4f117bc6ee20396ca20f0c5b354c2de00d92":["dd42c8ecc9f8a8e590c5526544a77258089ca23f"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"e8e3766b37206c683d41cf09b4a544b7b28530d0":["a5893ca90be29bda741b187c863bb89b4c411d8b"],"7ab17db13bd6ba87189b198d11a3c8d5836fa96f":["bb8548d5b6b919c14a179b607ad0c4f7b3136b17"],"dd42c8ecc9f8a8e590c5526544a77258089ca23f":["8d22c66b0638c82521891318fc352042c5b86e03"],"153cc06382fdc94d0ea3db127eab860ae4310525":["7ab17db13bd6ba87189b198d11a3c8d5836fa96f"],"8d22c66b0638c82521891318fc352042c5b86e03":["4d4f1b2c5601680b01c4bb95a43fe6fb73f03103"],"17c481d761bb0f02c41f89f608c75949a9c65e74":["153cc06382fdc94d0ea3db127eab860ae4310525"],"4d4f1b2c5601680b01c4bb95a43fe6fb73f03103":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"6a90b0c0d735fb9f6839557571eedd4c370c94bf":["8ad45b4ed9e3fd478bb4cd27c6d93a8911126b6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb8548d5b6b919c14a179b607ad0c4f7b3136b17":["f24d87791042430a77c0e6c1e7a59d5840146f5e"],"f24d87791042430a77c0e6c1e7a59d5840146f5e":["14aa57a2d9f13bcc41e8b38c52bd1e55f6390576"],"a5893ca90be29bda741b187c863bb89b4c411d8b":["a6e1337304d0d6b29c55795414487cf0f595e154"],"ad94625fb8d088209f46650c8097196fec67f00c":["17c481d761bb0f02c41f89f608c75949a9c65e74"],"8ad45b4ed9e3fd478bb4cd27c6d93a8911126b6e":["c6ff4f117bc6ee20396ca20f0c5b354c2de00d92"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a6e1337304d0d6b29c55795414487cf0f595e154":["a5893ca90be29bda741b187c863bb89b4c411d8b"],"14aa57a2d9f13bcc41e8b38c52bd1e55f6390576":["f24d87791042430a77c0e6c1e7a59d5840146f5e"],"c6ff4f117bc6ee20396ca20f0c5b354c2de00d92":["8ad45b4ed9e3fd478bb4cd27c6d93a8911126b6e"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["4d4f1b2c5601680b01c4bb95a43fe6fb73f03103"],"e8e3766b37206c683d41cf09b4a544b7b28530d0":["14aa57a2d9f13bcc41e8b38c52bd1e55f6390576"],"7ab17db13bd6ba87189b198d11a3c8d5836fa96f":["153cc06382fdc94d0ea3db127eab860ae4310525"],"dd42c8ecc9f8a8e590c5526544a77258089ca23f":["c6ff4f117bc6ee20396ca20f0c5b354c2de00d92"],"153cc06382fdc94d0ea3db127eab860ae4310525":["17c481d761bb0f02c41f89f608c75949a9c65e74"],"8d22c66b0638c82521891318fc352042c5b86e03":["dd42c8ecc9f8a8e590c5526544a77258089ca23f"],"4d4f1b2c5601680b01c4bb95a43fe6fb73f03103":["8d22c66b0638c82521891318fc352042c5b86e03"],"17c481d761bb0f02c41f89f608c75949a9c65e74":["ad94625fb8d088209f46650c8097196fec67f00c"],"6a90b0c0d735fb9f6839557571eedd4c370c94bf":["a6e1337304d0d6b29c55795414487cf0f595e154"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a5893ca90be29bda741b187c863bb89b4c411d8b":["e8e3766b37206c683d41cf09b4a544b7b28530d0"],"bb8548d5b6b919c14a179b607ad0c4f7b3136b17":["7ab17db13bd6ba87189b198d11a3c8d5836fa96f"],"f24d87791042430a77c0e6c1e7a59d5840146f5e":["bb8548d5b6b919c14a179b607ad0c4f7b3136b17"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"8ad45b4ed9e3fd478bb4cd27c6d93a8911126b6e":["6a90b0c0d735fb9f6839557571eedd4c370c94bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}