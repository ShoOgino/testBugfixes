{"path":"lucene/core/src/java/org/apache/lucene/geo/SimpleGeoJSONPolygonParser#parseObject(String).mjava","commits":[{"id":"928077c840ee09456eee199964d886c73fc53314","date":1468594268,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/SimpleGeoJSONPolygonParser#parseObject(String).mjava","pathOld":"/dev/null","sourceNew":"  /** path is the \"address\" by keys of where we are, e.g. geometry.coordinates */\n  private void parseObject(String path) throws ParseException {\n    scan('{');\n    boolean first = true;\n    while (true) {\n      char ch = peek();\n      if (ch == '}') {\n        break;\n      } else if (first == false) {\n        if (ch == ',') {\n          // ok\n          upto++;\n          ch = peek();\n          if (ch == '}') {\n            break;\n          }\n        } else {\n          throw newParseException(\"expected , but got \" + ch);\n        }\n      }\n\n      first = false;\n\n      int uptoStart = upto;\n      String key = parseString();\n\n      if (path.equals(\"crs.properties\") && key.equals(\"href\")) {\n        upto = uptoStart;\n        throw newParseException(\"cannot handle linked crs\");\n      }\n\n      scan(':');\n\n      Object o;\n\n      ch = peek();\n\n      uptoStart = upto;\n\n      if (ch == '[') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + \".\" + key;\n        }\n        o = parseArray(newPath);\n      } else if (ch == '{') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + \".\" + key;\n        }\n        parseObject(newPath);\n        o = null;\n      } else if (ch == '\"') {\n        o = parseString();\n      } else if (ch == 't') {\n        scan(\"true\");\n        o = Boolean.TRUE;\n      } else if (ch == 'f') {\n        scan(\"false\");\n        o = Boolean.FALSE;\n      } else if (ch == 'n') {\n        scan(\"null\");\n        o = null;\n      } else if (ch == '-' || ch == '.' || (ch >= '0' && ch <= '9')) {\n        o = parseNumber();\n      } else if (ch == '}') {\n        break;\n      } else {\n        throw newParseException(\"expected array, object, string or literal value, but got: \" + ch);\n      }\n\n      if (path.equals(\"crs.properties\") && key.equals(\"name\")) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException(\"crs.properties.name should be a string, but saw: \" + o);\n        }\n        String crs = (String) o;\n        if (crs.startsWith(\"urn:ogc:def:crs:OGC\") == false || crs.endsWith(\":CRS84\") == false) {\n          upto = uptoStart;\n          throw newParseException(\"crs must be CRS84 from OGC, but saw: \" + o);\n        }\n      }\n\n      if (key.equals(\"type\") && path.startsWith(\"crs\") == false) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException(\"type should be a string, but got: \" + o);\n        }\n        String type = (String) o;\n        if (type.equals(\"Polygon\") && isValidGeometryPath(path)) {\n          polyType = \"Polygon\";\n        } else if (type.equals(\"MultiPolygon\") && isValidGeometryPath(path)) {\n          polyType = \"MultiPolygon\";\n        } else if ((type.equals(\"FeatureCollection\") || type.equals(\"Feature\")) && (path.equals(\"features.[]\") || path.equals(\"\"))) {\n          // OK, we recurse\n        } else {\n          upto = uptoStart;\n          throw newParseException(\"can only handle type FeatureCollection (if it has a single polygon geometry), Feature, Polygon or MutiPolygon, but got \" + type);\n        }\n      } else if (key.equals(\"coordinates\") && isValidGeometryPath(path)) {\n        if (o instanceof List == false) {\n          upto = uptoStart;\n          throw newParseException(\"coordinates should be an array, but got: \" + o.getClass());\n        }\n        if (coordinates != null) {\n          upto = uptoStart;\n          throw newParseException(\"only one Polygon or MultiPolygon is supported\");\n        }\n        coordinates = (List<Object>) o;\n      }\n    }\n\n    scan('}');\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/SimpleGeoJSONPolygonParser#parseObject(String).mjava","pathOld":"/dev/null","sourceNew":"  /** path is the \"address\" by keys of where we are, e.g. geometry.coordinates */\n  private void parseObject(String path) throws ParseException {\n    scan('{');\n    boolean first = true;\n    while (true) {\n      char ch = peek();\n      if (ch == '}') {\n        break;\n      } else if (first == false) {\n        if (ch == ',') {\n          // ok\n          upto++;\n          ch = peek();\n          if (ch == '}') {\n            break;\n          }\n        } else {\n          throw newParseException(\"expected , but got \" + ch);\n        }\n      }\n\n      first = false;\n\n      int uptoStart = upto;\n      String key = parseString();\n\n      if (path.equals(\"crs.properties\") && key.equals(\"href\")) {\n        upto = uptoStart;\n        throw newParseException(\"cannot handle linked crs\");\n      }\n\n      scan(':');\n\n      Object o;\n\n      ch = peek();\n\n      uptoStart = upto;\n\n      if (ch == '[') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + \".\" + key;\n        }\n        o = parseArray(newPath);\n      } else if (ch == '{') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + \".\" + key;\n        }\n        parseObject(newPath);\n        o = null;\n      } else if (ch == '\"') {\n        o = parseString();\n      } else if (ch == 't') {\n        scan(\"true\");\n        o = Boolean.TRUE;\n      } else if (ch == 'f') {\n        scan(\"false\");\n        o = Boolean.FALSE;\n      } else if (ch == 'n') {\n        scan(\"null\");\n        o = null;\n      } else if (ch == '-' || ch == '.' || (ch >= '0' && ch <= '9')) {\n        o = parseNumber();\n      } else if (ch == '}') {\n        break;\n      } else {\n        throw newParseException(\"expected array, object, string or literal value, but got: \" + ch);\n      }\n\n      if (path.equals(\"crs.properties\") && key.equals(\"name\")) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException(\"crs.properties.name should be a string, but saw: \" + o);\n        }\n        String crs = (String) o;\n        if (crs.startsWith(\"urn:ogc:def:crs:OGC\") == false || crs.endsWith(\":CRS84\") == false) {\n          upto = uptoStart;\n          throw newParseException(\"crs must be CRS84 from OGC, but saw: \" + o);\n        }\n      }\n\n      if (key.equals(\"type\") && path.startsWith(\"crs\") == false) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException(\"type should be a string, but got: \" + o);\n        }\n        String type = (String) o;\n        if (type.equals(\"Polygon\") && isValidGeometryPath(path)) {\n          polyType = \"Polygon\";\n        } else if (type.equals(\"MultiPolygon\") && isValidGeometryPath(path)) {\n          polyType = \"MultiPolygon\";\n        } else if ((type.equals(\"FeatureCollection\") || type.equals(\"Feature\")) && (path.equals(\"features.[]\") || path.equals(\"\"))) {\n          // OK, we recurse\n        } else {\n          upto = uptoStart;\n          throw newParseException(\"can only handle type FeatureCollection (if it has a single polygon geometry), Feature, Polygon or MutiPolygon, but got \" + type);\n        }\n      } else if (key.equals(\"coordinates\") && isValidGeometryPath(path)) {\n        if (o instanceof List == false) {\n          upto = uptoStart;\n          throw newParseException(\"coordinates should be an array, but got: \" + o.getClass());\n        }\n        if (coordinates != null) {\n          upto = uptoStart;\n          throw newParseException(\"only one Polygon or MultiPolygon is supported\");\n        }\n        coordinates = (List<Object>) o;\n      }\n    }\n\n    scan('}');\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2af44fa9bd43d5df330d6438c1af390323f7d567","date":1574847240,"type":3,"author":"Benedict Jin","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/SimpleGeoJSONPolygonParser#parseObject(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/SimpleGeoJSONPolygonParser#parseObject(String).mjava","sourceNew":"  /** path is the \"address\" by keys of where we are, e.g. geometry.coordinates */\n  private void parseObject(String path) throws ParseException {\n    scan('{');\n    boolean first = true;\n    while (true) {\n      char ch = peek();\n      if (ch == '}') {\n        break;\n      } else if (first == false) {\n        if (ch == ',') {\n          // ok\n          upto++;\n          ch = peek();\n          if (ch == '}') {\n            break;\n          }\n        } else {\n          throw newParseException(\"expected , but got \" + ch);\n        }\n      }\n\n      first = false;\n\n      int uptoStart = upto;\n      String key = parseString();\n\n      if (path.equals(\"crs.properties\") && key.equals(\"href\")) {\n        upto = uptoStart;\n        throw newParseException(\"cannot handle linked crs\");\n      }\n\n      scan(':');\n\n      Object o;\n\n      ch = peek();\n\n      uptoStart = upto;\n\n      if (ch == '[') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + \".\" + key;\n        }\n        o = parseArray(newPath);\n      } else if (ch == '{') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + \".\" + key;\n        }\n        parseObject(newPath);\n        o = null;\n      } else if (ch == '\"') {\n        o = parseString();\n      } else if (ch == 't') {\n        scan(\"true\");\n        o = Boolean.TRUE;\n      } else if (ch == 'f') {\n        scan(\"false\");\n        o = Boolean.FALSE;\n      } else if (ch == 'n') {\n        scan(\"null\");\n        o = null;\n      } else if (ch == '-' || ch == '.' || (ch >= '0' && ch <= '9')) {\n        o = parseNumber();\n      } else if (ch == '}') {\n        break;\n      } else {\n        throw newParseException(\"expected array, object, string or literal value, but got: \" + ch);\n      }\n\n      if (path.equals(\"crs.properties\") && key.equals(\"name\")) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException(\"crs.properties.name should be a string, but saw: \" + o);\n        }\n        String crs = (String) o;\n        if (crs.startsWith(\"urn:ogc:def:crs:OGC\") == false || crs.endsWith(\":CRS84\") == false) {\n          upto = uptoStart;\n          throw newParseException(\"crs must be CRS84 from OGC, but saw: \" + o);\n        }\n      }\n\n      if (key.equals(\"type\") && path.startsWith(\"crs\") == false) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException(\"type should be a string, but got: \" + o);\n        }\n        String type = (String) o;\n        if (type.equals(\"Polygon\") && isValidGeometryPath(path)) {\n          polyType = \"Polygon\";\n        } else if (type.equals(\"MultiPolygon\") && isValidGeometryPath(path)) {\n          polyType = \"MultiPolygon\";\n        } else if ((type.equals(\"FeatureCollection\") || type.equals(\"Feature\")) && (path.equals(\"features.[]\") || path.equals(\"\"))) {\n          // OK, we recurse\n        } else {\n          upto = uptoStart;\n          throw newParseException(\"can only handle type FeatureCollection (if it has a single polygon geometry), Feature, Polygon or MultiPolygon, but got \" + type);\n        }\n      } else if (key.equals(\"coordinates\") && isValidGeometryPath(path)) {\n        if (o instanceof List == false) {\n          upto = uptoStart;\n          throw newParseException(\"coordinates should be an array, but got: \" + o.getClass());\n        }\n        if (coordinates != null) {\n          upto = uptoStart;\n          throw newParseException(\"only one Polygon or MultiPolygon is supported\");\n        }\n        coordinates = (List<Object>) o;\n      }\n    }\n\n    scan('}');\n  }\n\n","sourceOld":"  /** path is the \"address\" by keys of where we are, e.g. geometry.coordinates */\n  private void parseObject(String path) throws ParseException {\n    scan('{');\n    boolean first = true;\n    while (true) {\n      char ch = peek();\n      if (ch == '}') {\n        break;\n      } else if (first == false) {\n        if (ch == ',') {\n          // ok\n          upto++;\n          ch = peek();\n          if (ch == '}') {\n            break;\n          }\n        } else {\n          throw newParseException(\"expected , but got \" + ch);\n        }\n      }\n\n      first = false;\n\n      int uptoStart = upto;\n      String key = parseString();\n\n      if (path.equals(\"crs.properties\") && key.equals(\"href\")) {\n        upto = uptoStart;\n        throw newParseException(\"cannot handle linked crs\");\n      }\n\n      scan(':');\n\n      Object o;\n\n      ch = peek();\n\n      uptoStart = upto;\n\n      if (ch == '[') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + \".\" + key;\n        }\n        o = parseArray(newPath);\n      } else if (ch == '{') {\n        String newPath;\n        if (path.length() == 0) {\n          newPath = key;\n        } else {\n          newPath = path + \".\" + key;\n        }\n        parseObject(newPath);\n        o = null;\n      } else if (ch == '\"') {\n        o = parseString();\n      } else if (ch == 't') {\n        scan(\"true\");\n        o = Boolean.TRUE;\n      } else if (ch == 'f') {\n        scan(\"false\");\n        o = Boolean.FALSE;\n      } else if (ch == 'n') {\n        scan(\"null\");\n        o = null;\n      } else if (ch == '-' || ch == '.' || (ch >= '0' && ch <= '9')) {\n        o = parseNumber();\n      } else if (ch == '}') {\n        break;\n      } else {\n        throw newParseException(\"expected array, object, string or literal value, but got: \" + ch);\n      }\n\n      if (path.equals(\"crs.properties\") && key.equals(\"name\")) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException(\"crs.properties.name should be a string, but saw: \" + o);\n        }\n        String crs = (String) o;\n        if (crs.startsWith(\"urn:ogc:def:crs:OGC\") == false || crs.endsWith(\":CRS84\") == false) {\n          upto = uptoStart;\n          throw newParseException(\"crs must be CRS84 from OGC, but saw: \" + o);\n        }\n      }\n\n      if (key.equals(\"type\") && path.startsWith(\"crs\") == false) {\n        if (o instanceof String == false) {\n          upto = uptoStart;\n          throw newParseException(\"type should be a string, but got: \" + o);\n        }\n        String type = (String) o;\n        if (type.equals(\"Polygon\") && isValidGeometryPath(path)) {\n          polyType = \"Polygon\";\n        } else if (type.equals(\"MultiPolygon\") && isValidGeometryPath(path)) {\n          polyType = \"MultiPolygon\";\n        } else if ((type.equals(\"FeatureCollection\") || type.equals(\"Feature\")) && (path.equals(\"features.[]\") || path.equals(\"\"))) {\n          // OK, we recurse\n        } else {\n          upto = uptoStart;\n          throw newParseException(\"can only handle type FeatureCollection (if it has a single polygon geometry), Feature, Polygon or MutiPolygon, but got \" + type);\n        }\n      } else if (key.equals(\"coordinates\") && isValidGeometryPath(path)) {\n        if (o instanceof List == false) {\n          upto = uptoStart;\n          throw newParseException(\"coordinates should be an array, but got: \" + o.getClass());\n        }\n        if (coordinates != null) {\n          upto = uptoStart;\n          throw newParseException(\"only one Polygon or MultiPolygon is supported\");\n        }\n        coordinates = (List<Object>) o;\n      }\n    }\n\n    scan('}');\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"928077c840ee09456eee199964d886c73fc53314":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2af44fa9bd43d5df330d6438c1af390323f7d567":["928077c840ee09456eee199964d886c73fc53314"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","928077c840ee09456eee199964d886c73fc53314"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2af44fa9bd43d5df330d6438c1af390323f7d567"]},"commit2Childs":{"928077c840ee09456eee199964d886c73fc53314":["2af44fa9bd43d5df330d6438c1af390323f7d567","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["928077c840ee09456eee199964d886c73fc53314","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"2af44fa9bd43d5df330d6438c1af390323f7d567":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}