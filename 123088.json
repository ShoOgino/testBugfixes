{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","commits":[{"id":"1e7090fb56105afb6515b6506724359c32ec7639","date":1521211434,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.LinearCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0f7139cdd1f0943275ead761e4705c424e9d638","date":1522191927,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        \n        // The crossing point is shared by two edges.  If we are going to count it, this is the edge we'll count it on.\n        // We have to figure out if this crossing should be counted.\n        \n        // We look at the above plane and the below plane and see if we cross either of them.\n        // If we cross NEITHER of them: we're in the \"zone\" between the planes, and this edge doesn't count.\n\n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n\n        if ((aboveIntersections == null || aboveIntersections.length == 0) && (belowIntersections == null || belowIntersections.length == 0)) {\n          return;\n        }\n        \n        // A null value means we have a situation where the edge is numerically identical.  That's not counted as a \"crossing\".\n        \n        assert !(aboveIntersections != null && aboveIntersections.length > 0 && belowIntersections != null && belowIntersections.length > 0) : \"edge that ends in a crossing can't be both up and down!\";\n        \n        final boolean edgeCrossesAbove = aboveIntersections != null && aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findCrossings(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findCrossings(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          if ((assessAboveIntersections == null || assessAboveIntersections.length == 0) && (assessBelowIntersections == null || assessBelowIntersections.length == 0)) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections != null && assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        if ((aboveIntersections == null || aboveIntersections.length == 0) && (belowIntersections == null || belowIntersections.length == 0)) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections != null && aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findCrossings(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findCrossings(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          if (assessAboveIntersections != null && assessAboveIntersections.length == 0 && assessBelowIntersections != null && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections != null && assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b879b14da40ab73551b75835099a61e622a83d3","date":1522406622,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":null,"sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        \n        // The crossing point is shared by two edges.  If we are going to count it, this is the edge we'll count it on.\n        // We have to figure out if this crossing should be counted.\n        \n        // We look at the above plane and the below plane and see if we cross either of them.\n        // If we cross NEITHER of them: we're in the \"zone\" between the planes, and this edge doesn't count.\n\n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n\n        if ((aboveIntersections == null || aboveIntersections.length == 0) && (belowIntersections == null || belowIntersections.length == 0)) {\n          return;\n        }\n        \n        // A null value means we have a situation where the edge is numerically identical.  That's not counted as a \"crossing\".\n        \n        assert !(aboveIntersections != null && aboveIntersections.length > 0 && belowIntersections != null && belowIntersections.length > 0) : \"edge that ends in a crossing can't be both up and down!\";\n        \n        final boolean edgeCrossesAbove = aboveIntersections != null && aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findCrossings(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findCrossings(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          if ((assessAboveIntersections == null || assessAboveIntersections.length == 0) && (assessBelowIntersections == null || assessBelowIntersections.length == 0)) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections != null && assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        if ((aboveIntersections == null || aboveIntersections.length == 0) && (belowIntersections == null || belowIntersections.length == 0)) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections != null && aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findCrossings(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findCrossings(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          if (assessAboveIntersections != null && assessAboveIntersections.length == 0 && assessBelowIntersections != null && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections != null && assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0f7139cdd1f0943275ead761e4705c424e9d638":["1e7090fb56105afb6515b6506724359c32ec7639"],"8b879b14da40ab73551b75835099a61e622a83d3":["c0f7139cdd1f0943275ead761e4705c424e9d638"],"1e7090fb56105afb6515b6506724359c32ec7639":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8b879b14da40ab73551b75835099a61e622a83d3"]},"commit2Childs":{"c0f7139cdd1f0943275ead761e4705c424e9d638":["8b879b14da40ab73551b75835099a61e622a83d3"],"1e7090fb56105afb6515b6506724359c32ec7639":["c0f7139cdd1f0943275ead761e4705c424e9d638"],"8b879b14da40ab73551b75835099a61e622a83d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e7090fb56105afb6515b6506724359c32ec7639"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}