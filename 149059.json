{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#createCollectionsIfRequired(AddUpdateCommand).mjava","commits":[{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":1,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#createCollectionsIfRequired(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","sourceNew":"  @Override\n  public String createCollectionsIfRequired(AddUpdateCommand cmd) {\n    SolrQueryRequest req = cmd.getReq();\n    SolrCore core = req.getCore();\n    CoreContainer coreContainer = core.getCoreContainer();\n    CollectionsHandler collectionsHandler = coreContainer.getCollectionsHandler();\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd, candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!preemptiveCreateOnceAlready) {\n            log.debug(\"Executing preemptive creation for {}\", getAliasName());\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName, collectionsHandler), core);\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!preemptiveCreateOnceAlready) {\n            log.info(\"EXECUTING preemptive creation for {}\", timeRoutedAlias.getAliasName());\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"105e345cf3c0abed3cb6c109274a379cb2655adc","date":1561038472,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#createCollectionsIfRequired(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#createCollectionsIfRequired(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public String createCollectionsIfRequired(AddUpdateCommand cmd) {\n    SolrQueryRequest req = cmd.getReq();\n    SolrCore core = req.getCore();\n    CoreContainer coreContainer = core.getCoreContainer();\n    CollectionsHandler collectionsHandler = coreContainer.getCollectionsHandler();\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd, candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!preemptiveCreateOnceAlready) {\n            log.debug(\"Executing preemptive creation for {}\", getAliasName());\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n            log.debug(\"Most recent at preemptive: {}\", mostRecentCollName);\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName, collectionsHandler), core);\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public String createCollectionsIfRequired(AddUpdateCommand cmd) {\n    SolrQueryRequest req = cmd.getReq();\n    SolrCore core = req.getCore();\n    CoreContainer coreContainer = core.getCoreContainer();\n    CollectionsHandler collectionsHandler = coreContainer.getCollectionsHandler();\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd, candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!preemptiveCreateOnceAlready) {\n            log.debug(\"Executing preemptive creation for {}\", getAliasName());\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName, collectionsHandler), core);\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":4,"author":"Gus Heck","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#createCollectionsIfRequired(AddUpdateCommand).mjava","sourceNew":null,"sourceOld":"  @Override\n  public String createCollectionsIfRequired(AddUpdateCommand cmd) {\n    SolrQueryRequest req = cmd.getReq();\n    SolrCore core = req.getCore();\n    CoreContainer coreContainer = core.getCoreContainer();\n    CollectionsHandler collectionsHandler = coreContainer.getCollectionsHandler();\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd, candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!preemptiveCreateOnceAlready) {\n            log.debug(\"Executing preemptive creation for {}\", getAliasName());\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n            log.debug(\"Most recent at preemptive: {}\", mostRecentCollName);\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName, collectionsHandler), core);\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["b627755385655c7cd3fb296f17593658805cf4d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"]},"commit2Childs":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b627755385655c7cd3fb296f17593658805cf4d5"],"b627755385655c7cd3fb296f17593658805cf4d5":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}