{"path":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","commits":[{"id":"dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d","date":1450976696,"type":0,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"/dev/null","sourceNew":"  private void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      indexDoc(pdoc);\n    }\n    commit();\n    \n    //handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIPVAL); // not a cloud test, but may use updateLog\n    handle.put(\"maxScore\", SKIP);// see org.apache.solr.TestDistributedSearch.test()\n    handle.put(\"shards\", SKIP);\n    handle.put(\"distrib\", SKIP);\n    handle.put(\"rid\", SKIP);\n    handle.put(\"track\", SKIP);\n    handle.put(\"facet_fields\", UNORDERED);\n    handle.put(\"SIZE_s\", UNORDERED);\n    handle.put(\"COLOR_s\", UNORDERED);\n    \n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n  //  }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ce10a28c50d8072f34d6c5dd02ff8e2ed0396a94"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da83c90417e805f2b355afc2d79f4d2b2ce27469","date":1464346037,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  private void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      indexDoc(pdoc);\n    }\n    commit();\n    \n    //handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIPVAL); // not a cloud test, but may use updateLog\n    handle.put(\"maxScore\", SKIP);// see org.apache.solr.TestDistributedSearch.test()\n    handle.put(\"shards\", SKIP);\n    handle.put(\"distrib\", SKIP);\n    handle.put(\"rid\", SKIP);\n    handle.put(\"track\", SKIP);\n    handle.put(\"facet_fields\", UNORDERED);\n    handle.put(\"SIZE_s\", UNORDERED);\n    handle.put(\"COLOR_s\", UNORDERED);\n    \n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n  //  }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da8a02bef7458089240404614139b53c9f875ec7","date":1464597207,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  private void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      indexDoc(pdoc);\n    }\n    commit();\n    \n    //handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIPVAL); // not a cloud test, but may use updateLog\n    handle.put(\"maxScore\", SKIP);// see org.apache.solr.TestDistributedSearch.test()\n    handle.put(\"shards\", SKIP);\n    handle.put(\"distrib\", SKIP);\n    handle.put(\"rid\", SKIP);\n    handle.put(\"track\", SKIP);\n    handle.put(\"facet_fields\", UNORDERED);\n    handle.put(\"SIZE_s\", UNORDERED);\n    handle.put(\"COLOR_s\", UNORDERED);\n    \n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n  //  }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  private void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      indexDoc(pdoc);\n    }\n    commit();\n    \n    //handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIPVAL); // not a cloud test, but may use updateLog\n    handle.put(\"maxScore\", SKIP);// see org.apache.solr.TestDistributedSearch.test()\n    handle.put(\"shards\", SKIP);\n    handle.put(\"distrib\", SKIP);\n    handle.put(\"rid\", SKIP);\n    handle.put(\"track\", SKIP);\n    handle.put(\"facet_fields\", UNORDERED);\n    handle.put(\"SIZE_s\", UNORDERED);\n    handle.put(\"COLOR_s\", UNORDERED);\n    \n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n  //  }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  private void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      indexDoc(pdoc);\n    }\n    commit();\n    \n    //handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIPVAL); // not a cloud test, but may use updateLog\n    handle.put(\"maxScore\", SKIP);// see org.apache.solr.TestDistributedSearch.test()\n    handle.put(\"shards\", SKIP);\n    handle.put(\"distrib\", SKIP);\n    handle.put(\"rid\", SKIP);\n    handle.put(\"track\", SKIP);\n    handle.put(\"facet_fields\", UNORDERED);\n    handle.put(\"SIZE_s\", UNORDERED);\n    handle.put(\"COLOR_s\", UNORDERED);\n    \n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n  //  }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce10a28c50d8072f34d6c5dd02ff8e2ed0396a94","date":1493112785,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","bugFix":["dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", random().nextBoolean() ? \"true\":\"false\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"rows\",\"0\" // we care only abt results \n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ff704ef91e9ae30ca59babb23ece85720701b60","date":1498684964,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"/blockJoinDocSetFacetRH\" : \"/blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"/blockJoinDocSetFacetRH\" : \"/blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"/blockJoinDocSetFacetRH\" : \"/blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","sourceOld":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"blockJoinDocSetFacetRH\" : \"blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79a29c6bd3f9ceeff3a351a23029546d12b66034","date":1525195155,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  @Test \n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    if (random().nextBoolean()) {\n      cluster.getSolrClient().commit(collection);\n    } else {\n      cluster.getSolrClient().optimize(collection);\n    }\n    // to parent query\n    final String matchingColorsCommaSep = matchingColors.toString().replaceAll(\"[ \\\\[\\\\]]\", \"\");\n    final String childQueryClause = \"{!terms f=COLOR_s}\" + matchingColorsCommaSep;\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      final boolean limitJsonSizes = random().nextBoolean();\n      final boolean limitJsonColors = random().nextBoolean();\n      \n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\" v=$matchingColors}\",//+childQueryClause,\n          \"matchingColors\", childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"/blockJoinDocSetFacetRH\" : \"/blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\",\n          \"json.facet\",\"{ \"\n              + \"children:{ type: query, query:\\\"*:*\\\", domain:{\"\n                    +\"blockChildren:\\\"type_s:parent\\\", filter:{param:matchingColors}\"\n                    + \"}, facet:{ colors:{ type:field, field:COLOR_s,\"\n                    +              (limitJsonColors ? \"\":\" limit:-1,\")\n                    +              \" facet:{ inprods:\\\"uniqueBlock(_root_)\\\"}}, \"\n                    +         \"sizes:{type:field, field:SIZE_s, \"\n                    +              (limitJsonSizes ? \"\" : \"limit:-1,\")\n                    +              \" facet:{inprods:\\\"uniqueBlock(_root_)\\\"}}\"\n                    + \"}\"\n              + \"}}\", \"debugQuery\",\"true\"//, \"shards\", \"shard1\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n\n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n\n      final List<NamedList<Object>> jsonSizes = (List<NamedList<Object>>)\n                              get(resultsResponse, \"facets\", \"children\", \"sizes\", \"buckets\");\n      final List<NamedList<Object>> jsonColors = (List<NamedList<Object>>)\n                                get(resultsResponse, \"facets\", \"children\", \"colors\", \"buckets\");\n\n      if (limitJsonColors) {\n        assertTrue(\"\"+jsonColors, jsonColors.size()<=defFacetLimit);\n      }\n\n      if (limitJsonSizes) {\n        assertTrue(\"\"+jsonSizes, jsonSizes.size()<=defFacetLimit);\n      }\n\n      for (List<NamedList<Object>> vals : new List[] { jsonSizes,jsonColors}) {\n        int i=0;\n        for(NamedList<Object> tuples: vals) {\n          String  val = (String) get(tuples,\"val\");\n          Number  count = (Number) get(tuples,\"inprods\");\n          if (((vals==jsonSizes && limitJsonSizes) || // vals close to the limit are not exact \n              (vals==jsonColors && limitJsonColors)) && i>=defFacetLimit/2) {\n            assertTrue(i+ \"th \"+tuples+\". \"+vals, \n                parentIdsByAttrValue.get(val).size()>= count.intValue() &&\n                count.intValue()>0);\n          } else {\n            assertEquals(tuples+\". \"+vals, \n                parentIdsByAttrValue.get(val).size(),count.intValue());\n          }\n          i++;\n        }\n      }\n      if (!limitJsonColors && !limitJsonSizes) {\n        assertEquals(\"\"+jsonSizes+jsonColors, parentIdsByAttrValue.size(),jsonSizes.size() + jsonColors.size());\n      }\n  }\n\n","sourceOld":"  @Test\n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    cluster.getSolrClient().commit(collection);\n\n    // to parent query\n    final String childQueryClause = \"COLOR_s:(\"+(matchingColors.toString().replaceAll(\"[,\\\\[\\\\]]\", \" \"))+\")\";\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\"}\"+childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"/blockJoinDocSetFacetRH\" : \"/blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n      \n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n      //System.out.println(parentIdsByAttrValue);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00a778ad8ad6c2c04607538d2f36fee001239eef","date":1576657013,"type":4,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"unchecked\")\n  @Test \n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    if (random().nextBoolean()) {\n      cluster.getSolrClient().commit(collection);\n    } else {\n      cluster.getSolrClient().optimize(collection);\n    }\n    // to parent query\n    final String matchingColorsCommaSep = matchingColors.toString().replaceAll(\"[ \\\\[\\\\]]\", \"\");\n    final String childQueryClause = \"{!terms f=COLOR_s}\" + matchingColorsCommaSep;\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      final boolean limitJsonSizes = random().nextBoolean();\n      final boolean limitJsonColors = random().nextBoolean();\n      \n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\" v=$matchingColors}\",//+childQueryClause,\n          \"matchingColors\", childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"/blockJoinDocSetFacetRH\" : \"/blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\",\n          \"json.facet\",\"{ \"\n              + \"children:{ type: query, query:\\\"*:*\\\", domain:{\"\n                    +\"blockChildren:\\\"type_s:parent\\\", filter:{param:matchingColors}\"\n                    + \"}, facet:{ colors:{ type:field, field:COLOR_s,\"\n                    +              (limitJsonColors ? \"\":\" limit:-1,\")\n                    +              \" facet:{ inprods:\\\"uniqueBlock(_root_)\\\"}}, \"\n                    +         \"sizes:{type:field, field:SIZE_s, \"\n                    +              (limitJsonSizes ? \"\" : \"limit:-1,\")\n                    +              \" facet:{inprods:\\\"uniqueBlock(_root_)\\\"}}\"\n                    + \"}\"\n              + \"}}\", \"debugQuery\",\"true\"//, \"shards\", \"shard1\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n\n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n\n      final List<NamedList<Object>> jsonSizes = (List<NamedList<Object>>)\n                              get(resultsResponse, \"facets\", \"children\", \"sizes\", \"buckets\");\n      final List<NamedList<Object>> jsonColors = (List<NamedList<Object>>)\n                                get(resultsResponse, \"facets\", \"children\", \"colors\", \"buckets\");\n\n      if (limitJsonColors) {\n        assertTrue(\"\"+jsonColors, jsonColors.size()<=defFacetLimit);\n      }\n\n      if (limitJsonSizes) {\n        assertTrue(\"\"+jsonSizes, jsonSizes.size()<=defFacetLimit);\n      }\n\n      for (List<NamedList<Object>> vals : new List[] { jsonSizes,jsonColors}) {\n        int i=0;\n        for(NamedList<Object> tuples: vals) {\n          String  val = (String) get(tuples,\"val\");\n          Number  count = (Number) get(tuples,\"inprods\");\n          if (((vals==jsonSizes && limitJsonSizes) || // vals close to the limit are not exact \n              (vals==jsonColors && limitJsonColors)) && i>=defFacetLimit/2) {\n            assertTrue(i+ \"th \"+tuples+\". \"+vals, \n                parentIdsByAttrValue.get(val).size()>= count.intValue() &&\n                count.intValue()>0);\n          } else {\n            assertEquals(tuples+\". \"+vals, \n                parentIdsByAttrValue.get(val).size(),count.intValue());\n          }\n          i++;\n        }\n      }\n      if (!limitJsonColors && !limitJsonSizes) {\n        assertEquals(\"\"+jsonSizes+jsonColors, parentIdsByAttrValue.size(),jsonSizes.size() + jsonColors.size());\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"246314af59d76a47fccc31e9494eefee01ec9c00","date":1576657955,"type":4,"author":"Dawid Weiss","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/search/join/BlockJoinFacetDistribTest#testBJQFacetComponent().mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"unchecked\")\n  @Test \n  public void testBJQFacetComponent() throws Exception {\n    \n    assert ! colors.removeAll(sizes): \"there is no colors in sizes\";\n    Collections.shuffle(colors,random());\n    List<String> matchingColors = colors.subList(0, Math.min(atLeast(random(), 2), colors.size()));\n        \n    Map<String, Set<Integer>> parentIdsByAttrValue = new HashMap<String, Set<Integer>>(){\n      @Override\n      public Set<Integer> get(Object key) {\n        return super.get(key)==null && put((String)key, new HashSet<>())==null?super.get(key):super.get(key);\n      }\n    };\n    \n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    \n    final int parents = atLeast(10);\n    boolean aggregationOccurs = false;\n    List<SolrInputDocument> parentDocs = new ArrayList<>();\n    for(int parent=0; parent<parents || !aggregationOccurs;parent++){\n      assert parent < 2000000 : \"parent num \"+parent+\n           \" aggregationOccurs:\"+aggregationOccurs+\". Sorry! too tricky loop condition.\";\n      SolrInputDocument pdoc = new SolrInputDocument();\n      pdoc.addField(\"id\", parent);\n      pdoc.addField(\"type_s\", \"parent\");\n      final String parentBrand = \"brand\"+(random().nextInt(5));\n      pdoc.addField(\"BRAND_s\", parentBrand);\n      \n      for(int child=0; child<atLeast(colors.size()/2);child++){\n        SolrInputDocument childDoc= new SolrInputDocument();\n        final String color = colors.get(random().nextInt(colors.size()));\n        childDoc.addField(\"COLOR_s\", color);\n        final String size = sizes.get(random().nextInt(sizes.size()));\n        childDoc.addField(\"SIZE_s\",  size);\n        \n        if(matchingColors.contains(color)){\n          final boolean colorDupe = !parentIdsByAttrValue.get(color).add(parent);\n          final boolean sizeDupe = !parentIdsByAttrValue.get(size).add(parent);\n          aggregationOccurs |= colorDupe || sizeDupe;\n        }\n        pdoc.addChildDocument(childDoc);\n      }\n      parentDocs.add(pdoc);\n      if (!parentDocs.isEmpty() && rarely()) {\n        indexDocs(parentDocs);\n        parentDocs.clear();\n        cluster.getSolrClient().commit(collection, false, false, true);\n      }\n    }\n    if (!parentDocs.isEmpty()) {\n      indexDocs(parentDocs);\n    }\n    if (random().nextBoolean()) {\n      cluster.getSolrClient().commit(collection);\n    } else {\n      cluster.getSolrClient().optimize(collection);\n    }\n    // to parent query\n    final String matchingColorsCommaSep = matchingColors.toString().replaceAll(\"[ \\\\[\\\\]]\", \"\");\n    final String childQueryClause = \"{!terms f=COLOR_s}\" + matchingColorsCommaSep;\n      final boolean oldFacetsEnabled = random().nextBoolean();\n      final boolean limitJsonSizes = random().nextBoolean();\n      final boolean limitJsonColors = random().nextBoolean();\n      \n      QueryResponse results = query(\"q\", \"{!parent which=\\\"type_s:parent\\\" v=$matchingColors}\",//+childQueryClause,\n          \"matchingColors\", childQueryClause,\n          \"facet\", oldFacetsEnabled ? \"true\":\"false\", // try to enforce multiple phases\n              oldFacetsEnabled ? \"facet.field\" : \"ignore\" , \"BRAND_s\",\n              oldFacetsEnabled&&usually() ? \"facet.limit\" : \"ignore\" , \"1\",\n              oldFacetsEnabled&&usually() ? \"facet.mincount\" : \"ignore\" , \"2\",\n              oldFacetsEnabled&&usually() ? \"facet.overrequest.count\" : \"ignore\" , \"0\",\n          \"qt\",  random().nextBoolean() ? \"/blockJoinDocSetFacetRH\" : \"/blockJoinFacetRH\",\n          \"child.facet.field\", \"COLOR_s\",\n          \"child.facet.field\", \"SIZE_s\",\n          \"distrib.singlePass\", random().nextBoolean() ? \"true\":\"false\",\n          \"rows\", random().nextBoolean() ? \"0\":\"10\",\n          \"json.facet\",\"{ \"\n              + \"children:{ type: query, query:\\\"*:*\\\", domain:{\"\n                    +\"blockChildren:\\\"type_s:parent\\\", filter:{param:matchingColors}\"\n                    + \"}, facet:{ colors:{ type:field, field:COLOR_s,\"\n                    +              (limitJsonColors ? \"\":\" limit:-1,\")\n                    +              \" facet:{ inprods:\\\"uniqueBlock(_root_)\\\"}}, \"\n                    +         \"sizes:{type:field, field:SIZE_s, \"\n                    +              (limitJsonSizes ? \"\" : \"limit:-1,\")\n                    +              \" facet:{inprods:\\\"uniqueBlock(_root_)\\\"}}\"\n                    + \"}\"\n              + \"}}\", \"debugQuery\",\"true\"//, \"shards\", \"shard1\"\n          );\n      NamedList<Object> resultsResponse = results.getResponse();\n      assertNotNull(resultsResponse);\n      FacetField color_s = results.getFacetField(\"COLOR_s\");\n      FacetField size_s = results.getFacetField(\"SIZE_s\");\n      \n      String msg = \"\"+parentIdsByAttrValue+\" \"+color_s+\" \"+size_s;\n      for (FacetField facet: new FacetField[]{color_s, size_s}) {\n        for (Count c : facet.getValues()) {\n          assertEquals(c.getName()+\"(\"+msg+\")\", \n              parentIdsByAttrValue.get(c.getName()).size(), c.getCount());\n        }\n      }\n\n      assertEquals(msg , parentIdsByAttrValue.size(),color_s.getValueCount() + size_s.getValueCount());\n\n      final List<NamedList<Object>> jsonSizes = (List<NamedList<Object>>)\n                              get(resultsResponse, \"facets\", \"children\", \"sizes\", \"buckets\");\n      final List<NamedList<Object>> jsonColors = (List<NamedList<Object>>)\n                                get(resultsResponse, \"facets\", \"children\", \"colors\", \"buckets\");\n\n      if (limitJsonColors) {\n        assertTrue(\"\"+jsonColors, jsonColors.size()<=defFacetLimit);\n      }\n\n      if (limitJsonSizes) {\n        assertTrue(\"\"+jsonSizes, jsonSizes.size()<=defFacetLimit);\n      }\n\n      for (List<NamedList<Object>> vals : new List[] { jsonSizes,jsonColors}) {\n        int i=0;\n        for(NamedList<Object> tuples: vals) {\n          String  val = (String) get(tuples,\"val\");\n          Number  count = (Number) get(tuples,\"inprods\");\n          if (((vals==jsonSizes && limitJsonSizes) || // vals close to the limit are not exact \n              (vals==jsonColors && limitJsonColors)) && i>=defFacetLimit/2) {\n            assertTrue(i+ \"th \"+tuples+\". \"+vals, \n                parentIdsByAttrValue.get(val).size()>= count.intValue() &&\n                count.intValue()>0);\n          } else {\n            assertEquals(tuples+\". \"+vals, \n                parentIdsByAttrValue.get(val).size(),count.intValue());\n          }\n          i++;\n        }\n      }\n      if (!limitJsonColors && !limitJsonSizes) {\n        assertEquals(\"\"+jsonSizes+jsonColors, parentIdsByAttrValue.size(),jsonSizes.size() + jsonColors.size());\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"30c8e5574b55d57947e989443dfde611646530ee":["e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d","da83c90417e805f2b355afc2d79f4d2b2ce27469"],"28288370235ed02234a64753cdbf0c6ec096304a":["ce10a28c50d8072f34d6c5dd02ff8e2ed0396a94","5ff704ef91e9ae30ca59babb23ece85720701b60"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d","da83c90417e805f2b355afc2d79f4d2b2ce27469"],"da8a02bef7458089240404614139b53c9f875ec7":["dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d","da83c90417e805f2b355afc2d79f4d2b2ce27469"],"246314af59d76a47fccc31e9494eefee01ec9c00":["79a29c6bd3f9ceeff3a351a23029546d12b66034","00a778ad8ad6c2c04607538d2f36fee001239eef"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["da83c90417e805f2b355afc2d79f4d2b2ce27469","ce10a28c50d8072f34d6c5dd02ff8e2ed0396a94"],"ce10a28c50d8072f34d6c5dd02ff8e2ed0396a94":["da83c90417e805f2b355afc2d79f4d2b2ce27469"],"da83c90417e805f2b355afc2d79f4d2b2ce27469":["dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"79a29c6bd3f9ceeff3a351a23029546d12b66034":["28288370235ed02234a64753cdbf0c6ec096304a"],"00a778ad8ad6c2c04607538d2f36fee001239eef":["79a29c6bd3f9ceeff3a351a23029546d12b66034"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["00a778ad8ad6c2c04607538d2f36fee001239eef"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["ce10a28c50d8072f34d6c5dd02ff8e2ed0396a94"]},"commit2Childs":{"30c8e5574b55d57947e989443dfde611646530ee":[],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":[],"28288370235ed02234a64753cdbf0c6ec096304a":["30c8e5574b55d57947e989443dfde611646530ee","79a29c6bd3f9ceeff3a351a23029546d12b66034"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"da8a02bef7458089240404614139b53c9f875ec7":[],"e9017cf144952056066919f1ebc7897ff9bd71b1":["30c8e5574b55d57947e989443dfde611646530ee"],"246314af59d76a47fccc31e9494eefee01ec9c00":[],"ce10a28c50d8072f34d6c5dd02ff8e2ed0396a94":["28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1","5ff704ef91e9ae30ca59babb23ece85720701b60"],"da83c90417e805f2b355afc2d79f4d2b2ce27469":["5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","da8a02bef7458089240404614139b53c9f875ec7","e9017cf144952056066919f1ebc7897ff9bd71b1","ce10a28c50d8072f34d6c5dd02ff8e2ed0396a94"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d"],"dbb4b815ac37f3938a2f7c18c2e7a5267ed50a1d":["5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","da8a02bef7458089240404614139b53c9f875ec7","da83c90417e805f2b355afc2d79f4d2b2ce27469"],"79a29c6bd3f9ceeff3a351a23029546d12b66034":["246314af59d76a47fccc31e9494eefee01ec9c00","00a778ad8ad6c2c04607538d2f36fee001239eef"],"00a778ad8ad6c2c04607538d2f36fee001239eef":["246314af59d76a47fccc31e9494eefee01ec9c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","da8a02bef7458089240404614139b53c9f875ec7","246314af59d76a47fccc31e9494eefee01ec9c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}