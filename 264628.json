{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","commits":[{"id":"102c0838edfd08e8eaf1ec7ad709a8db84f500ed","date":1592251335,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","pathOld":"/dev/null","sourceNew":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished() {\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n          writer.addDocument(doc);\n          writer.flush();\n          writer.addDocument(doc);\n          writer.flush();\n          writer.deleteDocuments(new Term(\"id\", \"1\"));\n          writer.flush();\n          assertEquals(2, writer.getSegmentCount());\n          assertEquals(0, writer.getDocStats().numDocs);\n          assertEquals(2, writer.getDocStats().maxDoc);\n          writer.forceMerge(1);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0","date":1592426892,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","sourceNew":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished(boolean success) {\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n          writer.addDocument(doc);\n          writer.flush();\n          writer.addDocument(doc);\n          writer.flush();\n          writer.deleteDocuments(new Term(\"id\", \"1\"));\n          writer.flush();\n          assertEquals(2, writer.getSegmentCount());\n          assertEquals(0, writer.getDocStats().numDocs);\n          assertEquals(2, writer.getDocStats().maxDoc);\n          writer.forceMerge(1);\n      }\n    }\n  }\n\n","sourceOld":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished() {\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n          writer.addDocument(doc);\n          writer.flush();\n          writer.addDocument(doc);\n          writer.flush();\n          writer.deleteDocuments(new Term(\"id\", \"1\"));\n          writer.flush();\n          assertEquals(2, writer.getSegmentCount());\n          assertEquals(0, writer.getDocStats().numDocs);\n          assertEquals(2, writer.getDocStats().maxDoc);\n          writer.forceMerge(1);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe39f1a106531207c028defebbc9eb5bb489ac50","date":1592513789,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","sourceNew":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished(boolean success) {\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        writer.flush();\n        writer.addDocument(doc);\n        writer.flush();\n        writer.deleteDocuments(new Term(\"id\", \"1\"));\n        writer.flush();\n        assertEquals(2, writer.getSegmentCount());\n        assertEquals(0, writer.getDocStats().numDocs);\n        assertEquals(2, writer.getDocStats().maxDoc);\n        writer.forceMerge(1);\n      }\n    }\n  }\n\n","sourceOld":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished(boolean success) {\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n          writer.addDocument(doc);\n          writer.flush();\n          writer.addDocument(doc);\n          writer.flush();\n          writer.deleteDocuments(new Term(\"id\", \"1\"));\n          writer.flush();\n          assertEquals(2, writer.getSegmentCount());\n          assertEquals(0, writer.getDocStats().numDocs);\n          assertEquals(2, writer.getDocStats().maxDoc);\n          writer.forceMerge(1);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1182fe36fb5df768dc2da53f6d5338cbc07268ae","date":1592861749,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","sourceNew":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished(boolean success) {\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n          writer.addDocument(doc);\n          writer.flush();\n          writer.addDocument(doc);\n          writer.flush();\n          writer.deleteDocuments(new Term(\"id\", \"1\"));\n          writer.flush();\n          assertEquals(2, writer.getSegmentCount());\n          assertEquals(0, writer.getDocStats().numDocs);\n          assertEquals(2, writer.getDocStats().maxDoc);\n          writer.forceMerge(1);\n      }\n    }\n  }\n\n","sourceOld":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished(boolean success) {\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        writer.flush();\n        writer.addDocument(doc);\n        writer.flush();\n        writer.deleteDocuments(new Term(\"id\", \"1\"));\n        writer.flush();\n        assertEquals(2, writer.getSegmentCount());\n        assertEquals(0, writer.getDocStats().numDocs);\n        assertEquals(2, writer.getDocStats().maxDoc);\n        writer.forceMerge(1);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testMergeZeroDocsMergeIsClosedOnce().mjava","sourceNew":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished(boolean success, boolean segmentDropped) throws IOException {\n                super.mergeFinished(success, segmentDropped);\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        writer.flush();\n        writer.addDocument(doc);\n        writer.flush();\n        writer.deleteDocuments(new Term(\"id\", \"1\"));\n        writer.flush();\n        assertEquals(2, writer.getSegmentCount());\n        assertEquals(0, writer.getDocStats().numDocs);\n        assertEquals(2, writer.getDocStats().maxDoc);\n        writer.forceMerge(1);\n      }\n    }\n  }\n\n","sourceOld":"  public void testMergeZeroDocsMergeIsClosedOnce() throws IOException {\n    LogDocMergePolicy keepAllSegments = new LogDocMergePolicy() {\n      @Override\n      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {\n        return true;\n      }\n    };\n    try (Directory dir = newDirectory()) {\n      try (IndexWriter writer = new IndexWriter(dir,\n          new IndexWriterConfig().setMergePolicy(new OneMergeWrappingMergePolicy(keepAllSegments, merge -> {\n            SetOnce<Boolean> onlyFinishOnce = new SetOnce<>();\n            return new MergePolicy.OneMerge(merge.segments) {\n              @Override\n              public void mergeFinished(boolean success) {\n                onlyFinishOnce.set(true);\n              }\n            };\n          })))) {\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n          writer.addDocument(doc);\n          writer.flush();\n          writer.addDocument(doc);\n          writer.flush();\n          writer.deleteDocuments(new Term(\"id\", \"1\"));\n          writer.flush();\n          assertEquals(2, writer.getSegmentCount());\n          assertEquals(0, writer.getDocStats().numDocs);\n          assertEquals(2, writer.getDocStats().maxDoc);\n          writer.forceMerge(1);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0":["102c0838edfd08e8eaf1ec7ad709a8db84f500ed"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"102c0838edfd08e8eaf1ec7ad709a8db84f500ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["af4f318fc7955d8e4e40cdf4a8a93931004fe7c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"]},"commit2Childs":{"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"102c0838edfd08e8eaf1ec7ad709a8db84f500ed":["af4f318fc7955d8e4e40cdf4a8a93931004fe7c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["102c0838edfd08e8eaf1ec7ad709a8db84f500ed"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}