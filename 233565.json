{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"40dce2b6d4360eb09fa16fb6c40a18b25507ed73","date":1383035822,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath,\n        CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(),\n        CoreAdminParams.CORE, core) ;\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["cd548b14f1051e707393e77329f80c5e89f69919"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"352e39466fda4bfc4523c74007409c1b693a3bba","date":1383323416,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName);\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath,\n        CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(),\n        CoreAdminParams.CORE, core) ;\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath,\n        CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(),\n        CoreAdminParams.CORE, core) ;\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0e3d12b100ee32c1c04e9f0eb435571d40a460a","date":1384360839,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath,\n        CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(),\n        CoreAdminParams.CORE, core) ;\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName);\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath,\n        CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(),\n        CoreAdminParams.CORE, core) ;\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9e6c873b95174ff04c895232927baa76a95925eb","date":1385054916,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath,\n        CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(),\n        CoreAdminParams.CORE, core) ;\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","bugFix":null,"bugIntro":["cd548b14f1051e707393e77329f80c5e89f69919"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd548b14f1051e707393e77329f80c5e89f69919","date":1385226862,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","bugFix":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73","9e6c873b95174ff04c895232927baa76a95925eb"],"bugIntro":["69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    //assume the core exists and try to unload it\n    if (!Slice.ACTIVE.equals(replica.getStr(Slice.STATE))) {\n      deleteCoreNode(collectionName, replicaName, replica, core);\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n    } else {\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath,\n        CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(),\n        CoreAdminParams.CORE, core) ;\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m) );\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.info(\"Exception trying to unload core \"+sreq,e);\n      }\n      if (waitForCoreNodeGone(collectionName, shard, replicaName)) return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // this could be because the core is gone but not updated in ZK yet (race condition)\n      if(waitForCoreNodeGone(collectionName, shard, replicaName)) return;\n\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \"+collectionName+\"/\"+shard+\"/\"+replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","date":1391985588,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b","date":1392108367,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"afd709fe548f0ddbaa0a678015e7c3d41ff1c87a","date":1392108948,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8497bb4f9de61b5520423bd9af88ea11a6e109e7","date":1393245090,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6225820ca5f401e2fe460f36e4a919a384cef6c","date":1393272577,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    if (baseUrl.startsWith(\"http://\")) baseUrl = baseUrl.substring(7);\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<String>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f26f74e4969851a019d28f10315cb1c77786f22","date":1400539241,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results, false, null);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735","date":1403859600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n        CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n        CoreAdminParams.DELETE_DATA_DIR, \"true\");\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core);\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":["cd548b14f1051e707393e77329f80c5e89f69919"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0509309ff81e19f3388e28ecf9e5d51e21b15a64","date":1410750485,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n        ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n          shard+\"/\" + replicaName +\n          \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n        CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n        CoreAdminParams.DELETE_DATA_DIR, \"true\");\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n        CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n        CoreAdminParams.DELETE_DATA_DIR, \"true\");\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n        ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n          shard+\"/\" + replicaName +\n          \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n        CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n        CoreAdminParams.DELETE_DATA_DIR, \"true\");\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","sourceOld":"  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n        ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n          shard+\"/\" + replicaName +\n          \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n        CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n        CoreAdminParams.DELETE_DATA_DIR, \"true\");\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbf528c0e702c5cbd1339b2da1cdc823fd44a925","date":1427230904,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n          ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n        ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n          shard+\"/\" + replicaName +\n          \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n        CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n        CoreAdminParams.DELETE_DATA_DIR, \"true\");\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n          ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if(slice==null){\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \"+shard+\" in collection : \"+ collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if(replica == null){\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas()) l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\"+ collectionName + \" available replicas are \"+ StrUtils.join(l,','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n        ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n          shard+\"/\" + replicaName +\n          \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n        CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n        CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n        CoreAdminParams.DELETE_DATA_DIR, \"true\");\n    \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n        false, null, shardHandler);\n    \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;//check if the core unload removed the corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if(waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n    throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard+\"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n          ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(!ZkStateReader.ACTIVE.equals(replica.getStr(ZkStateReader.STATE_PROP)) ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n          ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n          ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(!ZkStateReader.ACTIVE.equals(replica.getStr(ZkStateReader.STATE_PROP)) ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n          ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(!Slice.ACTIVE.equals(replica.getStr(Slice.STATE)) ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) &&\n          ZkStateReader.DOWN.equals(replica.getStr(ZkStateReader.STATE_PROP)) == false) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(!ZkStateReader.ACTIVE.equals(replica.getStr(ZkStateReader.STATE_PROP)) ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8","date":1431966199,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = ZkNodeProps.makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n    \n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = makeMap(\"qt\", adminPath, CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE,\n        core, CoreAdminParams.DELETE_INSTANCE_DIR, \"true\", CoreAdminParams.DELETE_DATA_DIR, \"true\");\n        \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results, false, null,\n        shardHandler);\n        \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;// check if the core unload removed the\n                                                                              // corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n        \n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collectionName, shard, replicaName, null);\n    try {\n      DocCollection coll = clusterState.getCollection(collectionName);\n      Slice slice = coll.getSlice(shard);\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      if (slice == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n      }\n      Replica replica = slice.getReplica(replicaName);\n      if (replica == null) {\n        ArrayList<String> l = new ArrayList<>();\n        for (Replica r : slice.getReplicas()) l.add(r.getName());\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n            + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n      }\n\n      // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n      // on the command.\n      if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Attempted to remove replica : \" + collectionName + \"/\" +\n            shard + \"/\" + replicaName +\n            \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n      }\n\n      String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n      String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      // assume the core exists and try to unload it\n      Map m = makeMap(\"qt\", adminPath, CoreAdminParams.ACTION,\n          CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE, core,\n          CoreAdminParams.DELETE_INSTANCE_DIR, \"true\",\n          CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n      ShardRequest sreq = new ShardRequest();\n      sreq.purpose = 1;\n      sreq.shards = new String[]{baseUrl};\n      sreq.actualShards = sreq.shards;\n      sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n      try {\n        shardHandler.submit(sreq, baseUrl, sreq.params);\n      } catch (Exception e) {\n        log.warn(\"Exception trying to unload core \" + sreq, e);\n      }\n\n      collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results,\n          false, null, shardHandler);\n\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000))\n        return;//check if the core unload removed the corenode zk enry\n      deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n      if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n    \n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = makeMap(\"qt\", adminPath, CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE,\n        core, CoreAdminParams.DELETE_INSTANCE_DIR, \"true\", CoreAdminParams.DELETE_DATA_DIR, \"true\");\n        \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results, false, null,\n        shardHandler);\n        \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;// check if the core unload removed the\n                                                                              // corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n        \n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n    \n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = makeMap(\"qt\", adminPath, CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE,\n        core, CoreAdminParams.DELETE_INSTANCE_DIR, \"true\", CoreAdminParams.DELETE_DATA_DIR, \"true\");\n        \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results, false, null,\n        shardHandler);\n        \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;// check if the core unload removed the\n                                                                              // corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n        \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0509309ff81e19f3388e28ecf9e5d51e21b15a64":["69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"b7605579001505896d48b07160075a5c8b8e128e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","6f26f74e4969851a019d28f10315cb1c77786f22"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["0509309ff81e19f3388e28ecf9e5d51e21b15a64"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8"],"69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735":["6f26f74e4969851a019d28f10315cb1c77786f22"],"0c924d4069ef5a5bc479a493befe0121aada6896":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["30c688f7052130cef7bd419c85e3c5be214f7b9e","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b0e3d12b100ee32c1c04e9f0eb435571d40a460a":["352e39466fda4bfc4523c74007409c1b693a3bba"],"6f26f74e4969851a019d28f10315cb1c77786f22":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e6225820ca5f401e2fe460f36e4a919a384cef6c":["8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"cd548b14f1051e707393e77329f80c5e89f69919":["9e6c873b95174ff04c895232927baa76a95925eb"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["e6225820ca5f401e2fe460f36e4a919a384cef6c"],"afd709fe548f0ddbaa0a678015e7c3d41ff1c87a":["6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b"],"6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"352e39466fda4bfc4523c74007409c1b693a3bba":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["cd548b14f1051e707393e77329f80c5e89f69919"],"9e6c873b95174ff04c895232927baa76a95925eb":["b0e3d12b100ee32c1c04e9f0eb435571d40a460a"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["b0e3d12b100ee32c1c04e9f0eb435571d40a460a","cd548b14f1051e707393e77329f80c5e89f69919"],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8497bb4f9de61b5520423bd9af88ea11a6e109e7":["afd709fe548f0ddbaa0a678015e7c3d41ff1c87a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["30c688f7052130cef7bd419c85e3c5be214f7b9e"]},"commit2Childs":{"0509309ff81e19f3388e28ecf9e5d51e21b15a64":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["0c924d4069ef5a5bc479a493befe0121aada6896","a219f1dcad1700e84807666bdbd2b573e8de7021"],"b7605579001505896d48b07160075a5c8b8e128e":[],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735":["0509309ff81e19f3388e28ecf9e5d51e21b15a64"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"a219f1dcad1700e84807666bdbd2b573e8de7021":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["0c924d4069ef5a5bc479a493befe0121aada6896"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"b0e3d12b100ee32c1c04e9f0eb435571d40a460a":["9e6c873b95174ff04c895232927baa76a95925eb","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"6f26f74e4969851a019d28f10315cb1c77786f22":["b7605579001505896d48b07160075a5c8b8e128e","69ea2d05f1aa6c792bdd8ac7ccbc14cce654c735"],"e6225820ca5f401e2fe460f36e4a919a384cef6c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd548b14f1051e707393e77329f80c5e89f69919":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b7605579001505896d48b07160075a5c8b8e128e","6f26f74e4969851a019d28f10315cb1c77786f22"],"afd709fe548f0ddbaa0a678015e7c3d41ff1c87a":["8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b":["afd709fe548f0ddbaa0a678015e7c3d41ff1c87a"],"352e39466fda4bfc4523c74007409c1b693a3bba":["b0e3d12b100ee32c1c04e9f0eb435571d40a460a"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["6bdd460d2fe72f80e52acb2774d58a4ae2e67b9b"],"9e6c873b95174ff04c895232927baa76a95925eb":["cd548b14f1051e707393e77329f80c5e89f69919"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["352e39466fda4bfc4523c74007409c1b693a3bba"],"8497bb4f9de61b5520423bd9af88ea11a6e109e7":["e6225820ca5f401e2fe460f36e4a919a384cef6c"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","0c924d4069ef5a5bc479a493befe0121aada6896","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}