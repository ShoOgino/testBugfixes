{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      SegmentReader currentReader = merge.readers[i];\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (previousReader.isDeleted(j))\n              assert currentReader.isDeleted(j);\n            else {\n              if (currentReader.isDeleted(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentReader.isDeleted(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount >= 0;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      SegmentReader currentReader = merge.readers[i];\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (previousReader.isDeleted(j))\n              assert currentReader.isDeleted(j);\n            else {\n              if (currentReader.isDeleted(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentReader.isDeleted(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount >= 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"406e7055a3e99d3fa6ce49a555a51dd18b321806","date":1282520243,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount >= 0;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      SegmentReader currentReader = merge.readers[i];\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (previousReader.isDeleted(j))\n              assert currentReader.isDeleted(j);\n            else {\n              if (currentReader.isDeleted(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentReader.isDeleted(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount >= 0;\n  }\n\n","bugFix":["c4ff8864209d2e972cb4393600c26082f9a6533d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"284c57b0c650aa87cf871b9bb882e491521a0f30","date":1289658233,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount > 0;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount >= 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c498d3f8d75170b121f5eda2c6210ac5beb5d411","date":1289726298,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount > 0;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount >= 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44fcbde6fb2ac44ee3b45e013e54a42911e689ff","date":1292065621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergeReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      SegmentReader currentReader = merge.readers[i];\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (previousReader.isDeleted(j))\n              assert currentReader.isDeleted(j);\n            else {\n              if (currentReader.isDeleted(j)) {\n                mergeReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentReader.isDeleted(j)) {\n            mergeReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergeReader.numDeletedDocs() == delCount;\n\n    mergeReader.hasChanges = delCount >= 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c19f985e36a65cc969e8e564fe337a0d41512075","date":1296330536,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n  }\n\n","bugFix":null,"bugIntro":["119ae5b0966bbb5d6948c7f86207613595764d2e","119ae5b0966bbb5d6948c7f86207613595764d2e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","date":1297940445,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      int docCount = info.docCount;\n      SegmentReader previousReader = merge.readersClone[i];\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      SegmentReader currentReader = merge.readers[i];\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5270fb4f55a1b77663dda53cb8090c083f0a23b3","date":1305050821,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final SegmentInfos sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.info(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevLiveDocs = previousReader.getLiveDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentLiveDocs = currentReader.getLiveDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j))\n              assert !currentLiveDocs.get(j);\n            else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevLiveDocs = previousReader.getLiveDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentLiveDocs = currentReader.getLiveDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j))\n              assert !currentLiveDocs.get(j);\n            else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevLiveDocs = previousReader.getLiveDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentLiveDocs = currentReader.getLiveDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j))\n              assert !currentLiveDocs.get(j);\n            else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevDelDocs = previousReader.getDeletedDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentDelDocs = currentReader.getDeletedDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (prevDelDocs.get(j))\n              assert currentDelDocs.get(j);\n            else {\n              if (currentDelDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (currentDelDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0061262413ecc163d6eebba1b5c43ab91a0c2dc5","date":1311195279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      int docCount = info.docCount;\n      final SegmentReader previousReader = merge.readerClones.get(i);\n      if (previousReader == null) {\n        // Reader was skipped because it was 100% deletions\n        continue;\n      }\n      final Bits prevLiveDocs = previousReader.getLiveDocs();\n      final SegmentReader currentReader = merge.readers.get(i);\n      final Bits currentLiveDocs = currentReader.getLiveDocs();\n      if (previousReader.hasDeletions()) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentReader.numDeletedDocs() > previousReader.numDeletedDocs()) {\n          // This means this segment has had new deletes\n          // committed since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j))\n              assert !currentLiveDocs.get(j);\n            else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += docCount - previousReader.numDeletedDocs();\n        }\n      } else if (currentReader.hasDeletions()) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else\n        // No deletes before or after\n        docUpto += info.docCount;\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":["36d84416fc00253f9e834f8dba14fa89b298e64e","36d84416fc00253f9e834f8dba14fa89b298e64e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      message(\"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58c6bbc222f074c844e736e6fb23647e3db9cfe3","date":1322743940,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\"))\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream != null)\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5df35ab57c223ea11aec64b53bf611904f3dced","date":1323640545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\"))\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\"))\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781537683b56c6c5aad3b1046f00daf1c7ea93ae","date":1323968781,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.deleteDocument(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.deleteDocument(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.doDelete(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.doDelete(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.deleteDocument(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.deleteDocument(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":["36d84416fc00253f9e834f8dba14fa89b298e64e","36d84416fc00253f9e834f8dba14fa89b298e64e","119ae5b0966bbb5d6948c7f86207613595764d2e","119ae5b0966bbb5d6948c7f86207613595764d2e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["06584e6e98d592b34e1329b384182f368d2025e8"],"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["284c57b0c650aa87cf871b9bb882e491521a0f30"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["58c6bbc222f074c844e736e6fb23647e3db9cfe3","c5df35ab57c223ea11aec64b53bf611904f3dced"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"c19f985e36a65cc969e8e564fe337a0d41512075":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["c19f985e36a65cc969e8e564fe337a0d41512075"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","c19f985e36a65cc969e8e564fe337a0d41512075"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["f1bdbf92da222965b46c0a942c3857ba56e5c638","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["781537683b56c6c5aad3b1046f00daf1c7ea93ae"],"406e7055a3e99d3fa6ce49a555a51dd18b321806":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"781537683b56c6c5aad3b1046f00daf1c7ea93ae":["c5df35ab57c223ea11aec64b53bf611904f3dced"],"c498d3f8d75170b121f5eda2c6210ac5beb5d411":["406e7055a3e99d3fa6ce49a555a51dd18b321806","284c57b0c650aa87cf871b9bb882e491521a0f30"],"06584e6e98d592b34e1329b384182f368d2025e8":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["c498d3f8d75170b121f5eda2c6210ac5beb5d411","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["5270fb4f55a1b77663dda53cb8090c083f0a23b3","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a3776dccca01c11e7046323cfad46a3b4a471233","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"284c57b0c650aa87cf871b9bb882e491521a0f30":["406e7055a3e99d3fa6ce49a555a51dd18b321806"],"a3776dccca01c11e7046323cfad46a3b4a471233":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ce667c6d3400b22523701c549c0d35e26da8b46"]},"commit2Childs":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","781537683b56c6c5aad3b1046f00daf1c7ea93ae"],"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["c5df35ab57c223ea11aec64b53bf611904f3dced","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c19f985e36a65cc969e8e564fe337a0d41512075","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["06584e6e98d592b34e1329b384182f368d2025e8"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c19f985e36a65cc969e8e564fe337a0d41512075":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","29ef99d61cda9641b6250bf9567329a6e65f901d"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac","5270fb4f55a1b77663dda53cb8090c083f0a23b3","a3776dccca01c11e7046323cfad46a3b4a471233"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"9ce667c6d3400b22523701c549c0d35e26da8b46":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"406e7055a3e99d3fa6ce49a555a51dd18b321806":["c498d3f8d75170b121f5eda2c6210ac5beb5d411","284c57b0c650aa87cf871b9bb882e491521a0f30"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","406e7055a3e99d3fa6ce49a555a51dd18b321806"],"781537683b56c6c5aad3b1046f00daf1c7ea93ae":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"c498d3f8d75170b121f5eda2c6210ac5beb5d411":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"06584e6e98d592b34e1329b384182f368d2025e8":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","d083e83f225b11e5fdd900e83d26ddb385b6955c","a3776dccca01c11e7046323cfad46a3b4a471233"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"284c57b0c650aa87cf871b9bb882e491521a0f30":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff","c498d3f8d75170b121f5eda2c6210ac5beb5d411"],"a3776dccca01c11e7046323cfad46a3b4a471233":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","bde51b089eb7f86171eb3406e38a274743f9b7ac","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}