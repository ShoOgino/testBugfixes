{"path":"solr/core/src/java/org/apache/solr/search/facet/BlockJoin#toParents(DocSet,BitDocSet,QueryContext).mjava","commits":[{"id":"9e47fba8dd946896c408eb448f6199f5a9f0da2d","date":1434234768,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/BlockJoin#toParents(DocSet,BitDocSet,QueryContext).mjava","pathOld":"/dev/null","sourceNew":"  /** childInput may also contain parents (i.e. a parent or below will all roll up to that parent) */\n  public static DocSet toParents(DocSet childInput, BitDocSet parentList, QueryContext qcontext) throws IOException {\n    FixedBitSet parentBits = parentList.getBits();\n    DocSetCollector collector = new DocSetCollector(qcontext.searcher().maxDoc()>>6, qcontext.searcher().maxDoc());\n    DocIterator iter = childInput.iterator();\n    int currentParent = -1;\n    while (iter.hasNext()) {\n      int childDoc = iter.nextDoc(); // TODO: skipping\n      if (childDoc <= currentParent) { // use <= since we also allow parents in the input\n        // we already visited this parent\n        continue;\n      }\n      currentParent = parentBits.nextSetBit(childDoc);\n      if (currentParent != DocIdSetIterator.NO_MORE_DOCS) {\n        // only collect the parent the first time we skip to it\n        collector.collect( currentParent );\n      }\n    }\n    return collector.getDocSet();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0","date":1442027674,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/BlockJoin#toParents(DocSet,BitDocSet,QueryContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/BlockJoin#toParents(DocSet,BitDocSet,QueryContext).mjava","sourceNew":"  /** childInput may also contain parents (i.e. a parent or below will all roll up to that parent) */\n  public static DocSet toParents(DocSet childInput, BitDocSet parentList, QueryContext qcontext) throws IOException {\n    FixedBitSet parentBits = parentList.getBits();\n    DocSetCollector collector = new DocSetCollector(qcontext.searcher().maxDoc());\n    DocIterator iter = childInput.iterator();\n    int currentParent = -1;\n    while (iter.hasNext()) {\n      int childDoc = iter.nextDoc(); // TODO: skipping\n      if (childDoc <= currentParent) { // use <= since we also allow parents in the input\n        // we already visited this parent\n        continue;\n      }\n      currentParent = parentBits.nextSetBit(childDoc);\n      if (currentParent != DocIdSetIterator.NO_MORE_DOCS) {\n        // only collect the parent the first time we skip to it\n        collector.collect( currentParent );\n      }\n    }\n    return collector.getDocSet();\n  }\n\n","sourceOld":"  /** childInput may also contain parents (i.e. a parent or below will all roll up to that parent) */\n  public static DocSet toParents(DocSet childInput, BitDocSet parentList, QueryContext qcontext) throws IOException {\n    FixedBitSet parentBits = parentList.getBits();\n    DocSetCollector collector = new DocSetCollector(qcontext.searcher().maxDoc()>>6, qcontext.searcher().maxDoc());\n    DocIterator iter = childInput.iterator();\n    int currentParent = -1;\n    while (iter.hasNext()) {\n      int childDoc = iter.nextDoc(); // TODO: skipping\n      if (childDoc <= currentParent) { // use <= since we also allow parents in the input\n        // we already visited this parent\n        continue;\n      }\n      currentParent = parentBits.nextSetBit(childDoc);\n      if (currentParent != DocIdSetIterator.NO_MORE_DOCS) {\n        // only collect the parent the first time we skip to it\n        collector.collect( currentParent );\n      }\n    }\n    return collector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9e47fba8dd946896c408eb448f6199f5a9f0da2d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["9e47fba8dd946896c408eb448f6199f5a9f0da2d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"]},"commit2Childs":{"9e47fba8dd946896c408eb448f6199f5a9f0da2d":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9e47fba8dd946896c408eb448f6199f5a9f0da2d"],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}