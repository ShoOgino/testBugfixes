{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findArcDistancePoints(PlanetModel,double,GeoPoint,Membership...).mjava","commits":[{"id":"ebdd689e565874356dbd8933bc2924b11b4250d0","date":1461075600,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findArcDistancePoints(PlanetModel,double,GeoPoint,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Locate a point that is within the specified bounds and on the specified plane, that has an arcDistance as\n   * specified from the startPoint.\n   * @param planetModel is the planet model.\n   * @param arcDistanceValue is the arc distance.\n   * @param startPoint is the starting point.\n   * @param bounds are the bounds.\n   * @return zero, one, or two points.\n   */\n  public GeoPoint[] findArcDistancePoints(final PlanetModel planetModel, final double arcDistanceValue, final GeoPoint startPoint, final Membership... bounds) {\n    if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n      throw new IllegalStateException(\"Can't find arc distance using plane that doesn't go through origin\");\n    }\n    if (!evaluateIsZero(startPoint)) {\n      throw new IllegalArgumentException(\"Start point is not on plane\");\n    }\n    assert Math.abs(x*x + y*y + z*z - 1.0) < MINIMUM_RESOLUTION_SQUARED : \"Plane needs to be normalized\";\n    \n    // The first step is to rotate coordinates for the point so that the plane lies on the x-y plane.\n    // To acheive this, there will need to be three rotations:\n    // (1) rotate the plane in x-y so that the y axis lies in it.\n    // (2) rotate the plane in x-z so that the plane lies on the x-y plane.\n    // (3) rotate in x-y so that the starting vector points to (1,0,0).\n    \n    // This presumes a normalized plane!!\n    final double azimuthMagnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n    final double cosPlaneAltitude = this.z;\n    final double sinPlaneAltitude = azimuthMagnitude;\n    final double cosPlaneAzimuth = this.x / azimuthMagnitude;\n    final double sinPlaneAzimuth = this.y / azimuthMagnitude;\n    \n    assert Math.abs(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of altitude: \"+(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude);\n    assert Math.abs(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of azimuth: \"+(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth);\n\n    // Coordinate rotation formula:\n    // xT = xS cos T - yS sin T\n    // yT = xS sin T + yS cos T\n    // But we're rotating backwards, so use:\n    // sin (-T) = -sin (T)\n    // cos (-T) = cos (T)\n    \n    // Now, rotate startpoint in x-y\n    final double x0 = startPoint.x;\n    final double y0 = startPoint.y;\n    final double z0 = startPoint.z;\n    \n    final double x1 = x0 * cosPlaneAzimuth + y0 * sinPlaneAzimuth;\n    final double y1 = -x0 * sinPlaneAzimuth + y0 * cosPlaneAzimuth;\n    final double z1 = z0;\n    \n    // Rotate now in x-z\n    final double x2 = x1 * cosPlaneAltitude - z1 * sinPlaneAltitude;\n    final double y2 = y1;\n    final double z2 = +x1 * sinPlaneAltitude + z1 * cosPlaneAltitude;\n    \n    assert Math.abs(z2) < MINIMUM_RESOLUTION : \"Rotation should have put startpoint on x-y plane, instead has value \"+z2;\n    \n    // Ok, we have the start point on the x-y plane.  To apply the arc distance, we\n    // next need to convert to an angle (in radians).\n    final double startAngle = Math.atan2(y2, x2);\n    \n    // To apply the arc distance, just add to startAngle.\n    final double point1Angle = startAngle + arcDistanceValue;\n    final double point2Angle = startAngle - arcDistanceValue;\n    // Convert each point to x-y\n    final double point1x2 = Math.cos(point1Angle);\n    final double point1y2 = Math.sin(point1Angle);\n    final double point1z2 = 0.0;\n    \n    final double point2x2 = Math.cos(point2Angle);\n    final double point2y2 = Math.sin(point2Angle);\n    final double point2z2 = 0.0;\n    \n    // Now, do the reverse rotations for both points\n    // Altitude...\n    final double point1x1 = point1x2 * cosPlaneAltitude + point1z2 * sinPlaneAltitude;\n    final double point1y1 = point1y2;\n    final double point1z1 = -point1x2 * sinPlaneAltitude + point1z2 * cosPlaneAltitude;\n    \n    final double point2x1 = point2x2 * cosPlaneAltitude + point2z2 * sinPlaneAltitude;\n    final double point2y1 = point2y2;\n    final double point2z1 = -point2x2 * sinPlaneAltitude + point2z2 * cosPlaneAltitude;\n\n    // Azimuth...\n    final double point1x0 = point1x1 * cosPlaneAzimuth - point1y1 * sinPlaneAzimuth;\n    final double point1y0 = point1x1 * sinPlaneAzimuth + point1y1 * cosPlaneAzimuth;\n    final double point1z0 = point1z1;\n\n    final double point2x0 = point2x1 * cosPlaneAzimuth - point2y1 * sinPlaneAzimuth;\n    final double point2y0 = point2x1 * sinPlaneAzimuth + point2y1 * cosPlaneAzimuth;\n    final double point2z0 = point2z1;\n\n    final GeoPoint point1 = planetModel.createSurfacePoint(point1x0, point1y0, point1z0);\n    final GeoPoint point2 = planetModel.createSurfacePoint(point2x0, point2y0, point2z0);\n    \n    // Figure out what to return\n    boolean isPoint1Inside = meetsAllBounds(point1, bounds);\n    boolean isPoint2Inside = meetsAllBounds(point2, bounds);\n    \n    if (isPoint1Inside) {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point1, point2};\n      } else {\n        return new GeoPoint[]{point1};\n      }\n    } else {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point2};\n      } else {\n        return new GeoPoint[0];\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1352d7a69040022c85085c9bfdde0d394ee6eed9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1352d7a69040022c85085c9bfdde0d394ee6eed9","date":1503938073,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findArcDistancePoints(PlanetModel,double,GeoPoint,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findArcDistancePoints(PlanetModel,double,GeoPoint,Membership...).mjava","sourceNew":"  /**\n   * Locate a point that is within the specified bounds and on the specified plane, that has an arcDistance as\n   * specified from the startPoint.\n   * @param planetModel is the planet model.\n   * @param arcDistanceValue is the arc distance.\n   * @param startPoint is the starting point.\n   * @param bounds are the bounds.\n   * @return zero, one, or two points.\n   */\n  public GeoPoint[] findArcDistancePoints(final PlanetModel planetModel, final double arcDistanceValue, final GeoPoint startPoint, final Membership... bounds) {\n    if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n      throw new IllegalStateException(\"Can't find arc distance using plane that doesn't go through origin\");\n    }\n    if (!evaluateIsZero(startPoint)) {\n      throw new IllegalArgumentException(\"Start point is not on plane\");\n    }\n    \n    // The following assertion fails at times even for planes that were *explicitly* normalized, so I've disabled the check.\n    //assert Math.abs(x*x + y*y + z*z - 1.0) < MINIMUM_RESOLUTION_SQUARED : \"Plane needs to be normalized\";\n    \n    // The first step is to rotate coordinates for the point so that the plane lies on the x-y plane.\n    // To acheive this, there will need to be three rotations:\n    // (1) rotate the plane in x-y so that the y axis lies in it.\n    // (2) rotate the plane in x-z so that the plane lies on the x-y plane.\n    // (3) rotate in x-y so that the starting vector points to (1,0,0).\n    \n    // This presumes a normalized plane!!\n    final double azimuthMagnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n    final double cosPlaneAltitude = this.z;\n    final double sinPlaneAltitude = azimuthMagnitude;\n    final double cosPlaneAzimuth = this.x / azimuthMagnitude;\n    final double sinPlaneAzimuth = this.y / azimuthMagnitude;\n    \n    assert Math.abs(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of altitude: \"+(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude);\n    assert Math.abs(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of azimuth: \"+(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth);\n\n    // Coordinate rotation formula:\n    // xT = xS cos T - yS sin T\n    // yT = xS sin T + yS cos T\n    // But we're rotating backwards, so use:\n    // sin (-T) = -sin (T)\n    // cos (-T) = cos (T)\n    \n    // Now, rotate startpoint in x-y\n    final double x0 = startPoint.x;\n    final double y0 = startPoint.y;\n    final double z0 = startPoint.z;\n    \n    final double x1 = x0 * cosPlaneAzimuth + y0 * sinPlaneAzimuth;\n    final double y1 = -x0 * sinPlaneAzimuth + y0 * cosPlaneAzimuth;\n    final double z1 = z0;\n    \n    // Rotate now in x-z\n    final double x2 = x1 * cosPlaneAltitude - z1 * sinPlaneAltitude;\n    final double y2 = y1;\n    final double z2 = +x1 * sinPlaneAltitude + z1 * cosPlaneAltitude;\n    \n    assert Math.abs(z2) < MINIMUM_RESOLUTION : \"Rotation should have put startpoint on x-y plane, instead has value \"+z2;\n    \n    // Ok, we have the start point on the x-y plane.  To apply the arc distance, we\n    // next need to convert to an angle (in radians).\n    final double startAngle = Math.atan2(y2, x2);\n    \n    // To apply the arc distance, just add to startAngle.\n    final double point1Angle = startAngle + arcDistanceValue;\n    final double point2Angle = startAngle - arcDistanceValue;\n    // Convert each point to x-y\n    final double point1x2 = Math.cos(point1Angle);\n    final double point1y2 = Math.sin(point1Angle);\n    final double point1z2 = 0.0;\n    \n    final double point2x2 = Math.cos(point2Angle);\n    final double point2y2 = Math.sin(point2Angle);\n    final double point2z2 = 0.0;\n    \n    // Now, do the reverse rotations for both points\n    // Altitude...\n    final double point1x1 = point1x2 * cosPlaneAltitude + point1z2 * sinPlaneAltitude;\n    final double point1y1 = point1y2;\n    final double point1z1 = -point1x2 * sinPlaneAltitude + point1z2 * cosPlaneAltitude;\n    \n    final double point2x1 = point2x2 * cosPlaneAltitude + point2z2 * sinPlaneAltitude;\n    final double point2y1 = point2y2;\n    final double point2z1 = -point2x2 * sinPlaneAltitude + point2z2 * cosPlaneAltitude;\n\n    // Azimuth...\n    final double point1x0 = point1x1 * cosPlaneAzimuth - point1y1 * sinPlaneAzimuth;\n    final double point1y0 = point1x1 * sinPlaneAzimuth + point1y1 * cosPlaneAzimuth;\n    final double point1z0 = point1z1;\n\n    final double point2x0 = point2x1 * cosPlaneAzimuth - point2y1 * sinPlaneAzimuth;\n    final double point2y0 = point2x1 * sinPlaneAzimuth + point2y1 * cosPlaneAzimuth;\n    final double point2z0 = point2z1;\n\n    final GeoPoint point1 = planetModel.createSurfacePoint(point1x0, point1y0, point1z0);\n    final GeoPoint point2 = planetModel.createSurfacePoint(point2x0, point2y0, point2z0);\n    \n    // Figure out what to return\n    boolean isPoint1Inside = meetsAllBounds(point1, bounds);\n    boolean isPoint2Inside = meetsAllBounds(point2, bounds);\n    \n    if (isPoint1Inside) {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point1, point2};\n      } else {\n        return new GeoPoint[]{point1};\n      }\n    } else {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point2};\n      } else {\n        return new GeoPoint[0];\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Locate a point that is within the specified bounds and on the specified plane, that has an arcDistance as\n   * specified from the startPoint.\n   * @param planetModel is the planet model.\n   * @param arcDistanceValue is the arc distance.\n   * @param startPoint is the starting point.\n   * @param bounds are the bounds.\n   * @return zero, one, or two points.\n   */\n  public GeoPoint[] findArcDistancePoints(final PlanetModel planetModel, final double arcDistanceValue, final GeoPoint startPoint, final Membership... bounds) {\n    if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n      throw new IllegalStateException(\"Can't find arc distance using plane that doesn't go through origin\");\n    }\n    if (!evaluateIsZero(startPoint)) {\n      throw new IllegalArgumentException(\"Start point is not on plane\");\n    }\n    assert Math.abs(x*x + y*y + z*z - 1.0) < MINIMUM_RESOLUTION_SQUARED : \"Plane needs to be normalized\";\n    \n    // The first step is to rotate coordinates for the point so that the plane lies on the x-y plane.\n    // To acheive this, there will need to be three rotations:\n    // (1) rotate the plane in x-y so that the y axis lies in it.\n    // (2) rotate the plane in x-z so that the plane lies on the x-y plane.\n    // (3) rotate in x-y so that the starting vector points to (1,0,0).\n    \n    // This presumes a normalized plane!!\n    final double azimuthMagnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n    final double cosPlaneAltitude = this.z;\n    final double sinPlaneAltitude = azimuthMagnitude;\n    final double cosPlaneAzimuth = this.x / azimuthMagnitude;\n    final double sinPlaneAzimuth = this.y / azimuthMagnitude;\n    \n    assert Math.abs(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of altitude: \"+(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude);\n    assert Math.abs(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of azimuth: \"+(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth);\n\n    // Coordinate rotation formula:\n    // xT = xS cos T - yS sin T\n    // yT = xS sin T + yS cos T\n    // But we're rotating backwards, so use:\n    // sin (-T) = -sin (T)\n    // cos (-T) = cos (T)\n    \n    // Now, rotate startpoint in x-y\n    final double x0 = startPoint.x;\n    final double y0 = startPoint.y;\n    final double z0 = startPoint.z;\n    \n    final double x1 = x0 * cosPlaneAzimuth + y0 * sinPlaneAzimuth;\n    final double y1 = -x0 * sinPlaneAzimuth + y0 * cosPlaneAzimuth;\n    final double z1 = z0;\n    \n    // Rotate now in x-z\n    final double x2 = x1 * cosPlaneAltitude - z1 * sinPlaneAltitude;\n    final double y2 = y1;\n    final double z2 = +x1 * sinPlaneAltitude + z1 * cosPlaneAltitude;\n    \n    assert Math.abs(z2) < MINIMUM_RESOLUTION : \"Rotation should have put startpoint on x-y plane, instead has value \"+z2;\n    \n    // Ok, we have the start point on the x-y plane.  To apply the arc distance, we\n    // next need to convert to an angle (in radians).\n    final double startAngle = Math.atan2(y2, x2);\n    \n    // To apply the arc distance, just add to startAngle.\n    final double point1Angle = startAngle + arcDistanceValue;\n    final double point2Angle = startAngle - arcDistanceValue;\n    // Convert each point to x-y\n    final double point1x2 = Math.cos(point1Angle);\n    final double point1y2 = Math.sin(point1Angle);\n    final double point1z2 = 0.0;\n    \n    final double point2x2 = Math.cos(point2Angle);\n    final double point2y2 = Math.sin(point2Angle);\n    final double point2z2 = 0.0;\n    \n    // Now, do the reverse rotations for both points\n    // Altitude...\n    final double point1x1 = point1x2 * cosPlaneAltitude + point1z2 * sinPlaneAltitude;\n    final double point1y1 = point1y2;\n    final double point1z1 = -point1x2 * sinPlaneAltitude + point1z2 * cosPlaneAltitude;\n    \n    final double point2x1 = point2x2 * cosPlaneAltitude + point2z2 * sinPlaneAltitude;\n    final double point2y1 = point2y2;\n    final double point2z1 = -point2x2 * sinPlaneAltitude + point2z2 * cosPlaneAltitude;\n\n    // Azimuth...\n    final double point1x0 = point1x1 * cosPlaneAzimuth - point1y1 * sinPlaneAzimuth;\n    final double point1y0 = point1x1 * sinPlaneAzimuth + point1y1 * cosPlaneAzimuth;\n    final double point1z0 = point1z1;\n\n    final double point2x0 = point2x1 * cosPlaneAzimuth - point2y1 * sinPlaneAzimuth;\n    final double point2y0 = point2x1 * sinPlaneAzimuth + point2y1 * cosPlaneAzimuth;\n    final double point2z0 = point2z1;\n\n    final GeoPoint point1 = planetModel.createSurfacePoint(point1x0, point1y0, point1z0);\n    final GeoPoint point2 = planetModel.createSurfacePoint(point2x0, point2y0, point2z0);\n    \n    // Figure out what to return\n    boolean isPoint1Inside = meetsAllBounds(point1, bounds);\n    boolean isPoint2Inside = meetsAllBounds(point2, bounds);\n    \n    if (isPoint1Inside) {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point1, point2};\n      } else {\n        return new GeoPoint[]{point1};\n      }\n    } else {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point2};\n      } else {\n        return new GeoPoint[0];\n      }\n    }\n  }\n\n","bugFix":["ebdd689e565874356dbd8933bc2924b11b4250d0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findArcDistancePoints(PlanetModel,double,GeoPoint,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#findArcDistancePoints(PlanetModel,double,GeoPoint,Membership...).mjava","sourceNew":"  /**\n   * Locate a point that is within the specified bounds and on the specified plane, that has an arcDistance as\n   * specified from the startPoint.\n   * @param planetModel is the planet model.\n   * @param arcDistanceValue is the arc distance.\n   * @param startPoint is the starting point.\n   * @param bounds are the bounds.\n   * @return zero, one, or two points.\n   */\n  public GeoPoint[] findArcDistancePoints(final PlanetModel planetModel, final double arcDistanceValue, final GeoPoint startPoint, final Membership... bounds) {\n    if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n      throw new IllegalStateException(\"Can't find arc distance using plane that doesn't go through origin\");\n    }\n    if (!evaluateIsZero(startPoint)) {\n      throw new IllegalArgumentException(\"Start point is not on plane\");\n    }\n    \n    // The following assertion fails at times even for planes that were *explicitly* normalized, so I've disabled the check.\n    //assert Math.abs(x*x + y*y + z*z - 1.0) < MINIMUM_RESOLUTION_SQUARED : \"Plane needs to be normalized\";\n    \n    // The first step is to rotate coordinates for the point so that the plane lies on the x-y plane.\n    // To acheive this, there will need to be three rotations:\n    // (1) rotate the plane in x-y so that the y axis lies in it.\n    // (2) rotate the plane in x-z so that the plane lies on the x-y plane.\n    // (3) rotate in x-y so that the starting vector points to (1,0,0).\n    \n    // This presumes a normalized plane!!\n    final double azimuthMagnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n    final double cosPlaneAltitude = this.z;\n    final double sinPlaneAltitude = azimuthMagnitude;\n    final double cosPlaneAzimuth = this.x / azimuthMagnitude;\n    final double sinPlaneAzimuth = this.y / azimuthMagnitude;\n    \n    assert Math.abs(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of altitude: \"+(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude);\n    assert Math.abs(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of azimuth: \"+(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth);\n\n    // Coordinate rotation formula:\n    // xT = xS cos T - yS sin T\n    // yT = xS sin T + yS cos T\n    // But we're rotating backwards, so use:\n    // sin (-T) = -sin (T)\n    // cos (-T) = cos (T)\n    \n    // Now, rotate startpoint in x-y\n    final double x0 = startPoint.x;\n    final double y0 = startPoint.y;\n    final double z0 = startPoint.z;\n    \n    final double x1 = x0 * cosPlaneAzimuth + y0 * sinPlaneAzimuth;\n    final double y1 = -x0 * sinPlaneAzimuth + y0 * cosPlaneAzimuth;\n    final double z1 = z0;\n    \n    // Rotate now in x-z\n    final double x2 = x1 * cosPlaneAltitude - z1 * sinPlaneAltitude;\n    final double y2 = y1;\n    final double z2 = +x1 * sinPlaneAltitude + z1 * cosPlaneAltitude;\n    \n    assert Math.abs(z2) < MINIMUM_RESOLUTION : \"Rotation should have put startpoint on x-y plane, instead has value \"+z2;\n    \n    // Ok, we have the start point on the x-y plane.  To apply the arc distance, we\n    // next need to convert to an angle (in radians).\n    final double startAngle = Math.atan2(y2, x2);\n    \n    // To apply the arc distance, just add to startAngle.\n    final double point1Angle = startAngle + arcDistanceValue;\n    final double point2Angle = startAngle - arcDistanceValue;\n    // Convert each point to x-y\n    final double point1x2 = Math.cos(point1Angle);\n    final double point1y2 = Math.sin(point1Angle);\n    final double point1z2 = 0.0;\n    \n    final double point2x2 = Math.cos(point2Angle);\n    final double point2y2 = Math.sin(point2Angle);\n    final double point2z2 = 0.0;\n    \n    // Now, do the reverse rotations for both points\n    // Altitude...\n    final double point1x1 = point1x2 * cosPlaneAltitude + point1z2 * sinPlaneAltitude;\n    final double point1y1 = point1y2;\n    final double point1z1 = -point1x2 * sinPlaneAltitude + point1z2 * cosPlaneAltitude;\n    \n    final double point2x1 = point2x2 * cosPlaneAltitude + point2z2 * sinPlaneAltitude;\n    final double point2y1 = point2y2;\n    final double point2z1 = -point2x2 * sinPlaneAltitude + point2z2 * cosPlaneAltitude;\n\n    // Azimuth...\n    final double point1x0 = point1x1 * cosPlaneAzimuth - point1y1 * sinPlaneAzimuth;\n    final double point1y0 = point1x1 * sinPlaneAzimuth + point1y1 * cosPlaneAzimuth;\n    final double point1z0 = point1z1;\n\n    final double point2x0 = point2x1 * cosPlaneAzimuth - point2y1 * sinPlaneAzimuth;\n    final double point2y0 = point2x1 * sinPlaneAzimuth + point2y1 * cosPlaneAzimuth;\n    final double point2z0 = point2z1;\n\n    final GeoPoint point1 = planetModel.createSurfacePoint(point1x0, point1y0, point1z0);\n    final GeoPoint point2 = planetModel.createSurfacePoint(point2x0, point2y0, point2z0);\n    \n    // Figure out what to return\n    boolean isPoint1Inside = meetsAllBounds(point1, bounds);\n    boolean isPoint2Inside = meetsAllBounds(point2, bounds);\n    \n    if (isPoint1Inside) {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point1, point2};\n      } else {\n        return new GeoPoint[]{point1};\n      }\n    } else {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point2};\n      } else {\n        return new GeoPoint[0];\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Locate a point that is within the specified bounds and on the specified plane, that has an arcDistance as\n   * specified from the startPoint.\n   * @param planetModel is the planet model.\n   * @param arcDistanceValue is the arc distance.\n   * @param startPoint is the starting point.\n   * @param bounds are the bounds.\n   * @return zero, one, or two points.\n   */\n  public GeoPoint[] findArcDistancePoints(final PlanetModel planetModel, final double arcDistanceValue, final GeoPoint startPoint, final Membership... bounds) {\n    if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n      throw new IllegalStateException(\"Can't find arc distance using plane that doesn't go through origin\");\n    }\n    if (!evaluateIsZero(startPoint)) {\n      throw new IllegalArgumentException(\"Start point is not on plane\");\n    }\n    assert Math.abs(x*x + y*y + z*z - 1.0) < MINIMUM_RESOLUTION_SQUARED : \"Plane needs to be normalized\";\n    \n    // The first step is to rotate coordinates for the point so that the plane lies on the x-y plane.\n    // To acheive this, there will need to be three rotations:\n    // (1) rotate the plane in x-y so that the y axis lies in it.\n    // (2) rotate the plane in x-z so that the plane lies on the x-y plane.\n    // (3) rotate in x-y so that the starting vector points to (1,0,0).\n    \n    // This presumes a normalized plane!!\n    final double azimuthMagnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n    final double cosPlaneAltitude = this.z;\n    final double sinPlaneAltitude = azimuthMagnitude;\n    final double cosPlaneAzimuth = this.x / azimuthMagnitude;\n    final double sinPlaneAzimuth = this.y / azimuthMagnitude;\n    \n    assert Math.abs(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of altitude: \"+(sinPlaneAltitude * sinPlaneAltitude + cosPlaneAltitude * cosPlaneAltitude);\n    assert Math.abs(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth - 1.0) < MINIMUM_RESOLUTION : \"Improper sin/cos of azimuth: \"+(sinPlaneAzimuth * sinPlaneAzimuth + cosPlaneAzimuth * cosPlaneAzimuth);\n\n    // Coordinate rotation formula:\n    // xT = xS cos T - yS sin T\n    // yT = xS sin T + yS cos T\n    // But we're rotating backwards, so use:\n    // sin (-T) = -sin (T)\n    // cos (-T) = cos (T)\n    \n    // Now, rotate startpoint in x-y\n    final double x0 = startPoint.x;\n    final double y0 = startPoint.y;\n    final double z0 = startPoint.z;\n    \n    final double x1 = x0 * cosPlaneAzimuth + y0 * sinPlaneAzimuth;\n    final double y1 = -x0 * sinPlaneAzimuth + y0 * cosPlaneAzimuth;\n    final double z1 = z0;\n    \n    // Rotate now in x-z\n    final double x2 = x1 * cosPlaneAltitude - z1 * sinPlaneAltitude;\n    final double y2 = y1;\n    final double z2 = +x1 * sinPlaneAltitude + z1 * cosPlaneAltitude;\n    \n    assert Math.abs(z2) < MINIMUM_RESOLUTION : \"Rotation should have put startpoint on x-y plane, instead has value \"+z2;\n    \n    // Ok, we have the start point on the x-y plane.  To apply the arc distance, we\n    // next need to convert to an angle (in radians).\n    final double startAngle = Math.atan2(y2, x2);\n    \n    // To apply the arc distance, just add to startAngle.\n    final double point1Angle = startAngle + arcDistanceValue;\n    final double point2Angle = startAngle - arcDistanceValue;\n    // Convert each point to x-y\n    final double point1x2 = Math.cos(point1Angle);\n    final double point1y2 = Math.sin(point1Angle);\n    final double point1z2 = 0.0;\n    \n    final double point2x2 = Math.cos(point2Angle);\n    final double point2y2 = Math.sin(point2Angle);\n    final double point2z2 = 0.0;\n    \n    // Now, do the reverse rotations for both points\n    // Altitude...\n    final double point1x1 = point1x2 * cosPlaneAltitude + point1z2 * sinPlaneAltitude;\n    final double point1y1 = point1y2;\n    final double point1z1 = -point1x2 * sinPlaneAltitude + point1z2 * cosPlaneAltitude;\n    \n    final double point2x1 = point2x2 * cosPlaneAltitude + point2z2 * sinPlaneAltitude;\n    final double point2y1 = point2y2;\n    final double point2z1 = -point2x2 * sinPlaneAltitude + point2z2 * cosPlaneAltitude;\n\n    // Azimuth...\n    final double point1x0 = point1x1 * cosPlaneAzimuth - point1y1 * sinPlaneAzimuth;\n    final double point1y0 = point1x1 * sinPlaneAzimuth + point1y1 * cosPlaneAzimuth;\n    final double point1z0 = point1z1;\n\n    final double point2x0 = point2x1 * cosPlaneAzimuth - point2y1 * sinPlaneAzimuth;\n    final double point2y0 = point2x1 * sinPlaneAzimuth + point2y1 * cosPlaneAzimuth;\n    final double point2z0 = point2z1;\n\n    final GeoPoint point1 = planetModel.createSurfacePoint(point1x0, point1y0, point1z0);\n    final GeoPoint point2 = planetModel.createSurfacePoint(point2x0, point2y0, point2z0);\n    \n    // Figure out what to return\n    boolean isPoint1Inside = meetsAllBounds(point1, bounds);\n    boolean isPoint2Inside = meetsAllBounds(point2, bounds);\n    \n    if (isPoint1Inside) {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point1, point2};\n      } else {\n        return new GeoPoint[]{point1};\n      }\n    } else {\n      if (isPoint2Inside) {\n        return new GeoPoint[]{point2};\n      } else {\n        return new GeoPoint[0];\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ebdd689e565874356dbd8933bc2924b11b4250d0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["ebdd689e565874356dbd8933bc2924b11b4250d0","1352d7a69040022c85085c9bfdde0d394ee6eed9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1352d7a69040022c85085c9bfdde0d394ee6eed9":["ebdd689e565874356dbd8933bc2924b11b4250d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1352d7a69040022c85085c9bfdde0d394ee6eed9"]},"commit2Childs":{"ebdd689e565874356dbd8933bc2924b11b4250d0":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","1352d7a69040022c85085c9bfdde0d394ee6eed9"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ebdd689e565874356dbd8933bc2924b11b4250d0"],"1352d7a69040022c85085c9bfdde0d394ee6eed9":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}