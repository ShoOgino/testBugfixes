{"path":"backwards/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"/dev/null","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      boolean debug = false;\n\n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (debug)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (debug)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (debug)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (debug)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (debug)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"backwards/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      boolean debug = false;\n\n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (debug)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (debug)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (debug)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (debug)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (debug)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      boolean debug = false;\n\n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (debug)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (debug)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (debug)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (debug)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (debug)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}