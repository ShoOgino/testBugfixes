{"path":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    autowarm = new AutoWarmCountRef((String)args.get(\"autowarmCount\"));\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarm.isAutoWarmingOn()) {\n      description += \", autowarmCount=\" + autowarm + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    autowarm = new AutoWarmCountRef((String)args.get(\"autowarmCount\"));\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarm.isAutoWarmingOn()) {\n      description += \", autowarmCount=\" + autowarm + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    autowarm = new AutoWarmCountRef((String)args.get(\"autowarmCount\"));\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarm.isAutoWarmingOn()) {\n      description += \", autowarmCount=\" + autowarm + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    autowarm = new AutoWarmCountRef((String)args.get(\"autowarmCount\"));\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarm.isAutoWarmingOn()) {\n      description += \", autowarmCount=\" + autowarm + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    autowarm = new AutoWarmCountRef((String)args.get(\"autowarmCount\"));\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarm.isAutoWarmingOn()) {\n      description += \", autowarmCount=\" + autowarm + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    autowarm = new AutoWarmCountRef((String)args.get(\"autowarmCount\"));\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarm.isAutoWarmingOn()) {\n      description += \", autowarmCount=\" + autowarm + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63131741120598595ba46620adaf3fad049ca291","date":1335567423,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    autowarm = new AutoWarmCountRef((String)args.get(\"autowarmCount\"));\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarm.isAutoWarmingOn()) {\n      description += \", autowarmCount=\" + autowarm + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c5044c9bb1518e7a13c1c5385a21325ae343056","date":1479187798,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      int ramLowerWatermark = (int) (maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      int ramLowerWatermark = (int) (maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n    description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n    cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dc809283a68a1108c6c8f7adc03ceec7a1475ad5","date":1484044538,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit <= 0) minLimit = 1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      int ramLowerWatermark = (int) (maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      int ramLowerWatermark = (int) (maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":["516bcb3c0d409157f56056e1ecd5e5361ca4ae0b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit <= 0) minLimit = 1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      int ramLowerWatermark = (int) (maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      int ramLowerWatermark = (int) (maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a71ca10e7131e1f01868c80d228f26a855e79dd0","date":1562166223,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit <= 0) minLimit = 1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      long ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit <= 0) minLimit = 1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      int ramLowerWatermark = (int) (maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce13e934d6cfdcc82d51e85de460cf9790e97566","date":1563877281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    sizeLimit = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (sizeLimit * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (sizeLimit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? sizeLimit : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null);\n    } else  {\n      ramLowerWatermark = -1L;\n      description = generateDescription(sizeLimit, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(sizeLimit, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit <= 0) minLimit = 1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(\"maxRamMB\");\n    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      long ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, newThread);\n      cache = new ConcurrentLRUCache<K, V>(ramLowerWatermark, maxRamBytes, newThread, null);\n    } else  {\n      description = generateDescription(limit, initialSize, minLimit, acceptableLimit, newThread);\n      cache = new ConcurrentLRUCache<>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e33a2e75ecee8b06fba2bd570c0fb9273962bc7","date":1565791119,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null);\n    } else  {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    sizeLimit = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (sizeLimit * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (sizeLimit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? sizeLimit : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null);\n    } else  {\n      ramLowerWatermark = -1L;\n      description = generateDescription(sizeLimit, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(sizeLimit, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a117d95183986014a31f25bb04e5464ca06d6068","date":1566208086,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null);\n    } else  {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c","date":1566455239,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83","date":1568645407,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df72a23fb74bebe914e3f3972063a884327c0436","date":1570470832,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    cacheMap = new MetricsMap((detailed, map) -> {\n      if (cache != null) {\n        ConcurrentLRUCache.Stats stats = cache.getStats();\n        long lookups = stats.getCumulativeLookups();\n        long hits = stats.getCumulativeHits();\n        long inserts = stats.getCumulativePuts();\n        long evictions = stats.getCumulativeEvictions();\n        long idleEvictions = stats.getCumulativeIdleEvictions();\n        long size = stats.getCurrentSize();\n        long clookups = 0;\n        long chits = 0;\n        long cinserts = 0;\n        long cevictions = 0;\n        long cIdleEvictions = 0;\n\n        // NOTE: It is safe to iterate on a CopyOnWriteArrayList\n        for (ConcurrentLRUCache.Stats statistiscs : statsList) {\n          clookups += statistiscs.getCumulativeLookups();\n          chits += statistiscs.getCumulativeHits();\n          cinserts += statistiscs.getCumulativePuts();\n          cevictions += statistiscs.getCumulativeEvictions();\n          cIdleEvictions += statistiscs.getCumulativeIdleEvictions();\n        }\n\n        map.put(LOOKUPS_PARAM, lookups);\n        map.put(HITS_PARAM, hits);\n        map.put(HIT_RATIO_PARAM, calcHitRatio(lookups, hits));\n        map.put(INSERTS_PARAM, inserts);\n        map.put(EVICTIONS_PARAM, evictions);\n        map.put(SIZE_PARAM, size);\n        map.put(\"cleanupThread\", cleanupThread);\n        map.put(\"idleEvictions\", idleEvictions);\n        map.put(RAM_BYTES_USED_PARAM, ramBytesUsed());\n        map.put(MAX_RAM_MB_PARAM, getMaxRamMB());\n\n        map.put(\"warmupTime\", warmupTime);\n        map.put(\"cumulative_lookups\", clookups);\n        map.put(\"cumulative_hits\", chits);\n        map.put(\"cumulative_hitratio\", calcHitRatio(clookups, chits));\n        map.put(\"cumulative_inserts\", cinserts);\n        map.put(\"cumulative_evictions\", cevictions);\n        map.put(\"cumulative_idleEvictions\", cIdleEvictions);\n\n        if (detailed && showItems != 0) {\n          Map items = cache.getLatestAccessedItems(showItems == -1 ? Integer.MAX_VALUE : showItems);\n          for (Map.Entry e : (Set<Map.Entry>) items.entrySet()) {\n            Object k = e.getKey();\n            Object v = e.getValue();\n\n            String ks = \"item_\" + k;\n            String vs = v.toString();\n            map.put(ks, vs);\n          }\n\n        }\n      }\n    });\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    cacheMap = new MetricsMap((detailed, map) -> {\n      if (cache != null) {\n        ConcurrentLRUCache.Stats stats = cache.getStats();\n        long lookups = stats.getCumulativeLookups();\n        long hits = stats.getCumulativeHits();\n        long inserts = stats.getCumulativePuts();\n        long evictions = stats.getCumulativeEvictions();\n        long idleEvictions = stats.getCumulativeIdleEvictions();\n        long size = stats.getCurrentSize();\n        long clookups = 0;\n        long chits = 0;\n        long cinserts = 0;\n        long cevictions = 0;\n        long cIdleEvictions = 0;\n\n        // NOTE: It is safe to iterate on a CopyOnWriteArrayList\n        for (ConcurrentLRUCache.Stats statistiscs : statsList) {\n          clookups += statistiscs.getCumulativeLookups();\n          chits += statistiscs.getCumulativeHits();\n          cinserts += statistiscs.getCumulativePuts();\n          cevictions += statistiscs.getCumulativeEvictions();\n          cIdleEvictions += statistiscs.getCumulativeIdleEvictions();\n        }\n\n        map.put(LOOKUPS_PARAM, lookups);\n        map.put(HITS_PARAM, hits);\n        map.put(HIT_RATIO_PARAM, calcHitRatio(lookups, hits));\n        map.put(INSERTS_PARAM, inserts);\n        map.put(EVICTIONS_PARAM, evictions);\n        map.put(SIZE_PARAM, size);\n        map.put(\"cleanupThread\", cleanupThread);\n        map.put(\"idleEvictions\", idleEvictions);\n        map.put(RAM_BYTES_USED_PARAM, ramBytesUsed());\n        map.put(MAX_RAM_MB_PARAM, getMaxRamMB());\n\n        map.put(\"warmupTime\", warmupTime);\n        map.put(\"cumulative_lookups\", clookups);\n        map.put(\"cumulative_hits\", chits);\n        map.put(\"cumulative_hitratio\", calcHitRatio(clookups, chits));\n        map.put(\"cumulative_inserts\", cinserts);\n        map.put(\"cumulative_evictions\", cevictions);\n        map.put(\"cumulative_idleEvictions\", cIdleEvictions);\n\n        if (detailed && showItems != 0) {\n          Map items = cache.getLatestAccessedItems(showItems == -1 ? Integer.MAX_VALUE : showItems);\n          for (Map.Entry e : (Set<Map.Entry>) items.entrySet()) {\n            Object k = e.getKey();\n            Object v = e.getValue();\n\n            String ks = \"item_\" + k;\n            String vs = v.toString();\n            map.put(ks, vs);\n          }\n\n        }\n      }\n    });\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","date":1571411704,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    cacheMap = new MetricsMap((detailed, map) -> {\n      if (cache != null) {\n        ConcurrentLRUCache.Stats stats = cache.getStats();\n        long lookups = stats.getCumulativeLookups();\n        long hits = stats.getCumulativeHits();\n        long inserts = stats.getCumulativePuts();\n        long evictions = stats.getCumulativeEvictions();\n        long idleEvictions = stats.getCumulativeIdleEvictions();\n        long size = stats.getCurrentSize();\n        long clookups = 0;\n        long chits = 0;\n        long cinserts = 0;\n        long cevictions = 0;\n        long cIdleEvictions = 0;\n\n        // NOTE: It is safe to iterate on a CopyOnWriteArrayList\n        for (ConcurrentLRUCache.Stats statistiscs : statsList) {\n          clookups += statistiscs.getCumulativeLookups();\n          chits += statistiscs.getCumulativeHits();\n          cinserts += statistiscs.getCumulativePuts();\n          cevictions += statistiscs.getCumulativeEvictions();\n          cIdleEvictions += statistiscs.getCumulativeIdleEvictions();\n        }\n\n        map.put(LOOKUPS_PARAM, lookups);\n        map.put(HITS_PARAM, hits);\n        map.put(HIT_RATIO_PARAM, calcHitRatio(lookups, hits));\n        map.put(INSERTS_PARAM, inserts);\n        map.put(EVICTIONS_PARAM, evictions);\n        map.put(SIZE_PARAM, size);\n        map.put(\"cleanupThread\", cleanupThread);\n        map.put(\"idleEvictions\", idleEvictions);\n        map.put(RAM_BYTES_USED_PARAM, ramBytesUsed());\n        map.put(MAX_RAM_MB_PARAM, getMaxRamMB());\n\n        map.put(\"warmupTime\", warmupTime);\n        map.put(\"cumulative_lookups\", clookups);\n        map.put(\"cumulative_hits\", chits);\n        map.put(\"cumulative_hitratio\", calcHitRatio(clookups, chits));\n        map.put(\"cumulative_inserts\", cinserts);\n        map.put(\"cumulative_evictions\", cevictions);\n        map.put(\"cumulative_idleEvictions\", cIdleEvictions);\n\n        if (detailed && showItems != 0) {\n          Map items = cache.getLatestAccessedItems(showItems == -1 ? Integer.MAX_VALUE : showItems);\n          for (Map.Entry e : (Set<Map.Entry>) items.entrySet()) {\n            Object k = e.getKey();\n            Object v = e.getValue();\n\n            String ks = \"item_\" + k;\n            String vs = v.toString();\n            map.put(ks, vs);\n          }\n\n        }\n      }\n    });\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE)  {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    cacheMap = new MetricsMap((detailed, map) -> {\n      if (cache != null) {\n        ConcurrentLRUCache.Stats stats = cache.getStats();\n        long lookups = stats.getCumulativeLookups();\n        long hits = stats.getCumulativeHits();\n        long inserts = stats.getCumulativePuts();\n        long evictions = stats.getCumulativeEvictions();\n        long idleEvictions = stats.getCumulativeIdleEvictions();\n        long size = stats.getCurrentSize();\n        long clookups = 0;\n        long chits = 0;\n        long cinserts = 0;\n        long cevictions = 0;\n        long cIdleEvictions = 0;\n\n        // NOTE: It is safe to iterate on a CopyOnWriteArrayList\n        for (ConcurrentLRUCache.Stats statistiscs : statsList) {\n          clookups += statistiscs.getCumulativeLookups();\n          chits += statistiscs.getCumulativeHits();\n          cinserts += statistiscs.getCumulativePuts();\n          cevictions += statistiscs.getCumulativeEvictions();\n          cIdleEvictions += statistiscs.getCumulativeIdleEvictions();\n        }\n\n        map.put(LOOKUPS_PARAM, lookups);\n        map.put(HITS_PARAM, hits);\n        map.put(HIT_RATIO_PARAM, calcHitRatio(lookups, hits));\n        map.put(INSERTS_PARAM, inserts);\n        map.put(EVICTIONS_PARAM, evictions);\n        map.put(SIZE_PARAM, size);\n        map.put(\"cleanupThread\", cleanupThread);\n        map.put(\"idleEvictions\", idleEvictions);\n        map.put(RAM_BYTES_USED_PARAM, ramBytesUsed());\n        map.put(MAX_RAM_MB_PARAM, getMaxRamMB());\n\n        map.put(\"warmupTime\", warmupTime);\n        map.put(\"cumulative_lookups\", clookups);\n        map.put(\"cumulative_hits\", chits);\n        map.put(\"cumulative_hitratio\", calcHitRatio(clookups, chits));\n        map.put(\"cumulative_inserts\", cinserts);\n        map.put(\"cumulative_evictions\", cevictions);\n        map.put(\"cumulative_idleEvictions\", cIdleEvictions);\n\n        if (detailed && showItems != 0) {\n          Map items = cache.getLatestAccessedItems(showItems == -1 ? Integer.MAX_VALUE : showItems);\n          for (Map.Entry e : (Set<Map.Entry>) items.entrySet()) {\n            Object k = e.getKey();\n            Object v = e.getValue();\n\n            String ks = \"item_\" + k;\n            String vs = v.toString();\n            map.put(ks, vs);\n          }\n\n        }\n      }\n    });\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d7d3943904804560937e6239effeebda0f920e4","date":1573762904,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    super.init(args, regenerator);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n\n    str = (String) args.get(MAX_RAM_MB_PARAM);\n    long maxRamMB = str == null ? -1 : (long) Double.parseDouble(str);\n    this.maxRamBytes = maxRamMB < 0 ? Long.MAX_VALUE : maxRamMB * 1024L * 1024L;\n    if (maxRamBytes != Long.MAX_VALUE) {\n      ramLowerWatermark = Math.round(maxRamBytes * 0.8);\n      description = generateDescription(maxRamBytes, ramLowerWatermark, cleanupThread);\n      cache = new ConcurrentLRUCache<>(ramLowerWatermark, maxRamBytes, cleanupThread, null, maxIdleTimeSec);\n    } else {\n      ramLowerWatermark = -1L;\n      description = generateDescription(maxSize, initialSize, minSizeLimit, acceptableSize, cleanupThread);\n      cache = new ConcurrentLRUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, maxIdleTimeSec);\n    }\n\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    cacheMap = new MetricsMap((detailed, map) -> {\n      if (cache != null) {\n        ConcurrentLRUCache.Stats stats = cache.getStats();\n        long lookups = stats.getCumulativeLookups();\n        long hits = stats.getCumulativeHits();\n        long inserts = stats.getCumulativePuts();\n        long evictions = stats.getCumulativeEvictions();\n        long idleEvictions = stats.getCumulativeIdleEvictions();\n        long size = stats.getCurrentSize();\n        long clookups = 0;\n        long chits = 0;\n        long cinserts = 0;\n        long cevictions = 0;\n        long cIdleEvictions = 0;\n\n        // NOTE: It is safe to iterate on a CopyOnWriteArrayList\n        for (ConcurrentLRUCache.Stats statistiscs : statsList) {\n          clookups += statistiscs.getCumulativeLookups();\n          chits += statistiscs.getCumulativeHits();\n          cinserts += statistiscs.getCumulativePuts();\n          cevictions += statistiscs.getCumulativeEvictions();\n          cIdleEvictions += statistiscs.getCumulativeIdleEvictions();\n        }\n\n        map.put(LOOKUPS_PARAM, lookups);\n        map.put(HITS_PARAM, hits);\n        map.put(HIT_RATIO_PARAM, calcHitRatio(lookups, hits));\n        map.put(INSERTS_PARAM, inserts);\n        map.put(EVICTIONS_PARAM, evictions);\n        map.put(SIZE_PARAM, size);\n        map.put(\"cleanupThread\", cleanupThread);\n        map.put(\"idleEvictions\", idleEvictions);\n        map.put(RAM_BYTES_USED_PARAM, ramBytesUsed());\n        map.put(MAX_RAM_MB_PARAM, getMaxRamMB());\n\n        map.put(\"warmupTime\", warmupTime);\n        map.put(\"cumulative_lookups\", clookups);\n        map.put(\"cumulative_hits\", chits);\n        map.put(\"cumulative_hitratio\", calcHitRatio(clookups, chits));\n        map.put(\"cumulative_inserts\", cinserts);\n        map.put(\"cumulative_evictions\", cevictions);\n        map.put(\"cumulative_idleEvictions\", cIdleEvictions);\n\n        if (detailed && showItems != 0) {\n          Map items = cache.getLatestAccessedItems(showItems == -1 ? Integer.MAX_VALUE : showItems);\n          for (Map.Entry e : (Set<Map.Entry>) items.entrySet()) {\n            Object k = e.getKey();\n            Object v = e.getValue();\n\n            String ks = \"item_\" + k;\n            String vs = v.toString();\n            map.put(ks, vs);\n          }\n\n        }\n      }\n    });\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["63131741120598595ba46620adaf3fad049ca291","7530de27b87b961b51f01bd1299b7004d46e8823"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7530de27b87b961b51f01bd1299b7004d46e8823"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["df72a23fb74bebe914e3f3972063a884327c0436"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","7c5044c9bb1518e7a13c1c5385a21325ae343056"],"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"4d7d3943904804560937e6239effeebda0f920e4":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"a71ca10e7131e1f01868c80d228f26a855e79dd0":["dc809283a68a1108c6c8f7adc03ceec7a1475ad5"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["21019aa828c8c9b0153877543a8b3f200bf2ca19","dc809283a68a1108c6c8f7adc03ceec7a1475ad5"],"df72a23fb74bebe914e3f3972063a884327c0436":["c44cc06c26e456fe9c215072b79fce30babe3975"],"c44cc06c26e456fe9c215072b79fce30babe3975":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83"],"a117d95183986014a31f25bb04e5464ca06d6068":["0e33a2e75ecee8b06fba2bd570c0fb9273962bc7"],"63131741120598595ba46620adaf3fad049ca291":["c26f00b574427b55127e869b935845554afde1fa"],"ce13e934d6cfdcc82d51e85de460cf9790e97566":["a71ca10e7131e1f01868c80d228f26a855e79dd0"],"7c5044c9bb1518e7a13c1c5385a21325ae343056":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"dc809283a68a1108c6c8f7adc03ceec7a1475ad5":["7c5044c9bb1518e7a13c1c5385a21325ae343056"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["a117d95183986014a31f25bb04e5464ca06d6068"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7530de27b87b961b51f01bd1299b7004d46e8823":["63131741120598595ba46620adaf3fad049ca291"],"0e33a2e75ecee8b06fba2bd570c0fb9273962bc7":["ce13e934d6cfdcc82d51e85de460cf9790e97566"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d7d3943904804560937e6239effeebda0f920e4"],"b0b597c65628ca9e73913a07e81691f8229bae35":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83","df72a23fb74bebe914e3f3972063a884327c0436"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["21019aa828c8c9b0153877543a8b3f200bf2ca19","7c5044c9bb1518e7a13c1c5385a21325ae343056"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["4d7d3943904804560937e6239effeebda0f920e4"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83":["c44cc06c26e456fe9c215072b79fce30babe3975","b0b597c65628ca9e73913a07e81691f8229bae35"],"c26f00b574427b55127e869b935845554afde1fa":["63131741120598595ba46620adaf3fad049ca291"],"4d7d3943904804560937e6239effeebda0f920e4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a71ca10e7131e1f01868c80d228f26a855e79dd0":["ce13e934d6cfdcc82d51e85de460cf9790e97566"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"63131741120598595ba46620adaf3fad049ca291":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"df72a23fb74bebe914e3f3972063a884327c0436":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","b0b597c65628ca9e73913a07e81691f8229bae35"],"c44cc06c26e456fe9c215072b79fce30babe3975":["df72a23fb74bebe914e3f3972063a884327c0436"],"a117d95183986014a31f25bb04e5464ca06d6068":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"ce13e934d6cfdcc82d51e85de460cf9790e97566":["0e33a2e75ecee8b06fba2bd570c0fb9273962bc7"],"7c5044c9bb1518e7a13c1c5385a21325ae343056":["21019aa828c8c9b0153877543a8b3f200bf2ca19","dc809283a68a1108c6c8f7adc03ceec7a1475ad5"],"dc809283a68a1108c6c8f7adc03ceec7a1475ad5":["a71ca10e7131e1f01868c80d228f26a855e79dd0","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"0e33a2e75ecee8b06fba2bd570c0fb9273962bc7":["a117d95183986014a31f25bb04e5464ca06d6068"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}