{"path":"lucene/test-framework/src/test/org/apache/lucene/mockfile/TestWindowsFS#testOpenDeleteConcurrently().mjava","commits":[{"id":"bfed6e3427046e2823569b34ac8a6a100b4e84cc","date":1432671921,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/test/org/apache/lucene/mockfile/TestWindowsFS#testOpenDeleteConcurrently().mjava","pathOld":"/dev/null","sourceNew":"  public void testOpenDeleteConcurrently() throws IOException, Exception {\n    Path dir = wrap(createTempDir());\n    Path file = dir.resolve(\"thefile\");\n    final CyclicBarrier barrier = new CyclicBarrier(2);\n    final AtomicBoolean stopped = new AtomicBoolean(false);\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          barrier.await();\n        } catch (Exception ex) {\n          throw new RuntimeException(ex);\n        }\n        while (stopped.get() == false) {\n          try {\n            if (random().nextBoolean()) {\n              Files.delete(file);\n            } else if (random().nextBoolean()) {\n              Files.deleteIfExists(file);\n            } else {\n              Path target = file.resolveSibling(\"other\");\n              Files.move(file, target);\n              Files.delete(target);\n            }\n          } catch (IOException ex) {\n            // continue\n          }\n        }\n      }\n    };\n    t.start();\n    barrier.await();\n    try {\n      final int iters = 10 + random().nextInt(100);\n      for (int i = 0; i < iters; i++) {\n        boolean opened = false;\n        try (OutputStream stream = Files.newOutputStream(file)) {\n          opened = true;\n          stream.write(0);\n          // just create\n        } catch (FileNotFoundException | NoSuchFileException ex) {\n          assertEquals(\"File handle leaked - file is closed but still regeistered\", 0, ((WindowsFS) dir.getFileSystem().provider()).openFiles.size());\n          assertFalse(\"caught FNF on close\", opened);\n        }\n        assertEquals(\"File handle leaked - file is closed but still regeistered\", 0, ((WindowsFS) dir.getFileSystem().provider()).openFiles.size());\n        Files.deleteIfExists(file);\n      }\n    } finally {\n      stopped.set(true);\n      t.join();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1355426412e7d5e541003aa9ffed7be672291385"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1355426412e7d5e541003aa9ffed7be672291385","date":1432672561,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/test/org/apache/lucene/mockfile/TestWindowsFS#testOpenDeleteConcurrently().mjava","pathOld":"lucene/test-framework/src/test/org/apache/lucene/mockfile/TestWindowsFS#testOpenDeleteConcurrently().mjava","sourceNew":"  public void testOpenDeleteConcurrently() throws IOException, Exception {\n    final Path dir = wrap(createTempDir());\n    final Path file = dir.resolve(\"thefile\");\n    final CyclicBarrier barrier = new CyclicBarrier(2);\n    final AtomicBoolean stopped = new AtomicBoolean(false);\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          barrier.await();\n        } catch (Exception ex) {\n          throw new RuntimeException(ex);\n        }\n        while (stopped.get() == false) {\n          try {\n            if (random().nextBoolean()) {\n              Files.delete(file);\n            } else if (random().nextBoolean()) {\n              Files.deleteIfExists(file);\n            } else {\n              Path target = file.resolveSibling(\"other\");\n              Files.move(file, target);\n              Files.delete(target);\n            }\n          } catch (IOException ex) {\n            // continue\n          }\n        }\n      }\n    };\n    t.start();\n    barrier.await();\n    try {\n      final int iters = 10 + random().nextInt(100);\n      for (int i = 0; i < iters; i++) {\n        boolean opened = false;\n        try (OutputStream stream = Files.newOutputStream(file)) {\n          opened = true;\n          stream.write(0);\n          // just create\n        } catch (FileNotFoundException | NoSuchFileException ex) {\n          assertEquals(\"File handle leaked - file is closed but still registered\", 0, ((WindowsFS) dir.getFileSystem().provider()).openFiles.size());\n          assertFalse(\"caught FNF on close\", opened);\n        }\n        assertEquals(\"File handle leaked - file is closed but still registered\", 0, ((WindowsFS) dir.getFileSystem().provider()).openFiles.size());\n        Files.deleteIfExists(file);\n      }\n    } finally {\n      stopped.set(true);\n      t.join();\n    }\n  }\n\n","sourceOld":"  public void testOpenDeleteConcurrently() throws IOException, Exception {\n    Path dir = wrap(createTempDir());\n    Path file = dir.resolve(\"thefile\");\n    final CyclicBarrier barrier = new CyclicBarrier(2);\n    final AtomicBoolean stopped = new AtomicBoolean(false);\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        try {\n          barrier.await();\n        } catch (Exception ex) {\n          throw new RuntimeException(ex);\n        }\n        while (stopped.get() == false) {\n          try {\n            if (random().nextBoolean()) {\n              Files.delete(file);\n            } else if (random().nextBoolean()) {\n              Files.deleteIfExists(file);\n            } else {\n              Path target = file.resolveSibling(\"other\");\n              Files.move(file, target);\n              Files.delete(target);\n            }\n          } catch (IOException ex) {\n            // continue\n          }\n        }\n      }\n    };\n    t.start();\n    barrier.await();\n    try {\n      final int iters = 10 + random().nextInt(100);\n      for (int i = 0; i < iters; i++) {\n        boolean opened = false;\n        try (OutputStream stream = Files.newOutputStream(file)) {\n          opened = true;\n          stream.write(0);\n          // just create\n        } catch (FileNotFoundException | NoSuchFileException ex) {\n          assertEquals(\"File handle leaked - file is closed but still regeistered\", 0, ((WindowsFS) dir.getFileSystem().provider()).openFiles.size());\n          assertFalse(\"caught FNF on close\", opened);\n        }\n        assertEquals(\"File handle leaked - file is closed but still regeistered\", 0, ((WindowsFS) dir.getFileSystem().provider()).openFiles.size());\n        Files.deleteIfExists(file);\n      }\n    } finally {\n      stopped.set(true);\n      t.join();\n    }\n  }\n\n","bugFix":["bfed6e3427046e2823569b34ac8a6a100b4e84cc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bfed6e3427046e2823569b34ac8a6a100b4e84cc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1355426412e7d5e541003aa9ffed7be672291385":["bfed6e3427046e2823569b34ac8a6a100b4e84cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1355426412e7d5e541003aa9ffed7be672291385"]},"commit2Childs":{"bfed6e3427046e2823569b34ac8a6a100b4e84cc":["1355426412e7d5e541003aa9ffed7be672291385"],"1355426412e7d5e541003aa9ffed7be672291385":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bfed6e3427046e2823569b34ac8a6a100b4e84cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}