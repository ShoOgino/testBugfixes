{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","commits":[{"id":"46589ed5cc841861bf6b5e2afc55f718ebcd02a0","date":1516984620,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","pathOld":"/dev/null","sourceNew":"  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got everything we need\n    if (!message.getProperties().keySet().containsAll(TimeRoutedAlias.REQUIRED_ROUTER_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + TimeRoutedAlias.REQUIRED_ROUTER_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    Map<String, String> aliasMetadata = new LinkedHashMap<>();\n    message.getProperties().entrySet().stream()\n        .filter(entry -> TimeRoutedAlias.PARAM_IS_METADATA.test(entry.getKey()))\n        .forEach(entry -> aliasMetadata.put(entry.getKey(), (String) entry.getValue())); // way easier than .collect\n\n    TimeRoutedAlias timeRoutedAlias = new TimeRoutedAlias(aliasName, aliasMetadata); // validates as well\n\n    String start = message.getStr(TimeRoutedAlias.ROUTER_START);\n    Instant startTime = parseStart(start, timeRoutedAlias.getTimeZone());\n\n    String initialCollectionName = TimeRoutedAlias.formatCollectionNameFromInstant(aliasName, startTime);\n\n    // Create the collection\n    NamedList createResults = new NamedList();\n    RoutedAliasCreateCollectionCmd.createCollectionAndWait(state, createResults, aliasName, aliasMetadata, initialCollectionName, ocmh);\n    validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n    // Create/update the alias\n    zkStateReader.aliasesHolder.applyModificationAndExportToZk(aliases -> aliases\n        .cloneWithCollectionAlias(aliasName, initialCollectionName)\n        .cloneWithCollectionAliasMetadata(aliasName, aliasMetadata));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cbd743a4843f513f793670e3ab0e272bf824faf","date":1518149529,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","sourceNew":"  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got everything we need\n    if (!message.getProperties().keySet().containsAll(TimeRoutedAlias.REQUIRED_ROUTER_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + TimeRoutedAlias.REQUIRED_ROUTER_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    Map<String, String> aliasMetadata = new LinkedHashMap<>();\n    message.getProperties().entrySet().stream()\n        .filter(entry -> TimeRoutedAlias.PARAM_IS_METADATA.test(entry.getKey()))\n        .forEach(entry -> aliasMetadata.put(entry.getKey(), (String) entry.getValue())); // way easier than .collect\n\n    TimeRoutedAlias timeRoutedAlias = new TimeRoutedAlias(aliasName, aliasMetadata); // validates as well\n\n    String start = message.getStr(TimeRoutedAlias.ROUTER_START);\n    Instant startTime = parseStart(start, timeRoutedAlias.getTimeZone());\n\n    String initialCollectionName = TimeRoutedAlias.formatCollectionNameFromInstant(aliasName, startTime);\n\n    // Create the collection\n    RoutedAliasCreateCollectionCmd.createCollectionAndWait(state, aliasName, aliasMetadata, initialCollectionName, ocmh);\n    validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n    // Create/update the alias\n    zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n        .cloneWithCollectionAlias(aliasName, initialCollectionName)\n        .cloneWithCollectionAliasMetadata(aliasName, aliasMetadata));\n  }\n\n","sourceOld":"  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got everything we need\n    if (!message.getProperties().keySet().containsAll(TimeRoutedAlias.REQUIRED_ROUTER_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + TimeRoutedAlias.REQUIRED_ROUTER_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    Map<String, String> aliasMetadata = new LinkedHashMap<>();\n    message.getProperties().entrySet().stream()\n        .filter(entry -> TimeRoutedAlias.PARAM_IS_METADATA.test(entry.getKey()))\n        .forEach(entry -> aliasMetadata.put(entry.getKey(), (String) entry.getValue())); // way easier than .collect\n\n    TimeRoutedAlias timeRoutedAlias = new TimeRoutedAlias(aliasName, aliasMetadata); // validates as well\n\n    String start = message.getStr(TimeRoutedAlias.ROUTER_START);\n    Instant startTime = parseStart(start, timeRoutedAlias.getTimeZone());\n\n    String initialCollectionName = TimeRoutedAlias.formatCollectionNameFromInstant(aliasName, startTime);\n\n    // Create the collection\n    NamedList createResults = new NamedList();\n    RoutedAliasCreateCollectionCmd.createCollectionAndWait(state, createResults, aliasName, aliasMetadata, initialCollectionName, ocmh);\n    validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n    // Create/update the alias\n    zkStateReader.aliasesHolder.applyModificationAndExportToZk(aliases -> aliases\n        .cloneWithCollectionAlias(aliasName, initialCollectionName)\n        .cloneWithCollectionAliasMetadata(aliasName, aliasMetadata));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b6eb78cb29a08063ed0ed2816d8817ede89fa90","date":1518149772,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","sourceNew":"  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got everything we need\n    if (!message.getProperties().keySet().containsAll(TimeRoutedAlias.REQUIRED_ROUTER_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + TimeRoutedAlias.REQUIRED_ROUTER_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    Map<String, String> aliasMetadata = new LinkedHashMap<>();\n    message.getProperties().entrySet().stream()\n        .filter(entry -> TimeRoutedAlias.PARAM_IS_METADATA.test(entry.getKey()))\n        .forEach(entry -> aliasMetadata.put(entry.getKey(), (String) entry.getValue())); // way easier than .collect\n\n    TimeRoutedAlias timeRoutedAlias = new TimeRoutedAlias(aliasName, aliasMetadata); // validates as well\n\n    String start = message.getStr(TimeRoutedAlias.ROUTER_START);\n    Instant startTime = parseStart(start, timeRoutedAlias.getTimeZone());\n\n    String initialCollectionName = TimeRoutedAlias.formatCollectionNameFromInstant(aliasName, startTime);\n\n    // Create the collection\n    MaintainRoutedAliasCmd.createCollectionAndWait(state, aliasName, aliasMetadata, initialCollectionName, ocmh);\n    validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n    // Create/update the alias\n    zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n        .cloneWithCollectionAlias(aliasName, initialCollectionName)\n        .cloneWithCollectionAliasMetadata(aliasName, aliasMetadata));\n  }\n\n","sourceOld":"  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got everything we need\n    if (!message.getProperties().keySet().containsAll(TimeRoutedAlias.REQUIRED_ROUTER_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + TimeRoutedAlias.REQUIRED_ROUTER_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    Map<String, String> aliasMetadata = new LinkedHashMap<>();\n    message.getProperties().entrySet().stream()\n        .filter(entry -> TimeRoutedAlias.PARAM_IS_METADATA.test(entry.getKey()))\n        .forEach(entry -> aliasMetadata.put(entry.getKey(), (String) entry.getValue())); // way easier than .collect\n\n    TimeRoutedAlias timeRoutedAlias = new TimeRoutedAlias(aliasName, aliasMetadata); // validates as well\n\n    String start = message.getStr(TimeRoutedAlias.ROUTER_START);\n    Instant startTime = parseStart(start, timeRoutedAlias.getTimeZone());\n\n    String initialCollectionName = TimeRoutedAlias.formatCollectionNameFromInstant(aliasName, startTime);\n\n    // Create the collection\n    RoutedAliasCreateCollectionCmd.createCollectionAndWait(state, aliasName, aliasMetadata, initialCollectionName, ocmh);\n    validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n    // Create/update the alias\n    zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n        .cloneWithCollectionAlias(aliasName, initialCollectionName)\n        .cloneWithCollectionAliasMetadata(aliasName, aliasMetadata));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767","date":1520865397,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","sourceNew":"  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got everything we need\n    if (!message.getProperties().keySet().containsAll(TimeRoutedAlias.REQUIRED_ROUTER_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + TimeRoutedAlias.REQUIRED_ROUTER_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    Map<String, String> aliasProperties = new LinkedHashMap<>();\n    message.getProperties().entrySet().stream()\n        .filter(entry -> TimeRoutedAlias.PARAM_IS_PROP.test(entry.getKey()))\n        .forEach(entry -> aliasProperties.put(entry.getKey(), (String) entry.getValue())); // way easier than .collect\n\n    TimeRoutedAlias timeRoutedAlias = new TimeRoutedAlias(aliasName, aliasProperties); // validates as well\n\n    String start = message.getStr(TimeRoutedAlias.ROUTER_START);\n    Instant startTime = parseStart(start, timeRoutedAlias.getTimeZone());\n\n    String initialCollectionName = TimeRoutedAlias.formatCollectionNameFromInstant(aliasName, startTime);\n\n    // Create the collection\n    MaintainRoutedAliasCmd.createCollectionAndWait(state, aliasName, aliasProperties, initialCollectionName, ocmh);\n    validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n    // Create/update the alias\n    zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n        .cloneWithCollectionAlias(aliasName, initialCollectionName)\n        .cloneWithCollectionAliasProperties(aliasName, aliasProperties));\n  }\n\n","sourceOld":"  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got everything we need\n    if (!message.getProperties().keySet().containsAll(TimeRoutedAlias.REQUIRED_ROUTER_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + TimeRoutedAlias.REQUIRED_ROUTER_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    Map<String, String> aliasMetadata = new LinkedHashMap<>();\n    message.getProperties().entrySet().stream()\n        .filter(entry -> TimeRoutedAlias.PARAM_IS_METADATA.test(entry.getKey()))\n        .forEach(entry -> aliasMetadata.put(entry.getKey(), (String) entry.getValue())); // way easier than .collect\n\n    TimeRoutedAlias timeRoutedAlias = new TimeRoutedAlias(aliasName, aliasMetadata); // validates as well\n\n    String start = message.getStr(TimeRoutedAlias.ROUTER_START);\n    Instant startTime = parseStart(start, timeRoutedAlias.getTimeZone());\n\n    String initialCollectionName = TimeRoutedAlias.formatCollectionNameFromInstant(aliasName, startTime);\n\n    // Create the collection\n    MaintainRoutedAliasCmd.createCollectionAndWait(state, aliasName, aliasMetadata, initialCollectionName, ocmh);\n    validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n    // Create/update the alias\n    zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n        .cloneWithCollectionAlias(aliasName, initialCollectionName)\n        .cloneWithCollectionAliasMetadata(aliasName, aliasMetadata));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got a basic minimum\n    if (!message.getProperties().keySet().containsAll(RoutedAlias.MINIMAL_REQUIRED_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + RoutedAlias.MINIMAL_REQUIRED_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    // convert values to strings\n    Map<String, String> props = new LinkedHashMap<>();\n    message.getProperties().forEach((key, value) -> props.put(key, String.valueOf(value)));\n\n    // Further validation happens here\n    RoutedAlias routedAlias = RoutedAlias.fromProps(aliasName, props);\n    if (routedAlias == null) {\n      // should never happen here, but keep static analysis in IDE's happy...\n      throw new SolrException(SERVER_ERROR,\"Tried to create a routed alias with no type!\");\n    }\n\n    if (!props.keySet().containsAll(routedAlias.getRequiredParams())) {\n      throw new SolrException(BAD_REQUEST, \"Not all required params were supplied. Missing params: \" +\n          StrUtils.join(Sets.difference(routedAlias.getRequiredParams(), props.keySet()), ','));\n    }\n\n    // Create the first collection.\n    String initialColl = routedAlias.computeInitialCollectionName();\n      ensureAliasCollection(aliasName, zkStateReader, state, routedAlias.getAliasMetadata(), initialColl);\n      // Create/update the alias\n      zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n          .cloneWithCollectionAlias(aliasName, initialColl)\n          .cloneWithCollectionAliasProperties(aliasName, routedAlias.getAliasMetadata()));\n  }\n\n","sourceOld":"  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got everything we need\n    if (!message.getProperties().keySet().containsAll(TimeRoutedAlias.REQUIRED_ROUTER_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + TimeRoutedAlias.REQUIRED_ROUTER_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    Map<String, String> aliasProperties = new LinkedHashMap<>();\n    message.getProperties().entrySet().stream()\n        .filter(entry -> TimeRoutedAlias.PARAM_IS_PROP.test(entry.getKey()))\n        .forEach(entry -> aliasProperties.put(entry.getKey(), (String) entry.getValue())); // way easier than .collect\n\n    TimeRoutedAlias timeRoutedAlias = new TimeRoutedAlias(aliasName, aliasProperties); // validates as well\n\n    String start = message.getStr(TimeRoutedAlias.ROUTER_START);\n    Instant startTime = parseStart(start, timeRoutedAlias.getTimeZone());\n\n    String initialCollectionName = TimeRoutedAlias.formatCollectionNameFromInstant(aliasName, startTime);\n\n    // Create the collection\n    MaintainRoutedAliasCmd.createCollectionAndWait(state, aliasName, aliasProperties, initialCollectionName, ocmh);\n    validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n    // Create/update the alias\n    zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n        .cloneWithCollectionAlias(aliasName, initialCollectionName)\n        .cloneWithCollectionAliasProperties(aliasName, aliasProperties));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState,CloudConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state, CloudConfig cloudConfig) throws Exception {\n    // Validate we got a basic minimum\n    if (!message.getProperties().keySet().containsAll(RoutedAlias.MINIMAL_REQUIRED_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + RoutedAlias.MINIMAL_REQUIRED_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    // convert values to strings\n    Map<String, String> props = new LinkedHashMap<>();\n    message.getProperties().forEach((key, value) -> props.put(key, String.valueOf(value)));\n\n    // Further validation happens here\n    RoutedAlias routedAlias = RoutedAlias.fromProps(aliasName, props);\n    if (routedAlias == null) {\n      // should never happen here, but keep static analysis in IDE's happy...\n      throw new SolrException(SERVER_ERROR,\"Tried to create a routed alias with no type!\");\n    }\n\n    if (!props.keySet().containsAll(routedAlias.getRequiredParams())) {\n      throw new SolrException(BAD_REQUEST, \"Not all required params were supplied. Missing params: \" +\n          StrUtils.join(Sets.difference(routedAlias.getRequiredParams(), props.keySet()), ','));\n    }\n\n    // Create the first collection.\n    String initialColl = routedAlias.computeInitialCollectionName();\n      ensureAliasCollection(aliasName, zkStateReader, state, cloudConfig, routedAlias.getAliasMetadata(), initialColl);\n      // Create/update the alias\n      zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n          .cloneWithCollectionAlias(aliasName, initialColl)\n          .cloneWithCollectionAliasProperties(aliasName, routedAlias.getAliasMetadata()));\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got a basic minimum\n    if (!message.getProperties().keySet().containsAll(RoutedAlias.MINIMAL_REQUIRED_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + RoutedAlias.MINIMAL_REQUIRED_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    // convert values to strings\n    Map<String, String> props = new LinkedHashMap<>();\n    message.getProperties().forEach((key, value) -> props.put(key, String.valueOf(value)));\n\n    // Further validation happens here\n    RoutedAlias routedAlias = RoutedAlias.fromProps(aliasName, props);\n    if (routedAlias == null) {\n      // should never happen here, but keep static analysis in IDE's happy...\n      throw new SolrException(SERVER_ERROR,\"Tried to create a routed alias with no type!\");\n    }\n\n    if (!props.keySet().containsAll(routedAlias.getRequiredParams())) {\n      throw new SolrException(BAD_REQUEST, \"Not all required params were supplied. Missing params: \" +\n          StrUtils.join(Sets.difference(routedAlias.getRequiredParams(), props.keySet()), ','));\n    }\n\n    // Create the first collection.\n    String initialColl = routedAlias.computeInitialCollectionName();\n      ensureAliasCollection(aliasName, zkStateReader, state, routedAlias.getAliasMetadata(), initialColl);\n      // Create/update the alias\n      zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n          .cloneWithCollectionAlias(aliasName, initialColl)\n          .cloneWithCollectionAliasProperties(aliasName, routedAlias.getAliasMetadata()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#callCreateRoutedAlias(ZkNodeProps,String,ZkStateReader,ClusterState,CloudConfig).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state) throws Exception {\n    // Validate we got a basic minimum\n    if (!message.getProperties().keySet().containsAll(RoutedAlias.MINIMAL_REQUIRED_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + RoutedAlias.MINIMAL_REQUIRED_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    // convert values to strings\n    Map<String, String> props = new LinkedHashMap<>();\n    message.getProperties().forEach((key, value) -> props.put(key, String.valueOf(value)));\n\n    // Further validation happens here\n    RoutedAlias routedAlias = RoutedAlias.fromProps(aliasName, props);\n    if (routedAlias == null) {\n      // should never happen here, but keep static analysis in IDE's happy...\n      throw new SolrException(SERVER_ERROR,\"Tried to create a routed alias with no type!\");\n    }\n\n    if (!props.keySet().containsAll(routedAlias.getRequiredParams())) {\n      throw new SolrException(BAD_REQUEST, \"Not all required params were supplied. Missing params: \" +\n          StrUtils.join(Sets.difference(routedAlias.getRequiredParams(), props.keySet()), ','));\n    }\n\n    // Create the first collection.\n    String initialColl = routedAlias.computeInitialCollectionName();\n      ensureAliasCollection(aliasName, zkStateReader, state, routedAlias.getAliasMetadata(), initialColl);\n      // Create/update the alias\n      zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n          .cloneWithCollectionAlias(aliasName, initialColl)\n          .cloneWithCollectionAliasProperties(aliasName, routedAlias.getAliasMetadata()));\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void callCreateRoutedAlias(ZkNodeProps message, String aliasName, ZkStateReader zkStateReader, ClusterState state, CloudConfig cloudConfig) throws Exception {\n    // Validate we got a basic minimum\n    if (!message.getProperties().keySet().containsAll(RoutedAlias.MINIMAL_REQUIRED_PARAMS)) {\n      throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + RoutedAlias.MINIMAL_REQUIRED_PARAMS\n      + \" plus some create-collection prefixed ones.\");\n    }\n\n    // convert values to strings\n    Map<String, String> props = new LinkedHashMap<>();\n    message.getProperties().forEach((key, value) -> props.put(key, String.valueOf(value)));\n\n    // Further validation happens here\n    RoutedAlias routedAlias = RoutedAlias.fromProps(aliasName, props);\n    if (routedAlias == null) {\n      // should never happen here, but keep static analysis in IDE's happy...\n      throw new SolrException(SERVER_ERROR,\"Tried to create a routed alias with no type!\");\n    }\n\n    if (!props.keySet().containsAll(routedAlias.getRequiredParams())) {\n      throw new SolrException(BAD_REQUEST, \"Not all required params were supplied. Missing params: \" +\n          StrUtils.join(Sets.difference(routedAlias.getRequiredParams(), props.keySet()), ','));\n    }\n\n    // Create the first collection.\n    String initialColl = routedAlias.computeInitialCollectionName();\n      ensureAliasCollection(aliasName, zkStateReader, state, cloudConfig, routedAlias.getAliasMetadata(), initialColl);\n      // Create/update the alias\n      zkStateReader.aliasesManager.applyModificationAndExportToZk(aliases -> aliases\n          .cloneWithCollectionAlias(aliasName, initialColl)\n          .cloneWithCollectionAliasProperties(aliasName, routedAlias.getAliasMetadata()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767":["1b6eb78cb29a08063ed0ed2816d8817ede89fa90"],"46589ed5cc841861bf6b5e2afc55f718ebcd02a0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c526352db87264a72a7a9ad68c1b769b81e54305":["b627755385655c7cd3fb296f17593658805cf4d5"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["46589ed5cc841861bf6b5e2afc55f718ebcd02a0"],"1b6eb78cb29a08063ed0ed2816d8817ede89fa90":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767":["b627755385655c7cd3fb296f17593658805cf4d5"],"46589ed5cc841861bf6b5e2afc55f718ebcd02a0":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["1b6eb78cb29a08063ed0ed2816d8817ede89fa90"],"1b6eb78cb29a08063ed0ed2816d8817ede89fa90":["6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["46589ed5cc841861bf6b5e2afc55f718ebcd02a0"],"b627755385655c7cd3fb296f17593658805cf4d5":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}