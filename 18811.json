{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","commits":[{"id":"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","date":1523453934,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4aa99957dcb54cefbbec762eb896b084deac1b9","date":1526471995,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43ad790248d7f7daee5d9cced548c546f37c7218","date":1527269998,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0532cd2ef583ac8047d77493ec05c81836f483c2","date":1527687859,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d349b7a9cfb231c060621755aa416810ef809778","date":1528792436,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @Ignore(\"https://issues.apache.org/jira/browse/SOLR-12208\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b55cd711a129fb7fc4c3c4672d652149c9a4faa","date":1528813320,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore(\"https://issues.apache.org/jira/browse/SOLR-12208\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f607a0a2e930f55385c7a24afb68ef661ef7e3ee","date":1530823671,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":["ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops\", 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"383671a9fe2f5147abf22eb1ce56e3ca3d6eb133","date":1541008054,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"rewrite\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudTestUtils.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"rewrite\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 05-Jul-2018\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudTestUtils.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"rewrite\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":["ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cac1f2920f8057198f04505797cbabf74dd9a97","date":1546884894,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudTestUtils.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"link\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudTestUtils.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"rewrite\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"link\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudTestUtils.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"link\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d80c1ad9241ae005a167d7ee8ac473601b0e57c","date":1559036097,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  //@AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"link\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"link\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a97a72dc16d01fda8ca5c9e0264b3604e30ab539","date":1565639985,"type":3,"author":"Megan Carey","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify default split configs\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.LINK.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, false, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  //@AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"link\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      @SuppressWarnings({\"unchecked\"})\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        @SuppressWarnings({\"unchecked\"})\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify default split configs\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.LINK.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, false, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify default split configs\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.LINK.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, false, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      @SuppressWarnings({\"unchecked\"})\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        @SuppressWarnings({\"unchecked\"})\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify default split configs\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.LINK.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, false, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      @SuppressWarnings({\"unchecked\"})\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        @SuppressWarnings({\"unchecked\"})\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify default split configs\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.LINK.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, false, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testTrigger().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testTrigger() throws Exception {\n    String collectionName = \"testTrigger_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    \n    if (SPEED == 1) {\n      cluster.waitForActiveCollection(collectionName, 2, 4);\n    } else {\n      CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n          CloudUtil.clusterShape(2, 2, false, true));\n    }\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      @SuppressWarnings({\"unchecked\"})\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        @SuppressWarnings({\"unchecked\"})\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify default split configs\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.LINK.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, false, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"383671a9fe2f5147abf22eb1ce56e3ca3d6eb133":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"e4aa99957dcb54cefbbec762eb896b084deac1b9":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"7cac1f2920f8057198f04505797cbabf74dd9a97":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["383671a9fe2f5147abf22eb1ce56e3ca3d6eb133"],"d349b7a9cfb231c060621755aa416810ef809778":["0532cd2ef583ac8047d77493ec05c81836f483c2"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"43ad790248d7f7daee5d9cced548c546f37c7218":["e4aa99957dcb54cefbbec762eb896b084deac1b9"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"a97a72dc16d01fda8ca5c9e0264b3604e30ab539":["2d80c1ad9241ae005a167d7ee8ac473601b0e57c"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"0532cd2ef583ac8047d77493ec05c81836f483c2":["43ad790248d7f7daee5d9cced548c546f37c7218"],"6b55cd711a129fb7fc4c3c4672d652149c9a4faa":["d349b7a9cfb231c060621755aa416810ef809778"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["0532cd2ef583ac8047d77493ec05c81836f483c2","f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["a97a72dc16d01fda8ca5c9e0264b3604e30ab539"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2d80c1ad9241ae005a167d7ee8ac473601b0e57c":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["7cac1f2920f8057198f04505797cbabf74dd9a97"],"f607a0a2e930f55385c7a24afb68ef661ef7e3ee":["6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["0532cd2ef583ac8047d77493ec05c81836f483c2","f607a0a2e930f55385c7a24afb68ef661ef7e3ee"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["383671a9fe2f5147abf22eb1ce56e3ca3d6eb133"],"383671a9fe2f5147abf22eb1ce56e3ca3d6eb133":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e4aa99957dcb54cefbbec762eb896b084deac1b9":["43ad790248d7f7daee5d9cced548c546f37c7218"],"7cac1f2920f8057198f04505797cbabf74dd9a97":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["7cac1f2920f8057198f04505797cbabf74dd9a97"],"d349b7a9cfb231c060621755aa416810ef809778":["6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["e4aa99957dcb54cefbbec762eb896b084deac1b9"],"43ad790248d7f7daee5d9cced548c546f37c7218":["0532cd2ef583ac8047d77493ec05c81836f483c2"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"a97a72dc16d01fda8ca5c9e0264b3604e30ab539":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"0532cd2ef583ac8047d77493ec05c81836f483c2":["d349b7a9cfb231c060621755aa416810ef809778","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"6b55cd711a129fb7fc4c3c4672d652149c9a4faa":["f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["43345f1452f9510f8aaadae6156fe0c834e7d957","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"2d80c1ad9241ae005a167d7ee8ac473601b0e57c":["a97a72dc16d01fda8ca5c9e0264b3604e30ab539"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["2d80c1ad9241ae005a167d7ee8ac473601b0e57c"],"f607a0a2e930f55385c7a24afb68ef661ef7e3ee":["042b92cf48996255bedb0c3c4bf772d7e06e4dea","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}