{"path":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","commits":[{"id":"e721522f9692a64e877e34a4467f58dbeba866eb","date":1340444282,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a8363efa169b169f300a07252db8fdec6ebfe48f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"159ce76e1b4cf9a13db9b8be3765d192f2347a48","date":1345406815,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","sourceNew":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    // IMPORTANT: Don't use oal.util.FilterIterator here:\n    // We need *strong* reference to current key after setNext()!!!\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67588aedbc6edbcce873bd0c3c7b4199fbf0987c","date":1345506207,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","sourceNew":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    // IMPORTANT: Don't use oal.util.FilterIterator here:\n    // We need *strong* reference to current key after setNext()!!!\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","sourceNew":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    // IMPORTANT: Don't use oal.util.FilterIterator here:\n    // We need *strong* reference to current key after setNext()!!!\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8363efa169b169f300a07252db8fdec6ebfe48f","date":1349387906,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/WeakIdentityMap#keyIterator().mjava","sourceNew":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    // IMPORTANT: Don't use oal.util.FilterIterator here:\n    // We need *strong* reference to current key after setNext()!!!\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet || setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        assert nextIsSet;\n        try {\n          return (K) next;\n        } finally {\n           // release strong reference and invalidate current value:\n          nextIsSet = false;\n          next = null;\n        }\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // the key was already GCed, we can remove it from backing map:\n            iterator.remove();\n          } else {\n            // unfold \"null\" special value:\n            if (next == NULL) {\n              next = null;\n            }\n            return nextIsSet = true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns an iterator over all weak keys of this map.\n   * Keys already garbage collected will not be returned.\n   * This Iterator does not support removals. */\n  public Iterator<K> keyIterator() {\n    reap();\n    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();\n    // IMPORTANT: Don't use oal.util.FilterIterator here:\n    // We need *strong* reference to current key after setNext()!!!\n    return new Iterator<K>() {\n      // holds strong reference to next element in backing iterator:\n      private Object next = null;\n      // the backing iterator was already consumed:\n      private boolean nextIsSet = false;\n    \n      @Override\n      public boolean hasNext() {\n        return nextIsSet ? true : setNext();\n      }\n      \n      @Override @SuppressWarnings(\"unchecked\")\n      public K next() {\n        if (nextIsSet || setNext()) {\n          try {\n            assert nextIsSet;\n            return (K) next;\n          } finally {\n             // release strong reference and invalidate current value:\n            nextIsSet = false;\n            next = null;\n          }\n        }\n        throw new NoSuchElementException();\n      }\n      \n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      \n      private boolean setNext() {\n        assert !nextIsSet;\n        while (iterator.hasNext()) {\n          next = iterator.next().get();\n          if (next == null) {\n            // already garbage collected!\n            continue;\n          }\n          // unfold \"null\" special value\n          if (next == NULL) {\n            next = null;\n          }\n          return nextIsSet = true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":["e721522f9692a64e877e34a4467f58dbeba866eb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"001b25b42373b22a52f399dbf072f1224632e8e6":["e721522f9692a64e877e34a4467f58dbeba866eb","159ce76e1b4cf9a13db9b8be3765d192f2347a48"],"a8363efa169b169f300a07252db8fdec6ebfe48f":["159ce76e1b4cf9a13db9b8be3765d192f2347a48"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e721522f9692a64e877e34a4467f58dbeba866eb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e721522f9692a64e877e34a4467f58dbeba866eb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"159ce76e1b4cf9a13db9b8be3765d192f2347a48":["e721522f9692a64e877e34a4467f58dbeba866eb"],"67588aedbc6edbcce873bd0c3c7b4199fbf0987c":["fe33227f6805edab2036cbb80645cc4e2d1fa424","159ce76e1b4cf9a13db9b8be3765d192f2347a48"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a8363efa169b169f300a07252db8fdec6ebfe48f"]},"commit2Childs":{"001b25b42373b22a52f399dbf072f1224632e8e6":[],"a8363efa169b169f300a07252db8fdec6ebfe48f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["67588aedbc6edbcce873bd0c3c7b4199fbf0987c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fe33227f6805edab2036cbb80645cc4e2d1fa424","e721522f9692a64e877e34a4467f58dbeba866eb"],"e721522f9692a64e877e34a4467f58dbeba866eb":["001b25b42373b22a52f399dbf072f1224632e8e6","fe33227f6805edab2036cbb80645cc4e2d1fa424","159ce76e1b4cf9a13db9b8be3765d192f2347a48"],"159ce76e1b4cf9a13db9b8be3765d192f2347a48":["001b25b42373b22a52f399dbf072f1224632e8e6","a8363efa169b169f300a07252db8fdec6ebfe48f","67588aedbc6edbcce873bd0c3c7b4199fbf0987c"],"67588aedbc6edbcce873bd0c3c7b4199fbf0987c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["001b25b42373b22a52f399dbf072f1224632e8e6","67588aedbc6edbcce873bd0c3c7b4199fbf0987c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}