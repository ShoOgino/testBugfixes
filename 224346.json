{"path":"lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","commits":[{"id":"607428da722dcb3e86bbd11c63de8986e6275c36","date":1360334150,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new FacetLabel(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":null,"sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new FacetLabel(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":null,"sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"607428da722dcb3e86bbd11c63de8986e6275c36":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d33e19a97046248623a7591aeaa6547233fd15e2":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["607428da722dcb3e86bbd11c63de8986e6275c36","d33e19a97046248623a7591aeaa6547233fd15e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["607428da722dcb3e86bbd11c63de8986e6275c36"]},"commit2Childs":{"607428da722dcb3e86bbd11c63de8986e6275c36":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"d33e19a97046248623a7591aeaa6547233fd15e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["607428da722dcb3e86bbd11c63de8986e6275c36"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["d33e19a97046248623a7591aeaa6547233fd15e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}