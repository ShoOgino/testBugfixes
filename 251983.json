{"path":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","commits":[{"id":"7ad1376d356a33e10b3b9b95708ddc83252499a6","date":1353008654,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"/dev/null","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 2000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 61)}) {\n      if (bpv == 0) {\n        Arrays.fill(arr, random().nextLong());\n      } else if (bpv == 64) {\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = random().nextLong();\n        }\n      } else {\n        final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = minValue + random().nextLong() & PackedInts.maxValue(bpv);\n        }\n      }\n      AppendingLongBuffer buf = new AppendingLongBuffer();\n      for (int i = 0; i < arr.length; ++i) {\n        buf.add(arr[i]);\n      }\n      assertEquals(arr.length, buf.size());\n      final AppendingLongBuffer.Iterator it = buf.iterator();\n      for (int i = 0; i < arr.length; ++i) {\n        if (random().nextBoolean()) {\n          assertTrue(it.hasNext());\n        }\n        assertEquals(arr[i], it.next());\n      }\n      assertFalse(it.hasNext());\n\n      final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n      final long computedBytesUsed = buf.ramBytesUsed();\n      assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n          expectedBytesUsed, computedBytesUsed);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a8b3f4209c6b8919a25d2a047a3d9f5172b715c","date":1353076805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 2000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 61)}) {\n      if (bpv == 0) {\n        Arrays.fill(arr, random().nextLong());\n      } else if (bpv == 64) {\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = random().nextLong();\n        }\n      } else {\n        final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = minValue + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n        }\n      }\n      AppendingLongBuffer buf = new AppendingLongBuffer();\n      for (int i = 0; i < arr.length; ++i) {\n        buf.add(arr[i]);\n      }\n      assertEquals(arr.length, buf.size());\n      final AppendingLongBuffer.Iterator it = buf.iterator();\n      for (int i = 0; i < arr.length; ++i) {\n        if (random().nextBoolean()) {\n          assertTrue(it.hasNext());\n        }\n        assertEquals(arr[i], it.next());\n      }\n      assertFalse(it.hasNext());\n\n      final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n      final long computedBytesUsed = buf.ramBytesUsed();\n      assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n          expectedBytesUsed, computedBytesUsed);\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 2000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 61)}) {\n      if (bpv == 0) {\n        Arrays.fill(arr, random().nextLong());\n      } else if (bpv == 64) {\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = random().nextLong();\n        }\n      } else {\n        final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = minValue + random().nextLong() & PackedInts.maxValue(bpv);\n        }\n      }\n      AppendingLongBuffer buf = new AppendingLongBuffer();\n      for (int i = 0; i < arr.length; ++i) {\n        buf.add(arr[i]);\n      }\n      assertEquals(arr.length, buf.size());\n      final AppendingLongBuffer.Iterator it = buf.iterator();\n      for (int i = 0; i < arr.length; ++i) {\n        if (random().nextBoolean()) {\n          assertTrue(it.hasNext());\n        }\n        assertEquals(arr[i], it.next());\n      }\n      assertFalse(it.hasNext());\n\n      final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n      final long computedBytesUsed = buf.ramBytesUsed();\n      assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n          expectedBytesUsed, computedBytesUsed);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0957acf04dd58e07d48286537fe0e924f34e070a","date":1359597575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 2000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 61)}) {\n      if (bpv == 0) {\n        Arrays.fill(arr, random().nextLong());\n      } else if (bpv == 64) {\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = random().nextLong();\n        }\n      } else {\n        final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = minValue + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n        }\n      }\n      AppendingLongBuffer buf = new AppendingLongBuffer();\n      for (int i = 0; i < arr.length; ++i) {\n        buf.add(arr[i]);\n      }\n      assertEquals(arr.length, buf.size());\n      final AppendingLongBuffer.Iterator it = buf.iterator();\n      for (int i = 0; i < arr.length; ++i) {\n        if (random().nextBoolean()) {\n          assertTrue(it.hasNext());\n        }\n        assertEquals(arr[i], it.next());\n      }\n      assertFalse(it.hasNext());\n      \n      for (int i = 0; i < arr.length; ++i) {\n        assertEquals(arr[i], buf.get(i));\n      }\n\n      final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n      final long computedBytesUsed = buf.ramBytesUsed();\n      assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n          expectedBytesUsed, computedBytesUsed);\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 2000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 61)}) {\n      if (bpv == 0) {\n        Arrays.fill(arr, random().nextLong());\n      } else if (bpv == 64) {\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = random().nextLong();\n        }\n      } else {\n        final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = minValue + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n        }\n      }\n      AppendingLongBuffer buf = new AppendingLongBuffer();\n      for (int i = 0; i < arr.length; ++i) {\n        buf.add(arr[i]);\n      }\n      assertEquals(arr.length, buf.size());\n      final AppendingLongBuffer.Iterator it = buf.iterator();\n      for (int i = 0; i < arr.length; ++i) {\n        if (random().nextBoolean()) {\n          assertTrue(it.hasNext());\n        }\n        assertEquals(arr[i], it.next());\n      }\n      assertFalse(it.hasNext());\n\n      final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n      final long computedBytesUsed = buf.ramBytesUsed();\n      assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n          expectedBytesUsed, computedBytesUsed);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"/dev/null","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 2000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 61)}) {\n      if (bpv == 0) {\n        Arrays.fill(arr, random().nextLong());\n      } else if (bpv == 64) {\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = random().nextLong();\n        }\n      } else {\n        final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = minValue + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n        }\n      }\n      AppendingLongBuffer buf = new AppendingLongBuffer();\n      for (int i = 0; i < arr.length; ++i) {\n        buf.add(arr[i]);\n      }\n      assertEquals(arr.length, buf.size());\n      final AppendingLongBuffer.Iterator it = buf.iterator();\n      for (int i = 0; i < arr.length; ++i) {\n        if (random().nextBoolean()) {\n          assertTrue(it.hasNext());\n        }\n        assertEquals(arr[i], it.next());\n      }\n      assertFalse(it.hasNext());\n      \n      for (int i = 0; i < arr.length; ++i) {\n        assertEquals(arr[i], buf.get(i));\n      }\n\n      final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n      final long computedBytesUsed = buf.ramBytesUsed();\n      assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n          expectedBytesUsed, computedBytesUsed);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae3be3418aea9954be27a83315087f67c0c2201e","date":1361023362,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer();\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer();\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n            expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 2000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 61)}) {\n      if (bpv == 0) {\n        Arrays.fill(arr, random().nextLong());\n      } else if (bpv == 64) {\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = random().nextLong();\n        }\n      } else {\n        final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = minValue + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n        }\n      }\n      AppendingLongBuffer buf = new AppendingLongBuffer();\n      for (int i = 0; i < arr.length; ++i) {\n        buf.add(arr[i]);\n      }\n      assertEquals(arr.length, buf.size());\n      final AppendingLongBuffer.Iterator it = buf.iterator();\n      for (int i = 0; i < arr.length; ++i) {\n        if (random().nextBoolean()) {\n          assertTrue(it.hasNext());\n        }\n        assertEquals(arr[i], it.next());\n      }\n      assertFalse(it.hasNext());\n      \n      for (int i = 0; i < arr.length; ++i) {\n        assertEquals(arr[i], buf.get(i));\n      }\n\n      final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n      final long computedBytesUsed = buf.ramBytesUsed();\n      assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n          expectedBytesUsed, computedBytesUsed);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer();\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer();\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n            expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 2000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 61)}) {\n      if (bpv == 0) {\n        Arrays.fill(arr, random().nextLong());\n      } else if (bpv == 64) {\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = random().nextLong();\n        }\n      } else {\n        final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n        for (int i = 0; i < arr.length; ++i) {\n          arr[i] = minValue + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n        }\n      }\n      AppendingLongBuffer buf = new AppendingLongBuffer();\n      for (int i = 0; i < arr.length; ++i) {\n        buf.add(arr[i]);\n      }\n      assertEquals(arr.length, buf.size());\n      final AppendingLongBuffer.Iterator it = buf.iterator();\n      for (int i = 0; i < arr.length; ++i) {\n        if (random().nextBoolean()) {\n          assertTrue(it.hasNext());\n        }\n        assertEquals(arr[i], it.next());\n      }\n      assertFalse(it.hasNext());\n      \n      for (int i = 0; i < arr.length; ++i) {\n        assertEquals(arr[i], buf.get(i));\n      }\n\n      final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n      final long computedBytesUsed = buf.ramBytesUsed();\n      assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n          expectedBytesUsed, computedBytesUsed);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22344cc5c695683a5a6cecff291f840d71c20d25","date":1370561415,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize);\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer(initialPageCount, pageSize);\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n            expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer();\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer();\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n            expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3618e9b99a76b26b0dbb5e7ea75cbb6065433eaa","date":1373959221,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize);\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer(initialPageCount, pageSize);\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize);\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer(initialPageCount, pageSize);\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n            expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize);\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer(initialPageCount, pageSize);\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize);\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer(initialPageCount, pageSize);\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(\"got \" + computedBytesUsed + \", expected: \" + expectedBytesUsed,\n            expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb240aebd5a347d79f642127ad9255dd9a979f06","date":1375188159,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[_TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = _TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += _TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize);\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer(initialPageCount, pageSize);\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[_TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = _TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += _TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    for (int bpv : new int[] {0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (boolean monotonic : new boolean[] {true, false}) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        if (monotonic) {\n          buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize);\n          inc = _TestUtil.nextInt(random(), -1000, 1000);\n        } else {\n          buf = new AppendingLongBuffer(initialPageCount, pageSize);\n          inc = 0;\n        }\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i-1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n        \n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n  \n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << _TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = _TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[_TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = _TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = _TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += _TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1eb6b3ce884c0b9e064e112da158013ec33cd91","date":1402692077,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageTester.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageTester.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aae6236deecc1bf344f9c22d8d9dd09ef6701dbd","date":1404226546,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testPackedLongValues().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testAppendingLongBuffer().mjava","sourceNew":"  public void testPackedLongValues() {\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : Arrays.asList(DataType.DELTA_PACKED)) {\n        final int pageSize = 1 << TestUtil.nextInt(random(), 6, 20);\n        float acceptableOverheadRatio = ratioOptions[TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        PackedLongValues.Builder buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = PackedLongValues.packedBuilder(pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = PackedLongValues.deltaPackedBuilder(pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = PackedLongValues.monotonicBuilder(pageSize, acceptableOverheadRatio);\n            inc = TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n          if (rarely()) {\n            final long expectedBytesUsed = RamUsageTester.sizeOf(buf);\n            final long computedBytesUsed = buf.ramBytesUsed();\n            assertEquals(expectedBytesUsed, computedBytesUsed);\n          }\n        }\n        assertEquals(arr.length, buf.size());\n        final PackedLongValues values = buf.build();\n        try {\n          buf.add(random().nextLong());\n          fail(\"expected an exception\");\n        } catch (IllegalStateException e) {\n          // ok\n        }\n        assertEquals(arr.length, values.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], values.get(i));\n        }\n\n        final PackedLongValues.Iterator it = values.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n        final long expectedBytesUsed = RamUsageTester.sizeOf(values);\n        final long computedBytesUsed = values.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","sourceOld":"  public void testAppendingLongBuffer() {\n\n    final long[] arr = new long[RandomInts.randomIntBetween(random(), 1, 1000000)];\n    float[] ratioOptions = new float[]{PackedInts.DEFAULT, PackedInts.COMPACT, PackedInts.FAST};\n    for (int bpv : new int[]{0, 1, 63, 64, RandomInts.randomIntBetween(random(), 2, 62)}) {\n      for (DataType dataType : DataType.values()) {\n        final int pageSize = 1 << TestUtil.nextInt(random(), 6, 20);\n        final int initialPageCount = TestUtil.nextInt(random(), 0, 16);\n        float acceptableOverheadRatio = ratioOptions[TestUtil.nextInt(random(), 0, ratioOptions.length - 1)];\n        AbstractAppendingLongBuffer buf;\n        final int inc;\n        switch (dataType) {\n          case PACKED:\n            buf = new AppendingPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case DELTA_PACKED:\n            buf = new AppendingDeltaPackedLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = 0;\n            break;\n          case MONOTONIC:\n            buf = new MonotonicAppendingLongBuffer(initialPageCount, pageSize, acceptableOverheadRatio);\n            inc = TestUtil.nextInt(random(), -1000, 1000);\n            break;\n          default:\n            throw new RuntimeException(\"added a type and forgot to add it here?\");\n\n        }\n\n        if (bpv == 0) {\n          arr[0] = random().nextLong();\n          for (int i = 1; i < arr.length; ++i) {\n            arr[i] = arr[i - 1] + inc;\n          }\n        } else if (bpv == 64) {\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random().nextLong();\n          }\n        } else {\n          final long minValue = TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE - PackedInts.maxValue(bpv));\n          for (int i = 0; i < arr.length; ++i) {\n            arr[i] = minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv); // _TestUtil.nextLong is too slow\n          }\n        }\n\n        for (int i = 0; i < arr.length; ++i) {\n          buf.add(arr[i]);\n        }\n        assertEquals(arr.length, buf.size());\n        if (random().nextBoolean()) {\n          buf.freeze();\n          if (random().nextBoolean()) {\n            // Make sure double freeze doesn't break anything\n            buf.freeze();\n          }\n        }\n        assertEquals(arr.length, buf.size());\n\n        for (int i = 0; i < arr.length; ++i) {\n          assertEquals(arr[i], buf.get(i));\n        }\n\n        final AbstractAppendingLongBuffer.Iterator it = buf.iterator();\n        for (int i = 0; i < arr.length; ++i) {\n          if (random().nextBoolean()) {\n            assertTrue(it.hasNext());\n          }\n          assertEquals(arr[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n\n        long[] target = new long[arr.length + 1024]; // check the request for more is OK.\n        for (int i = 0; i < arr.length; i += TestUtil.nextInt(random(), 0, 10000)) {\n          int lenToRead = random().nextInt(buf.pageSize() * 2) + 1;\n          lenToRead = Math.min(lenToRead, target.length - i);\n          int lenToCheck = Math.min(lenToRead, arr.length - i);\n          int off = i;\n          while (off < arr.length && lenToRead > 0) {\n            int read = buf.get(off, target, off, lenToRead);\n            assertTrue(read > 0);\n            assertTrue(read <= lenToRead);\n            lenToRead -= read;\n            off += read;\n          }\n\n          for (int j = 0; j < lenToCheck; j++) {\n            assertEquals(arr[j + i], target[j + i]);\n          }\n        }\n\n        final long expectedBytesUsed = RamUsageTester.sizeOf(buf);\n        final long computedBytesUsed = buf.ramBytesUsed();\n        assertEquals(expectedBytesUsed, computedBytesUsed);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3618e9b99a76b26b0dbb5e7ea75cbb6065433eaa":["22344cc5c695683a5a6cecff291f840d71c20d25"],"7ad1376d356a33e10b3b9b95708ddc83252499a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["22344cc5c695683a5a6cecff291f840d71c20d25","3618e9b99a76b26b0dbb5e7ea75cbb6065433eaa"],"6613659748fe4411a7dcf85266e55db1f95f7315":["cb240aebd5a347d79f642127ad9255dd9a979f06"],"cb240aebd5a347d79f642127ad9255dd9a979f06":["3618e9b99a76b26b0dbb5e7ea75cbb6065433eaa"],"22344cc5c695683a5a6cecff291f840d71c20d25":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["d4d69c535930b5cce125cff868d40f6373dc27d4","ae3be3418aea9954be27a83315087f67c0c2201e"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["6613659748fe4411a7dcf85266e55db1f95f7315","e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"9a8b3f4209c6b8919a25d2a047a3d9f5172b715c":["7ad1376d356a33e10b3b9b95708ddc83252499a6"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0957acf04dd58e07d48286537fe0e924f34e070a"],"0957acf04dd58e07d48286537fe0e924f34e070a":["9a8b3f4209c6b8919a25d2a047a3d9f5172b715c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["37a0f60745e53927c4c876cfe5b5a58170f0646c"],"ae3be3418aea9954be27a83315087f67c0c2201e":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aae6236deecc1bf344f9c22d8d9dd09ef6701dbd"],"aae6236deecc1bf344f9c22d8d9dd09ef6701dbd":["e1eb6b3ce884c0b9e064e112da158013ec33cd91"]},"commit2Childs":{"3618e9b99a76b26b0dbb5e7ea75cbb6065433eaa":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cb240aebd5a347d79f642127ad9255dd9a979f06"],"7ad1376d356a33e10b3b9b95708ddc83252499a6":["9a8b3f4209c6b8919a25d2a047a3d9f5172b715c"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"6613659748fe4411a7dcf85266e55db1f95f7315":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"cb240aebd5a347d79f642127ad9255dd9a979f06":["6613659748fe4411a7dcf85266e55db1f95f7315"],"22344cc5c695683a5a6cecff291f840d71c20d25":["3618e9b99a76b26b0dbb5e7ea75cbb6065433eaa","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["22344cc5c695683a5a6cecff291f840d71c20d25"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"9a8b3f4209c6b8919a25d2a047a3d9f5172b715c":["0957acf04dd58e07d48286537fe0e924f34e070a"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["ddbb72a33557d2b5bc22ee95daf3281c43560502","ae3be3418aea9954be27a83315087f67c0c2201e"],"0957acf04dd58e07d48286537fe0e924f34e070a":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7ad1376d356a33e10b3b9b95708ddc83252499a6","d4d69c535930b5cce125cff868d40f6373dc27d4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"ae3be3418aea9954be27a83315087f67c0c2201e":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","aae6236deecc1bf344f9c22d8d9dd09ef6701dbd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"aae6236deecc1bf344f9c22d8d9dd09ef6701dbd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}