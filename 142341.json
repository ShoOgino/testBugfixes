{"path":"lucene/core/src/java/org/apache/lucene/index/MergePolicy.OneMergeProgress#pauseNanos(long,PauseReason,BooleanSupplier).mjava","commits":[{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergePolicy.OneMergeProgress#pauseNanos(long,PauseReason,BooleanSupplier).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Pauses the calling thread for at least <code>pauseNanos</code> nanoseconds\n     * unless the merge is aborted or the external condition returns <code>false</code>,\n     * in which case control returns immediately.\n     * \n     * The external condition is required so that other threads can terminate the pausing immediately,\n     * before <code>pauseNanos</code> expires. We can't rely on just {@link Condition#awaitNanos(long)} alone\n     * because it can return due to spurious wakeups too.  \n     * \n     * @param condition The pause condition that should return false if immediate return from this\n     *      method is needed. Other threads can wake up any sleeping thread by calling \n     *      {@link #wakeup}, but it'd fall to sleep for the remainder of the requested time if this\n     *      condition \n     */\n    public void pauseNanos(long pauseNanos, PauseReason reason, BooleanSupplier condition) throws InterruptedException {\n      if (Thread.currentThread() != owner) {\n        throw new RuntimeException(\"Only the merge owner thread can call pauseNanos(). This thread: \"\n            + Thread.currentThread().getName() + \", owner thread: \"\n            + owner);\n      }\n\n      long start = System.nanoTime();\n      AtomicLong timeUpdate = pauseTimesNS.get(reason);\n      pauseLock.lock();\n      try {\n        while (pauseNanos > 0 && !aborted && condition.getAsBoolean()) {\n          pauseNanos = pausing.awaitNanos(pauseNanos);\n        }\n      } finally {\n        pauseLock.unlock();\n        timeUpdate.addAndGet(System.nanoTime() - start);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}