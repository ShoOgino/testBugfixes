{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestMortonEncoder#testMortonEncoding().mjava","commits":[{"id":"065f36185d91a7d825ce7adac5b0d8df5cb4f73f","date":1461251676,"type":0,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestMortonEncoder#testMortonEncoding().mjava","pathOld":"/dev/null","sourceNew":"  public void testMortonEncoding() throws Exception {\n    final long TRANSLATE = 1L << 31;\n    final double LATITUDE_DECODE = 180.0D/(0x1L<<32);\n    final double LONGITUDE_DECODE = 360.0D/(0x1L<<32);\n    Random random = random();\n    for(int i=0; i < 10000; ++i) {\n      long encoded = random().nextLong();\n      long encodedLat = deinterleave(encoded >>> 1);\n      long encodedLon = deinterleave(encoded);\n      double expectedLat = decodeLatitude((int)(encodedLat - TRANSLATE));\n      double decodedLat = decodeLatitude(encoded);\n      double expectedLon = decodeLongitude((int)(encodedLon - TRANSLATE));\n      double decodedLon = decodeLongitude(encoded);\n      assertEquals(expectedLat, decodedLat, 0.0D);\n      assertEquals(expectedLon, decodedLon, 0.0D);\n      // should round-trip\n      assertEquals(encoded, encode(decodedLat, decodedLon));\n\n      // test within the range\n      if (encoded != 0xFFFFFFFFFFFFFFFFL) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double maxLat = expectedLat + LATITUDE_DECODE;\n        encodedLat += 1;\n        assertEquals(maxLat, decodeLatitude((int)(encodedLat - TRANSLATE)), 0.0D);\n        double maxLon = expectedLon + LONGITUDE_DECODE;\n        encodedLon += 1;\n        assertEquals(maxLon, decodeLongitude((int)(encodedLon - TRANSLATE)), 0.0D);\n        long encodedNext = encode(maxLat, maxLon);\n        assertEquals(interleave((int)encodedLon, (int)encodedLat), encodedNext);\n\n        // first and last doubles in range that will be quantized\n        double minEdgeLat = Math.nextUp(expectedLat);\n        double minEdgeLon = Math.nextUp(expectedLon);\n        long encodedMinEdge = encode(minEdgeLat, minEdgeLon);\n        long encodedMinEdgeCeil = encodeCeil(minEdgeLat, minEdgeLon);\n        double maxEdgeLat = Math.nextDown(maxLat);\n        double maxEdgeLon = Math.nextDown(maxLon);\n        long encodedMaxEdge = encode(maxEdgeLat, maxEdgeLon);\n        long encodedMaxEdgeCeil = encodeCeil(maxEdgeLat, maxEdgeLon);\n\n        assertEquals(encodedLat - 1, deinterleave(encodedMinEdge >>> 1));\n        assertEquals(encodedLat, deinterleave(encodedMinEdgeCeil >>> 1));\n        assertEquals(encodedLon - 1, deinterleave(encodedMinEdge));\n        assertEquals(encodedLon, deinterleave(encodedMinEdgeCeil));\n\n        assertEquals(encodedLat - 1, deinterleave(encodedMaxEdge >>> 1));\n        assertEquals(encodedLat, deinterleave(encodedMaxEdgeCeil >>> 1));\n        assertEquals(encodedLon - 1, deinterleave(encodedMaxEdge));\n        assertEquals(encodedLon, deinterleave(encodedMaxEdgeCeil));\n\n        // check random values within the double range\n        long minBitsLat = NumericUtils.doubleToSortableLong(minEdgeLat);\n        long maxBitsLat = NumericUtils.doubleToSortableLong(maxEdgeLat);\n        long minBitsLon = NumericUtils.doubleToSortableLong(minEdgeLon);\n        long maxBitsLon = NumericUtils.doubleToSortableLong(maxEdgeLon);\n        for (int j = 0; j < 100; j++) {\n          double valueLat = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBitsLat, maxBitsLat));\n          double valueLon = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBitsLon, maxBitsLon));\n          // round down\n          assertEquals(encoded,   encode(valueLat, valueLon));\n          // round up\n          assertEquals(interleave((int)encodedLon, (int)encodedLat), encodeCeil(valueLat, valueLon));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","date":1461308643,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestMortonEncoder#testMortonEncoding().mjava","pathOld":"/dev/null","sourceNew":"  public void testMortonEncoding() throws Exception {\n    final long TRANSLATE = 1L << 31;\n    final double LATITUDE_DECODE = 180.0D/(0x1L<<32);\n    final double LONGITUDE_DECODE = 360.0D/(0x1L<<32);\n    Random random = random();\n    for(int i=0; i < 10000; ++i) {\n      long encoded = random().nextLong();\n      long encodedLat = deinterleave(encoded >>> 1);\n      long encodedLon = deinterleave(encoded);\n      double expectedLat = decodeLatitude((int)(encodedLat - TRANSLATE));\n      double decodedLat = decodeLatitude(encoded);\n      double expectedLon = decodeLongitude((int)(encodedLon - TRANSLATE));\n      double decodedLon = decodeLongitude(encoded);\n      assertEquals(expectedLat, decodedLat, 0.0D);\n      assertEquals(expectedLon, decodedLon, 0.0D);\n      // should round-trip\n      assertEquals(encoded, encode(decodedLat, decodedLon));\n\n      // test within the range\n      if (encoded != 0xFFFFFFFFFFFFFFFFL) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double maxLat = expectedLat + LATITUDE_DECODE;\n        encodedLat += 1;\n        assertEquals(maxLat, decodeLatitude((int)(encodedLat - TRANSLATE)), 0.0D);\n        double maxLon = expectedLon + LONGITUDE_DECODE;\n        encodedLon += 1;\n        assertEquals(maxLon, decodeLongitude((int)(encodedLon - TRANSLATE)), 0.0D);\n        long encodedNext = encode(maxLat, maxLon);\n        assertEquals(interleave((int)encodedLon, (int)encodedLat), encodedNext);\n\n        // first and last doubles in range that will be quantized\n        double minEdgeLat = Math.nextUp(expectedLat);\n        double minEdgeLon = Math.nextUp(expectedLon);\n        long encodedMinEdge = encode(minEdgeLat, minEdgeLon);\n        long encodedMinEdgeCeil = encodeCeil(minEdgeLat, minEdgeLon);\n        double maxEdgeLat = Math.nextDown(maxLat);\n        double maxEdgeLon = Math.nextDown(maxLon);\n        long encodedMaxEdge = encode(maxEdgeLat, maxEdgeLon);\n        long encodedMaxEdgeCeil = encodeCeil(maxEdgeLat, maxEdgeLon);\n\n        assertEquals(encodedLat - 1, deinterleave(encodedMinEdge >>> 1));\n        assertEquals(encodedLat, deinterleave(encodedMinEdgeCeil >>> 1));\n        assertEquals(encodedLon - 1, deinterleave(encodedMinEdge));\n        assertEquals(encodedLon, deinterleave(encodedMinEdgeCeil));\n\n        assertEquals(encodedLat - 1, deinterleave(encodedMaxEdge >>> 1));\n        assertEquals(encodedLat, deinterleave(encodedMaxEdgeCeil >>> 1));\n        assertEquals(encodedLon - 1, deinterleave(encodedMaxEdge));\n        assertEquals(encodedLon, deinterleave(encodedMaxEdgeCeil));\n\n        // check random values within the double range\n        long minBitsLat = NumericUtils.doubleToSortableLong(minEdgeLat);\n        long maxBitsLat = NumericUtils.doubleToSortableLong(maxEdgeLat);\n        long minBitsLon = NumericUtils.doubleToSortableLong(minEdgeLon);\n        long maxBitsLon = NumericUtils.doubleToSortableLong(maxEdgeLon);\n        for (int j = 0; j < 100; j++) {\n          double valueLat = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBitsLat, maxBitsLat));\n          double valueLon = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBitsLon, maxBitsLon));\n          // round down\n          assertEquals(encoded,   encode(valueLat, valueLon));\n          // round up\n          assertEquals(interleave((int)encodedLon, (int)encodedLat), encodeCeil(valueLat, valueLon));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf436f74d20215759bddd34832de74d7227024b1","date":1579195325,"type":4,"author":"Nicholas Knize","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestMortonEncoder#testMortonEncoding().mjava","sourceNew":null,"sourceOld":"  public void testMortonEncoding() throws Exception {\n    final long TRANSLATE = 1L << 31;\n    final double LATITUDE_DECODE = 180.0D/(0x1L<<32);\n    final double LONGITUDE_DECODE = 360.0D/(0x1L<<32);\n    Random random = random();\n    for(int i=0; i < 10000; ++i) {\n      long encoded = random().nextLong();\n      long encodedLat = deinterleave(encoded >>> 1);\n      long encodedLon = deinterleave(encoded);\n      double expectedLat = decodeLatitude((int)(encodedLat - TRANSLATE));\n      double decodedLat = decodeLatitude(encoded);\n      double expectedLon = decodeLongitude((int)(encodedLon - TRANSLATE));\n      double decodedLon = decodeLongitude(encoded);\n      assertEquals(expectedLat, decodedLat, 0.0D);\n      assertEquals(expectedLon, decodedLon, 0.0D);\n      // should round-trip\n      assertEquals(encoded, encode(decodedLat, decodedLon));\n\n      // test within the range\n      if (encoded != 0xFFFFFFFFFFFFFFFFL) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double maxLat = expectedLat + LATITUDE_DECODE;\n        encodedLat += 1;\n        assertEquals(maxLat, decodeLatitude((int)(encodedLat - TRANSLATE)), 0.0D);\n        double maxLon = expectedLon + LONGITUDE_DECODE;\n        encodedLon += 1;\n        assertEquals(maxLon, decodeLongitude((int)(encodedLon - TRANSLATE)), 0.0D);\n        long encodedNext = encode(maxLat, maxLon);\n        assertEquals(interleave((int)encodedLon, (int)encodedLat), encodedNext);\n\n        // first and last doubles in range that will be quantized\n        double minEdgeLat = Math.nextUp(expectedLat);\n        double minEdgeLon = Math.nextUp(expectedLon);\n        long encodedMinEdge = encode(minEdgeLat, minEdgeLon);\n        long encodedMinEdgeCeil = encodeCeil(minEdgeLat, minEdgeLon);\n        double maxEdgeLat = Math.nextDown(maxLat);\n        double maxEdgeLon = Math.nextDown(maxLon);\n        long encodedMaxEdge = encode(maxEdgeLat, maxEdgeLon);\n        long encodedMaxEdgeCeil = encodeCeil(maxEdgeLat, maxEdgeLon);\n\n        assertEquals(encodedLat - 1, deinterleave(encodedMinEdge >>> 1));\n        assertEquals(encodedLat, deinterleave(encodedMinEdgeCeil >>> 1));\n        assertEquals(encodedLon - 1, deinterleave(encodedMinEdge));\n        assertEquals(encodedLon, deinterleave(encodedMinEdgeCeil));\n\n        assertEquals(encodedLat - 1, deinterleave(encodedMaxEdge >>> 1));\n        assertEquals(encodedLat, deinterleave(encodedMaxEdgeCeil >>> 1));\n        assertEquals(encodedLon - 1, deinterleave(encodedMaxEdge));\n        assertEquals(encodedLon, deinterleave(encodedMaxEdgeCeil));\n\n        // check random values within the double range\n        long minBitsLat = NumericUtils.doubleToSortableLong(minEdgeLat);\n        long maxBitsLat = NumericUtils.doubleToSortableLong(maxEdgeLat);\n        long minBitsLon = NumericUtils.doubleToSortableLong(minEdgeLon);\n        long maxBitsLon = NumericUtils.doubleToSortableLong(maxEdgeLon);\n        for (int j = 0; j < 100; j++) {\n          double valueLat = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBitsLat, maxBitsLat));\n          double valueLon = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBitsLon, maxBitsLon));\n          // round down\n          assertEquals(encoded,   encode(valueLat, valueLon));\n          // round up\n          assertEquals(interleave((int)encodedLon, (int)encodedLat), encodeCeil(valueLat, valueLon));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"065f36185d91a7d825ce7adac5b0d8df5cb4f73f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","065f36185d91a7d825ce7adac5b0d8df5cb4f73f"],"bf436f74d20215759bddd34832de74d7227024b1":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bf436f74d20215759bddd34832de74d7227024b1"]},"commit2Childs":{"065f36185d91a7d825ce7adac5b0d8df5cb4f73f":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["bf436f74d20215759bddd34832de74d7227024b1"],"bf436f74d20215759bddd34832de74d7227024b1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["065f36185d91a7d825ce7adac5b0d8df5cb4f73f","ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}