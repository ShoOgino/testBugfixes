{"path":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","commits":[{"id":"fb8457dd0880f5547d70dbf40ea4f1c5e7787798","date":1363378339,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    FacetsAggregator aggregator = getAggregator();\n    for (CategoryListParams clp : getCategoryLists()) {\n      for (MatchingDocs md : matchingDocs) {\n        aggregator.aggregate(md, clp, facetArrays);\n      }\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for(FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > bottomCount) {\n          dimCount += counts[ord];\n          //System.out.println(\"    keep\");\n          if (reuse == null) {\n            reuse = new FacetResultNode(ord, counts[ord]);\n          } else {\n            reuse.ordinal = ord;\n            reuse.value = counts[ord];\n          }\n          reuse = q.insertWithOverflow(reuse);\n          if (q.size() == request.numResults) {\n            bottomCount = (int) q.top().value;\n            //System.out.println(\"    new bottom=\" + bottomCount);\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childNodes.length));\n    }\n\n    return results;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a","date":1365621037,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","sourceNew":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    FacetsAggregator aggregator = getAggregator();\n    for (CategoryListParams clp : getCategoryLists()) {\n      for (MatchingDocs md : matchingDocs) {\n        aggregator.aggregate(md, clp, facetArrays);\n      }\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for(FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","sourceOld":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    FacetsAggregator aggregator = getAggregator();\n    for (CategoryListParams clp : getCategoryLists()) {\n      for (MatchingDocs md : matchingDocs) {\n        aggregator.aggregate(md, clp, facetArrays);\n      }\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for(FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > bottomCount) {\n          dimCount += counts[ord];\n          //System.out.println(\"    keep\");\n          if (reuse == null) {\n            reuse = new FacetResultNode(ord, counts[ord]);\n          } else {\n            reuse.ordinal = ord;\n            reuse.value = counts[ord];\n          }\n          reuse = q.insertWithOverflow(reuse);\n          if (q.size() == request.numResults) {\n            bottomCount = (int) q.top().value;\n            //System.out.println(\"    new bottom=\" + bottomCount);\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childNodes.length));\n    }\n\n    return results;\n  }\n\n","bugFix":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","date":1375103250,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","sourceNew":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    SortedSetAggregator aggregator = new SortedSetAggregator(field, state, dv);\n    for (MatchingDocs md : matchingDocs) {\n      aggregator.aggregate(md, facetArrays);\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for (FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","sourceOld":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    FacetsAggregator aggregator = getAggregator();\n    for (CategoryListParams clp : getCategoryLists()) {\n      for (MatchingDocs md : matchingDocs) {\n        aggregator.aggregate(md, clp, facetArrays);\n      }\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for(FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","sourceNew":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    SortedSetAggregator aggregator = new SortedSetAggregator(field, state, dv);\n    for (MatchingDocs md : matchingDocs) {\n      aggregator.aggregate(md, facetArrays);\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for (FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","sourceOld":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    FacetsAggregator aggregator = getAggregator();\n    for (CategoryListParams clp : getCategoryLists()) {\n      for (MatchingDocs md : matchingDocs) {\n        aggregator.aggregate(md, clp, facetArrays);\n      }\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for(FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","sourceNew":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    SortedSetAggregator aggregator = new SortedSetAggregator(field, state, dv);\n    for (MatchingDocs md : matchingDocs) {\n      aggregator.aggregate(md, facetArrays);\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for (FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new FacetLabel(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new FacetLabel(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new FacetLabel(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new FacetLabel(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","sourceOld":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    SortedSetAggregator aggregator = new SortedSetAggregator(field, state, dv);\n    for (MatchingDocs md : matchingDocs) {\n      aggregator.aggregate(md, facetArrays);\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for (FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8428426152984b387a961487efefbe9cf62acf","date":1385332540,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","sourceNew":null,"sourceOld":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    SortedSetAggregator aggregator = new SortedSetAggregator(field, state, dv);\n    for (MatchingDocs md : matchingDocs) {\n      aggregator.aggregate(md, facetArrays);\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for (FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new FacetLabel(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new FacetLabel(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new FacetLabel(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new FacetLabel(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator#accumulate(List[MatchingDocs]).mjava","sourceNew":null,"sourceOld":"  @Override\n  public List<FacetResult> accumulate(List<MatchingDocs> matchingDocs) throws IOException {\n\n    SortedSetAggregator aggregator = new SortedSetAggregator(field, state, dv);\n    for (MatchingDocs md : matchingDocs) {\n      aggregator.aggregate(md, facetArrays);\n    }\n\n    // compute top-K\n    List<FacetResult> results = new ArrayList<FacetResult>();\n\n    int[] counts = facetArrays.getIntArray();\n\n    BytesRef scratch = new BytesRef();\n\n    for (FacetRequest request : searchParams.facetRequests) {\n      String dim = request.categoryPath.components[0];\n      SortedSetDocValuesReaderState.OrdRange ordRange = state.getOrdRange(dim);\n      // checked in ctor:\n      assert ordRange != null;\n\n      if (request.numResults >= ordRange.end - ordRange.start + 1) {\n        // specialize this case, user is interested in all available results\n        ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();\n        int dimCount = 0;\n        for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n          //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n          if (counts[ord] != 0) {\n            dimCount += counts[ord];\n            FacetResultNode node = new FacetResultNode(ord, counts[ord]);\n            dv.lookupOrd(ord, scratch);\n            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n            nodes.add(node);\n          }\n        }\n\n        Collections.sort(nodes, new Comparator<FacetResultNode>() {\n            @Override\n            public int compare(FacetResultNode o1, FacetResultNode o2) {\n              // First by highest count\n              int value = (int) (o2.value - o1.value);\n              if (value == 0) {\n                // ... then by lowest ord:\n                value = o1.ordinal - o2.ordinal;\n              }\n              return value;\n            }\n          });\n      \n        CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n        if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n          dimCount = 0;\n        }\n\n        FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n        rootNode.label = new CategoryPath(new String[] {dim});\n        rootNode.subResults = nodes;\n        results.add(new FacetResult(request, rootNode, nodes.size()));\n        continue;\n      }\n\n      TopCountPQ q = new TopCountPQ(request.numResults);\n\n      int bottomCount = 0;\n\n      //System.out.println(\"collect\");\n      int dimCount = 0;\n      int childCount = 0;\n      FacetResultNode reuse = null;\n      for(int ord=ordRange.start; ord<=ordRange.end; ord++) {\n        //System.out.println(\"  ord=\" + ord + \" count= \"+ counts[ord] + \" bottomCount=\" + bottomCount);\n        if (counts[ord] > 0) {\n          childCount++;\n          if (counts[ord] > bottomCount) {\n            dimCount += counts[ord];\n            //System.out.println(\"    keep\");\n            if (reuse == null) {\n              reuse = new FacetResultNode(ord, counts[ord]);\n            } else {\n              reuse.ordinal = ord;\n              reuse.value = counts[ord];\n            }\n            reuse = q.insertWithOverflow(reuse);\n            if (q.size() == request.numResults) {\n              bottomCount = (int) q.top().value;\n              //System.out.println(\"    new bottom=\" + bottomCount);\n            }\n          }\n        }\n      }\n\n      CategoryListParams.OrdinalPolicy op = searchParams.indexingParams.getCategoryListParams(request.categoryPath).getOrdinalPolicy(dim);\n      if (op == CategoryListParams.OrdinalPolicy.ALL_BUT_DIMENSION) {\n        dimCount = 0;\n      }\n\n      FacetResultNode rootNode = new FacetResultNode(-1, dimCount);\n      rootNode.label = new CategoryPath(new String[] {dim});\n\n      FacetResultNode[] childNodes = new FacetResultNode[q.size()];\n      for(int i=childNodes.length-1;i>=0;i--) {\n        childNodes[i] = q.pop();\n        dv.lookupOrd(childNodes[i].ordinal, scratch);\n        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));\n      }\n      rootNode.subResults = Arrays.asList(childNodes);\n      \n      results.add(new FacetResult(request, rootNode, childCount));\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","2e8428426152984b387a961487efefbe9cf62acf"],"2e8428426152984b387a961487efefbe9cf62acf":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2e8428426152984b387a961487efefbe9cf62acf":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["2e8428426152984b387a961487efefbe9cf62acf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}