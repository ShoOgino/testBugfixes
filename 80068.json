{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","commits":[{"id":"1f6b20dc453cee198956989b90aa24bef0232bcf","date":1498221066,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5398bc4387a8e74fb85a7ddc7d8e89e56ed465ec","date":1499216175,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e0d9c88546c1a130d50b56981790d87a308daffd","date":1499234617,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15ba547dfc0dd0b670e678cb3db8e5d27c694420","date":1511865512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime() + \" expected diff: \" + TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS));\n          if (timeSource.getTime() - lastActionExecutedAt.get() < TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS)) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime() + \" expected diff: \" + TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS));\n          if (timeSource.getTime() - lastActionExecutedAt.get() < TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS)) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","date":1512481565,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        long currentTime = timeSource.getTime();\n        if (lastActionExecutedAt.get() != 0)  {\n          long minDiff = TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS);\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" current time = \" + currentTime +\n              \"\\nreal diff: \" + (currentTime - lastActionExecutedAt.get()) +\n              \"\\n min diff: \" + minDiff);\n          if (currentTime - lastActionExecutedAt.get() < minDiff) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(currentTime);\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime() + \" expected diff: \" + TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS));\n          if (timeSource.getTime() - lastActionExecutedAt.get() < TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS)) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","bugFix":["15ba547dfc0dd0b670e678cb3db8e5d27c694420","464244264804e3f981bf1fb4b732516d8d62dbc2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4412883c12067d8a4e2a354aa8adc58c32be1d6","date":1521129281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        long currentTime = timeSource.getTimeNs();\n        if (lastActionExecutedAt.get() != 0)  {\n          long minDiff = TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS);\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" current time = \" + currentTime +\n              \"\\nreal diff: \" + (currentTime - lastActionExecutedAt.get()) +\n              \"\\n min diff: \" + minDiff);\n          if (currentTime - lastActionExecutedAt.get() < minDiff) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(currentTime);\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        long currentTime = timeSource.getTime();\n        if (lastActionExecutedAt.get() != 0)  {\n          long minDiff = TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS);\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" current time = \" + currentTime +\n              \"\\nreal diff: \" + (currentTime - lastActionExecutedAt.get()) +\n              \"\\n min diff: \" + minDiff);\n          if (currentTime - lastActionExecutedAt.get() < minDiff) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(currentTime);\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc201e01d035a7370848d9d2451e0e27ee77df2e","date":1544724144,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        long currentTime = actionContext.getCloudManager().getTimeSource().getTimeNs();\n        if (lastActionExecutedAt.get() != 0)  {\n          long minDiff = TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS);\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" current time = \" + currentTime +\n              \"\\nreal diff: \" + (currentTime - lastActionExecutedAt.get()) +\n              \"\\n min diff: \" + minDiff);\n          if (currentTime - lastActionExecutedAt.get() < minDiff) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(currentTime);\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        long currentTime = timeSource.getTimeNs();\n        if (lastActionExecutedAt.get() != 0)  {\n          long minDiff = TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS);\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" current time = \" + currentTime +\n              \"\\nreal diff: \" + (currentTime - lastActionExecutedAt.get()) +\n              \"\\n min diff: \" + minDiff);\n          if (currentTime - lastActionExecutedAt.get() < minDiff) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(currentTime);\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        long currentTime = actionContext.getCloudManager().getTimeSource().getTimeNs();\n        if (lastActionExecutedAt.get() != 0)  {\n          long minDiff = TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS);\n          if (log.isInfoEnabled()) {\n            log.info(\"last action at {} current time = {}\\nreal diff: {}\\n min diff: {}\"\n                , lastActionExecutedAt.get(), currentTime\n                , (currentTime - lastActionExecutedAt.get())\n                , minDiff);\n          }\n          if (currentTime - lastActionExecutedAt.get() < minDiff) {\n            if (log.isInfoEnabled()) {\n              log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            }\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          if (log.isInfoEnabled()) {\n            log.info(\"action executed from {}\", event.getSource());\n          }\n          lastActionExecutedAt.set(currentTime);\n          getTriggerFiredLatch().countDown();\n        } else  {\n          if (log.isInfoEnabled()) {\n            log.info(\"action executed more than once from {}\", event.getSource());\n          }\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        long currentTime = actionContext.getCloudManager().getTimeSource().getTimeNs();\n        if (lastActionExecutedAt.get() != 0)  {\n          long minDiff = TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS);\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" current time = \" + currentTime +\n              \"\\nreal diff: \" + (currentTime - lastActionExecutedAt.get()) +\n              \"\\n min diff: \" + minDiff);\n          if (currentTime - lastActionExecutedAt.get() < minDiff) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(currentTime);\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent,ActionContext).mjava","sourceNew":null,"sourceOld":"    @Override\n    public void process(TriggerEvent event, ActionContext actionContext) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        long currentTime = actionContext.getCloudManager().getTimeSource().getTimeNs();\n        if (lastActionExecutedAt.get() != 0)  {\n          long minDiff = TimeUnit.MILLISECONDS.toNanos(throttlingDelayMs.get() - DELTA_MS);\n          if (log.isInfoEnabled()) {\n            log.info(\"last action at {} current time = {}\\nreal diff: {}\\n min diff: {}\"\n                , lastActionExecutedAt.get(), currentTime\n                , (currentTime - lastActionExecutedAt.get())\n                , minDiff);\n          }\n          if (currentTime - lastActionExecutedAt.get() < minDiff) {\n            if (log.isInfoEnabled()) {\n              log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            }\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          if (log.isInfoEnabled()) {\n            log.info(\"action executed from {}\", event.getSource());\n          }\n          lastActionExecutedAt.set(currentTime);\n          getTriggerFiredLatch().countDown();\n        } else  {\n          if (log.isInfoEnabled()) {\n            log.info(\"action executed more than once from {}\", event.getSource());\n          }\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e0d9c88546c1a130d50b56981790d87a308daffd"],"3f504512a03d978990cbff30db0522b354e846db":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"5398bc4387a8e74fb85a7ddc7d8e89e56ed465ec":["1f6b20dc453cee198956989b90aa24bef0232bcf"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["560c18d71dad43d675158783c3840f8c80d6d39c","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["560c18d71dad43d675158783c3840f8c80d6d39c"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["bc201e01d035a7370848d9d2451e0e27ee77df2e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"1f6b20dc453cee198956989b90aa24bef0232bcf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e0d9c88546c1a130d50b56981790d87a308daffd":["1f6b20dc453cee198956989b90aa24bef0232bcf","5398bc4387a8e74fb85a7ddc7d8e89e56ed465ec"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5398bc4387a8e74fb85a7ddc7d8e89e56ed465ec":["e0d9c88546c1a130d50b56981790d87a308daffd"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c","1f6b20dc453cee198956989b90aa24bef0232bcf"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["3f504512a03d978990cbff30db0522b354e846db"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["bc201e01d035a7370848d9d2451e0e27ee77df2e"],"e0d9c88546c1a130d50b56981790d87a308daffd":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"1f6b20dc453cee198956989b90aa24bef0232bcf":["5398bc4387a8e74fb85a7ddc7d8e89e56ed465ec","e0d9c88546c1a130d50b56981790d87a308daffd"],"560c18d71dad43d675158783c3840f8c80d6d39c":["1aad05eeff7818b0833c02ac6b743aa72054963b","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}