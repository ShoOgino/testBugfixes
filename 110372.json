{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","commits":[{"id":"f21ce13f410ee015e1ba14687ab4b8518ac52a11","date":1359713213,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"/dev/null","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    termsEnum = terms.iterator(random().nextBoolean() ? null : termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : docsEnum);\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n      bits.clear(0);\n      docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fa6955ed1b1007ded1349ab72cea4555640432f","date":1359721908,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"/dev/null","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    termsEnum = terms.iterator(random().nextBoolean() ? null : termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : docsEnum);\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n      bits.clear(0);\n      docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f5dc35fbd7ac2608de542ac2947ff8ab7b20b5a","date":1359818469,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    termsEnum = terms.iterator(random().nextBoolean() ? null : termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : docsEnum);\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n      bits.clear(0);\n      docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb97a913498e2387924cb19fb8be9a95daf6f38a","date":1359823388,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    termsEnum = terms.iterator(random().nextBoolean() ? null : termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : docsEnum);\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n      bits.clear(0);\n      docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes), random().nextBoolean()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms, terms.getComparator());\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<String>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<BytesRef>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6","date":1421884114,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception e) {\n            // ok\n          } catch (AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.FLAG_POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.FLAG_POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      DocsEnum docsEnum = termsEnum.docs(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      bits.set(0);\n\n      docsEnum = termsEnum.docs(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsEnum);\n      assertNotNull(docsEnum);\n      assertEquals(0, docsEnum.nextDoc());\n      assertEquals(0, docsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) docsEnum.freq());\n      assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n      this.docsEnum.set(docsEnum);\n\n      bits.clear(0);\n      DocsAndPositionsEnum docsAndPositionsEnum = termsEnum.docsAndPositions(bits, random().nextBoolean() ? null : this.docsAndPositionsEnum.get());\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.docsAndPositions(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(DocsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsAndPositionsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.FLAG_POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.FLAG_POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5311f0bff57ce15a23909f4cfb953773630534","date":1424827033,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      // nocommit: check\n      if (docsAndPositionsEnum != null) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0b81d743a15cd8d8e011856382d9ae1875d64c6","date":1427828269,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      if (terms.hasPositions()) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      // nocommit: check\n      if (docsAndPositionsEnum != null) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b4e3cd382d0d075a0f1725649c084bb6510c483","date":1428096423,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      if (terms.hasPositions()) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (docsAndPositionsEnum != null) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      assertEquals(ft.storeTermVectorOffsets() || ft.storeTermVectorPositions(), docsAndPositionsEnum != null);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator();\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      if (terms.hasPositions()) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator(random().nextBoolean() ? null : this.termsEnum.get());\n    this.termsEnum.set(termsEnum);\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      if (terms.hasPositions()) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator();\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      PostingsEnum postingsEnum = termsEnum.postings(null);\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(null);\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator();\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      final FixedBitSet bits = new FixedBitSet(1);\n      PostingsEnum postingsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      bits.set(0);\n\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      bits.clear(0);\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(bits, random().nextBoolean() ? null : this.docsEnum.get(), PostingsEnum.POSITIONS);\n      if (terms.hasPositions()) {\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      bits.set(0);\n\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? bits : null, random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f94c392daa8f5708186bede16c84eafad4cdd2","date":1599578873,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase#assertEquals(RandomTokenStream,FieldType,Terms).mjava","sourceNew":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator();\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      PostingsEnum postingsEnum = termsEnum.postings(null);\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(null);\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        for (int k = 0; k < freq; ++k) {\n          final int position = docsAndPositionsEnum.nextPosition();\n          final Set<Integer> indexes;\n          if (terms.hasPositions()) {\n            indexes = tk.positionToTerms.get(position);\n            assertNotNull(indexes);\n          } else {\n            indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n            assertNotNull(indexes);\n          }\n          if (terms.hasPositions()) {\n            boolean foundPosition = false;\n            for (int index : indexes) {\n              if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                foundPosition = true;\n                break;\n              }\n            }\n            assertTrue(foundPosition);\n          }\n          if (terms.hasOffsets()) {\n            boolean foundOffset = false;\n            for (int index : indexes) {\n              if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                foundOffset = true;\n                break;\n              }\n            }\n            assertTrue(foundOffset);\n          }\n          if (terms.hasPayloads()) {\n            boolean foundPayload = false;\n            for (int index : indexes) {\n              if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                foundPayload = true;\n                break;\n              }\n            }\n            assertTrue(foundPayload);\n          }\n        }\n        expectThrows(getReadPastLastPositionExceptionClass(), docsAndPositionsEnum::nextPosition);\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","sourceOld":"  protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) throws IOException {\n    assertEquals(1, terms.getDocCount());\n    final int termCount = new HashSet<>(Arrays.asList(tk.terms)).size();\n    assertEquals(termCount, terms.size());\n    assertEquals(termCount, terms.getSumDocFreq());\n    assertEquals(ft.storeTermVectorPositions(), terms.hasPositions());\n    assertEquals(ft.storeTermVectorOffsets(), terms.hasOffsets());\n    assertEquals(ft.storeTermVectorPayloads() && tk.hasPayloads(), terms.hasPayloads());\n    final Set<BytesRef> uniqueTerms = new HashSet<>();\n    for (String term : tk.freqs.keySet()) {\n      uniqueTerms.add(new BytesRef(term));\n    }\n    final BytesRef[] sortedTerms = uniqueTerms.toArray(new BytesRef[0]);\n    Arrays.sort(sortedTerms);\n    final TermsEnum termsEnum = terms.iterator();\n    for (int i = 0; i < sortedTerms.length; ++i) {\n      final BytesRef nextTerm = termsEnum.next();\n      assertEquals(sortedTerms[i], nextTerm);\n      assertEquals(sortedTerms[i], termsEnum.term());\n      assertEquals(1, termsEnum.docFreq());\n\n      PostingsEnum postingsEnum = termsEnum.postings(null);\n      postingsEnum = termsEnum.postings(random().nextBoolean() ? null : postingsEnum);\n      assertNotNull(postingsEnum);\n      assertEquals(0, postingsEnum.nextDoc());\n      assertEquals(0, postingsEnum.docID());\n      assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) postingsEnum.freq());\n      assertEquals(PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n      this.docsEnum.set(postingsEnum);\n\n      PostingsEnum docsAndPositionsEnum = termsEnum.postings(null);\n      docsAndPositionsEnum = termsEnum.postings(random().nextBoolean() ? null : docsAndPositionsEnum, PostingsEnum.POSITIONS);\n      if (terms.hasPositions() || terms.hasOffsets()) {\n        assertEquals(0, docsAndPositionsEnum.nextDoc());\n        final int freq = docsAndPositionsEnum.freq();\n        assertEquals(tk.freqs.get(termsEnum.term().utf8ToString()), (Integer) freq);\n        if (docsAndPositionsEnum != null) {\n          for (int k = 0; k < freq; ++k) {\n            final int position = docsAndPositionsEnum.nextPosition();\n            final Set<Integer> indexes;\n            if (terms.hasPositions()) {\n              indexes = tk.positionToTerms.get(position);\n              assertNotNull(indexes);\n            } else {\n              indexes = tk.startOffsetToTerms.get(docsAndPositionsEnum.startOffset());\n              assertNotNull(indexes);\n            }\n            if (terms.hasPositions()) {\n              boolean foundPosition = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.positions[index] == position) {\n                  foundPosition = true;\n                  break;\n                }\n              }\n              assertTrue(foundPosition);\n            }\n            if (terms.hasOffsets()) {\n              boolean foundOffset = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && tk.startOffsets[index] == docsAndPositionsEnum.startOffset() && tk.endOffsets[index] == docsAndPositionsEnum.endOffset()) {\n                  foundOffset = true;\n                  break;\n                }\n              }\n              assertTrue(foundOffset);\n            }\n            if (terms.hasPayloads()) {\n              boolean foundPayload = false;\n              for (int index : indexes) {\n                if (tk.termBytes[index].equals(termsEnum.term()) && equals(tk.payloads[index], docsAndPositionsEnum.getPayload())) {\n                  foundPayload = true;\n                  break;\n                }\n              }\n              assertTrue(foundPayload);\n            }\n          }\n          try {\n            docsAndPositionsEnum.nextPosition();\n            fail();\n          } catch (Exception | AssertionError e) {\n            // ok\n          }\n        }\n        assertEquals(PostingsEnum.NO_MORE_DOCS, docsAndPositionsEnum.nextDoc());\n      }\n      this.docsEnum.set(docsAndPositionsEnum);\n    }\n    assertNull(termsEnum.next());\n    for (int i = 0; i < 5; ++i) {\n      if (random().nextBoolean()) {\n        assertTrue(termsEnum.seekExact(RandomPicks.randomFrom(random(), tk.termBytes)));\n      } else {\n        assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(RandomPicks.randomFrom(random(), tk.termBytes)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["6b4e3cd382d0d075a0f1725649c084bb6510c483"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"c9f94c392daa8f5708186bede16c84eafad4cdd2":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"5f5dc35fbd7ac2608de542ac2947ff8ab7b20b5a":["f21ce13f410ee015e1ba14687ab4b8518ac52a11"],"d0b81d743a15cd8d8e011856382d9ae1875d64c6":["cb5311f0bff57ce15a23909f4cfb953773630534"],"51f5280f31484820499077f41fcdfe92d527d9dc":["5891bd634d5ddbf7c48cff0f4818c682ca42a4a6"],"cb5311f0bff57ce15a23909f4cfb953773630534":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"0fa6955ed1b1007ded1349ab72cea4555640432f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f21ce13f410ee015e1ba14687ab4b8518ac52a11"],"eb97a913498e2387924cb19fb8be9a95daf6f38a":["0fa6955ed1b1007ded1349ab72cea4555640432f","5f5dc35fbd7ac2608de542ac2947ff8ab7b20b5a"],"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"6b4e3cd382d0d075a0f1725649c084bb6510c483":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4","d0b81d743a15cd8d8e011856382d9ae1875d64c6"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["5f5dc35fbd7ac2608de542ac2947ff8ab7b20b5a"],"f21ce13f410ee015e1ba14687ab4b8518ac52a11":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["5f5dc35fbd7ac2608de542ac2947ff8ab7b20b5a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9f94c392daa8f5708186bede16c84eafad4cdd2"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5891bd634d5ddbf7c48cff0f4818c682ca42a4a6"],"c9f94c392daa8f5708186bede16c84eafad4cdd2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5f5dc35fbd7ac2608de542ac2947ff8ab7b20b5a":["eb97a913498e2387924cb19fb8be9a95daf6f38a","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"d0b81d743a15cd8d8e011856382d9ae1875d64c6":["6b4e3cd382d0d075a0f1725649c084bb6510c483"],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"cb5311f0bff57ce15a23909f4cfb953773630534":["d0b81d743a15cd8d8e011856382d9ae1875d64c6"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["c9f94c392daa8f5708186bede16c84eafad4cdd2"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["cb5311f0bff57ce15a23909f4cfb953773630534","6b4e3cd382d0d075a0f1725649c084bb6510c483"],"0fa6955ed1b1007ded1349ab72cea4555640432f":["eb97a913498e2387924cb19fb8be9a95daf6f38a"],"eb97a913498e2387924cb19fb8be9a95daf6f38a":[],"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6":["51f5280f31484820499077f41fcdfe92d527d9dc"],"6b4e3cd382d0d075a0f1725649c084bb6510c483":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0fa6955ed1b1007ded1349ab72cea4555640432f","f21ce13f410ee015e1ba14687ab4b8518ac52a11"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"f21ce13f410ee015e1ba14687ab4b8518ac52a11":["5f5dc35fbd7ac2608de542ac2947ff8ab7b20b5a","0fa6955ed1b1007ded1349ab72cea4555640432f"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["eb97a913498e2387924cb19fb8be9a95daf6f38a","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}