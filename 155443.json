{"path":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"/dev/null","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":null,"sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"/dev/null","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec3ba1d2792d1ffb27f73257ac395fb32728705e","date":1275503651,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5f3a3bdd2298a698af763bc4a4e6510f0b3549f","date":1284226094,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","date":1296400215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81c86ba78280d33631b3536414395ad80a19a8af","date":1302972671,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d493718201f0d0c54c773fb323d87bbd2fbffe41","date":1303546048,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["d5f3a3bdd2298a698af763bc4a4e6510f0b3549f"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["81c86ba78280d33631b3536414395ad80a19a8af","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","81c86ba78280d33631b3536414395ad80a19a8af"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["ec3ba1d2792d1ffb27f73257ac395fb32728705e","d5f3a3bdd2298a698af763bc4a4e6510f0b3549f"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":["bde51b089eb7f86171eb3406e38a274743f9b7ac","81c86ba78280d33631b3536414395ad80a19a8af"],"ec3ba1d2792d1ffb27f73257ac395fb32728705e":["1da8d55113b689b06716246649de6f62430f15c0"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"81c86ba78280d33631b3536414395ad80a19a8af":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a3776dccca01c11e7046323cfad46a3b4a471233"],"a3776dccca01c11e7046323cfad46a3b4a471233":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","81c86ba78280d33631b3536414395ad80a19a8af"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d5f3a3bdd2298a698af763bc4a4e6510f0b3549f","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["81c86ba78280d33631b3536414395ad80a19a8af"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"d5f3a3bdd2298a698af763bc4a4e6510f0b3549f":["ec3ba1d2792d1ffb27f73257ac395fb32728705e"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["81c86ba78280d33631b3536414395ad80a19a8af","a3776dccca01c11e7046323cfad46a3b4a471233","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":[],"ec3ba1d2792d1ffb27f73257ac395fb32728705e":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d5f3a3bdd2298a698af763bc4a4e6510f0b3549f"],"1da8d55113b689b06716246649de6f62430f15c0":["ec3ba1d2792d1ffb27f73257ac395fb32728705e"],"81c86ba78280d33631b3536414395ad80a19a8af":["c26f00b574427b55127e869b935845554afde1fa","135621f3a0670a9394eb563224a3b76cc4dddc0f","d493718201f0d0c54c773fb323d87bbd2fbffe41","a3776dccca01c11e7046323cfad46a3b4a471233","a258fbb26824fd104ed795e5d9033d2d040049ee"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"d5f3a3bdd2298a698af763bc4a4e6510f0b3549f":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","29ef99d61cda9641b6250bf9567329a6e65f901d"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["d493718201f0d0c54c773fb323d87bbd2fbffe41"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","d493718201f0d0c54c773fb323d87bbd2fbffe41","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}