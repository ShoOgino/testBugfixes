{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","commits":[{"id":"e22ffe8cc51a892ae103df018822d7873e901c2a","date":1313696790,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = r.getFieldNames(IndexReader.FieldOption.ALL);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache) {\n    super(r);\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (r.directory() instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) r.directory();\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = r.getFieldNames(IndexReader.FieldOption.ALL);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3321cfbf7f8aba27e37e7a4d6901531a97ac2b06","date":1326148180,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = r.getFieldNames(IndexReader.FieldOption.ALL);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d","058801f8673d53a5abac8088204860ec29a40f0d","058801f8673d53a5abac8088204860ec29a40f0d","058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":5,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0d22ac6a4146774c1bc8400160fc0b6150294e92":["3321cfbf7f8aba27e37e7a4d6901531a97ac2b06","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"96d207426bd26fa5c1014e26d21d87603aea68b7":["0d22ac6a4146774c1bc8400160fc0b6150294e92"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["3321cfbf7f8aba27e37e7a4d6901531a97ac2b06","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["3321cfbf7f8aba27e37e7a4d6901531a97ac2b06"],"3321cfbf7f8aba27e37e7a4d6901531a97ac2b06":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","96d207426bd26fa5c1014e26d21d87603aea68b7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5cab9a86bd67202d20b6adc463008c8e982b070a"]},"commit2Childs":{"0d22ac6a4146774c1bc8400160fc0b6150294e92":["96d207426bd26fa5c1014e26d21d87603aea68b7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","5cab9a86bd67202d20b6adc463008c8e982b070a"],"3321cfbf7f8aba27e37e7a4d6901531a97ac2b06":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["3321cfbf7f8aba27e37e7a4d6901531a97ac2b06"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}