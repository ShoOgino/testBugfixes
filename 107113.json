{"path":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#testExpectedSortOrdering(String,boolean,Object...).mjava","commits":[{"id":"4cf2282b6a7c3f113e7a233b785b80527c03d590","date":1516129064,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#testExpectedSortOrdering(String,boolean,Object...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a (multivalued) field name and an (ascending) sorted list of values, this method uses {@link #buildMultiValueSortedDocuments} to generate and test multiple function &amp; sort permutations ...\n   * <ul>\n   *  <li><code>f asc</code> (implicitly min)</li>\n   *  <li><code>field(f,min) asc</code></li>\n   *  <li><code>field(f,min) desc</code></li>\n   *  <li><code>f desc</code> (implicitly max)</li>\n   *  <li><code>field(f,max) desc</code></li>\n   *  <li><code>field(f,max) asc</code></li>\n   * </ul>\n   *\n   * <p>\n   * <b>NOTE:</b> if the sortedValues includes \"null\" then the field must <em>NOT</em> use <code>sortMissingFirst</code> or <code>sortMissingLast</code></b>\n   * </p>\n   *\n   * @param f the field to test\n   * @param trieFieldHack if this param and {@link #NUMERIC_POINTS_SYSPROP} are both true, then the <code>field(f,min|max)</code> functions will be wrapped in <code>def(...,0)</code> and the implicit <code>f asc|desc</code> syntax will not be tested -- see SOLR-8005 for the reason.\n   * @param sortedValues the values to use when building the docs and validating the sort\n   *\n   * @see #buildMultiValueSortedDocuments\n   * @see #testExpectedSortOrdering(String,List)\n   * @see #clearIndex\n   */\n  private void testExpectedSortOrdering(final String f, boolean trieFieldHack,\n                                        Object... sortedValues) {\n\n    SchemaField sf = h.getCore().getLatestSchema().getField(f);\n    assertFalse(\"this utility method does not work with fields that are sortMissingFirst|Last: \" + f,\n                sf.sortMissingFirst() || sf.sortMissingLast());\n    \n    // make a copy we can re-order later\n    final List<Object> vals = new ArrayList<Object>(sortedValues.length);\n    Collections.addAll(vals, sortedValues);\n      \n    String minFunc = \"field(\"+f+\",min)\";\n    String maxFunc = \"field(\"+f+\",max)\";\n\n    if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n      // we don't need to mess with this hack at all if we're using all point numerics\n      trieFieldHack = false;\n    }\n\n    if (trieFieldHack // SOLR-8005\n        // if this line of code stops compiling, then trie fields have been removed from solr\n        // and the entire trieFieldHack param should be removed from this method (and callers)\n        && null != TrieField.class) {\n      \n      // the SOLR-8005 hack is only needed if/when a doc has no value...\n      trieFieldHack = false; // assume we're safe\n      for (Object val : vals) {\n        if (null == val) { // we're not safe\n          trieFieldHack = true;\n          break;\n        }\n      }\n    }\n    if (trieFieldHack) {\n      // if we've made it this far, and we still need the hack, we have to wrap our\n      // functions with a default...\n      minFunc = \"def(\" + minFunc + \",0)\";\n      maxFunc = \"def(\" + maxFunc + \",0)\";\n      // and we can't test implicit min/max default behavior...\n    }\n    \n    // // // // min\n    \n    final List<SolrInputDocument> min_asc = buildMultiValueSortedDocuments(f, vals);\n    \n    // explicit min + asc\n    testExpectedSortOrdering(minFunc + \" asc\", min_asc);\n    // implicit: asc -> min\n    if (!trieFieldHack) testExpectedSortOrdering(f + \" asc\", min_asc);\n    \n    final List<SolrInputDocument> min_desc = new ArrayList<>(min_asc);\n    Collections.reverse(min_desc);\n    \n    // explicit min + desc\n    testExpectedSortOrdering(minFunc + \" desc\", min_desc);\n\n    // // // // max\n    Collections.reverse(vals);\n    \n    final List<SolrInputDocument> max_desc = buildMultiValueSortedDocuments(f, vals);\n\n    // explicit: max + desc\n    testExpectedSortOrdering(maxFunc +\" desc\", max_desc);\n    // implicit: desc -> max\n    if (!trieFieldHack) testExpectedSortOrdering(f + \" desc\", max_desc); \n    \n    final List<SolrInputDocument> max_asc = new ArrayList<>(max_desc);\n    Collections.reverse(max_asc);\n    \n    // explicit max + asc\n    testExpectedSortOrdering(maxFunc + \" asc\", max_asc);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#testExpectedSortOrdering(String,boolean,Object...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a (multivalued) field name and an (ascending) sorted list of values, this method uses {@link #buildMultiValueSortedDocuments} to generate and test multiple function &amp; sort permutations ...\n   * <ul>\n   *  <li><code>f asc</code> (implicitly min)</li>\n   *  <li><code>field(f,min) asc</code></li>\n   *  <li><code>field(f,min) desc</code></li>\n   *  <li><code>f desc</code> (implicitly max)</li>\n   *  <li><code>field(f,max) desc</code></li>\n   *  <li><code>field(f,max) asc</code></li>\n   * </ul>\n   *\n   * <p>\n   * <b>NOTE:</b> if the sortedValues includes \"null\" then the field must <em>NOT</em> use <code>sortMissingFirst</code> or <code>sortMissingLast</code></b>\n   * </p>\n   *\n   * @param f the field to test\n   * @param trieFieldHack if this param and {@link #NUMERIC_POINTS_SYSPROP} are both true, then the <code>field(f,min|max)</code> functions will be wrapped in <code>def(...,0)</code> and the implicit <code>f asc|desc</code> syntax will not be tested -- see SOLR-8005 for the reason.\n   * @param sortedValues the values to use when building the docs and validating the sort\n   *\n   * @see #buildMultiValueSortedDocuments\n   * @see #testExpectedSortOrdering(String,List)\n   * @see #clearIndex\n   */\n  private void testExpectedSortOrdering(final String f, boolean trieFieldHack,\n                                        Object... sortedValues) {\n\n    SchemaField sf = h.getCore().getLatestSchema().getField(f);\n    assertFalse(\"this utility method does not work with fields that are sortMissingFirst|Last: \" + f,\n                sf.sortMissingFirst() || sf.sortMissingLast());\n    \n    // make a copy we can re-order later\n    final List<Object> vals = new ArrayList<Object>(sortedValues.length);\n    Collections.addAll(vals, sortedValues);\n      \n    String minFunc = \"field(\"+f+\",min)\";\n    String maxFunc = \"field(\"+f+\",max)\";\n\n    if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n      // we don't need to mess with this hack at all if we're using all point numerics\n      trieFieldHack = false;\n    }\n\n    if (trieFieldHack // SOLR-8005\n        // if this line of code stops compiling, then trie fields have been removed from solr\n        // and the entire trieFieldHack param should be removed from this method (and callers)\n        && null != TrieField.class) {\n      \n      // the SOLR-8005 hack is only needed if/when a doc has no value...\n      trieFieldHack = false; // assume we're safe\n      for (Object val : vals) {\n        if (null == val) { // we're not safe\n          trieFieldHack = true;\n          break;\n        }\n      }\n    }\n    if (trieFieldHack) {\n      // if we've made it this far, and we still need the hack, we have to wrap our\n      // functions with a default...\n      minFunc = \"def(\" + minFunc + \",0)\";\n      maxFunc = \"def(\" + maxFunc + \",0)\";\n      // and we can't test implicit min/max default behavior...\n    }\n    \n    // // // // min\n    \n    final List<SolrInputDocument> min_asc = buildMultiValueSortedDocuments(f, vals);\n    \n    // explicit min + asc\n    testExpectedSortOrdering(minFunc + \" asc\", min_asc);\n    // implicit: asc -> min\n    if (!trieFieldHack) testExpectedSortOrdering(f + \" asc\", min_asc);\n    \n    final List<SolrInputDocument> min_desc = new ArrayList<>(min_asc);\n    Collections.reverse(min_desc);\n    \n    // explicit min + desc\n    testExpectedSortOrdering(minFunc + \" desc\", min_desc);\n\n    // // // // max\n    Collections.reverse(vals);\n    \n    final List<SolrInputDocument> max_desc = buildMultiValueSortedDocuments(f, vals);\n\n    // explicit: max + desc\n    testExpectedSortOrdering(maxFunc +\" desc\", max_desc);\n    // implicit: desc -> max\n    if (!trieFieldHack) testExpectedSortOrdering(f + \" desc\", max_desc); \n    \n    final List<SolrInputDocument> max_asc = new ArrayList<>(max_desc);\n    Collections.reverse(max_asc);\n    \n    // explicit max + asc\n    testExpectedSortOrdering(maxFunc + \" asc\", max_asc);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4cf2282b6a7c3f113e7a233b785b80527c03d590"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cf2282b6a7c3f113e7a233b785b80527c03d590":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","4cf2282b6a7c3f113e7a233b785b80527c03d590"],"4cf2282b6a7c3f113e7a233b785b80527c03d590":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}