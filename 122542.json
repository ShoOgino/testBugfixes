{"path":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","commits":[{"id":"106069d345c14ee5c76f0ea76397b02a656f883c","date":1411998064,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"/dev/null","sourceNew":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+stat.getVersion()+\" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          ManagedIndexSchema newSchema = oldSchema.reloadFields(inputSource, stat.getVersion());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["dbf14a58688f4f8d0fa6375733fbe8cfed9aac43"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1596015c8bad249c0b9a52182de1d47e1d56fdde","date":1412350121,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","sourceNew":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+stat.getVersion()+\" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          ManagedIndexSchema newSchema = oldSchema.reloadFields(inputSource, stat.getVersion());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+stat.getVersion()+\" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          ManagedIndexSchema newSchema = oldSchema.reloadFields(inputSource, stat.getVersion());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"/dev/null","sourceNew":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+stat.getVersion()+\" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          ManagedIndexSchema newSchema = oldSchema.reloadFields(inputSource, stat.getVersion());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeeea2295d6355a29e259130a5c48ace73022d7c","date":1426569216,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","sourceNew":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource,\n                  managedIndexSchemaFactory.isMutable(), resourceName, stat.getVersion(), new Object());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+stat.getVersion()+\" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          ManagedIndexSchema newSchema = oldSchema.reloadFields(inputSource, stat.getVersion());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c7e8d59fbf173ad3326aa0452c248fb1e6c0b62","date":1426694087,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","sourceNew":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource,\n                  managedIndexSchemaFactory.isMutable(), resourceName, stat.getVersion(), new Object());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","sourceNew":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+stat.getVersion()+\" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          ManagedIndexSchema newSchema = oldSchema.reloadFields(inputSource, stat.getVersion());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbf14a58688f4f8d0fa6375733fbe8cfed9aac43","date":1498572460,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","sourceNew":"  // package visibility for test purposes\n  void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","bugFix":["106069d345c14ee5c76f0ea76397b02a656f883c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98f11c416d30e556e0004a9a84960702d12d35b1","date":1498628359,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","sourceNew":"  // package visibility for test purposes\n  void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","sourceNew":"  // package visibility for test purposes\n  void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ZkIndexSchemaReader#updateSchema(Watcher,int).mjava","sourceNew":"  // package visibility for test purposes\n  void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Retrieved schema version {} from Zookeeper\", stat.getVersion());\n          }\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in {} ms\", TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS));\n        } else {\n          log.info(\"Current schema version {} is already the latest\", oldSchema.schemaZkVersion);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // package visibility for test purposes\n  void updateSchema(Watcher watcher, int expectedZkVersion) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    synchronized (getSchemaUpdateLock()) {\n      final ManagedIndexSchema oldSchema = managedIndexSchemaFactory.getSchema();\n      if (expectedZkVersion == -1 || oldSchema.schemaZkVersion < expectedZkVersion) {\n        byte[] data = zkClient.getData(managedSchemaPath, watcher, stat, true);\n        if (stat.getVersion() != oldSchema.schemaZkVersion) {\n          log.info(\"Retrieved schema version \"+ stat.getVersion() + \" from ZooKeeper\");\n          long start = System.nanoTime();\n          InputSource inputSource = new InputSource(new ByteArrayInputStream(data));\n          String resourceName = managedIndexSchemaFactory.getManagedSchemaResourceName();\n          ManagedIndexSchema newSchema = new ManagedIndexSchema\n              (managedIndexSchemaFactory.getConfig(), resourceName, inputSource, managedIndexSchemaFactory.isMutable(), \n                  resourceName, stat.getVersion(), oldSchema.getSchemaUpdateLock());\n          managedIndexSchemaFactory.setSchema(newSchema);\n          long stop = System.nanoTime();\n          log.info(\"Finished refreshing schema in \" + TimeUnit.MILLISECONDS.convert(stop - start, TimeUnit.NANOSECONDS) + \" ms\");\n        } else {\n          log.info(\"Current schema version \"+oldSchema.schemaZkVersion+\" is already the latest\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["1596015c8bad249c0b9a52182de1d47e1d56fdde","1c7e8d59fbf173ad3326aa0452c248fb1e6c0b62"],"1c7e8d59fbf173ad3326aa0452c248fb1e6c0b62":["eeeea2295d6355a29e259130a5c48ace73022d7c"],"1596015c8bad249c0b9a52182de1d47e1d56fdde":["106069d345c14ee5c76f0ea76397b02a656f883c"],"dbf14a58688f4f8d0fa6375733fbe8cfed9aac43":["1c7e8d59fbf173ad3326aa0452c248fb1e6c0b62"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["1596015c8bad249c0b9a52182de1d47e1d56fdde"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1596015c8bad249c0b9a52182de1d47e1d56fdde"],"106069d345c14ee5c76f0ea76397b02a656f883c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["1c7e8d59fbf173ad3326aa0452c248fb1e6c0b62","dbf14a58688f4f8d0fa6375733fbe8cfed9aac43"],"98f11c416d30e556e0004a9a84960702d12d35b1":["1c7e8d59fbf173ad3326aa0452c248fb1e6c0b62","dbf14a58688f4f8d0fa6375733fbe8cfed9aac43"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9df8125ba9193a2e2e285ed92157810b1952a244":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"1596015c8bad249c0b9a52182de1d47e1d56fdde":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","eeeea2295d6355a29e259130a5c48ace73022d7c","d9a47902d6207303f5ed3e7aaca62ca33433af66"],"1c7e8d59fbf173ad3326aa0452c248fb1e6c0b62":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","dbf14a58688f4f8d0fa6375733fbe8cfed9aac43","28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"dbf14a58688f4f8d0fa6375733fbe8cfed9aac43":["28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["1c7e8d59fbf173ad3326aa0452c248fb1e6c0b62"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9a47902d6207303f5ed3e7aaca62ca33433af66","106069d345c14ee5c76f0ea76397b02a656f883c"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"106069d345c14ee5c76f0ea76397b02a656f883c":["1596015c8bad249c0b9a52182de1d47e1d56fdde"],"28288370235ed02234a64753cdbf0c6ec096304a":["9df8125ba9193a2e2e285ed92157810b1952a244"],"98f11c416d30e556e0004a9a84960702d12d35b1":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9df8125ba9193a2e2e285ed92157810b1952a244":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d9a47902d6207303f5ed3e7aaca62ca33433af66","98f11c416d30e556e0004a9a84960702d12d35b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}