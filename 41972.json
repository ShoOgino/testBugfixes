{"path":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","commits":[{"id":"b77550c47735d804ddb8767848f5af9b02b88c84","date":1162245631,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","pathOld":"/dev/null","sourceNew":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (lazySkipPointer != 0) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = 0;\n    }\n     \n    if (lazySkipDocCount != 0) {\n      skipPositions(lazySkipDocCount);\n      lazySkipDocCount = 0;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["56f0812b01cb0620e0240c4c705162386719f24a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"351f55f384b26438bd93e6251597bbe35147f491","date":1173596800,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","sourceNew":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput)parent.proxStream.clone();\n    }\n      \n    if (lazySkipPointer != 0) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = 0;\n    }\n     \n    if (lazySkipDocCount != 0) {\n      skipPositions(lazySkipDocCount);\n      lazySkipDocCount = 0;\n    }\n  }\n\n","sourceOld":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (lazySkipPointer != 0) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = 0;\n    }\n     \n    if (lazySkipDocCount != 0) {\n      skipPositions(lazySkipDocCount);\n      lazySkipDocCount = 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bafc62307b6118053948fd691fe0ed618191914","date":1173644959,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","sourceNew":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput)parent.proxStream.clone();\n    }\n      \n    if (lazySkipPointer != 0) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = 0;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","sourceOld":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput)parent.proxStream.clone();\n    }\n      \n    if (lazySkipPointer != 0) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = 0;\n    }\n     \n    if (lazySkipDocCount != 0) {\n      skipPositions(lazySkipDocCount);\n      lazySkipDocCount = 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8522ae207a56c6db28ca06fe6cc33e70911c3600","date":1173935743,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","sourceNew":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput)parent.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != 0) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = 0;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","sourceOld":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput)parent.proxStream.clone();\n    }\n      \n    if (lazySkipPointer != 0) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = 0;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56f0812b01cb0620e0240c4c705162386719f24a","date":1184256894,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","sourceNew":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput)parent.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != -1) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = -1;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","sourceOld":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput)parent.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != 0) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = 0;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","bugFix":["b77550c47735d804ddb8767848f5af9b02b88c84"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66f3dadb253a44f4cccc81c8a21b685b18b201fb","date":1247245699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","sourceNew":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput) parent.core.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != -1) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = -1;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","sourceOld":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput)parent.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != -1) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = -1;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","sourceNew":"  // It is not always necessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput) parent.core.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != -1) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = -1;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","sourceOld":"  // It is not always neccessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput) parent.core.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != -1) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = -1;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermPositions#lazySkip().mjava","sourceNew":"  // It is not always necessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput) parent.core.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != -1) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = -1;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","sourceOld":"  // It is not always necessary to move the prox pointer\n  // to a new document after the freq pointer has been moved.\n  // Consider for example a phrase query with two terms:\n  // the freq pointer for term 1 has to move to document x\n  // to answer the question if the term occurs in that document. But\n  // only if term 2 also matches document x, the positions have to be\n  // read to figure out if term 1 and term 2 appear next\n  // to each other in document x and thus satisfy the query.\n  // So we move the prox pointer lazily to the document\n  // as soon as positions are requested.\n  private void lazySkip() throws IOException {\n    if (proxStream == null) {\n      // clone lazily\n      proxStream = (IndexInput) parent.core.proxStream.clone();\n    }\n    \n    // we might have to skip the current payload\n    // if it was not read yet\n    skipPayload();\n      \n    if (lazySkipPointer != -1) {\n      proxStream.seek(lazySkipPointer);\n      lazySkipPointer = -1;\n    }\n     \n    if (lazySkipProxCount != 0) {\n      skipPositions(lazySkipProxCount);\n      lazySkipProxCount = 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"56f0812b01cb0620e0240c4c705162386719f24a":["8522ae207a56c6db28ca06fe6cc33e70911c3600"],"0bafc62307b6118053948fd691fe0ed618191914":["351f55f384b26438bd93e6251597bbe35147f491"],"8522ae207a56c6db28ca06fe6cc33e70911c3600":["0bafc62307b6118053948fd691fe0ed618191914"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["66f3dadb253a44f4cccc81c8a21b685b18b201fb"],"351f55f384b26438bd93e6251597bbe35147f491":["b77550c47735d804ddb8767848f5af9b02b88c84"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"66f3dadb253a44f4cccc81c8a21b685b18b201fb":["56f0812b01cb0620e0240c4c705162386719f24a"],"b77550c47735d804ddb8767848f5af9b02b88c84":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"56f0812b01cb0620e0240c4c705162386719f24a":["66f3dadb253a44f4cccc81c8a21b685b18b201fb"],"0bafc62307b6118053948fd691fe0ed618191914":["8522ae207a56c6db28ca06fe6cc33e70911c3600"],"8522ae207a56c6db28ca06fe6cc33e70911c3600":["56f0812b01cb0620e0240c4c705162386719f24a"],"351f55f384b26438bd93e6251597bbe35147f491":["0bafc62307b6118053948fd691fe0ed618191914"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b77550c47735d804ddb8767848f5af9b02b88c84"],"66f3dadb253a44f4cccc81c8a21b685b18b201fb":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"b77550c47735d804ddb8767848f5af9b02b88c84":["351f55f384b26438bd93e6251597bbe35147f491"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}