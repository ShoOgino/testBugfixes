{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillDown#query(FacetIndexingParams,Query,Occur,CategoryPath...).mjava","commits":[{"id":"9fa7a3db4fa6c77f454964f515841c097ca09212","date":1359119468,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillDown#query(FacetIndexingParams,Query,Occur,CategoryPath...).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillDown#query(FacetIndexingParams,Query,CategoryPath...).mjava","sourceNew":"  /**\n   * Wraps a given {@link Query} by a drill-down query over the given\n   * categories. {@link Occur} defines the relationship between the cateories\n   * (e.g. {@code OR} or {@code AND}. If you need to construct a more\n   * complicated relationship, e.g. {@code AND} of {@code ORs}), call this\n   * method with every group of categories with the same relationship and then\n   * construct a {@link BooleanQuery} which will wrap all returned queries. It\n   * is advised to construct that boolean query with coord disabled, and also\n   * wrap the final query with {@link ConstantScoreQuery} and set its boost to\n   * {@code 0.0f}.\n   * <p>\n   * <b>NOTE:</b> {@link Occur} only makes sense when there is more than one\n   * {@link CategoryPath} given.\n   * <p>\n   * <b>NOTE:</b> {@code baseQuery} can be {@code null}, in which case only the\n   * {@link Query} over the categories will is returned.\n   */\n  public static final Query query(FacetIndexingParams iParams, Query baseQuery, Occur occur, CategoryPath... paths) {\n    if (paths == null || paths.length == 0) {\n      throw new IllegalArgumentException(\"Empty category path not allowed for drill down query!\");\n    }\n    \n    final Query q;\n    if (paths.length == 1) {\n      q = new TermQuery(term(iParams, paths[0]));\n    } else {\n      BooleanQuery bq = new BooleanQuery(true); // disable coord\n      for (CategoryPath cp : paths) {\n        bq.add(new TermQuery(term(iParams, cp)), occur);\n      }\n      q = bq;\n    }\n\n    final ConstantScoreQuery drillDownQuery = new ConstantScoreQuery(q);\n    drillDownQuery.setBoost(0.0f);\n\n    if (baseQuery == null) {\n      return drillDownQuery;\n    } else {\n      BooleanQuery res = new BooleanQuery(true);\n      res.add(baseQuery, Occur.MUST);\n      res.add(drillDownQuery, Occur.MUST);\n      return res;\n    }\n  }\n\n","sourceOld":"  /**\n   * Wraps a given {@link Query} as a drill-down query over the given\n   * categories, assuming all are required (e.g. {@code AND}). You can construct\n   * a query with different modes (such as {@code OR} or {@code AND} of\n   * {@code ORs}) by creating a {@link BooleanQuery} and call this method\n   * several times. Make sure to wrap the query in that case by\n   * {@link ConstantScoreQuery} and set the boost to 0.0f, so that it doesn't\n   * affect scoring.\n   * <p>\n   * <b>NOTE:</b> {@code baseQuery} can be {@code null}, in which case only the\n   * {@link Query} over the categories will is returned.\n   */\n  public static final Query query(FacetIndexingParams iParams, Query baseQuery, CategoryPath... paths) {\n    if (paths == null || paths.length == 0) {\n      throw new IllegalArgumentException(\"Empty category path not allowed for drill down query!\");\n    }\n    \n    final Query q;\n    if (paths.length == 1) {\n      q = new TermQuery(term(iParams, paths[0]));\n    } else {\n      BooleanQuery bq = new BooleanQuery(true); // disable coord\n      for (CategoryPath cp : paths) {\n        bq.add(new TermQuery(term(iParams, cp)), Occur.MUST);\n      }\n      q = bq;\n    }\n\n    final ConstantScoreQuery drillDownQuery = new ConstantScoreQuery(q);\n    drillDownQuery.setBoost(0.0f);\n\n    if (baseQuery == null) {\n      return drillDownQuery;\n    } else {\n      BooleanQuery res = new BooleanQuery(true);\n      res.add(baseQuery, Occur.MUST);\n      res.add(drillDownQuery, Occur.MUST);\n      return res;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillDown#query(FacetIndexingParams,Query,Occur,CategoryPath...).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillDown#query(FacetIndexingParams,Query,CategoryPath...).mjava","sourceNew":"  /**\n   * Wraps a given {@link Query} by a drill-down query over the given\n   * categories. {@link Occur} defines the relationship between the cateories\n   * (e.g. {@code OR} or {@code AND}. If you need to construct a more\n   * complicated relationship, e.g. {@code AND} of {@code ORs}), call this\n   * method with every group of categories with the same relationship and then\n   * construct a {@link BooleanQuery} which will wrap all returned queries. It\n   * is advised to construct that boolean query with coord disabled, and also\n   * wrap the final query with {@link ConstantScoreQuery} and set its boost to\n   * {@code 0.0f}.\n   * <p>\n   * <b>NOTE:</b> {@link Occur} only makes sense when there is more than one\n   * {@link CategoryPath} given.\n   * <p>\n   * <b>NOTE:</b> {@code baseQuery} can be {@code null}, in which case only the\n   * {@link Query} over the categories will is returned.\n   */\n  public static final Query query(FacetIndexingParams iParams, Query baseQuery, Occur occur, CategoryPath... paths) {\n    if (paths == null || paths.length == 0) {\n      throw new IllegalArgumentException(\"Empty category path not allowed for drill down query!\");\n    }\n    \n    final Query q;\n    if (paths.length == 1) {\n      q = new TermQuery(term(iParams, paths[0]));\n    } else {\n      BooleanQuery bq = new BooleanQuery(true); // disable coord\n      for (CategoryPath cp : paths) {\n        bq.add(new TermQuery(term(iParams, cp)), occur);\n      }\n      q = bq;\n    }\n\n    final ConstantScoreQuery drillDownQuery = new ConstantScoreQuery(q);\n    drillDownQuery.setBoost(0.0f);\n\n    if (baseQuery == null) {\n      return drillDownQuery;\n    } else {\n      BooleanQuery res = new BooleanQuery(true);\n      res.add(baseQuery, Occur.MUST);\n      res.add(drillDownQuery, Occur.MUST);\n      return res;\n    }\n  }\n\n","sourceOld":"  /**\n   * Wraps a given {@link Query} as a drill-down query over the given\n   * categories, assuming all are required (e.g. {@code AND}). You can construct\n   * a query with different modes (such as {@code OR} or {@code AND} of\n   * {@code ORs}) by creating a {@link BooleanQuery} and call this method\n   * several times. Make sure to wrap the query in that case by\n   * {@link ConstantScoreQuery} and set the boost to 0.0f, so that it doesn't\n   * affect scoring.\n   * <p>\n   * <b>NOTE:</b> {@code baseQuery} can be {@code null}, in which case only the\n   * {@link Query} over the categories will is returned.\n   */\n  public static final Query query(FacetIndexingParams iParams, Query baseQuery, CategoryPath... paths) {\n    if (paths == null || paths.length == 0) {\n      throw new IllegalArgumentException(\"Empty category path not allowed for drill down query!\");\n    }\n    \n    final Query q;\n    if (paths.length == 1) {\n      q = new TermQuery(term(iParams, paths[0]));\n    } else {\n      BooleanQuery bq = new BooleanQuery(true); // disable coord\n      for (CategoryPath cp : paths) {\n        bq.add(new TermQuery(term(iParams, cp)), Occur.MUST);\n      }\n      q = bq;\n    }\n\n    final ConstantScoreQuery drillDownQuery = new ConstantScoreQuery(q);\n    drillDownQuery.setBoost(0.0f);\n\n    if (baseQuery == null) {\n      return drillDownQuery;\n    } else {\n      BooleanQuery res = new BooleanQuery(true);\n      res.add(baseQuery, Occur.MUST);\n      res.add(drillDownQuery, Occur.MUST);\n      return res;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f793470bad5ce8422502e33eaae65fc6a3271bd2","date":1360479442,"type":4,"author":"Shai Erera","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillDown#query(FacetIndexingParams,Query,Occur,CategoryPath...).mjava","sourceNew":null,"sourceOld":"  /**\n   * Wraps a given {@link Query} by a drill-down query over the given\n   * categories. {@link Occur} defines the relationship between the cateories\n   * (e.g. {@code OR} or {@code AND}. If you need to construct a more\n   * complicated relationship, e.g. {@code AND} of {@code ORs}), call this\n   * method with every group of categories with the same relationship and then\n   * construct a {@link BooleanQuery} which will wrap all returned queries. It\n   * is advised to construct that boolean query with coord disabled, and also\n   * wrap the final query with {@link ConstantScoreQuery} and set its boost to\n   * {@code 0.0f}.\n   * <p>\n   * <b>NOTE:</b> {@link Occur} only makes sense when there is more than one\n   * {@link CategoryPath} given.\n   * <p>\n   * <b>NOTE:</b> {@code baseQuery} can be {@code null}, in which case only the\n   * {@link Query} over the categories will is returned.\n   */\n  public static final Query query(FacetIndexingParams iParams, Query baseQuery, Occur occur, CategoryPath... paths) {\n    if (paths == null || paths.length == 0) {\n      throw new IllegalArgumentException(\"Empty category path not allowed for drill down query!\");\n    }\n    \n    final Query q;\n    if (paths.length == 1) {\n      q = new TermQuery(term(iParams, paths[0]));\n    } else {\n      BooleanQuery bq = new BooleanQuery(true); // disable coord\n      for (CategoryPath cp : paths) {\n        bq.add(new TermQuery(term(iParams, cp)), occur);\n      }\n      q = bq;\n    }\n\n    final ConstantScoreQuery drillDownQuery = new ConstantScoreQuery(q);\n    drillDownQuery.setBoost(0.0f);\n\n    if (baseQuery == null) {\n      return drillDownQuery;\n    } else {\n      BooleanQuery res = new BooleanQuery(true);\n      res.add(baseQuery, Occur.MUST);\n      res.add(drillDownQuery, Occur.MUST);\n      return res;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fa7a3db4fa6c77f454964f515841c097ca09212":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fa7a3db4fa6c77f454964f515841c097ca09212"],"f793470bad5ce8422502e33eaae65fc6a3271bd2":["9fa7a3db4fa6c77f454964f515841c097ca09212"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f793470bad5ce8422502e33eaae65fc6a3271bd2"]},"commit2Childs":{"9fa7a3db4fa6c77f454964f515841c097ca09212":["dd45d4a2ee01a1932d33eec42f5272c2402da679","f793470bad5ce8422502e33eaae65fc6a3271bd2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fa7a3db4fa6c77f454964f515841c097ca09212","dd45d4a2ee01a1932d33eec42f5272c2402da679"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"f793470bad5ce8422502e33eaae65fc6a3271bd2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dd45d4a2ee01a1932d33eec42f5272c2402da679","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}