{"path":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","commits":[{"id":"042e4d934397657ba04c82b46cc5665076bc5c58","date":1336511170,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final SAXSource source = new SAXSource(isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (UpdateRequestHandler.log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          UpdateRequestHandler.log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5d511528a3d157ee978d8854e33ff698571cb22","date":1348740642,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (UpdateRequestHandler.log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          UpdateRequestHandler.log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final SAXSource source = new SAXSource(isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (UpdateRequestHandler.log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          UpdateRequestHandler.log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (UpdateRequestHandler.log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          UpdateRequestHandler.log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"917e62f3497c83634a13edd833e8e21dd6cc6496","date":1490728467,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      if (req.getCore().getCoreDescriptor().isConfigSetTrusted() == false) {\n          throw new SolrException(ErrorCode.UNAUTHORIZED, \"The configset for this collection was uploaded without any authentication in place,\"\n                  + \" and this operation is not available for collections with untrusted configsets. To use this feature, re-upload the configset\"\n                  + \" after enabling authentication and authorization.\");\n      }\n\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3732e34f27916e98704736cc6924a34fffca249a","date":1490873946,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      if (req.getCore().getCoreDescriptor().isConfigSetTrusted() == false) {\n          throw new SolrException(ErrorCode.UNAUTHORIZED, \"The configset for this collection was uploaded without any authentication in place,\"\n                  + \" and this operation is not available for collections with untrusted configsets. To use this feature, re-upload the configset\"\n                  + \" after enabling authentication and authorization.\");\n      }\n\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6afb0ba86024b96e8b34cfc2e15562239dc36360","date":1579768208,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      if (req.getCore().getCoreDescriptor().isConfigSetTrusted() == false) {\n          throw new SolrException(ErrorCode.UNAUTHORIZED, \"The configset for this collection was uploaded without any authentication in place,\"\n                  + \" and this operation is not available for collections with untrusted configsets. To use this feature, re-upload the configset\"\n                  + \" after enabling authentication and authorization.\");\n      }\n\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          log.trace(\"body: {}\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      if (req.getCore().getCoreDescriptor().isConfigSetTrusted() == false) {\n          throw new SolrException(ErrorCode.UNAUTHORIZED, \"The configset for this collection was uploaded without any authentication in place,\"\n                  + \" and this operation is not available for collections with untrusted configsets. To use this feature, re-upload the configset\"\n                  + \" after enabling authentication and authorization.\");\n      }\n\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          log.trace(\"body\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","bugFix":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/XMLLoader#load(SolrQueryRequest,SolrQueryResponse,ContentStream,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      if (req.getCore().getCoreDescriptor().isConfigSetTrusted() == false) {\n          throw new SolrException(ErrorCode.UNAUTHORIZED, \"The configset for this collection was uploaded without any authentication in place,\"\n                  + \" and this operation is not available for collections with untrusted configsets. To use this feature, re-upload the configset\"\n                  + \" after enabling authentication and authorization.\");\n      }\n\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          if (log.isTraceEnabled()) {\n            log.trace(\"body: {}\", new String(body, (charset == null) ?\n                ContentStreamBase.DEFAULT_CHARSET : charset));\n          }\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws Exception {\n    final String charset = ContentStreamBase.getCharsetFromContentType(stream.getContentType());\n    \n    InputStream is = null;\n    XMLStreamReader parser = null;\n\n    String tr = req.getParams().get(CommonParams.TR,null);\n    if(tr!=null) {\n      if (req.getCore().getCoreDescriptor().isConfigSetTrusted() == false) {\n          throw new SolrException(ErrorCode.UNAUTHORIZED, \"The configset for this collection was uploaded without any authentication in place,\"\n                  + \" and this operation is not available for collections with untrusted configsets. To use this feature, re-upload the configset\"\n                  + \" after enabling authentication and authorization.\");\n      }\n\n      final Transformer t = getTransformer(tr,req);\n      final DOMResult result = new DOMResult();\n      \n      // first step: read XML and build DOM using Transformer (this is no overhead, as XSL always produces\n      // an internal result DOM tree, we just access it directly as input for StAX):\n      try {\n        is = stream.getStream();\n        final InputSource isrc = new InputSource(is);\n        isrc.setEncoding(charset);\n        final XMLReader xmlr = saxFactory.newSAXParser().getXMLReader();\n        xmlr.setErrorHandler(xmllog);\n        xmlr.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n        final SAXSource source = new SAXSource(xmlr, isrc);\n        t.transform(source, result);\n      } catch(TransformerException te) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, te.getMessage(), te);\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      // second step: feed the intermediate DOM tree into StAX parser:\n      try {\n        parser = inputFactory.createXMLStreamReader(new DOMSource(result.getNode()));\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n      }\n    }\n    // Normal XML Loader\n    else {\n      try {\n        is = stream.getStream();\n        if (log.isTraceEnabled()) {\n          final byte[] body = IOUtils.toByteArray(is);\n          // TODO: The charset may be wrong, as the real charset is later\n          // determined by the XML parser, the content-type is only used as a hint!\n          log.trace(\"body: {}\", new String(body, (charset == null) ?\n            ContentStreamBase.DEFAULT_CHARSET : charset));\n          IOUtils.closeQuietly(is);\n          is = new ByteArrayInputStream(body);\n        }\n        parser = (charset == null) ?\n          inputFactory.createXMLStreamReader(is) : inputFactory.createXMLStreamReader(is, charset);\n        this.processUpdate(req, processor, parser);\n      } catch (XMLStreamException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n      } finally {\n        if (parser != null) parser.close();\n        IOUtils.closeQuietly(is);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"917e62f3497c83634a13edd833e8e21dd6cc6496":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["917e62f3497c83634a13edd833e8e21dd6cc6496"],"042e4d934397657ba04c82b46cc5665076bc5c58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"3732e34f27916e98704736cc6924a34fffca249a":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["b5d511528a3d157ee978d8854e33ff698571cb22"],"b5d511528a3d157ee978d8854e33ff698571cb22":["042e4d934397657ba04c82b46cc5665076bc5c58"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"917e62f3497c83634a13edd833e8e21dd6cc6496":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["575e66bd4b2349209027f6801184da7fc3cba13f"],"042e4d934397657ba04c82b46cc5665076bc5c58":["b5d511528a3d157ee978d8854e33ff698571cb22"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["042e4d934397657ba04c82b46cc5665076bc5c58"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3732e34f27916e98704736cc6924a34fffca249a":[],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["917e62f3497c83634a13edd833e8e21dd6cc6496","3732e34f27916e98704736cc6924a34fffca249a"],"b5d511528a3d157ee978d8854e33ff698571cb22":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3732e34f27916e98704736cc6924a34fffca249a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}