{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","commits":[{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the set of accepted strings, assuming that at most\n   * <code>limit</code> strings are accepted. If more than <code>limit</code> \n   * strings are accepted, null is returned. If <code>limit</code>&lt;0, then \n   * the limit is infinite.\n   */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    HashSet<IntsRef> strings = new HashSet<IntsRef>();\n    if (a.isSingleton()) {\n      if (limit > 0) {\n        strings.add(Util.toUTF32(a.singleton, new IntsRef()));\n      } else {\n        return null;\n      }\n    } else if (!getFiniteStrings(a.initial, new HashSet<State>(), strings, new IntsRef(), limit)) {\n      return null;\n    }\n    return strings;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["144725940ce5c83d189b7327223aceafdc0ebd39","61ac0dce4a88019c61f1217b42753d505b9d9c84"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"144725940ce5c83d189b7327223aceafdc0ebd39","date":1371765308,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","sourceNew":"  /**\n   * Returns the set of accepted strings, assuming that at most\n   * <code>limit</code> strings are accepted. If more than <code>limit</code> \n   * strings are accepted, the first limit strings found are returned. If <code>limit</code>&lt;0, then \n   * the limit is infinite.\n   */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    HashSet<IntsRef> strings = new HashSet<IntsRef>();\n    if (a.isSingleton()) {\n      if (limit > 0) {\n        strings.add(Util.toUTF32(a.singleton, new IntsRef()));\n      }\n    } else if (!getFiniteStrings(a.initial, new HashSet<State>(), strings, new IntsRef(), limit)) {\n      return strings;\n    }\n    return strings;\n  }\n\n","sourceOld":"  /**\n   * Returns the set of accepted strings, assuming that at most\n   * <code>limit</code> strings are accepted. If more than <code>limit</code> \n   * strings are accepted, null is returned. If <code>limit</code>&lt;0, then \n   * the limit is infinite.\n   */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    HashSet<IntsRef> strings = new HashSet<IntsRef>();\n    if (a.isSingleton()) {\n      if (limit > 0) {\n        strings.add(Util.toUTF32(a.singleton, new IntsRef()));\n      } else {\n        return null;\n      }\n    } else if (!getFiniteStrings(a.initial, new HashSet<State>(), strings, new IntsRef(), limit)) {\n      return null;\n    }\n    return strings;\n  }\n\n","bugFix":["6ce825e9276493231308229152c48f755ce1a0a5"],"bugIntro":["61ac0dce4a88019c61f1217b42753d505b9d9c84"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","sourceNew":"  /**\n   * Returns the set of accepted strings, assuming that at most\n   * <code>limit</code> strings are accepted. If more than <code>limit</code> \n   * strings are accepted, the first limit strings found are returned. If <code>limit</code>&lt;0, then \n   * the limit is infinite.\n   */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    HashSet<IntsRef> strings = new HashSet<IntsRef>();\n    if (a.isSingleton()) {\n      if (limit > 0) {\n        strings.add(Util.toUTF32(a.singleton, new IntsRef()));\n      }\n    } else if (!getFiniteStrings(a.initial, new HashSet<State>(), strings, new IntsRef(), limit)) {\n      return strings;\n    }\n    return strings;\n  }\n\n","sourceOld":"  /**\n   * Returns the set of accepted strings, assuming that at most\n   * <code>limit</code> strings are accepted. If more than <code>limit</code> \n   * strings are accepted, null is returned. If <code>limit</code>&lt;0, then \n   * the limit is infinite.\n   */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    HashSet<IntsRef> strings = new HashSet<IntsRef>();\n    if (a.isSingleton()) {\n      if (limit > 0) {\n        strings.add(Util.toUTF32(a.singleton, new IntsRef()));\n      } else {\n        return null;\n      }\n    } else if (!getFiniteStrings(a.initial, new HashSet<State>(), strings, new IntsRef(), limit)) {\n      return null;\n    }\n    return strings;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","sourceNew":"  /**\n   * Returns the set of accepted strings, assuming that at most\n   * <code>limit</code> strings are accepted. If more than <code>limit</code> \n   * strings are accepted, the first limit strings found are returned. If <code>limit</code>&lt;0, then \n   * the limit is infinite.\n   */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    HashSet<IntsRef> strings = new HashSet<>();\n    if (a.isSingleton()) {\n      if (limit > 0) {\n        strings.add(Util.toUTF32(a.singleton, new IntsRef()));\n      }\n    } else if (!getFiniteStrings(a.initial, new HashSet<State>(), strings, new IntsRef(), limit)) {\n      return strings;\n    }\n    return strings;\n  }\n\n","sourceOld":"  /**\n   * Returns the set of accepted strings, assuming that at most\n   * <code>limit</code> strings are accepted. If more than <code>limit</code> \n   * strings are accepted, the first limit strings found are returned. If <code>limit</code>&lt;0, then \n   * the limit is infinite.\n   */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    HashSet<IntsRef> strings = new HashSet<IntsRef>();\n    if (a.isSingleton()) {\n      if (limit > 0) {\n        strings.add(Util.toUTF32(a.singleton, new IntsRef()));\n      }\n    } else if (!getFiniteStrings(a.initial, new HashSet<State>(), strings, new IntsRef(), limit)) {\n      return strings;\n    }\n    return strings;\n  }\n\n","bugFix":null,"bugIntro":["61ac0dce4a88019c61f1217b42753d505b9d9c84"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61ac0dce4a88019c61f1217b42753d505b9d9c84","date":1399218479,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","sourceNew":"  /** Returns the set of accepted strings, up to at most\n   *  <code>limit</code> strings. If more than <code>limit</code> \n   *  strings are accepted, the first limit strings found are returned. If <code>limit</code> == -1, then \n   *  the limit is infinite.  If the {@link Automaton} has\n   *  cycles then this method might throw {@code\n   *  IllegalArgumentException} but that is not guaranteed\n   *  when the limit is set. */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    Set<IntsRef> results = new HashSet<>();\n\n    if (limit == -1 || limit > 0) {\n      // OK\n    } else {\n      throw new IllegalArgumentException(\"limit must be -1 (which means no limit), or > 0; got: \" + limit);\n    }\n\n    if (a.isSingleton()) {\n      // Easy case: automaton accepts only 1 string\n      results.add(Util.toUTF32(a.singleton, new IntsRef()));\n    } else {\n\n      if (a.initial.accept) {\n        // Special case the empty string, as usual:\n        results.add(new IntsRef());\n      }\n\n      if (a.initial.numTransitions() > 0 && (limit == -1 || results.size() < limit)) {\n\n        // TODO: we could use state numbers here and just\n        // alloc array, but asking for states array can be\n        // costly (it's lazily computed):\n\n        // Tracks which states are in the current path, for\n        // cycle detection:\n        Set<State> pathStates = Collections.newSetFromMap(new IdentityHashMap<State,Boolean>());\n\n        // Stack to hold our current state in the\n        // recursion/iteration:\n        PathNode[] nodes = new PathNode[4];\n\n        pathStates.add(a.initial);\n        PathNode root = getNode(nodes, 0);\n        root.resetState(a.initial);\n\n        IntsRef string = new IntsRef(1);\n        string.length = 1;\n\n        while (string.length > 0) {\n\n          PathNode node = nodes[string.length-1];\n\n          // Get next label leaving the current node:\n          int label = node.nextLabel();\n\n          if (label != -1) {\n            string.ints[string.length-1] = label;\n\n            if (node.to.accept) {\n              // This transition leads to an accept state,\n              // so we save the current string:\n              results.add(IntsRef.deepCopyOf(string));\n              if (results.size() == limit) {\n                break;\n              }\n            }\n\n            if (node.to.numTransitions() != 0) {\n              // Now recurse: the destination of this transition has\n              // outgoing transitions:\n              if (pathStates.contains(node.to)) {\n                throw new IllegalArgumentException(\"automaton has cycles\");\n              }\n              pathStates.add(node.to);\n\n              // Push node onto stack:\n              if (nodes.length == string.length) {\n                PathNode[] newNodes = new PathNode[ArrayUtil.oversize(nodes.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n                System.arraycopy(nodes, 0, newNodes, 0, nodes.length);\n                nodes = newNodes;\n              }\n              getNode(nodes, string.length).resetState(node.to);\n              string.length++;\n              string.grow(string.length);\n            }\n          } else {\n            // No more transitions leaving this state,\n            // pop/return back to previous state:\n            assert pathStates.contains(node.state);\n            pathStates.remove(node.state);\n            string.length--;\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Returns the set of accepted strings, assuming that at most\n   * <code>limit</code> strings are accepted. If more than <code>limit</code> \n   * strings are accepted, the first limit strings found are returned. If <code>limit</code>&lt;0, then \n   * the limit is infinite.\n   */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    HashSet<IntsRef> strings = new HashSet<>();\n    if (a.isSingleton()) {\n      if (limit > 0) {\n        strings.add(Util.toUTF32(a.singleton, new IntsRef()));\n      }\n    } else if (!getFiniteStrings(a.initial, new HashSet<State>(), strings, new IntsRef(), limit)) {\n      return strings;\n    }\n    return strings;\n  }\n\n","bugFix":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","6ce825e9276493231308229152c48f755ce1a0a5","144725940ce5c83d189b7327223aceafdc0ebd39"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f4ef381bf0c2d618c6db830d3dd668c6901c05a","date":1402592253,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","sourceNew":null,"sourceOld":"  /** Returns the set of accepted strings, up to at most\n   *  <code>limit</code> strings. If more than <code>limit</code> \n   *  strings are accepted, the first limit strings found are returned. If <code>limit</code> == -1, then \n   *  the limit is infinite.  If the {@link Automaton} has\n   *  cycles then this method might throw {@code\n   *  IllegalArgumentException} but that is not guaranteed\n   *  when the limit is set. */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    Set<IntsRef> results = new HashSet<>();\n\n    if (limit == -1 || limit > 0) {\n      // OK\n    } else {\n      throw new IllegalArgumentException(\"limit must be -1 (which means no limit), or > 0; got: \" + limit);\n    }\n\n    if (a.isSingleton()) {\n      // Easy case: automaton accepts only 1 string\n      results.add(Util.toUTF32(a.singleton, new IntsRef()));\n    } else {\n\n      if (a.initial.accept) {\n        // Special case the empty string, as usual:\n        results.add(new IntsRef());\n      }\n\n      if (a.initial.numTransitions() > 0 && (limit == -1 || results.size() < limit)) {\n\n        // TODO: we could use state numbers here and just\n        // alloc array, but asking for states array can be\n        // costly (it's lazily computed):\n\n        // Tracks which states are in the current path, for\n        // cycle detection:\n        Set<State> pathStates = Collections.newSetFromMap(new IdentityHashMap<State,Boolean>());\n\n        // Stack to hold our current state in the\n        // recursion/iteration:\n        PathNode[] nodes = new PathNode[4];\n\n        pathStates.add(a.initial);\n        PathNode root = getNode(nodes, 0);\n        root.resetState(a.initial);\n\n        IntsRef string = new IntsRef(1);\n        string.length = 1;\n\n        while (string.length > 0) {\n\n          PathNode node = nodes[string.length-1];\n\n          // Get next label leaving the current node:\n          int label = node.nextLabel();\n\n          if (label != -1) {\n            string.ints[string.length-1] = label;\n\n            if (node.to.accept) {\n              // This transition leads to an accept state,\n              // so we save the current string:\n              results.add(IntsRef.deepCopyOf(string));\n              if (results.size() == limit) {\n                break;\n              }\n            }\n\n            if (node.to.numTransitions() != 0) {\n              // Now recurse: the destination of this transition has\n              // outgoing transitions:\n              if (pathStates.contains(node.to)) {\n                throw new IllegalArgumentException(\"automaton has cycles\");\n              }\n              pathStates.add(node.to);\n\n              // Push node onto stack:\n              if (nodes.length == string.length) {\n                PathNode[] newNodes = new PathNode[ArrayUtil.oversize(nodes.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n                System.arraycopy(nodes, 0, newNodes, 0, nodes.length);\n                nodes = newNodes;\n              }\n              getNode(nodes, string.length).resetState(node.to);\n              string.length++;\n              string.grow(string.length);\n            }\n          } else {\n            // No more transitions leaving this state,\n            // pop/return back to previous state:\n            assert pathStates.contains(node.state);\n            pathStates.remove(node.state);\n            string.length--;\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/SpecialOperations#getFiniteStrings(Automaton,int).mjava","sourceNew":null,"sourceOld":"  /** Returns the set of accepted strings, up to at most\n   *  <code>limit</code> strings. If more than <code>limit</code> \n   *  strings are accepted, the first limit strings found are returned. If <code>limit</code> == -1, then \n   *  the limit is infinite.  If the {@link Automaton} has\n   *  cycles then this method might throw {@code\n   *  IllegalArgumentException} but that is not guaranteed\n   *  when the limit is set. */\n  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {\n    Set<IntsRef> results = new HashSet<>();\n\n    if (limit == -1 || limit > 0) {\n      // OK\n    } else {\n      throw new IllegalArgumentException(\"limit must be -1 (which means no limit), or > 0; got: \" + limit);\n    }\n\n    if (a.isSingleton()) {\n      // Easy case: automaton accepts only 1 string\n      results.add(Util.toUTF32(a.singleton, new IntsRef()));\n    } else {\n\n      if (a.initial.accept) {\n        // Special case the empty string, as usual:\n        results.add(new IntsRef());\n      }\n\n      if (a.initial.numTransitions() > 0 && (limit == -1 || results.size() < limit)) {\n\n        // TODO: we could use state numbers here and just\n        // alloc array, but asking for states array can be\n        // costly (it's lazily computed):\n\n        // Tracks which states are in the current path, for\n        // cycle detection:\n        Set<State> pathStates = Collections.newSetFromMap(new IdentityHashMap<State,Boolean>());\n\n        // Stack to hold our current state in the\n        // recursion/iteration:\n        PathNode[] nodes = new PathNode[4];\n\n        pathStates.add(a.initial);\n        PathNode root = getNode(nodes, 0);\n        root.resetState(a.initial);\n\n        IntsRef string = new IntsRef(1);\n        string.length = 1;\n\n        while (string.length > 0) {\n\n          PathNode node = nodes[string.length-1];\n\n          // Get next label leaving the current node:\n          int label = node.nextLabel();\n\n          if (label != -1) {\n            string.ints[string.length-1] = label;\n\n            if (node.to.accept) {\n              // This transition leads to an accept state,\n              // so we save the current string:\n              results.add(IntsRef.deepCopyOf(string));\n              if (results.size() == limit) {\n                break;\n              }\n            }\n\n            if (node.to.numTransitions() != 0) {\n              // Now recurse: the destination of this transition has\n              // outgoing transitions:\n              if (pathStates.contains(node.to)) {\n                throw new IllegalArgumentException(\"automaton has cycles\");\n              }\n              pathStates.add(node.to);\n\n              // Push node onto stack:\n              if (nodes.length == string.length) {\n                PathNode[] newNodes = new PathNode[ArrayUtil.oversize(nodes.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n                System.arraycopy(nodes, 0, newNodes, 0, nodes.length);\n                nodes = newNodes;\n              }\n              getNode(nodes, string.length).resetState(node.to);\n              string.length++;\n              string.grow(string.length);\n            }\n          } else {\n            // No more transitions leaving this state,\n            // pop/return back to previous state:\n            assert pathStates.contains(node.state);\n            pathStates.remove(node.state);\n            string.length--;\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["144725940ce5c83d189b7327223aceafdc0ebd39"],"144725940ce5c83d189b7327223aceafdc0ebd39":["6ce825e9276493231308229152c48f755ce1a0a5"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["6ce825e9276493231308229152c48f755ce1a0a5","144725940ce5c83d189b7327223aceafdc0ebd39"],"61ac0dce4a88019c61f1217b42753d505b9d9c84":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ce825e9276493231308229152c48f755ce1a0a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["61ac0dce4a88019c61f1217b42753d505b9d9c84"],"5c84485629d80d203608e8975a1139de9933cc38":["61ac0dce4a88019c61f1217b42753d505b9d9c84","7f4ef381bf0c2d618c6db830d3dd668c6901c05a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c84485629d80d203608e8975a1139de9933cc38"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["61ac0dce4a88019c61f1217b42753d505b9d9c84"],"144725940ce5c83d189b7327223aceafdc0ebd39":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"61ac0dce4a88019c61f1217b42753d505b9d9c84":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a","5c84485629d80d203608e8975a1139de9933cc38"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ce825e9276493231308229152c48f755ce1a0a5"],"6ce825e9276493231308229152c48f755ce1a0a5":["144725940ce5c83d189b7327223aceafdc0ebd39","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}