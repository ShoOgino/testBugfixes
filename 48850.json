{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","commits":[{"id":"9133745ed58338ebe8daabe49076605b61fc6b86","date":1487468548,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"/dev/null","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e11e54ce6015434b2aaadb49ca5071dbe7be50c","date":1489404389,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQIndividualReplicaTest().mjava","sourceNew":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void reorderedDBQIndividualReplicaTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    long version0 = 2000;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\",\n        newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\",\n        newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(\"inplace_updatable_float:\"+(newinplace_updatable_float + 1), version0 + 3));\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates by swapping the last two\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    reorderedUpdates.set(1, updates.get(2));\n    reorderedUpdates.set(2, updates.get(1));\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(100);\n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    SolrDocument doc = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n\n    log.info(\"reorderedDBQIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["be320990bdc77e643388fa801e75017f19289c42"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["9133745ed58338ebe8daabe49076605b61fc6b86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["61c45e99cf6676da48f19d7511c73712ad39402b"],"9133745ed58338ebe8daabe49076605b61fc6b86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"be320990bdc77e643388fa801e75017f19289c42":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"ab68488225b6a6c357dda72ed11dedca9914a192":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9133745ed58338ebe8daabe49076605b61fc6b86"],"9133745ed58338ebe8daabe49076605b61fc6b86":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"be320990bdc77e643388fa801e75017f19289c42":["61c45e99cf6676da48f19d7511c73712ad39402b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}