{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#aspect().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#aspect().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#aspect().mjava","sourceNew":"  /* handle `-ing' endings */\n  private void aspect() {\n    /*\n     * handle short words (aging -> age) via a direct mapping. This prevents\n     * (thing -> the) in the version of this routine that ignores inflectional\n     * variants that are mentioned in the dictionary (when the root is also\n     * present)\n     */\n\n    if (word.length() <= 5) return;\n    \n    /* the vowelinstem() is necessary so we don't stem acronyms */\n    if (endsIn('i', 'n', 'g') && vowelInStem()) {\n      \n      /* try adding an `e' to the stem and check against the dictionary */\n      word.setCharAt(j + 1, 'e');\n      word.setLength(j + 2);\n      k = j + 1;\n      \n      DictEntry entry = wordInDict();\n      if (entry != null) {\n        if (!entry.exception) /* if it's in the dictionary and not an exception */\n        return;\n      }\n      \n      /* adding on the `e' didn't work, so remove it */\n      word.setLength(k);\n      k--; /* note that `ing' has also been removed */\n      \n      if (lookup()) return;\n      \n      /* if I can remove a doubled consonant and get a word, then do so */\n      if (doubleC(k)) {\n        k--;\n        word.setLength(k + 1);\n        if (lookup()) return;\n        word.unsafeWrite(word.charAt(k)); /* restore the doubled consonant */\n        \n        /* the default is to leave the consonant doubled */\n        /* (e.g.,`fingerspelling' -> `fingerspell'). Unfortunately */\n        /* `bookselling' -> `booksell' and `mislabelling' -> `mislabell'). */\n        /* Without making the algorithm significantly more complicated, this */\n        /* is the best I can do */\n        k++;\n        lookup();\n        return;\n      }\n      \n      /*\n       * the word wasn't in the dictionary after removing the stem, and then\n       * checking with and without a final `e'. The default is to add an `e'\n       * unless the word ends in two consonants, so `microcoding' ->\n       * `microcode'. The two consonants restriction wouldn't normally be\n       * necessary, but is needed because we don't try to deal with prefixes and\n       * compounds, and most of the time it is correct (e.g., footstamping ->\n       * footstamp, not footstampe; however, decoupled -> decoupl). We can\n       * prevent almost all of the incorrect stems if we try to do some prefix\n       * analysis first\n       */\n\n      if ((j > 0) && isCons(j) && isCons(j - 1)) {\n        k = j;\n        word.setLength(k + 1);\n        // nolookup() because we already did according to the comment\n        return;\n      }\n      \n      word.setLength(j + 1);\n      word.unsafeWrite('e');\n      k = j + 1;\n      // nolookup(); we already tried an 'e' ending\n      return;\n    }\n  }\n\n","sourceOld":"  /* handle `-ing' endings */\n  private void aspect() {\n    /*\n     * handle short words (aging -> age) via a direct mapping. This prevents\n     * (thing -> the) in the version of this routine that ignores inflectional\n     * variants that are mentioned in the dictionary (when the root is also\n     * present)\n     */\n\n    if (word.length() <= 5) return;\n    \n    /* the vowelinstem() is necessary so we don't stem acronyms */\n    if (endsIn('i', 'n', 'g') && vowelInStem()) {\n      \n      /* try adding an `e' to the stem and check against the dictionary */\n      word.setCharAt(j + 1, 'e');\n      word.setLength(j + 2);\n      k = j + 1;\n      \n      DictEntry entry = wordInDict();\n      if (entry != null) {\n        if (!entry.exception) /* if it's in the dictionary and not an exception */\n        return;\n      }\n      \n      /* adding on the `e' didn't work, so remove it */\n      word.setLength(k);\n      k--; /* note that `ing' has also been removed */\n      \n      if (lookup()) return;\n      \n      /* if I can remove a doubled consonant and get a word, then do so */\n      if (doubleC(k)) {\n        k--;\n        word.setLength(k + 1);\n        if (lookup()) return;\n        word.unsafeWrite(word.charAt(k)); /* restore the doubled consonant */\n        \n        /* the default is to leave the consonant doubled */\n        /* (e.g.,`fingerspelling' -> `fingerspell'). Unfortunately */\n        /* `bookselling' -> `booksell' and `mislabelling' -> `mislabell'). */\n        /* Without making the algorithm significantly more complicated, this */\n        /* is the best I can do */\n        k++;\n        lookup();\n        return;\n      }\n      \n      /*\n       * the word wasn't in the dictionary after removing the stem, and then\n       * checking with and without a final `e'. The default is to add an `e'\n       * unless the word ends in two consonants, so `microcoding' ->\n       * `microcode'. The two consonants restriction wouldn't normally be\n       * necessary, but is needed because we don't try to deal with prefixes and\n       * compounds, and most of the time it is correct (e.g., footstamping ->\n       * footstamp, not footstampe; however, decoupled -> decoupl). We can\n       * prevent almost all of the incorrect stems if we try to do some prefix\n       * analysis first\n       */\n\n      if ((j > 0) && isCons(j) && isCons(j - 1)) {\n        k = j;\n        word.setLength(k + 1);\n        // nolookup() because we already did according to the comment\n        return;\n      }\n      \n      word.setLength(j + 1);\n      word.unsafeWrite('e');\n      k = j + 1;\n      // nolookup(); we already tried an 'e' ending\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}