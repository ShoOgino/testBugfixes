{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","commits":[{"id":"ee59f646cf24586a449cad77391a60a3ac8d8959","date":1408015131,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergeTrigger,int).mjava","sourceNew":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == -1 || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if we've hit OOME\n    if (hitOOM) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == -1 || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if we've hit OOME\n    if (hitOOM) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == -1 || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == -1 || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if we've hit OOME\n    if (hitOOM) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","date":1477166077,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == -1 || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == -1 || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n        \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0","date":1592426892,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","sourceOld":"  private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return false;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return false;\n    }\n    boolean newMergesFound = false;\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    newMergesFound = spec != null;\n    if (newMergesFound) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return newMergesFound;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe39f1a106531207c028defebbc9eb5bb489ac50","date":1592513789,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      switch (trigger) {\n        case COMMIT:\n          spec = mergePolicy.findFullFlushMerges(trigger, segmentInfos, this);\n          break;\n        default:\n          spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n      }\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","sourceOld":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1182fe36fb5df768dc2da53f6d5338cbc07268ae","date":1592861749,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","sourceOld":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      switch (trigger) {\n        case COMMIT:\n          spec = mergePolicy.findFullFlushMerges(trigger, segmentInfos, this);\n          break;\n        default:\n          spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n      }\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      switch (trigger) {\n        case COMMIT:\n          spec = mergePolicy.findFullFlushMerges(trigger, segmentInfos, this);\n          break;\n        default:\n          spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n      }\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","sourceOld":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a775b68a26e2d19d1b5f16cd18a3bc8df738a302","date":1598253342,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (merges.areEnabled() == false) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      switch (trigger) {\n        case COMMIT:\n          spec = mergePolicy.findFullFlushMerges(trigger, segmentInfos, this);\n          break;\n        default:\n          spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n      }\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","sourceOld":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (stopMerges) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      switch (trigger) {\n        case COMMIT:\n          spec = mergePolicy.findFullFlushMerges(trigger, segmentInfos, this);\n          break;\n        default:\n          spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n      }\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f354ba79a5a3e8491ec2953f14f365a02c058ac","date":1598293148,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updatePendingMerges(MergePolicy,MergeTrigger,int).mjava","sourceNew":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (merges.areEnabled() == false) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      switch (trigger) {\n        case GET_READER:\n        case COMMIT:\n          spec = mergePolicy.findFullFlushMerges(trigger, segmentInfos, this);\n          break;\n        default:\n          spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n      }\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","sourceOld":"  private synchronized MergePolicy.MergeSpecification updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)\n    throws IOException {\n\n    // In case infoStream was disabled on init, but then enabled at some\n    // point, try again to log the config here:\n    messageState();\n\n    assert maxNumSegments == UNBOUNDED_MAX_MERGE_SEGMENTS || maxNumSegments > 0;\n    assert trigger != null;\n    if (merges.areEnabled() == false) {\n      return null;\n    }\n\n    // Do not start new merges if disaster struck\n    if (tragedy.get() != null) {\n      return null;\n    }\n\n    final MergePolicy.MergeSpecification spec;\n    if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n      assert trigger == MergeTrigger.EXPLICIT || trigger == MergeTrigger.MERGE_FINISHED :\n      \"Expected EXPLICT or MERGE_FINISHED as trigger even with maxNumSegments set but was: \" + trigger.name();\n\n      spec = mergePolicy.findForcedMerges(segmentInfos, maxNumSegments, Collections.unmodifiableMap(segmentsToMerge), this);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++) {\n          final MergePolicy.OneMerge merge = spec.merges.get(i);\n          merge.maxNumSegments = maxNumSegments;\n        }\n      }\n    } else {\n      switch (trigger) {\n        case COMMIT:\n          spec = mergePolicy.findFullFlushMerges(trigger, segmentInfos, this);\n          break;\n        default:\n          spec = mergePolicy.findMerges(trigger, segmentInfos, this);\n      }\n    }\n    if (spec != null) {\n      final int numMerges = spec.merges.size();\n      for(int i=0;i<numMerges;i++) {\n        registerMerge(spec.merges.get(i));\n      }\n    }\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["28288370235ed02234a64753cdbf0c6ec096304a"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c"],"a775b68a26e2d19d1b5f16cd18a3bc8df738a302":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["af4f318fc7955d8e4e40cdf4a8a93931004fe7c0"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["949847c0040cd70a68222d526cb0da7bf6cbb3c2","6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["a775b68a26e2d19d1b5f16cd18a3bc8df738a302"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["af4f318fc7955d8e4e40cdf4a8a93931004fe7c0"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a775b68a26e2d19d1b5f16cd18a3bc8df738a302":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["a775b68a26e2d19d1b5f16cd18a3bc8df738a302"],"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}