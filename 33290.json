{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","pathOld":"/dev/null","sourceNew":"  // attempt to reproduce https://github.com/Heliosearch/heliosearch/issues/33\n  @Test\n  public void testComplex() throws Exception {\n    Random r = random();\n\n    Client client = Client.localClient;\n\n    double price_low = 11000;\n    double price_high = 100000;\n\n    ModifiableSolrParams p = params(\"make_s\",\"make_s\", \"model_s\",\"model_s\", \"price_low\",Double.toString(price_low), \"price_high\",Double.toString(price_high));\n\n\n    MacroExpander m = new MacroExpander( p.getMap() );\n\n    String make_s = m.expand(\"${make_s}\");\n    String model_s = m.expand(\"${model_s}\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    int nDocs = 99;\n    String[] makes = {\"honda\", \"toyota\", \"ford\", null};\n    Double[] prices = {10000.0, 30000.0, 50000.0, 0.0, null};\n    String[] honda_models = {\"accord\", \"civic\", \"fit\", \"pilot\", null};  // make sure this is alphabetized to match tiebreaks in index\n    String[] other_models = {\"a\", \"b\", \"c\", \"x\", \"y\", \"z\", null};\n\n    int nHonda = 0;\n    final int[] honda_model_counts = new int[honda_models.length];\n\n    for (int i=0; i<nDocs; i++) {\n      SolrInputDocument doc = sdoc(\"id\", Integer.toString(i));\n\n      Double price = rand(prices);\n      if (price != null) {\n        doc.addField(\"cost_f\", price);\n      }\n      boolean matches_price = price!=null && price >= price_low && price <= price_high;\n\n      String make = rand(makes);\n      if (make != null) {\n        doc.addField(make_s, make);\n      }\n\n      if (\"honda\".equals(make)) {\n        int modelNum = r.nextInt(honda_models.length);\n        String model = honda_models[modelNum];\n        if (model != null) {\n          doc.addField(model_s, model);\n        }\n        if (matches_price) {\n          nHonda++;\n          honda_model_counts[modelNum]++;\n        }\n      } else if (make == null) {\n        doc.addField(model_s, rand(honda_models));  // add some docs w/ model but w/o make\n      } else {\n        // other makes\n        doc.addField(model_s, rand(other_models));  // add some docs w/ model but w/o make\n      }\n\n      client.add(doc, null);\n      if (r.nextInt(10) == 0) {\n        client.add(doc, null);  // dup, causing a delete\n      }\n      if (r.nextInt(20) == 0) {\n        client.commit();  // force new seg\n      }\n    }\n\n    client.commit();\n\n    // now figure out top counts\n    List<Integer> idx = new ArrayList<>();\n    for (int i=0; i<honda_model_counts.length-1; i++) {\n      idx.add(i);\n    }\n    Collections.sort(idx, new Comparator<Integer>() {\n      @Override\n      public int compare(Integer o1, Integer o2) {\n        int cmp = honda_model_counts[o2] - honda_model_counts[o1];\n        return cmp == 0 ? o1 - o2 : cmp;\n      }\n    });\n\n\n\n    // straight query facets\n    client.testJQ(params(p, \"q\", \"*:*\", \"rows\",\"0\", \"fq\",\"+${make_s}:honda +cost_f:[${price_low} TO ${price_high}]\"\n            , \"json.facet\", \"{makes:{terms:{field:${make_s}, facet:{models:{terms:{field:${model_s}, limit:2, mincount:0}}}}}}}\"\n            , \"facet\",\"true\", \"facet.pivot\",\"make_s,model_s\", \"facet.limit\", \"2\"\n        )\n        , \"facets=={count:\" + nHonda + \", makes:{buckets:[{val:honda, count:\" + nHonda + \", models:{buckets:[\"\n           + \"{val:\" + honda_models[idx.get(0)] + \", count:\" + honda_model_counts[idx.get(0)] + \"},\"\n           + \"{val:\" + honda_models[idx.get(1)] + \", count:\" + honda_model_counts[idx.get(1)] + \"}]}\"\n           + \"}]}}\"\n    );\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","pathOld":"/dev/null","sourceNew":"  // attempt to reproduce https://github.com/Heliosearch/heliosearch/issues/33\n  @Test\n  public void testComplex() throws Exception {\n    Random r = random();\n\n    Client client = Client.localClient;\n\n    double price_low = 11000;\n    double price_high = 100000;\n\n    ModifiableSolrParams p = params(\"make_s\",\"make_s\", \"model_s\",\"model_s\", \"price_low\",Double.toString(price_low), \"price_high\",Double.toString(price_high));\n\n\n    MacroExpander m = new MacroExpander( p.getMap() );\n\n    String make_s = m.expand(\"${make_s}\");\n    String model_s = m.expand(\"${model_s}\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    int nDocs = 99;\n    String[] makes = {\"honda\", \"toyota\", \"ford\", null};\n    Double[] prices = {10000.0, 30000.0, 50000.0, 0.0, null};\n    String[] honda_models = {\"accord\", \"civic\", \"fit\", \"pilot\", null};  // make sure this is alphabetized to match tiebreaks in index\n    String[] other_models = {\"a\", \"b\", \"c\", \"x\", \"y\", \"z\", null};\n\n    int nHonda = 0;\n    final int[] honda_model_counts = new int[honda_models.length];\n\n    for (int i=0; i<nDocs; i++) {\n      SolrInputDocument doc = sdoc(\"id\", Integer.toString(i));\n\n      Double price = rand(prices);\n      if (price != null) {\n        doc.addField(\"cost_f\", price);\n      }\n      boolean matches_price = price!=null && price >= price_low && price <= price_high;\n\n      String make = rand(makes);\n      if (make != null) {\n        doc.addField(make_s, make);\n      }\n\n      if (\"honda\".equals(make)) {\n        int modelNum = r.nextInt(honda_models.length);\n        String model = honda_models[modelNum];\n        if (model != null) {\n          doc.addField(model_s, model);\n        }\n        if (matches_price) {\n          nHonda++;\n          honda_model_counts[modelNum]++;\n        }\n      } else if (make == null) {\n        doc.addField(model_s, rand(honda_models));  // add some docs w/ model but w/o make\n      } else {\n        // other makes\n        doc.addField(model_s, rand(other_models));  // add some docs w/ model but w/o make\n      }\n\n      client.add(doc, null);\n      if (r.nextInt(10) == 0) {\n        client.add(doc, null);  // dup, causing a delete\n      }\n      if (r.nextInt(20) == 0) {\n        client.commit();  // force new seg\n      }\n    }\n\n    client.commit();\n\n    // now figure out top counts\n    List<Integer> idx = new ArrayList<>();\n    for (int i=0; i<honda_model_counts.length-1; i++) {\n      idx.add(i);\n    }\n    Collections.sort(idx, new Comparator<Integer>() {\n      @Override\n      public int compare(Integer o1, Integer o2) {\n        int cmp = honda_model_counts[o2] - honda_model_counts[o1];\n        return cmp == 0 ? o1 - o2 : cmp;\n      }\n    });\n\n\n\n    // straight query facets\n    client.testJQ(params(p, \"q\", \"*:*\", \"rows\",\"0\", \"fq\",\"+${make_s}:honda +cost_f:[${price_low} TO ${price_high}]\"\n            , \"json.facet\", \"{makes:{terms:{field:${make_s}, facet:{models:{terms:{field:${model_s}, limit:2, mincount:0}}}}}}}\"\n            , \"facet\",\"true\", \"facet.pivot\",\"make_s,model_s\", \"facet.limit\", \"2\"\n        )\n        , \"facets=={count:\" + nHonda + \", makes:{buckets:[{val:honda, count:\" + nHonda + \", models:{buckets:[\"\n           + \"{val:\" + honda_models[idx.get(0)] + \", count:\" + honda_model_counts[idx.get(0)] + \"},\"\n           + \"{val:\" + honda_models[idx.get(1)] + \", count:\" + honda_model_counts[idx.get(1)] + \"}]}\"\n           + \"}]}}\"\n    );\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e85a45082c16d50af183c2782869a1fd612a16a","date":1430325300,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","sourceNew":"  // attempt to reproduce https://github.com/Heliosearch/heliosearch/issues/33\n  @Test\n  public void testComplex() throws Exception {\n    Random r = random();\n\n    Client client = Client.localClient;\n\n    double price_low = 11000;\n    double price_high = 100000;\n\n    ModifiableSolrParams p = params(\"make_s\",\"make_s\", \"model_s\",\"model_s\", \"price_low\",Double.toString(price_low), \"price_high\",Double.toString(price_high));\n\n\n    MacroExpander m = new MacroExpander( p.getMap() );\n\n    String make_s = m.expand(\"${make_s}\");\n    String model_s = m.expand(\"${model_s}\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    int nDocs = 99;\n    String[] makes = {\"honda\", \"toyota\", \"ford\", null};\n    Double[] prices = {10000.0, 30000.0, 50000.0, 0.0, null};\n    String[] honda_models = {\"accord\", \"civic\", \"fit\", \"pilot\", null};  // make sure this is alphabetized to match tiebreaks in index\n    String[] other_models = {\"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", null};\n\n    int nHonda = 0;\n    final int[] honda_model_counts = new int[honda_models.length];\n\n    for (int i=0; i<nDocs; i++) {\n      SolrInputDocument doc = sdoc(\"id\", Integer.toString(i));\n\n      Double price = rand(prices);\n      if (price != null) {\n        doc.addField(\"cost_f\", price);\n      }\n      boolean matches_price = price!=null && price >= price_low && price <= price_high;\n\n      String make = rand(makes);\n      if (make != null) {\n        doc.addField(make_s, make);\n      }\n\n      if (\"honda\".equals(make)) {\n        int modelNum = r.nextInt(honda_models.length);\n        String model = honda_models[modelNum];\n        if (model != null) {\n          doc.addField(model_s, model);\n        }\n        if (matches_price) {\n          nHonda++;\n          honda_model_counts[modelNum]++;\n        }\n      } else if (make == null) {\n        doc.addField(model_s, rand(honda_models));  // add some docs w/ model but w/o make\n      } else {\n        // other makes\n        doc.addField(model_s, rand(other_models));  // add some docs w/ model but w/o make\n      }\n\n      client.add(doc, null);\n      if (r.nextInt(10) == 0) {\n        client.add(doc, null);  // dup, causing a delete\n      }\n      if (r.nextInt(20) == 0) {\n        client.commit();  // force new seg\n      }\n    }\n\n    client.commit();\n\n    // now figure out top counts\n    List<Integer> idx = new ArrayList<>();\n    for (int i=0; i<honda_model_counts.length-1; i++) {\n      idx.add(i);\n    }\n    Collections.sort(idx, new Comparator<Integer>() {\n      @Override\n      public int compare(Integer o1, Integer o2) {\n        int cmp = honda_model_counts[o2] - honda_model_counts[o1];\n        return cmp == 0 ? o1 - o2 : cmp;\n      }\n    });\n\n\n\n    // straight query facets\n    client.testJQ(params(p, \"q\", \"*:*\", \"rows\",\"0\", \"fq\",\"+${make_s}:honda +cost_f:[${price_low} TO ${price_high}]\"\n            , \"json.facet\", \"{makes:{terms:{field:${make_s}, facet:{models:{terms:{field:${model_s}, limit:2, mincount:0}}}}}}}\"\n            , \"facet\",\"true\", \"facet.pivot\",\"make_s,model_s\", \"facet.limit\", \"2\"\n        )\n        , \"facets=={count:\" + nHonda + \", makes:{buckets:[{val:honda, count:\" + nHonda + \", models:{buckets:[\"\n           + \"{val:\" + honda_models[idx.get(0)] + \", count:\" + honda_model_counts[idx.get(0)] + \"},\"\n           + \"{val:\" + honda_models[idx.get(1)] + \", count:\" + honda_model_counts[idx.get(1)] + \"}]}\"\n           + \"}]}}\"\n    );\n\n\n  }\n\n","sourceOld":"  // attempt to reproduce https://github.com/Heliosearch/heliosearch/issues/33\n  @Test\n  public void testComplex() throws Exception {\n    Random r = random();\n\n    Client client = Client.localClient;\n\n    double price_low = 11000;\n    double price_high = 100000;\n\n    ModifiableSolrParams p = params(\"make_s\",\"make_s\", \"model_s\",\"model_s\", \"price_low\",Double.toString(price_low), \"price_high\",Double.toString(price_high));\n\n\n    MacroExpander m = new MacroExpander( p.getMap() );\n\n    String make_s = m.expand(\"${make_s}\");\n    String model_s = m.expand(\"${model_s}\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    int nDocs = 99;\n    String[] makes = {\"honda\", \"toyota\", \"ford\", null};\n    Double[] prices = {10000.0, 30000.0, 50000.0, 0.0, null};\n    String[] honda_models = {\"accord\", \"civic\", \"fit\", \"pilot\", null};  // make sure this is alphabetized to match tiebreaks in index\n    String[] other_models = {\"a\", \"b\", \"c\", \"x\", \"y\", \"z\", null};\n\n    int nHonda = 0;\n    final int[] honda_model_counts = new int[honda_models.length];\n\n    for (int i=0; i<nDocs; i++) {\n      SolrInputDocument doc = sdoc(\"id\", Integer.toString(i));\n\n      Double price = rand(prices);\n      if (price != null) {\n        doc.addField(\"cost_f\", price);\n      }\n      boolean matches_price = price!=null && price >= price_low && price <= price_high;\n\n      String make = rand(makes);\n      if (make != null) {\n        doc.addField(make_s, make);\n      }\n\n      if (\"honda\".equals(make)) {\n        int modelNum = r.nextInt(honda_models.length);\n        String model = honda_models[modelNum];\n        if (model != null) {\n          doc.addField(model_s, model);\n        }\n        if (matches_price) {\n          nHonda++;\n          honda_model_counts[modelNum]++;\n        }\n      } else if (make == null) {\n        doc.addField(model_s, rand(honda_models));  // add some docs w/ model but w/o make\n      } else {\n        // other makes\n        doc.addField(model_s, rand(other_models));  // add some docs w/ model but w/o make\n      }\n\n      client.add(doc, null);\n      if (r.nextInt(10) == 0) {\n        client.add(doc, null);  // dup, causing a delete\n      }\n      if (r.nextInt(20) == 0) {\n        client.commit();  // force new seg\n      }\n    }\n\n    client.commit();\n\n    // now figure out top counts\n    List<Integer> idx = new ArrayList<>();\n    for (int i=0; i<honda_model_counts.length-1; i++) {\n      idx.add(i);\n    }\n    Collections.sort(idx, new Comparator<Integer>() {\n      @Override\n      public int compare(Integer o1, Integer o2) {\n        int cmp = honda_model_counts[o2] - honda_model_counts[o1];\n        return cmp == 0 ? o1 - o2 : cmp;\n      }\n    });\n\n\n\n    // straight query facets\n    client.testJQ(params(p, \"q\", \"*:*\", \"rows\",\"0\", \"fq\",\"+${make_s}:honda +cost_f:[${price_low} TO ${price_high}]\"\n            , \"json.facet\", \"{makes:{terms:{field:${make_s}, facet:{models:{terms:{field:${model_s}, limit:2, mincount:0}}}}}}}\"\n            , \"facet\",\"true\", \"facet.pivot\",\"make_s,model_s\", \"facet.limit\", \"2\"\n        )\n        , \"facets=={count:\" + nHonda + \", makes:{buckets:[{val:honda, count:\" + nHonda + \", models:{buckets:[\"\n           + \"{val:\" + honda_models[idx.get(0)] + \", count:\" + honda_model_counts[idx.get(0)] + \"},\"\n           + \"{val:\" + honda_models[idx.get(1)] + \", count:\" + honda_model_counts[idx.get(1)] + \"}]}\"\n           + \"}]}}\"\n    );\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","sourceNew":"  // attempt to reproduce https://github.com/Heliosearch/heliosearch/issues/33\n  @Test\n  public void testComplex() throws Exception {\n    Random r = random();\n\n    Client client = Client.localClient;\n\n    double price_low = 11000;\n    double price_high = 100000;\n\n    ModifiableSolrParams p = params(\"make_s\",\"make_s\", \"model_s\",\"model_s\", \"price_low\",Double.toString(price_low), \"price_high\",Double.toString(price_high));\n\n\n    MacroExpander m = new MacroExpander( p.getMap() );\n\n    String make_s = m.expand(\"${make_s}\");\n    String model_s = m.expand(\"${model_s}\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    int nDocs = 99;\n    String[] makes = {\"honda\", \"toyota\", \"ford\", null};\n    Double[] prices = {10000.0, 30000.0, 50000.0, 0.0, null};\n    String[] honda_models = {\"accord\", \"civic\", \"fit\", \"pilot\", null};  // make sure this is alphabetized to match tiebreaks in index\n    String[] other_models = {\"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", null};\n\n    int nHonda = 0;\n    final int[] honda_model_counts = new int[honda_models.length];\n\n    for (int i=0; i<nDocs; i++) {\n      SolrInputDocument doc = sdoc(\"id\", Integer.toString(i));\n\n      Double price = rand(prices);\n      if (price != null) {\n        doc.addField(\"cost_f\", price);\n      }\n      boolean matches_price = price!=null && price >= price_low && price <= price_high;\n\n      String make = rand(makes);\n      if (make != null) {\n        doc.addField(make_s, make);\n      }\n\n      if (\"honda\".equals(make)) {\n        int modelNum = r.nextInt(honda_models.length);\n        String model = honda_models[modelNum];\n        if (model != null) {\n          doc.addField(model_s, model);\n        }\n        if (matches_price) {\n          nHonda++;\n          honda_model_counts[modelNum]++;\n        }\n      } else if (make == null) {\n        doc.addField(model_s, rand(honda_models));  // add some docs w/ model but w/o make\n      } else {\n        // other makes\n        doc.addField(model_s, rand(other_models));  // add some docs w/ model but w/o make\n      }\n\n      client.add(doc, null);\n      if (r.nextInt(10) == 0) {\n        client.add(doc, null);  // dup, causing a delete\n      }\n      if (r.nextInt(20) == 0) {\n        client.commit();  // force new seg\n      }\n    }\n\n    client.commit();\n\n    // now figure out top counts\n    List<Integer> idx = new ArrayList<>();\n    for (int i=0; i<honda_model_counts.length-1; i++) {\n      idx.add(i);\n    }\n    Collections.sort(idx, (o1, o2) -> {\n      int cmp = honda_model_counts[o2] - honda_model_counts[o1];\n      return cmp == 0 ? o1 - o2 : cmp;\n    });\n\n\n\n    // straight query facets\n    client.testJQ(params(p, \"q\", \"*:*\", \"rows\",\"0\", \"fq\",\"+${make_s}:honda +cost_f:[${price_low} TO ${price_high}]\"\n            , \"json.facet\", \"{makes:{terms:{field:${make_s}, facet:{models:{terms:{field:${model_s}, limit:2, mincount:0}}}}}}}\"\n            , \"facet\",\"true\", \"facet.pivot\",\"make_s,model_s\", \"facet.limit\", \"2\"\n        )\n        , \"facets=={count:\" + nHonda + \", makes:{buckets:[{val:honda, count:\" + nHonda + \", models:{buckets:[\"\n           + \"{val:\" + honda_models[idx.get(0)] + \", count:\" + honda_model_counts[idx.get(0)] + \"},\"\n           + \"{val:\" + honda_models[idx.get(1)] + \", count:\" + honda_model_counts[idx.get(1)] + \"}]}\"\n           + \"}]}}\"\n    );\n\n\n  }\n\n","sourceOld":"  // attempt to reproduce https://github.com/Heliosearch/heliosearch/issues/33\n  @Test\n  public void testComplex() throws Exception {\n    Random r = random();\n\n    Client client = Client.localClient;\n\n    double price_low = 11000;\n    double price_high = 100000;\n\n    ModifiableSolrParams p = params(\"make_s\",\"make_s\", \"model_s\",\"model_s\", \"price_low\",Double.toString(price_low), \"price_high\",Double.toString(price_high));\n\n\n    MacroExpander m = new MacroExpander( p.getMap() );\n\n    String make_s = m.expand(\"${make_s}\");\n    String model_s = m.expand(\"${model_s}\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    int nDocs = 99;\n    String[] makes = {\"honda\", \"toyota\", \"ford\", null};\n    Double[] prices = {10000.0, 30000.0, 50000.0, 0.0, null};\n    String[] honda_models = {\"accord\", \"civic\", \"fit\", \"pilot\", null};  // make sure this is alphabetized to match tiebreaks in index\n    String[] other_models = {\"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", null};\n\n    int nHonda = 0;\n    final int[] honda_model_counts = new int[honda_models.length];\n\n    for (int i=0; i<nDocs; i++) {\n      SolrInputDocument doc = sdoc(\"id\", Integer.toString(i));\n\n      Double price = rand(prices);\n      if (price != null) {\n        doc.addField(\"cost_f\", price);\n      }\n      boolean matches_price = price!=null && price >= price_low && price <= price_high;\n\n      String make = rand(makes);\n      if (make != null) {\n        doc.addField(make_s, make);\n      }\n\n      if (\"honda\".equals(make)) {\n        int modelNum = r.nextInt(honda_models.length);\n        String model = honda_models[modelNum];\n        if (model != null) {\n          doc.addField(model_s, model);\n        }\n        if (matches_price) {\n          nHonda++;\n          honda_model_counts[modelNum]++;\n        }\n      } else if (make == null) {\n        doc.addField(model_s, rand(honda_models));  // add some docs w/ model but w/o make\n      } else {\n        // other makes\n        doc.addField(model_s, rand(other_models));  // add some docs w/ model but w/o make\n      }\n\n      client.add(doc, null);\n      if (r.nextInt(10) == 0) {\n        client.add(doc, null);  // dup, causing a delete\n      }\n      if (r.nextInt(20) == 0) {\n        client.commit();  // force new seg\n      }\n    }\n\n    client.commit();\n\n    // now figure out top counts\n    List<Integer> idx = new ArrayList<>();\n    for (int i=0; i<honda_model_counts.length-1; i++) {\n      idx.add(i);\n    }\n    Collections.sort(idx, new Comparator<Integer>() {\n      @Override\n      public int compare(Integer o1, Integer o2) {\n        int cmp = honda_model_counts[o2] - honda_model_counts[o1];\n        return cmp == 0 ? o1 - o2 : cmp;\n      }\n    });\n\n\n\n    // straight query facets\n    client.testJQ(params(p, \"q\", \"*:*\", \"rows\",\"0\", \"fq\",\"+${make_s}:honda +cost_f:[${price_low} TO ${price_high}]\"\n            , \"json.facet\", \"{makes:{terms:{field:${make_s}, facet:{models:{terms:{field:${model_s}, limit:2, mincount:0}}}}}}}\"\n            , \"facet\",\"true\", \"facet.pivot\",\"make_s,model_s\", \"facet.limit\", \"2\"\n        )\n        , \"facets=={count:\" + nHonda + \", makes:{buckets:[{val:honda, count:\" + nHonda + \", models:{buckets:[\"\n           + \"{val:\" + honda_models[idx.get(0)] + \", count:\" + honda_model_counts[idx.get(0)] + \"},\"\n           + \"{val:\" + honda_models[idx.get(1)] + \", count:\" + honda_model_counts[idx.get(1)] + \"}]}\"\n           + \"}]}}\"\n    );\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99","date":1571689506,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testComplex().mjava","sourceNew":"  // attempt to reproduce https://github.com/Heliosearch/heliosearch/issues/33\n  @Test\n  public void testComplex() throws Exception {\n    Random r = random();\n\n    Client client = Client.localClient;\n\n    double price_low = 11000;\n    double price_high = 100000;\n\n    ModifiableSolrParams p = params(\"make_s\",\"make_s\", \"model_s\",\"model_s\", \"price_low\",Double.toString(price_low), \"price_high\",Double.toString(price_high));\n\n\n    MacroExpander m = new MacroExpander( p.getMap() );\n\n    String make_s = m.expand(\"${make_s}\");\n    String model_s = m.expand(\"${model_s}\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    int nDocs = 99;\n    String[] makes = {\"honda\", \"toyota\", \"ford\", null};\n    Double[] prices = {10000.0, 30000.0, 50000.0, 0.0, null};\n    String[] honda_models = {\"accord\", \"civic\", \"fit\", \"pilot\", null};  // make sure this is alphabetized to match tiebreaks in index\n    String[] other_models = {\"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", null};\n\n    int nHonda = 0;\n    final int[] honda_model_counts = new int[honda_models.length];\n\n    for (int i=0; i<nDocs; i++) {\n      SolrInputDocument doc = sdoc(\"id\", Integer.toString(i));\n\n      Double price = rand(prices);\n      if (price != null) {\n        doc.addField(\"cost_f\", price);\n      }\n      boolean matches_price = price!=null && price >= price_low && price <= price_high;\n\n      String make = rand(makes);\n      if (make != null) {\n        doc.addField(make_s, make);\n      }\n\n      if (\"honda\".equals(make)) {\n        int modelNum = r.nextInt(honda_models.length);\n        String model = honda_models[modelNum];\n        if (model != null) {\n          doc.addField(model_s, model);\n        }\n        if (matches_price) {\n          nHonda++;\n          honda_model_counts[modelNum]++;\n        }\n      } else if (make == null) {\n        doc.addField(model_s, rand(honda_models));  // add some docs w/ model but w/o make\n      } else {\n        // other makes\n        doc.addField(model_s, rand(other_models));  // add some docs w/ model but w/o make\n      }\n\n      client.add(doc, null);\n      if (r.nextInt(10) == 0) {\n        client.add(doc, null);  // dup, causing a delete\n      }\n      if (r.nextInt(20) == 0) {\n        client.commit();  // force new seg\n      }\n    }\n\n    client.commit();\n\n    // now figure out top counts\n    List<Integer> idx = new ArrayList<>();\n    for (int i=0; i<honda_model_counts.length-1; i++) {\n      idx.add(i);\n    }\n    Collections.sort(idx, (o1, o2) -> {\n      int cmp = honda_model_counts[o2] - honda_model_counts[o1];\n      return cmp == 0 ? o1 - o2 : cmp;\n    });\n\n\n\n    // straight query facets\n    client.testJQ(params(p, \"q\", \"*:*\", \"rows\",\"0\", \"fq\",\"+${make_s}:honda +cost_f:[${price_low} TO ${price_high}]\"\n            , \"json.facet\", \"{makes:{terms:{field:${make_s}, facet:{models:{terms:{field:${model_s}, limit:2, mincount:0}}}}\"\n                + \"}}\"\n            , \"facet\",\"true\", \"facet.pivot\",\"make_s,model_s\", \"facet.limit\", \"2\"\n        )\n        , \"facets=={count:\" + nHonda + \", makes:{buckets:[{val:honda, count:\" + nHonda + \", models:{buckets:[\"\n           + \"{val:\" + honda_models[idx.get(0)] + \", count:\" + honda_model_counts[idx.get(0)] + \"},\"\n           + \"{val:\" + honda_models[idx.get(1)] + \", count:\" + honda_model_counts[idx.get(1)] + \"}]}\"\n           + \"}]}}\"\n    );\n\n\n  }\n\n","sourceOld":"  // attempt to reproduce https://github.com/Heliosearch/heliosearch/issues/33\n  @Test\n  public void testComplex() throws Exception {\n    Random r = random();\n\n    Client client = Client.localClient;\n\n    double price_low = 11000;\n    double price_high = 100000;\n\n    ModifiableSolrParams p = params(\"make_s\",\"make_s\", \"model_s\",\"model_s\", \"price_low\",Double.toString(price_low), \"price_high\",Double.toString(price_high));\n\n\n    MacroExpander m = new MacroExpander( p.getMap() );\n\n    String make_s = m.expand(\"${make_s}\");\n    String model_s = m.expand(\"${model_s}\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    int nDocs = 99;\n    String[] makes = {\"honda\", \"toyota\", \"ford\", null};\n    Double[] prices = {10000.0, 30000.0, 50000.0, 0.0, null};\n    String[] honda_models = {\"accord\", \"civic\", \"fit\", \"pilot\", null};  // make sure this is alphabetized to match tiebreaks in index\n    String[] other_models = {\"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", null};\n\n    int nHonda = 0;\n    final int[] honda_model_counts = new int[honda_models.length];\n\n    for (int i=0; i<nDocs; i++) {\n      SolrInputDocument doc = sdoc(\"id\", Integer.toString(i));\n\n      Double price = rand(prices);\n      if (price != null) {\n        doc.addField(\"cost_f\", price);\n      }\n      boolean matches_price = price!=null && price >= price_low && price <= price_high;\n\n      String make = rand(makes);\n      if (make != null) {\n        doc.addField(make_s, make);\n      }\n\n      if (\"honda\".equals(make)) {\n        int modelNum = r.nextInt(honda_models.length);\n        String model = honda_models[modelNum];\n        if (model != null) {\n          doc.addField(model_s, model);\n        }\n        if (matches_price) {\n          nHonda++;\n          honda_model_counts[modelNum]++;\n        }\n      } else if (make == null) {\n        doc.addField(model_s, rand(honda_models));  // add some docs w/ model but w/o make\n      } else {\n        // other makes\n        doc.addField(model_s, rand(other_models));  // add some docs w/ model but w/o make\n      }\n\n      client.add(doc, null);\n      if (r.nextInt(10) == 0) {\n        client.add(doc, null);  // dup, causing a delete\n      }\n      if (r.nextInt(20) == 0) {\n        client.commit();  // force new seg\n      }\n    }\n\n    client.commit();\n\n    // now figure out top counts\n    List<Integer> idx = new ArrayList<>();\n    for (int i=0; i<honda_model_counts.length-1; i++) {\n      idx.add(i);\n    }\n    Collections.sort(idx, (o1, o2) -> {\n      int cmp = honda_model_counts[o2] - honda_model_counts[o1];\n      return cmp == 0 ? o1 - o2 : cmp;\n    });\n\n\n\n    // straight query facets\n    client.testJQ(params(p, \"q\", \"*:*\", \"rows\",\"0\", \"fq\",\"+${make_s}:honda +cost_f:[${price_low} TO ${price_high}]\"\n            , \"json.facet\", \"{makes:{terms:{field:${make_s}, facet:{models:{terms:{field:${model_s}, limit:2, mincount:0}}}}}}}\"\n            , \"facet\",\"true\", \"facet.pivot\",\"make_s,model_s\", \"facet.limit\", \"2\"\n        )\n        , \"facets=={count:\" + nHonda + \", makes:{buckets:[{val:honda, count:\" + nHonda + \", models:{buckets:[\"\n           + \"{val:\" + honda_models[idx.get(0)] + \", count:\" + honda_model_counts[idx.get(0)] + \"},\"\n           + \"{val:\" + honda_models[idx.get(1)] + \", count:\" + honda_model_counts[idx.get(1)] + \"}]}\"\n           + \"}]}}\"\n    );\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99":["3a0c04b71951333291abc7f317109a6a5957bd28"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3e85a45082c16d50af183c2782869a1fd612a16a":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a0c04b71951333291abc7f317109a6a5957bd28":["3e85a45082c16d50af183c2782869a1fd612a16a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["61f55b4999c3f858f4f4acc9c6dc57af2c1acf99"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","3e85a45082c16d50af183c2782869a1fd612a16a"],"3e85a45082c16d50af183c2782869a1fd612a16a":["3a0c04b71951333291abc7f317109a6a5957bd28"],"3a0c04b71951333291abc7f317109a6a5957bd28":["61f55b4999c3f858f4f4acc9c6dc57af2c1acf99"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}