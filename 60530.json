{"path":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParser#expression(int).mjava","commits":[{"id":"d23d4828afa583ebf35b4a541763af6206133458","date":1438931440,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptParser#expression(int).mjava","pathOld":"/dev/null","sourceNew":"  private ExpressionContext expression(int _p) throws RecognitionException {\n    ParserRuleContext _parentctx = _ctx;\n    int _parentState = getState();\n    ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);\n    ExpressionContext _prevctx = _localctx;\n    int _startState = 2;\n    enterRecursionRule(_localctx, 2, RULE_expression, _p);\n    int _la;\n    try {\n      int _alt;\n      enterOuterAlt(_localctx, 1);\n      {\n      setState(30);\n      switch (_input.LA(1)) {\n      case BOOLNOT:\n      case BWNOT:\n      case ADD:\n      case SUB:\n        {\n        _localctx = new UnaryContext(_localctx);\n        _ctx = _localctx;\n        _prevctx = _localctx;\n\n        setState(8);\n        _la = _input.LA(1);\n        if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB))) != 0)) ) {\n        _errHandler.recoverInline(this);\n        } else {\n          consume();\n        }\n        setState(9);\n        expression(12);\n        }\n        break;\n      case LP:\n        {\n        _localctx = new PrecedenceContext(_localctx);\n        _ctx = _localctx;\n        _prevctx = _localctx;\n        setState(10);\n        match(LP);\n        setState(11);\n        expression(0);\n        setState(12);\n        match(RP);\n        }\n        break;\n      case OCTAL:\n      case HEX:\n      case DECIMAL:\n        {\n        _localctx = new NumericContext(_localctx);\n        _ctx = _localctx;\n        _prevctx = _localctx;\n        setState(14);\n        _la = _input.LA(1);\n        if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OCTAL) | (1L << HEX) | (1L << DECIMAL))) != 0)) ) {\n        _errHandler.recoverInline(this);\n        } else {\n          consume();\n        }\n        }\n        break;\n      case VARIABLE:\n        {\n        _localctx = new ExternalContext(_localctx);\n        _ctx = _localctx;\n        _prevctx = _localctx;\n        setState(15);\n        match(VARIABLE);\n        setState(28);\n        switch ( getInterpreter().adaptivePredict(_input,2,_ctx) ) {\n        case 1:\n          {\n          setState(16);\n          match(LP);\n          setState(25);\n          _la = _input.LA(1);\n          if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB) | (1L << VARIABLE) | (1L << OCTAL) | (1L << HEX) | (1L << DECIMAL))) != 0)) {\n            {\n            setState(17);\n            expression(0);\n            setState(22);\n            _errHandler.sync(this);\n            _la = _input.LA(1);\n            while (_la==COMMA) {\n              {\n              {\n              setState(18);\n              match(COMMA);\n              setState(19);\n              expression(0);\n              }\n              }\n              setState(24);\n              _errHandler.sync(this);\n              _la = _input.LA(1);\n            }\n            }\n          }\n\n          setState(27);\n          match(RP);\n          }\n          break;\n        }\n        }\n        break;\n      default:\n        throw new NoViableAltException(this);\n      }\n      _ctx.stop = _input.LT(-1);\n      setState(70);\n      _errHandler.sync(this);\n      _alt = getInterpreter().adaptivePredict(_input,5,_ctx);\n      while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {\n        if ( _alt==1 ) {\n          if ( _parseListeners!=null ) triggerExitRuleEvent();\n          _prevctx = _localctx;\n          {\n          setState(68);\n          switch ( getInterpreter().adaptivePredict(_input,4,_ctx) ) {\n          case 1:\n            {\n            _localctx = new MuldivContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(32);\n            if (!(precpred(_ctx, 11))) throw new FailedPredicateException(this, \"precpred(_ctx, 11)\");\n            setState(33);\n            _la = _input.LA(1);\n            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << MUL) | (1L << DIV) | (1L << REM))) != 0)) ) {\n            _errHandler.recoverInline(this);\n            } else {\n              consume();\n            }\n            setState(34);\n            expression(12);\n            }\n            break;\n          case 2:\n            {\n            _localctx = new AddsubContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(35);\n            if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, \"precpred(_ctx, 10)\");\n            setState(36);\n            _la = _input.LA(1);\n            if ( !(_la==ADD || _la==SUB) ) {\n            _errHandler.recoverInline(this);\n            } else {\n              consume();\n            }\n            setState(37);\n            expression(11);\n            }\n            break;\n          case 3:\n            {\n            _localctx = new BwshiftContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(38);\n            if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, \"precpred(_ctx, 9)\");\n            setState(39);\n            _la = _input.LA(1);\n            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LSH) | (1L << RSH) | (1L << USH))) != 0)) ) {\n            _errHandler.recoverInline(this);\n            } else {\n              consume();\n            }\n            setState(40);\n            expression(10);\n            }\n            break;\n          case 4:\n            {\n            _localctx = new BoolcompContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(41);\n            if (!(precpred(_ctx, 8))) throw new FailedPredicateException(this, \"precpred(_ctx, 8)\");\n            setState(42);\n            _la = _input.LA(1);\n            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LT) | (1L << LTE) | (1L << GT) | (1L << GTE))) != 0)) ) {\n            _errHandler.recoverInline(this);\n            } else {\n              consume();\n            }\n            setState(43);\n            expression(9);\n            }\n            break;\n          case 5:\n            {\n            _localctx = new BooleqneContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(44);\n            if (!(precpred(_ctx, 7))) throw new FailedPredicateException(this, \"precpred(_ctx, 7)\");\n            setState(45);\n            _la = _input.LA(1);\n            if ( !(_la==EQ || _la==NE) ) {\n            _errHandler.recoverInline(this);\n            } else {\n              consume();\n            }\n            setState(46);\n            expression(8);\n            }\n            break;\n          case 6:\n            {\n            _localctx = new BwandContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(47);\n            if (!(precpred(_ctx, 6))) throw new FailedPredicateException(this, \"precpred(_ctx, 6)\");\n            setState(48);\n            match(BWAND);\n            setState(49);\n            expression(7);\n            }\n            break;\n          case 7:\n            {\n            _localctx = new BwxorContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(50);\n            if (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, \"precpred(_ctx, 5)\");\n            setState(51);\n            match(BWXOR);\n            setState(52);\n            expression(6);\n            }\n            break;\n          case 8:\n            {\n            _localctx = new BworContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(53);\n            if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, \"precpred(_ctx, 4)\");\n            setState(54);\n            match(BWOR);\n            setState(55);\n            expression(5);\n            }\n            break;\n          case 9:\n            {\n            _localctx = new BoolandContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(56);\n            if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, \"precpred(_ctx, 3)\");\n            setState(57);\n            match(BOOLAND);\n            setState(58);\n            expression(4);\n            }\n            break;\n          case 10:\n            {\n            _localctx = new BoolorContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(59);\n            if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, \"precpred(_ctx, 2)\");\n            setState(60);\n            match(BOOLOR);\n            setState(61);\n            expression(3);\n            }\n            break;\n          case 11:\n            {\n            _localctx = new ConditionalContext(new ExpressionContext(_parentctx, _parentState));\n            pushNewRecursionContext(_localctx, _startState, RULE_expression);\n            setState(62);\n            if (!(precpred(_ctx, 1))) throw new FailedPredicateException(this, \"precpred(_ctx, 1)\");\n            setState(63);\n            match(COND);\n            setState(64);\n            expression(0);\n            setState(65);\n            match(COLON);\n            setState(66);\n            expression(1);\n            }\n            break;\n          }\n          } \n        }\n        setState(72);\n        _errHandler.sync(this);\n        _alt = getInterpreter().adaptivePredict(_input,5,_ctx);\n      }\n      }\n    }\n    catch (RecognitionException re) {\n      _localctx.exception = re;\n      _errHandler.reportError(this, re);\n      _errHandler.recover(this, re);\n    }\n    finally {\n      unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d23d4828afa583ebf35b4a541763af6206133458":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d23d4828afa583ebf35b4a541763af6206133458"]},"commit2Childs":{"d23d4828afa583ebf35b4a541763af6206133458":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d23d4828afa583ebf35b4a541763af6206133458"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}