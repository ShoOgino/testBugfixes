{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(SegmentState[],boolean).mjava","commits":[{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    finishSegmentStates(segmentStates);\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<BufferedUpdatesStream.SegmentState> segmentStates = Arrays.asList(segStates);\n    for (BufferedUpdatesStream.SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.close(segmentStates);\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    finishSegmentStates(segmentStates);\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":["183c6c48c88f771980fbee167337abf9932c6f80","4987206dabc9f3576bb1df72e987094a7dad6e4f"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1926100d9b67becc9701c54266fee3ba7878a5f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"]},"commit2Childs":{"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}