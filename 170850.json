{"path":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","commits":[{"id":"03a198be002bb6786dce54cf550c3ca7bb7b88a9","date":1287519003,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = searcher.getSchema().getField(field).getType();\n    \n    // Required to translate back to an object\n    Field f = new Field( field, \"X\", Store.YES, Index.ANALYZED );\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        String internal = ftype.toInternal( kv.getKey() );\n        f.setValue( internal );\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject( f ) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, internal));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e250f610380dc5c3ba65cb770f4076d47d2c1d89","e250f610380dc5c3ba65cb770f4076d47d2c1d89","e250f610380dc5c3ba65cb770f4076d47d2c1d89"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = searcher.getSchema().getField(field).getType();\n    \n    // Required to translate back to an object\n    Field f = new Field( field, \"X\", Store.YES, Index.ANALYZED );\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        String internal = ftype.toInternal( kv.getKey() );\n        f.setValue( internal );\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject( f ) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, internal));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87337212608bc7aa67d96011034596313b071c0e","date":1288995394,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = searcher.getSchema().getField(field).getType();\n    \n    // Required to translate back to an object\n    Field f = new Field( field, \"X\", Store.YES, Index.ANALYZED );\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        String internal = ftype.toInternal( kv.getKey() );\n        f.setValue( internal );\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject( f ) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, internal));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":["e250f610380dc5c3ba65cb770f4076d47d2c1d89","e250f610380dc5c3ba65cb770f4076d47d2c1d89","e250f610380dc5c3ba65cb770f4076d47d2c1d89"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = searcher.getSchema().getField(field).getType();\n    \n    // Required to translate back to an object\n    Field f = new Field( field, \"X\", Store.YES, Index.ANALYZED );\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        String internal = ftype.toInternal( kv.getKey() );\n        f.setValue( internal );\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject( f ) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, internal));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16a7edba6fcd8947b63d65ec819a2686aa8f1f37","date":1296311445,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["16a7edba6fcd8947b63d65ec819a2686aa8f1f37","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"85a883878c0af761245ab048babc63d099f835f3":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","87337212608bc7aa67d96011034596313b071c0e"],"16a7edba6fcd8947b63d65ec819a2686aa8f1f37":["87337212608bc7aa67d96011034596313b071c0e"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","87337212608bc7aa67d96011034596313b071c0e"],"87337212608bc7aa67d96011034596313b071c0e":["03a198be002bb6786dce54cf550c3ca7bb7b88a9"],"03a198be002bb6786dce54cf550c3ca7bb7b88a9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["16a7edba6fcd8947b63d65ec819a2686aa8f1f37"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["85a883878c0af761245ab048babc63d099f835f3","16a7edba6fcd8947b63d65ec819a2686aa8f1f37"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["16a7edba6fcd8947b63d65ec819a2686aa8f1f37"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","03a198be002bb6786dce54cf550c3ca7bb7b88a9"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","16a7edba6fcd8947b63d65ec819a2686aa8f1f37"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"85a883878c0af761245ab048babc63d099f835f3":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"16a7edba6fcd8947b63d65ec819a2686aa8f1f37":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"87337212608bc7aa67d96011034596313b071c0e":["85a883878c0af761245ab048babc63d099f835f3","16a7edba6fcd8947b63d65ec819a2686aa8f1f37","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"03a198be002bb6786dce54cf550c3ca7bb7b88a9":["87337212608bc7aa67d96011034596313b071c0e","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","03a198be002bb6786dce54cf550c3ca7bb7b88a9","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["85a883878c0af761245ab048babc63d099f835f3"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}