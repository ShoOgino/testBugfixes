{"path":"solr/core/src/java/org/apache/solr/search/facet/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","sourceNew":"  public static UnInvertedField getUnInvertedField(String field, SolrIndexSearcher searcher) throws IOException {\n    SolrCache<String,UnInvertedField> cache = searcher.getFieldValueCache();\n    if (cache == null) {\n      return new UnInvertedField(field, searcher);\n    }\n    UnInvertedField uif = null;\n    Boolean doWait = false;\n    synchronized (cache) {\n      uif = cache.get(field);\n      if (uif == null) {\n        /**\n         * We use this place holder object to pull the UninvertedField construction out of the sync\n         * so that if many fields are accessed in a short time, the UninvertedField can be\n         * built for these fields in parallel rather than sequentially.\n         */\n        cache.put(field, uifPlaceholder);\n      } else {\n        if (uif != uifPlaceholder) {\n          return uif;\n        }\n        doWait = true; // Someone else has put the place holder in, wait for that to complete.\n      }\n    }\n    while (doWait) {\n      try {\n        synchronized (cache) {\n          uif = cache.get(field); // Should at least return the placeholder, NPE if not is OK.\n          if (uif != uifPlaceholder) { // OK, another thread put this in the cache we should be good.\n            return uif;\n          }\n          cache.wait();\n        }\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted in getUninvertedField.\");\n      }\n    }\n\n    uif = new UnInvertedField(field, searcher);\n    synchronized (cache) {\n      cache.put(field, uif); // Note, this cleverly replaces the placeholder.\n      cache.notifyAll();\n    }\n\n    return uif;\n  }\n\n","sourceOld":"  public static UnInvertedField getUnInvertedField(String field, SolrIndexSearcher searcher) throws IOException {\n    SolrCache<String,UnInvertedField> cache = searcher.getFieldValueCache();\n    if (cache == null) {\n      return new UnInvertedField(field, searcher);\n    }\n    UnInvertedField uif = null;\n    Boolean doWait = false;\n    synchronized (cache) {\n      uif = cache.get(field);\n      if (uif == null) {\n        /**\n         * We use this place holder object to pull the UninvertedField construction out of the sync\n         * so that if many fields are accessed in a short time, the UninvertedField can be\n         * built for these fields in parallel rather than sequentially.\n         */\n        cache.put(field, uifPlaceholder);\n      } else {\n        if (uif != uifPlaceholder) {\n          return uif;\n        }\n        doWait = true; // Someone else has put the place holder in, wait for that to complete.\n      }\n    }\n    while (doWait) {\n      try {\n        synchronized (cache) {\n          uif = cache.get(field); // Should at least return the placeholder, NPE if not is OK.\n          if (uif != uifPlaceholder) { // OK, another thread put this in the cache we should be good.\n            return uif;\n          }\n          cache.wait();\n        }\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted in getUninvertedField.\");\n      }\n    }\n\n    uif = new UnInvertedField(field, searcher);\n    synchronized (cache) {\n      cache.put(field, uif); // Note, this cleverly replaces the placeholder.\n      cache.notifyAll();\n    }\n\n    return uif;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":1,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","sourceNew":"  public static UnInvertedField getUnInvertedField(String field, SolrIndexSearcher searcher) throws IOException {\n    SolrCache<String,UnInvertedField> cache = searcher.getFieldValueCache();\n    if (cache == null) {\n      return new UnInvertedField(field, searcher);\n    }\n    UnInvertedField uif = null;\n    Boolean doWait = false;\n    synchronized (cache) {\n      uif = cache.get(field);\n      if (uif == null) {\n        /**\n         * We use this place holder object to pull the UninvertedField construction out of the sync\n         * so that if many fields are accessed in a short time, the UninvertedField can be\n         * built for these fields in parallel rather than sequentially.\n         */\n        cache.put(field, uifPlaceholder);\n      } else {\n        if (uif != uifPlaceholder) {\n          return uif;\n        }\n        doWait = true; // Someone else has put the place holder in, wait for that to complete.\n      }\n    }\n    while (doWait) {\n      try {\n        synchronized (cache) {\n          uif = cache.get(field); // Should at least return the placeholder, NPE if not is OK.\n          if (uif != uifPlaceholder) { // OK, another thread put this in the cache we should be good.\n            return uif;\n          }\n          cache.wait();\n        }\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted in getUninvertedField.\");\n      }\n    }\n\n    uif = new UnInvertedField(field, searcher);\n    synchronized (cache) {\n      cache.put(field, uif); // Note, this cleverly replaces the placeholder.\n      cache.notifyAll();\n    }\n\n    return uif;\n  }\n\n","sourceOld":"  public static UnInvertedField getUnInvertedField(String field, SolrIndexSearcher searcher) throws IOException {\n    SolrCache<String,UnInvertedField> cache = searcher.getFieldValueCache();\n    if (cache == null) {\n      return new UnInvertedField(field, searcher);\n    }\n    UnInvertedField uif = null;\n    Boolean doWait = false;\n    synchronized (cache) {\n      uif = cache.get(field);\n      if (uif == null) {\n        /**\n         * We use this place holder object to pull the UninvertedField construction out of the sync\n         * so that if many fields are accessed in a short time, the UninvertedField can be\n         * built for these fields in parallel rather than sequentially.\n         */\n        cache.put(field, uifPlaceholder);\n      } else {\n        if (uif != uifPlaceholder) {\n          return uif;\n        }\n        doWait = true; // Someone else has put the place holder in, wait for that to complete.\n      }\n    }\n    while (doWait) {\n      try {\n        synchronized (cache) {\n          uif = cache.get(field); // Should at least return the placeholder, NPE if not is OK.\n          if (uif != uifPlaceholder) { // OK, another thread put this in the cache we should be good.\n            return uif;\n          }\n          cache.wait();\n        }\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted in getUninvertedField.\");\n      }\n    }\n\n    uif = new UnInvertedField(field, searcher);\n    synchronized (cache) {\n      cache.put(field, uif); // Note, this cleverly replaces the placeholder.\n      cache.notifyAll();\n    }\n\n    return uif;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b850f06b1db39c994c6386cbbaa486651f490b","date":1523385145,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public static UnInvertedField getUnInvertedField(String field, SolrIndexSearcher searcher) throws IOException {\n    SolrCache cache = searcher.getFieldValueCache();\n    if (cache == null) {\n      return new UnInvertedField(field, searcher);\n    }\n\n    Boolean doWait = false;\n    synchronized (cache) {\n      final Object val = cache.get(field);\n      if (val == null || (val instanceof Throwable)) {\n        /**\n         * We use this place holder object to pull the UninvertedField construction out of the sync\n         * so that if many fields are accessed in a short time, the UninvertedField can be\n         * built for these fields in parallel rather than sequentially.\n         */\n        cache.put(field, uifPlaceholder);\n      } else {\n        if (val != uifPlaceholder) {\n          return (UnInvertedField) val;\n        }\n        doWait = true; // Someone else has put the place holder in, wait for that to complete.\n      }\n    }\n    while (doWait) {\n      try {\n        synchronized (cache) {\n          final Object val = cache.get(field);\n          if (val != uifPlaceholder) { // OK, another thread put this in the cache we should be good.\n            if (val instanceof Throwable) {\n              rethrowAsSolrException(field, (Throwable) val);\n            } else {\n              return (UnInvertedField) val;\n            }\n          }\n          cache.wait();\n        }\n      } catch (InterruptedException e) {\n        rethrowAsSolrException(field, e);\n      }\n    }\n\n    UnInvertedField uif = null;\n    try {\n      uif = new UnInvertedField(field, searcher);\n    }catch(Throwable e) {\n      synchronized (cache) {\n        cache.put(field, e); // signaling the failure\n        cache.notifyAll();\n      }\n      rethrowAsSolrException(field, e);\n    }\n    synchronized (cache) {\n      cache.put(field, uif); // Note, this cleverly replaces the placeholder.\n      cache.notifyAll();\n    }\n    return uif;\n  }\n\n","sourceOld":"  public static UnInvertedField getUnInvertedField(String field, SolrIndexSearcher searcher) throws IOException {\n    SolrCache<String,UnInvertedField> cache = searcher.getFieldValueCache();\n    if (cache == null) {\n      return new UnInvertedField(field, searcher);\n    }\n    UnInvertedField uif = null;\n    Boolean doWait = false;\n    synchronized (cache) {\n      uif = cache.get(field);\n      if (uif == null) {\n        /**\n         * We use this place holder object to pull the UninvertedField construction out of the sync\n         * so that if many fields are accessed in a short time, the UninvertedField can be\n         * built for these fields in parallel rather than sequentially.\n         */\n        cache.put(field, uifPlaceholder);\n      } else {\n        if (uif != uifPlaceholder) {\n          return uif;\n        }\n        doWait = true; // Someone else has put the place holder in, wait for that to complete.\n      }\n    }\n    while (doWait) {\n      try {\n        synchronized (cache) {\n          uif = cache.get(field); // Should at least return the placeholder, NPE if not is OK.\n          if (uif != uifPlaceholder) { // OK, another thread put this in the cache we should be good.\n            return uif;\n          }\n          cache.wait();\n        }\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted in getUninvertedField.\");\n      }\n    }\n\n    uif = new UnInvertedField(field, searcher);\n    synchronized (cache) {\n      cache.put(field, uif); // Note, this cleverly replaces the placeholder.\n      cache.notifyAll();\n    }\n\n    return uif;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfa27be7bde9d711ce2b418fadc555654849383f","date":1573652589,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/UnInvertedField#getUnInvertedField(String,SolrIndexSearcher).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public static UnInvertedField getUnInvertedField(String field, SolrIndexSearcher searcher) throws IOException {\n    SolrCache<String, UnInvertedField> cache = searcher.getFieldValueCache();\n    if (cache == null) {\n      return new UnInvertedField(field, searcher);\n    }\n    AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n    UnInvertedField uif = cache.computeIfAbsent(field, f -> {\n      UnInvertedField newUif;\n      try {\n        newUif = new UnInvertedField(field, searcher);\n      } catch (Throwable t) {\n        throwableRef.set(t);\n        newUif = null;\n      }\n      return newUif;\n    });\n    if (throwableRef.get() != null) {\n      rethrowAsSolrException(field, throwableRef.get());\n    }\n    return uif;\n\n    // (ab) if my understanding is correct this whole block tried to mimic the\n    // semantics of computeIfAbsent\n\n//    Boolean doWait = false;\n//    synchronized (cache) {\n//      final Object val = cache.get(field);\n//      if (val == null || (val instanceof Throwable)) {\n//        /**\n//         * We use this place holder object to pull the UninvertedField construction out of the sync\n//         * so that if many fields are accessed in a short time, the UninvertedField can be\n//         * built for these fields in parallel rather than sequentially.\n//         */\n//        cache.put(field, uifPlaceholder);\n//      } else {\n//        if (val != uifPlaceholder) {\n//          return (UnInvertedField) val;\n//        }\n//        doWait = true; // Someone else has put the place holder in, wait for that to complete.\n//      }\n//    }\n//    while (doWait) {\n//      try {\n//        synchronized (cache) {\n//          final Object val = cache.get(field);\n//          if (val != uifPlaceholder) { // OK, another thread put this in the cache we should be good.\n//            if (val instanceof Throwable) {\n//              rethrowAsSolrException(field, (Throwable) val);\n//            } else {\n//              return (UnInvertedField) val;\n//            }\n//          }\n//          cache.wait();\n//        }\n//      } catch (InterruptedException e) {\n//        rethrowAsSolrException(field, e);\n//      }\n//    }\n//\n//    UnInvertedField uif = null;\n//    try {\n//      uif = new UnInvertedField(field, searcher);\n//    }catch(Throwable e) {\n//      synchronized (cache) {\n//        cache.put(field, e); // signaling the failure\n//        cache.notifyAll();\n//      }\n//      rethrowAsSolrException(field, e);\n//    }\n//    synchronized (cache) {\n//      cache.put(field, uif); // Note, this cleverly replaces the placeholder.\n//      cache.notifyAll();\n//    }\n//    return uif;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public static UnInvertedField getUnInvertedField(String field, SolrIndexSearcher searcher) throws IOException {\n    SolrCache cache = searcher.getFieldValueCache();\n    if (cache == null) {\n      return new UnInvertedField(field, searcher);\n    }\n\n    Boolean doWait = false;\n    synchronized (cache) {\n      final Object val = cache.get(field);\n      if (val == null || (val instanceof Throwable)) {\n        /**\n         * We use this place holder object to pull the UninvertedField construction out of the sync\n         * so that if many fields are accessed in a short time, the UninvertedField can be\n         * built for these fields in parallel rather than sequentially.\n         */\n        cache.put(field, uifPlaceholder);\n      } else {\n        if (val != uifPlaceholder) {\n          return (UnInvertedField) val;\n        }\n        doWait = true; // Someone else has put the place holder in, wait for that to complete.\n      }\n    }\n    while (doWait) {\n      try {\n        synchronized (cache) {\n          final Object val = cache.get(field);\n          if (val != uifPlaceholder) { // OK, another thread put this in the cache we should be good.\n            if (val instanceof Throwable) {\n              rethrowAsSolrException(field, (Throwable) val);\n            } else {\n              return (UnInvertedField) val;\n            }\n          }\n          cache.wait();\n        }\n      } catch (InterruptedException e) {\n        rethrowAsSolrException(field, e);\n      }\n    }\n\n    UnInvertedField uif = null;\n    try {\n      uif = new UnInvertedField(field, searcher);\n    }catch(Throwable e) {\n      synchronized (cache) {\n        cache.put(field, e); // signaling the failure\n        cache.notifyAll();\n      }\n      rethrowAsSolrException(field, e);\n    }\n    synchronized (cache) {\n      cache.put(field, uif); // Note, this cleverly replaces the placeholder.\n      cache.notifyAll();\n    }\n    return uif;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bfa27be7bde9d711ce2b418fadc555654849383f":["f0b850f06b1db39c994c6386cbbaa486651f490b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f0b850f06b1db39c994c6386cbbaa486651f490b":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bfa27be7bde9d711ce2b418fadc555654849383f"]},"commit2Childs":{"bfa27be7bde9d711ce2b418fadc555654849383f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","f0b850f06b1db39c994c6386cbbaa486651f490b"],"f0b850f06b1db39c994c6386cbbaa486651f490b":["bfa27be7bde9d711ce2b418fadc555654849383f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}