{"path":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","commits":[{"id":"9813dd0748537c429b7c0a9b4723ea1ba496c047","date":1330304954,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean,SolrCore).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   * @param leaderSeqPath \n   * \n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   * @param leaderSeqPath \n   * \n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @param core \n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement, SolrCore core) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement, core);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true, null);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true, null);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   * @param leaderSeqPath \n   * \n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"578eff0bc5aee20ceab0bb85d2e639e93d68c952","date":1335146102,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   * @param leaderSeqPath \n   * \n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aa13594d60227932a46e09d7219144b9c5115cd","date":1340889829,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param seq\n   * @param context \n   * @param replacement has someone else been the leader already?\n   * @throws KeeperException\n   * @throws InterruptedException\n   * @throws IOException \n   * @throws UnsupportedEncodingException\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a","date":1351228731,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35b85bcb9f4029b10b1fcd20934d760755940bb2","date":1363925237,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e6c873b95174ff04c895232927baa76a95925eb","date":1385054916,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b15576cafd8b5d06857055c28f26912321937e3","date":1396452121,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index), watcher = new ElectionWatcher(context.leaderSeqPath , seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index), watcher = new ElectionWatcher(context.leaderSeqPath , seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    \n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index),\n            new Watcher() {\n              \n              @Override\n              public void process(WatchedEvent event) {\n                // session events are not change events,\n                // and do not remove the watcher\n                if (EventType.None.equals(event.getType())) {\n                  return;\n                }\n                // am I the next leader?\n                try {\n                  checkIfIamLeader(seq, context, true);\n                } catch (InterruptedException e) {\n                  // Restore the interrupted status\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                } catch (IOException e) {\n                  log.warn(\"\", e);\n                } catch (Exception e) {\n                  log.warn(\"\", e);\n                }\n              }\n              \n            }, null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d996c36bf85996da326201b915c87d41449d7f5","date":1403084374,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      if(seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath+\"/\"+seqs.get(0)) ) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going be leader {} , seq(0) {}\",context.leaderSeqPath,holdElectionPath+\"/\"+seqs.get(0));//but someone else jumped the line\n        retryElection(context,false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(index);\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index), watcher = new ElectionWatcher(context.leaderSeqPath , seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e57c73924f3b8c19defa62e96bfa34a4922d49c2","date":1403106358,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      if(seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath+\"/\"+seqs.get(0)) ) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going be leader {} , seq(0) {}\",context.leaderSeqPath,holdElectionPath+\"/\"+seqs.get(0));//but someone else jumped the line\n        retryElection(context,false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(index);\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      } catch(Exception e) {\n        // fine\n      }\n\n      runIamLeaderProcess(context, replacement);\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        zkClient.getData(holdElectionPath + \"/\" + seqs.get(index), watcher = new ElectionWatcher(context.leaderSeqPath , seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5455c7b3fed6c1671990a44c19071cb0488c2c25","date":1413557414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      if(seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath+\"/\"+seqs.get(0)) ) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going be leader {} , seq(0) {}\",context.leaderSeqPath,holdElectionPath+\"/\"+seqs.get(0));//but someone else jumped the line\n        retryElection(context,false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(index);\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      if(seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath+\"/\"+seqs.get(0)) ) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going be leader {} , seq(0) {}\",context.leaderSeqPath,holdElectionPath+\"/\"+seqs.get(0));//but someone else jumped the line\n        retryElection(context,false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(index);\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      if(seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath+\"/\"+seqs.get(0)) ) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going be leader {} , seq(0) {}\",context.leaderSeqPath,holdElectionPath+\"/\"+seqs.get(0));//but someone else jumped the line\n        retryElection(context,false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(index);\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      if(seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath+\"/\"+seqs.get(0)) ) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going be leader {} , seq(0) {}\",context.leaderSeqPath,holdElectionPath+\"/\"+seqs.get(0));//but someone else jumped the line\n        retryElection(context,false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(index);\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6b620c271c84c0f14919eec7b90083b292ee51","date":1419461736,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    // We can't really rely on the sequence number stored in the old watcher, it may be stale, thus this check.\n\n    int seq = -1;\n\n    // See if we've already been re-added, and this is an old context. In which case, use our current sequence number.\n    String newLeaderSeq = \"\";\n    for (String elec : seqs) {\n      if (getNodeName(elec).equals(getNodeName(context.leaderSeqPath)) && seq < getSeq(elec)) {\n        seq = getSeq(elec); // so use the current sequence number.\n        newLeaderSeq = elec;\n        break;\n      }\n    }\n\n    // Now, if we've been re-added, presumably we've also set up watchers and all that kind of thing, so we're done\n    if (StringUtils.isNotBlank(newLeaderSeq) && seq > getSeq(context.leaderSeqPath)) {\n      log.info(\"Node \" + context.leaderSeqPath + \" already in queue as \" + newLeaderSeq + \" nothing to do.\");\n      return;\n    }\n\n    // Fallback in case we're all coming in here fresh and there is no node for this core already in the election queue.\n    if (seq == -1) {\n      seq = getSeq(context.leaderSeqPath);\n    }\n\n    if (seq <= intSeqs.get(0)) {\n      if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + \"/\" + seqs.get(0))) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going to be leader {} , seq(0) {}\", context.leaderSeqPath, holdElectionPath + \"/\" + seqs.get(0));//but someone else jumped the line\n\n        // The problem is that deleting the ZK node that's watched by others\n        // results in an unpredictable sequencing of the events and sometime the context that comes in for checking\n        // this happens to be after the node has already taken over leadership. So just leave out of here.\n        // This caused one of the tests to fail on having two nodes with the same name in the queue. I'm not sure\n        // the assumption that this is a bad state is valid.\n        if (getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(0)))) {\n          return;\n        }\n        retryElection(context, false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int toWatch = -1;\n      for (int idx = 0; idx < intSeqs.size(); idx++) {\n        if (intSeqs.get(idx) < seq && ! getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(idx)))) {\n          toWatch = idx;\n        }\n        if (intSeqs.get(idx) >= seq) {\n          break;\n        }\n      }\n      if (toWatch < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(toWatch);\n\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      if(seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath+\"/\"+seqs.get(0)) ) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going be leader {} , seq(0) {}\",context.leaderSeqPath,holdElectionPath+\"/\"+seqs.get(0));//but someone else jumped the line\n        retryElection(context,false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(index);\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"5eb2511ababf862ea11e10761c70ee560cd84510":["9e6c873b95174ff04c895232927baa76a95925eb","5b15576cafd8b5d06857055c28f26912321937e3"],"7d996c36bf85996da326201b915c87d41449d7f5":["5b15576cafd8b5d06857055c28f26912321937e3"],"9813dd0748537c429b7c0a9b4723ea1ba496c047":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9813dd0748537c429b7c0a9b4723ea1ba496c047"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":["5b15576cafd8b5d06857055c28f26912321937e3","7d996c36bf85996da326201b915c87d41449d7f5"],"6aa13594d60227932a46e09d7219144b9c5115cd":["578eff0bc5aee20ceab0bb85d2e639e93d68c952"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["7d996c36bf85996da326201b915c87d41449d7f5"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["6aa13594d60227932a46e09d7219144b9c5115cd","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["6aa13594d60227932a46e09d7219144b9c5115cd"],"35b85bcb9f4029b10b1fcd20934d760755940bb2":["5e71cbdfcf34d779dd7e7ba148dfff6022f2005a"],"578eff0bc5aee20ceab0bb85d2e639e93d68c952":["9813dd0748537c429b7c0a9b4723ea1ba496c047"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["7d996c36bf85996da326201b915c87d41449d7f5","5455c7b3fed6c1671990a44c19071cb0488c2c25"],"5b15576cafd8b5d06857055c28f26912321937e3":["9e6c873b95174ff04c895232927baa76a95925eb"],"9e6c873b95174ff04c895232927baa76a95925eb":["35b85bcb9f4029b10b1fcd20934d760755940bb2"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["578eff0bc5aee20ceab0bb85d2e639e93d68c952","6aa13594d60227932a46e09d7219144b9c5115cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["35b85bcb9f4029b10b1fcd20934d760755940bb2","9e6c873b95174ff04c895232927baa76a95925eb"],"f2126b84bd093fa3d921582a109a0ee578c28126":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","5e71cbdfcf34d779dd7e7ba148dfff6022f2005a"],"4e6b620c271c84c0f14919eec7b90083b292ee51":["5455c7b3fed6c1671990a44c19071cb0488c2c25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4e6b620c271c84c0f14919eec7b90083b292ee51"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["5e71cbdfcf34d779dd7e7ba148dfff6022f2005a","f2126b84bd093fa3d921582a109a0ee578c28126"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"7d996c36bf85996da326201b915c87d41449d7f5":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","5455c7b3fed6c1671990a44c19071cb0488c2c25","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"9813dd0748537c429b7c0a9b4723ea1ba496c047":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","578eff0bc5aee20ceab0bb85d2e639e93d68c952"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":[],"6aa13594d60227932a46e09d7219144b9c5115cd":["05a14b2611ead08655a2b2bdc61632eb31316e57","6013b4c7388f1627659c8f96c44abd10a294d3a6","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","4e6b620c271c84c0f14919eec7b90083b292ee51"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a":["35b85bcb9f4029b10b1fcd20934d760755940bb2","f2126b84bd093fa3d921582a109a0ee578c28126"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","05a14b2611ead08655a2b2bdc61632eb31316e57"],"578eff0bc5aee20ceab0bb85d2e639e93d68c952":["6aa13594d60227932a46e09d7219144b9c5115cd","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"35b85bcb9f4029b10b1fcd20934d760755940bb2":["9e6c873b95174ff04c895232927baa76a95925eb","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"9e6c873b95174ff04c895232927baa76a95925eb":["5eb2511ababf862ea11e10761c70ee560cd84510","5b15576cafd8b5d06857055c28f26912321937e3","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"5b15576cafd8b5d06857055c28f26912321937e3":["5eb2511ababf862ea11e10761c70ee560cd84510","7d996c36bf85996da326201b915c87d41449d7f5","e57c73924f3b8c19defa62e96bfa34a4922d49c2"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9813dd0748537c429b7c0a9b4723ea1ba496c047","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"4e6b620c271c84c0f14919eec7b90083b292ee51":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e57c73924f3b8c19defa62e96bfa34a4922d49c2","05a14b2611ead08655a2b2bdc61632eb31316e57","0a22eafe3f72a4c2945eaad9547e6c78816978f4","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}