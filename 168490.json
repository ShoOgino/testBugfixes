{"path":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"5391288921372c32bf6096df320497ad2d05757f","date":1200634221,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void prepare(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException \n  {\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n    \n    ResponseBuilder builder = SearchHandler.getResponseBuilder( req );\n    Query query = builder.getQuery();\n    if( query == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"The QueryElevationComponent needs to be registered 'after' the query component\" );\n    }\n    \n    String qstr = getAnalyzedQuery( builder.getQueryString() );\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      builder.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = builder.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( forceElevation && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( builder.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      builder.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["61cd7bdf2e4fbdad8e97effdfc84f04a3656d596","1445434793334e26d7938862ae6f101e137de632","1445434793334e26d7938862ae6f101e137de632","1445434793334e26d7938862ae6f101e137de632"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","date":1204055227,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n    \n    Query query = rb.getQuery();\n    if( query == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"The QueryElevationComponent needs to be registered 'after' the query component\" );\n    }\n    \n    String qstr = getAnalyzedQuery( rb.getQueryString() );\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( forceElevation && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException \n  {\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n    \n    ResponseBuilder builder = SearchHandler.getResponseBuilder( req );\n    Query query = builder.getQuery();\n    if( query == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"The QueryElevationComponent needs to be registered 'after' the query component\" );\n    }\n    \n    String qstr = getAnalyzedQuery( builder.getQueryString() );\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      builder.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = builder.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( forceElevation && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( builder.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      builder.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":["61cd7bdf2e4fbdad8e97effdfc84f04a3656d596"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5391288921372c32bf6096df320497ad2d05757f":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["5391288921372c32bf6096df320497ad2d05757f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5391288921372c32bf6096df320497ad2d05757f":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["5391288921372c32bf6096df320497ad2d05757f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}