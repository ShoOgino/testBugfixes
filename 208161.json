{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a completel response tree for each pivot.  The values in this response will either \n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      try {\n        this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      //REFINEMENT\n      String fieldValueKey = localParams == null ? null : localParams.get(PivotFacet.REFINE_PARAM);\n      if(fieldValueKey != null ){\n        String[] refinementValuesByField = params.getParams(PivotFacet.REFINE_PARAM+fieldValueKey);\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null));\n      }\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","sourceNew":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a completel response tree for each pivot.  The values in this response will either \n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo; \n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      try {\n        // NOTE: this sets localParams (SimpleFacets is stateful)\n        this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuing no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      \n      if (null != localParams) {\n        // we might be refining..\n        refineKey = localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields));\n      }\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a completel response tree for each pivot.  The values in this response will either \n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      try {\n        this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      //REFINEMENT\n      String fieldValueKey = localParams == null ? null : localParams.get(PivotFacet.REFINE_PARAM);\n      if(fieldValueKey != null ){\n        String[] refinementValuesByField = params.getParams(PivotFacet.REFINE_PARAM+fieldValueKey);\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null));\n      }\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"658218bdad5bc0415007e8e0cd9197fb3b0298af","date":1423726262,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","sourceNew":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a complete response tree for each pivot.  The values in this response will either\n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo; \n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      try {\n        // NOTE: this sets localParams (SimpleFacets is stateful)\n        this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuming no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      \n      if (null != localParams) {\n        // we might be refining..\n        refineKey = localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields));\n      }\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a completel response tree for each pivot.  The values in this response will either \n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo; \n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      try {\n        // NOTE: this sets localParams (SimpleFacets is stateful)\n        this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuing no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      \n      if (null != localParams) {\n        // we might be refining..\n        refineKey = localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields));\n      }\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","sourceNew":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a complete response tree for each pivot.  The values in this response will either\n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo; \n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      final ParsedParams parsed;\n      \n      try {\n        parsed = this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(parsed.facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuming no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      \n      if (null != parsed.localParams) {\n        // we might be refining..\n        refineKey = parsed.localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = parsed.localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields, parsed));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields, parsed));\n      }\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a complete response tree for each pivot.  The values in this response will either\n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo; \n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      try {\n        // NOTE: this sets localParams (SimpleFacets is stateful)\n        this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuming no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      \n      if (null != localParams) {\n        // we might be refining..\n        refineKey = localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields));\n      }\n    }\n    return pivotResponse;\n  }\n\n","bugFix":["4c18a95e9168a30be855f5d5e7d61a863186fdc5","92751ba9273251eab6a2e379ec42a1697a32ff96"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","sourceNew":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a complete response tree for each pivot.  The values in this response will either\n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo; \n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      final ParsedParams parsed;\n      \n      try {\n        parsed = this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(parsed.facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuming no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      List<FacetComponent.FacetBase> facetQueries = Collections.emptyList();\n      List<RangeFacetRequest> facetRanges = Collections.emptyList();\n      if (null != parsed.localParams) {\n        // we might be refining..\n        refineKey = parsed.localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = parsed.localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n\n        try {\n          FacetComponent.FacetContext facetContext = FacetComponent.FacetContext.getFacetContext(req);\n\n          String taggedQueries = parsed.localParams.get(QUERY);\n          if (StringUtils.isEmpty(taggedQueries))  {\n            facetQueries = Collections.emptyList();\n          } else  {\n            List<String> localParamValue = StrUtils.splitSmart(taggedQueries, ',');\n            if (localParamValue.size() > 1) {\n              String msg = QUERY + \" local param of \" + FacetParams.FACET_PIVOT +\n                  \"may not include tags separated by a comma - please use a common tag on all \" +\n                  FacetParams.FACET_QUERY + \" params you wish to compute under this pivot\";\n              throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n            }\n            taggedQueries = localParamValue.get(0);\n            facetQueries = facetContext.getQueryFacetsForTag(taggedQueries);\n          }\n\n          String taggedRanges = parsed.localParams.get(RANGE);\n          if (StringUtils.isEmpty(taggedRanges)) {\n            facetRanges = Collections.emptyList();\n          } else  {\n            List<String> localParamValue = StrUtils.splitSmart(taggedRanges, ',');\n            if (localParamValue.size() > 1) {\n              String msg = RANGE + \" local param of \" + FacetParams.FACET_PIVOT +\n                  \"may not include tags separated by a comma - please use a common tag on all \" +\n                  FacetParams.FACET_RANGE + \" params you wish to compute under this pivot\";\n              throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n            }\n            taggedRanges = localParamValue.get(0);\n            facetRanges = facetContext.getRangeFacetRequestsForTag(taggedRanges);\n          }\n        } catch (IllegalStateException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Faceting context not set, cannot calculate pivot values\");\n        }\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields, parsed, facetQueries, facetRanges));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields, parsed, facetQueries, facetRanges));\n      }\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a complete response tree for each pivot.  The values in this response will either\n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo; \n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      final ParsedParams parsed;\n      \n      try {\n        parsed = this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(parsed.facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuming no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      \n      if (null != parsed.localParams) {\n        // we might be refining..\n        refineKey = parsed.localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = parsed.localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields, parsed));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields, parsed));\n      }\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba33781da68babcaa5828121b443d3eb5c9d8480","date":1590595589,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#process(String[]).mjava","sourceNew":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a complete response tree for each pivot.  The values in this response will either\n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo;\n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      final ParsedParams parsed;\n      \n      try {\n        parsed = this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(parsed.facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuming no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      List<FacetComponent.FacetBase> facetQueries = Collections.emptyList();\n      List<RangeFacetRequest> facetRanges = Collections.emptyList();\n      if (null != parsed.localParams) {\n        // we might be refining..\n        refineKey = parsed.localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = parsed.localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n\n        try {\n          FacetComponent.FacetContext facetContext = FacetComponent.FacetContext.getFacetContext(req);\n\n          String taggedQueries = parsed.localParams.get(QUERY);\n          if (StringUtils.isEmpty(taggedQueries))  {\n            facetQueries = Collections.emptyList();\n          } else  {\n            List<String> localParamValue = StrUtils.splitSmart(taggedQueries, ',');\n            if (localParamValue.size() > 1) {\n              String msg = QUERY + \" local param of \" + FacetParams.FACET_PIVOT +\n                  \"may not include tags separated by a comma - please use a common tag on all \" +\n                  FacetParams.FACET_QUERY + \" params you wish to compute under this pivot\";\n              throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n            }\n            taggedQueries = localParamValue.get(0);\n            facetQueries = facetContext.getQueryFacetsForTag(taggedQueries);\n          }\n\n          String taggedRanges = parsed.localParams.get(RANGE);\n          if (StringUtils.isEmpty(taggedRanges)) {\n            facetRanges = Collections.emptyList();\n          } else  {\n            List<String> localParamValue = StrUtils.splitSmart(taggedRanges, ',');\n            if (localParamValue.size() > 1) {\n              String msg = RANGE + \" local param of \" + FacetParams.FACET_PIVOT +\n                  \"may not include tags separated by a comma - please use a common tag on all \" +\n                  FacetParams.FACET_RANGE + \" params you wish to compute under this pivot\";\n              throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n            }\n            taggedRanges = localParamValue.get(0);\n            facetRanges = facetContext.getRangeFacetRequestsForTag(taggedRanges);\n          }\n        } catch (IllegalStateException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Faceting context not set, cannot calculate pivot values\");\n        }\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields, parsed, facetQueries, facetRanges));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields, parsed, facetQueries, facetRanges));\n      }\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Processes all of the specified {@link FacetParams#FACET_PIVOT} strings, generating \n   * a complete response tree for each pivot.  The values in this response will either\n   * be the complete tree of fields and values for the specified pivot in the local index, \n   * or the requested refinements if the pivot params include the {@link PivotFacet#REFINE_PARAM}\n   */\n  public SimpleOrderedMap<List<NamedList<Object>>> process(String[] pivots) throws IOException {\n    if (!rb.doFacets || pivots == null) \n      return null;\n    \n    // rb._statsInfo may be null if stats=false, ie: refine requests\n    // if that's the case, but we need to refine w/stats, then we'll lazy init our \n    // own instance of StatsInfo\n    StatsInfo statsInfo = rb._statsInfo; \n\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n    for (String pivotList : pivots) {\n      final ParsedParams parsed;\n      \n      try {\n        parsed = this.parseParams(FacetParams.FACET_PIVOT, pivotList);\n      } catch (SyntaxError e) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, e);\n      }\n      List<String> pivotFields = StrUtils.splitSmart(parsed.facetValue, \",\", true);\n      if( pivotFields.size() < 1 ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST,\n                                 \"Pivot Facet needs at least one field name: \" + pivotList);\n      } else {\n        SolrIndexSearcher searcher = rb.req.getSearcher();\n        for (String fieldName : pivotFields) {\n          SchemaField sfield = searcher.getSchema().getField(fieldName);\n          if (sfield == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"\\\"\" + fieldName + \"\\\" is not a valid field name in pivot: \" + pivotList);\n          }\n        }\n      } \n\n      // start by assuming no local params...\n\n      String refineKey = null; // no local => no refinement\n      List<StatsField> statsFields = Collections.emptyList(); // no local => no stats\n      List<FacetComponent.FacetBase> facetQueries = Collections.emptyList();\n      List<RangeFacetRequest> facetRanges = Collections.emptyList();\n      if (null != parsed.localParams) {\n        // we might be refining..\n        refineKey = parsed.localParams.get(PivotFacet.REFINE_PARAM);\n        \n        String statsLocalParam = parsed.localParams.get(StatsParams.STATS);\n        if (null != refineKey\n            && null != statsLocalParam\n            && null == statsInfo) {\n          // we are refining and need to compute stats, \n          // but stats component hasn't inited StatsInfo (because we\n          // don't need/want top level stats when refining) so we lazy init\n          // our own copy of StatsInfo\n          statsInfo = new StatsInfo(rb);\n        }\n        statsFields = getTaggedStatsFields(statsInfo, statsLocalParam);\n\n        try {\n          FacetComponent.FacetContext facetContext = FacetComponent.FacetContext.getFacetContext(req);\n\n          String taggedQueries = parsed.localParams.get(QUERY);\n          if (StringUtils.isEmpty(taggedQueries))  {\n            facetQueries = Collections.emptyList();\n          } else  {\n            List<String> localParamValue = StrUtils.splitSmart(taggedQueries, ',');\n            if (localParamValue.size() > 1) {\n              String msg = QUERY + \" local param of \" + FacetParams.FACET_PIVOT +\n                  \"may not include tags separated by a comma - please use a common tag on all \" +\n                  FacetParams.FACET_QUERY + \" params you wish to compute under this pivot\";\n              throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n            }\n            taggedQueries = localParamValue.get(0);\n            facetQueries = facetContext.getQueryFacetsForTag(taggedQueries);\n          }\n\n          String taggedRanges = parsed.localParams.get(RANGE);\n          if (StringUtils.isEmpty(taggedRanges)) {\n            facetRanges = Collections.emptyList();\n          } else  {\n            List<String> localParamValue = StrUtils.splitSmart(taggedRanges, ',');\n            if (localParamValue.size() > 1) {\n              String msg = RANGE + \" local param of \" + FacetParams.FACET_PIVOT +\n                  \"may not include tags separated by a comma - please use a common tag on all \" +\n                  FacetParams.FACET_RANGE + \" params you wish to compute under this pivot\";\n              throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n            }\n            taggedRanges = localParamValue.get(0);\n            facetRanges = facetContext.getRangeFacetRequestsForTag(taggedRanges);\n          }\n        } catch (IllegalStateException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Faceting context not set, cannot calculate pivot values\");\n        }\n      }\n\n      if (null != refineKey) {\n        String[] refinementValuesByField \n          = params.getParams(PivotFacet.REFINE_PARAM + refineKey);\n\n        for(String refinements : refinementValuesByField){\n          pivotResponse.addAll(processSingle(pivotFields, refinements, statsFields, parsed, facetQueries, facetRanges));\n        }\n      } else{\n        pivotResponse.addAll(processSingle(pivotFields, null, statsFields, parsed, facetQueries, facetRanges));\n      }\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22d0a81a05eba47d5e18976f17d88306b218cc22":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"ba33781da68babcaa5828121b443d3eb5c9d8480":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["658218bdad5bc0415007e8e0cd9197fb3b0298af"],"658218bdad5bc0415007e8e0cd9197fb3b0298af":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba33781da68babcaa5828121b443d3eb5c9d8480"]},"commit2Childs":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["658218bdad5bc0415007e8e0cd9197fb3b0298af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["ba33781da68babcaa5828121b443d3eb5c9d8480"],"ba33781da68babcaa5828121b443d3eb5c9d8480":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"658218bdad5bc0415007e8e0cd9197fb3b0298af":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}