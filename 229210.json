{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","commits":[{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","pathOld":"/dev/null","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    //System.out.println(\"\\nCONVERT\");\n\n    // nocommit make sure singleton cases work:\n    //if (utf32.isSingleton()) {\n    //utf32 = utf32.cloneExpanded();\n    //}\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    // nocommit we don't track this\n    // utf8.setDeterministic(false);\n\n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    LightAutomaton.Transition scratch = new LightAutomaton.Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75ac8571c2d82c574e446c3729251b994c69a55c","date":1402523781,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    //System.out.println(\"\\nCONVERT\");\n\n    // nocommit make sure singleton cases work:\n    //if (utf32.isSingleton()) {\n    //utf32 = utf32.cloneExpanded();\n    //}\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    // nocommit we don't track this\n    // utf8.setDeterministic(false);\n\n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    LightAutomaton.Transition scratch = new LightAutomaton.Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    //System.out.println(\"\\nCONVERT\");\n\n    // nocommit make sure singleton cases work:\n    //if (utf32.isSingleton()) {\n    //utf32 = utf32.cloneExpanded();\n    //}\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    // nocommit we don't track this\n    // utf8.setDeterministic(false);\n\n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    LightAutomaton.Transition scratch = new LightAutomaton.Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c8cfaac638acc80d26d08288440ede37e6539e9","date":1402678000,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    //System.out.println(\"\\nCONVERT\");\n\n    // nocommit make sure singleton cases work:\n    //if (utf32.isSingleton()) {\n    //utf32 = utf32.cloneExpanded();\n    //}\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    // nocommit we don't track this\n    // utf8.setDeterministic(false);\n\n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    //System.out.println(\"\\nCONVERT\");\n\n    // nocommit make sure singleton cases work:\n    //if (utf32.isSingleton()) {\n    //utf32 = utf32.cloneExpanded();\n    //}\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    // nocommit we don't track this\n    // utf8.setDeterministic(false);\n\n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    LightAutomaton.Transition scratch = new LightAutomaton.Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    //System.out.println(\"\\nCONVERT\");\n\n    // nocommit make sure singleton cases work:\n    //if (utf32.isSingleton()) {\n    //utf32 = utf32.cloneExpanded();\n    //}\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    // nocommit we don't track this\n    // utf8.setDeterministic(false);\n\n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new Automaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"75ac8571c2d82c574e446c3729251b994c69a55c":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["0c8cfaac638acc80d26d08288440ede37e6539e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"0c8cfaac638acc80d26d08288440ede37e6539e9":["75ac8571c2d82c574e446c3729251b994c69a55c"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"75ac8571c2d82c574e446c3729251b994c69a55c":["0c8cfaac638acc80d26d08288440ede37e6539e9"],"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac34f0c5bb9274821fb0cb18075234e02002e9bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":[],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["75ac8571c2d82c574e446c3729251b994c69a55c"],"0c8cfaac638acc80d26d08288440ede37e6539e9":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}