{"path":"lucene/src/java/org/apache/lucene/index/SegmentInfo#SegmentInfo(Directory,int,IndexInput).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#SegmentInfo(Directory,int,IndexInput).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfo#SegmentInfo(Directory,int,IndexInput).mjava","sourceNew":"  /**\n   * Construct a new SegmentInfo instance by reading a\n   * previously saved SegmentInfo from input.\n   *\n   * @param dir directory to load from\n   * @param format format of the segments info file\n   * @param input input handle to read segment info from\n   */\n  SegmentInfo(Directory dir, int format, IndexInput input) throws IOException {\n    this.dir = dir;\n    name = input.readString();\n    docCount = input.readInt();\n    if (format <= SegmentInfos.FORMAT_LOCKLESS) {\n      delGen = input.readLong();\n      if (format <= SegmentInfos.FORMAT_SHARED_DOC_STORE) {\n        docStoreOffset = input.readInt();\n        if (docStoreOffset != -1) {\n          docStoreSegment = input.readString();\n          docStoreIsCompoundFile = (1 == input.readByte());\n        } else {\n          docStoreSegment = name;\n          docStoreIsCompoundFile = false;\n        }\n      } else {\n        docStoreOffset = -1;\n        docStoreSegment = name;\n        docStoreIsCompoundFile = false;\n      }\n      if (format <= SegmentInfos.FORMAT_SINGLE_NORM_FILE) {\n        hasSingleNormFile = (1 == input.readByte());\n      } else {\n        hasSingleNormFile = false;\n      }\n      int numNormGen = input.readInt();\n      if (numNormGen == NO) {\n        normGen = null;\n      } else {\n        normGen = new long[numNormGen];\n        for(int j=0;j<numNormGen;j++) {\n          normGen[j] = input.readLong();\n        }\n      }\n      isCompoundFile = input.readByte();\n      preLockless = (isCompoundFile == CHECK_DIR);\n      if (format <= SegmentInfos.FORMAT_DEL_COUNT) {\n        delCount = input.readInt();\n        assert delCount <= docCount;\n      } else\n        delCount = -1;\n      if (format <= SegmentInfos.FORMAT_HAS_PROX)\n        hasProx = input.readByte() == 1;\n      else\n        hasProx = true;\n\n      if (format <= SegmentInfos.FORMAT_DIAGNOSTICS) {\n        diagnostics = input.readStringStringMap();\n      } else {\n        diagnostics = Collections.<String,String>emptyMap();\n      }\n    } else {\n      delGen = CHECK_DIR;\n      normGen = null;\n      isCompoundFile = CHECK_DIR;\n      preLockless = true;\n      hasSingleNormFile = false;\n      docStoreOffset = -1;\n      docStoreIsCompoundFile = false;\n      docStoreSegment = null;\n      delCount = -1;\n      hasProx = true;\n      diagnostics = Collections.<String,String>emptyMap();\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a new SegmentInfo instance by reading a\n   * previously saved SegmentInfo from input.\n   *\n   * @param dir directory to load from\n   * @param format format of the segments info file\n   * @param input input handle to read segment info from\n   */\n  SegmentInfo(Directory dir, int format, IndexInput input) throws IOException {\n    this.dir = dir;\n    name = input.readString();\n    docCount = input.readInt();\n    if (format <= SegmentInfos.FORMAT_LOCKLESS) {\n      delGen = input.readLong();\n      if (format <= SegmentInfos.FORMAT_SHARED_DOC_STORE) {\n        docStoreOffset = input.readInt();\n        if (docStoreOffset != -1) {\n          docStoreSegment = input.readString();\n          docStoreIsCompoundFile = (1 == input.readByte());\n        } else {\n          docStoreSegment = name;\n          docStoreIsCompoundFile = false;\n        }\n      } else {\n        docStoreOffset = -1;\n        docStoreSegment = name;\n        docStoreIsCompoundFile = false;\n      }\n      if (format <= SegmentInfos.FORMAT_SINGLE_NORM_FILE) {\n        hasSingleNormFile = (1 == input.readByte());\n      } else {\n        hasSingleNormFile = false;\n      }\n      int numNormGen = input.readInt();\n      if (numNormGen == NO) {\n        normGen = null;\n      } else {\n        normGen = new long[numNormGen];\n        for(int j=0;j<numNormGen;j++) {\n          normGen[j] = input.readLong();\n        }\n      }\n      isCompoundFile = input.readByte();\n      preLockless = (isCompoundFile == CHECK_DIR);\n      if (format <= SegmentInfos.FORMAT_DEL_COUNT) {\n        delCount = input.readInt();\n        assert delCount <= docCount;\n      } else\n        delCount = -1;\n      if (format <= SegmentInfos.FORMAT_HAS_PROX)\n        hasProx = input.readByte() == 1;\n      else\n        hasProx = true;\n\n      if (format <= SegmentInfos.FORMAT_DIAGNOSTICS) {\n        diagnostics = input.readStringStringMap();\n      } else {\n        diagnostics = Collections.<String,String>emptyMap();\n      }\n    } else {\n      delGen = CHECK_DIR;\n      normGen = null;\n      isCompoundFile = CHECK_DIR;\n      preLockless = true;\n      hasSingleNormFile = false;\n      docStoreOffset = -1;\n      docStoreIsCompoundFile = false;\n      docStoreSegment = null;\n      delCount = -1;\n      hasProx = true;\n      diagnostics = Collections.<String,String>emptyMap();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#SegmentInfo(Directory,int,IndexInput).mjava","sourceNew":null,"sourceOld":"  /**\n   * Construct a new SegmentInfo instance by reading a\n   * previously saved SegmentInfo from input.\n   *\n   * @param dir directory to load from\n   * @param format format of the segments info file\n   * @param input input handle to read segment info from\n   */\n  SegmentInfo(Directory dir, int format, IndexInput input) throws IOException {\n    this.dir = dir;\n    name = input.readString();\n    docCount = input.readInt();\n    if (format <= SegmentInfos.FORMAT_LOCKLESS) {\n      delGen = input.readLong();\n      if (format <= SegmentInfos.FORMAT_SHARED_DOC_STORE) {\n        docStoreOffset = input.readInt();\n        if (docStoreOffset != -1) {\n          docStoreSegment = input.readString();\n          docStoreIsCompoundFile = (1 == input.readByte());\n        } else {\n          docStoreSegment = name;\n          docStoreIsCompoundFile = false;\n        }\n      } else {\n        docStoreOffset = -1;\n        docStoreSegment = name;\n        docStoreIsCompoundFile = false;\n      }\n      if (format <= SegmentInfos.FORMAT_SINGLE_NORM_FILE) {\n        hasSingleNormFile = (1 == input.readByte());\n      } else {\n        hasSingleNormFile = false;\n      }\n      int numNormGen = input.readInt();\n      if (numNormGen == NO) {\n        normGen = null;\n      } else {\n        normGen = new long[numNormGen];\n        for(int j=0;j<numNormGen;j++) {\n          normGen[j] = input.readLong();\n        }\n      }\n      isCompoundFile = input.readByte();\n      preLockless = (isCompoundFile == CHECK_DIR);\n      if (format <= SegmentInfos.FORMAT_DEL_COUNT) {\n        delCount = input.readInt();\n        assert delCount <= docCount;\n      } else\n        delCount = -1;\n      if (format <= SegmentInfos.FORMAT_HAS_PROX)\n        hasProx = input.readByte() == 1;\n      else\n        hasProx = true;\n\n      if (format <= SegmentInfos.FORMAT_DIAGNOSTICS) {\n        diagnostics = input.readStringStringMap();\n      } else {\n        diagnostics = Collections.<String,String>emptyMap();\n      }\n    } else {\n      delGen = CHECK_DIR;\n      normGen = null;\n      isCompoundFile = CHECK_DIR;\n      preLockless = true;\n      hasSingleNormFile = false;\n      docStoreOffset = -1;\n      docStoreIsCompoundFile = false;\n      docStoreSegment = null;\n      delCount = -1;\n      hasProx = true;\n      diagnostics = Collections.<String,String>emptyMap();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#SegmentInfo(Directory,int,IndexInput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#SegmentInfo(Directory,int,IndexInput,CodecProvider).mjava","sourceNew":"  /**\n   * Construct a new SegmentInfo instance by reading a\n   * previously saved SegmentInfo from input.\n   * <p>Note: this is public only to allow access from\n   * the codecs package.</p>\n   *\n   * @param dir directory to load from\n   * @param format format of the segments info file\n   * @param input input handle to read segment info from\n   */\n  public SegmentInfo(Directory dir, int format, IndexInput input) throws IOException {\n    this.dir = dir;\n    if (format <= DefaultSegmentInfosWriter.FORMAT_3_1) {\n      version = input.readString();\n    }\n    name = input.readString();\n    docCount = input.readInt();\n    delGen = input.readLong();\n    docStoreOffset = input.readInt();\n    if (docStoreOffset != -1) {\n      docStoreSegment = input.readString();\n      docStoreIsCompoundFile = input.readByte() == YES;\n    } else {\n      docStoreSegment = name;\n      docStoreIsCompoundFile = false;\n    }\n\n    if (format > DefaultSegmentInfosWriter.FORMAT_4_0) {\n      // pre-4.0 indexes write a byte if there is a single norms file\n      byte b = input.readByte();\n      assert 1 == b;\n    }\n\n    int numNormGen = input.readInt();\n    if (numNormGen == NO) {\n      normGen = null;\n    } else {\n      normGen = new HashMap<Integer, Long>();\n      for(int j=0;j<numNormGen;j++) {\n        int fieldNumber = j;\n        if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n          fieldNumber = input.readInt();\n        }\n\n        normGen.put(fieldNumber, input.readLong());\n      }\n    }\n    isCompoundFile = input.readByte() == YES;\n\n    delCount = input.readInt();\n    assert delCount <= docCount;\n\n    hasProx = input.readByte();\n\n    \n    // System.out.println(Thread.currentThread().getName() + \": si.read hasProx=\" + hasProx + \" seg=\" + name);\n    // note: if the codec is not available: Codec.forName will throw an exception.\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      codec = Codec.forName(input.readString());\n    } else {\n      codec = Codec.forName(\"Lucene3x\");\n    }\n    diagnostics = input.readStringStringMap();\n\n    if (format <= DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      hasVectors = input.readByte();\n    } else {\n      final String storesSegment;\n      final String ext;\n      final boolean isCompoundFile;\n      if (docStoreOffset != -1) {\n        storesSegment = docStoreSegment;\n        isCompoundFile = docStoreIsCompoundFile;\n        ext = IndexFileNames.COMPOUND_FILE_STORE_EXTENSION;\n      } else {\n        storesSegment = name;\n        isCompoundFile = getUseCompoundFile();\n        ext = IndexFileNames.COMPOUND_FILE_EXTENSION;\n      }\n      final Directory dirToTest;\n      if (isCompoundFile) {\n        dirToTest = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(storesSegment, \"\", ext), IOContext.READONCE, false);\n      } else {\n        dirToTest = dir;\n      }\n      try {\n        hasVectors = dirToTest.fileExists(IndexFileNames.segmentFileName(storesSegment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION)) ? YES : NO;\n      } finally {\n        if (isCompoundFile) {\n          dirToTest.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a new SegmentInfo instance by reading a\n   * previously saved SegmentInfo from input.\n   * <p>Note: this is public only to allow access from\n   * the codecs package.</p>\n   *\n   * @param dir directory to load from\n   * @param format format of the segments info file\n   * @param input input handle to read segment info from\n   */\n  public SegmentInfo(Directory dir, int format, IndexInput input, CodecProvider codecs) throws IOException {\n    this.dir = dir;\n    if (format <= DefaultSegmentInfosWriter.FORMAT_3_1) {\n      version = input.readString();\n    }\n    name = input.readString();\n    docCount = input.readInt();\n    delGen = input.readLong();\n    docStoreOffset = input.readInt();\n    if (docStoreOffset != -1) {\n      docStoreSegment = input.readString();\n      docStoreIsCompoundFile = input.readByte() == YES;\n    } else {\n      docStoreSegment = name;\n      docStoreIsCompoundFile = false;\n    }\n\n    if (format > DefaultSegmentInfosWriter.FORMAT_4_0) {\n      // pre-4.0 indexes write a byte if there is a single norms file\n      byte b = input.readByte();\n      assert 1 == b;\n    }\n\n    int numNormGen = input.readInt();\n    if (numNormGen == NO) {\n      normGen = null;\n    } else {\n      normGen = new HashMap<Integer, Long>();\n      for(int j=0;j<numNormGen;j++) {\n        int fieldNumber = j;\n        if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n          fieldNumber = input.readInt();\n        }\n\n        normGen.put(fieldNumber, input.readLong());\n      }\n    }\n    isCompoundFile = input.readByte() == YES;\n\n    delCount = input.readInt();\n    assert delCount <= docCount;\n\n    hasProx = input.readByte();\n\n    // System.out.println(Thread.currentThread().getName() + \": si.read hasProx=\" + hasProx + \" seg=\" + name);\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      segmentCodecs = new SegmentCodecs(codecs, input);\n    } else {\n      // codec ID on FieldInfo is 0 so it will simply use the first codec available\n      // TODO what todo if preflex is not available in the provider? register it or fail?\n      segmentCodecs = new SegmentCodecs(codecs, new Codec[] { codecs.lookup(\"PreFlex\")});\n    }\n    diagnostics = input.readStringStringMap();\n\n    if (format <= DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      hasVectors = input.readByte();\n    } else {\n      final String storesSegment;\n      final String ext;\n      final boolean isCompoundFile;\n      if (docStoreOffset != -1) {\n        storesSegment = docStoreSegment;\n        isCompoundFile = docStoreIsCompoundFile;\n        ext = IndexFileNames.COMPOUND_FILE_STORE_EXTENSION;\n      } else {\n        storesSegment = name;\n        isCompoundFile = getUseCompoundFile();\n        ext = IndexFileNames.COMPOUND_FILE_EXTENSION;\n      }\n      final Directory dirToTest;\n      if (isCompoundFile) {\n        dirToTest = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(storesSegment, \"\", ext), IOContext.READONCE, false);\n      } else {\n        dirToTest = dir;\n      }\n      try {\n        hasVectors = dirToTest.fileExists(IndexFileNames.segmentFileName(storesSegment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION)) ? YES : NO;\n      } finally {\n        if (isCompoundFile) {\n          dirToTest.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#readSegmentInfo(Directory,int,ChecksumIndexInput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#SegmentInfo(Directory,int,IndexInput).mjava","sourceNew":"  // if we make a preflex impl we can remove a lot of this hair...\n  public SegmentInfo readSegmentInfo(Directory dir, int format, ChecksumIndexInput input) throws IOException {\n    final String version;\n    if (format <= DefaultSegmentInfosWriter.FORMAT_3_1) {\n      version = input.readString();\n    } else {\n      version = null;\n    }\n    final String name = input.readString();\n    final int docCount = input.readInt();\n    final long delGen = input.readLong();\n    final int docStoreOffset = input.readInt();\n    final String docStoreSegment;\n    final boolean docStoreIsCompoundFile;\n    if (docStoreOffset != -1) {\n      docStoreSegment = input.readString();\n      docStoreIsCompoundFile = input.readByte() == SegmentInfo.YES;\n    } else {\n      docStoreSegment = name;\n      docStoreIsCompoundFile = false;\n    }\n\n    if (format > DefaultSegmentInfosWriter.FORMAT_4_0) {\n      // pre-4.0 indexes write a byte if there is a single norms file\n      byte b = input.readByte();\n      assert 1 == b;\n    }\n\n    final int numNormGen = input.readInt();\n    final Map<Integer,Long> normGen;\n    if (numNormGen == SegmentInfo.NO) {\n      normGen = null;\n    } else {\n      normGen = new HashMap<Integer, Long>();\n      for(int j=0;j<numNormGen;j++) {\n        int fieldNumber = j;\n        if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n          fieldNumber = input.readInt();\n        }\n\n        normGen.put(fieldNumber, input.readLong());\n      }\n    }\n    final boolean isCompoundFile = input.readByte() == SegmentInfo.YES;\n\n    final int delCount = input.readInt();\n    assert delCount <= docCount;\n\n    final int hasProx = input.readByte();\n\n    final Codec codec;\n    // note: if the codec is not available: Codec.forName will throw an exception.\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      codec = Codec.forName(input.readString());\n    } else {\n      codec = Codec.forName(\"Lucene3x\");\n    }\n    final Map<String,String> diagnostics = input.readStringStringMap();\n\n    final int hasVectors;\n    if (format <= DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      hasVectors = input.readByte();\n    } else {\n      final String storesSegment;\n      final String ext;\n      final boolean storeIsCompoundFile;\n      if (docStoreOffset != -1) {\n        storesSegment = docStoreSegment;\n        storeIsCompoundFile = docStoreIsCompoundFile;\n        ext = IndexFileNames.COMPOUND_FILE_STORE_EXTENSION;\n      } else {\n        storesSegment = name;\n        storeIsCompoundFile = isCompoundFile;\n        ext = IndexFileNames.COMPOUND_FILE_EXTENSION;\n      }\n      final Directory dirToTest;\n      if (storeIsCompoundFile) {\n        dirToTest = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(storesSegment, \"\", ext), IOContext.READONCE, false);\n      } else {\n        dirToTest = dir;\n      }\n      try {\n        // TODO: remove this manual file check or push to preflex codec\n        hasVectors = dirToTest.fileExists(IndexFileNames.segmentFileName(storesSegment, \"\", DefaultTermVectorsReader.VECTORS_INDEX_EXTENSION)) ? SegmentInfo.YES : SegmentInfo.NO;\n      } finally {\n        if (isCompoundFile) {\n          dirToTest.close();\n        }\n      }\n    }\n    \n    return new SegmentInfo(dir, version, name, docCount, delGen, docStoreOffset,\n      docStoreSegment, docStoreIsCompoundFile, normGen, isCompoundFile,\n      delCount, hasProx, codec, diagnostics, hasVectors);\n  }\n\n","sourceOld":"  /**\n   * Construct a new SegmentInfo instance by reading a\n   * previously saved SegmentInfo from input.\n   * <p>Note: this is public only to allow access from\n   * the codecs package.</p>\n   *\n   * @param dir directory to load from\n   * @param format format of the segments info file\n   * @param input input handle to read segment info from\n   */\n  public SegmentInfo(Directory dir, int format, IndexInput input) throws IOException {\n    this.dir = dir;\n    if (format <= DefaultSegmentInfosWriter.FORMAT_3_1) {\n      version = input.readString();\n    }\n    name = input.readString();\n    docCount = input.readInt();\n    delGen = input.readLong();\n    docStoreOffset = input.readInt();\n    if (docStoreOffset != -1) {\n      docStoreSegment = input.readString();\n      docStoreIsCompoundFile = input.readByte() == YES;\n    } else {\n      docStoreSegment = name;\n      docStoreIsCompoundFile = false;\n    }\n\n    if (format > DefaultSegmentInfosWriter.FORMAT_4_0) {\n      // pre-4.0 indexes write a byte if there is a single norms file\n      byte b = input.readByte();\n      assert 1 == b;\n    }\n\n    int numNormGen = input.readInt();\n    if (numNormGen == NO) {\n      normGen = null;\n    } else {\n      normGen = new HashMap<Integer, Long>();\n      for(int j=0;j<numNormGen;j++) {\n        int fieldNumber = j;\n        if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n          fieldNumber = input.readInt();\n        }\n\n        normGen.put(fieldNumber, input.readLong());\n      }\n    }\n    isCompoundFile = input.readByte() == YES;\n\n    delCount = input.readInt();\n    assert delCount <= docCount;\n\n    hasProx = input.readByte();\n\n    \n    // System.out.println(Thread.currentThread().getName() + \": si.read hasProx=\" + hasProx + \" seg=\" + name);\n    // note: if the codec is not available: Codec.forName will throw an exception.\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      codec = Codec.forName(input.readString());\n    } else {\n      codec = Codec.forName(\"Lucene3x\");\n    }\n    diagnostics = input.readStringStringMap();\n\n    if (format <= DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      hasVectors = input.readByte();\n    } else {\n      final String storesSegment;\n      final String ext;\n      final boolean isCompoundFile;\n      if (docStoreOffset != -1) {\n        storesSegment = docStoreSegment;\n        isCompoundFile = docStoreIsCompoundFile;\n        ext = IndexFileNames.COMPOUND_FILE_STORE_EXTENSION;\n      } else {\n        storesSegment = name;\n        isCompoundFile = getUseCompoundFile();\n        ext = IndexFileNames.COMPOUND_FILE_EXTENSION;\n      }\n      final Directory dirToTest;\n      if (isCompoundFile) {\n        dirToTest = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(storesSegment, \"\", ext), IOContext.READONCE, false);\n      } else {\n        dirToTest = dir;\n      }\n      try {\n        hasVectors = dirToTest.fileExists(IndexFileNames.segmentFileName(storesSegment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION)) ? YES : NO;\n      } finally {\n        if (isCompoundFile) {\n          dirToTest.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["7b91922b55d15444d554721b352861d028eb8278"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc749c053615f5871f3b95715fe292f34e70a53"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["3cc749c053615f5871f3b95715fe292f34e70a53"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["7b91922b55d15444d554721b352861d028eb8278"],"3cc749c053615f5871f3b95715fe292f34e70a53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}