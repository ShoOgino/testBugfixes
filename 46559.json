{"path":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","commits":[{"id":"653c1ca305e0065ee988a09e59c8316b8cde02fd","date":1492506780,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/recipe/Policy.Suggester#getOperation().mjava","sourceNew":"    public Map getOperation() {\n      if (!isInitialized) {\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public Map getOperation() {\n      if (!isInitialized) {\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d14f4b04a5c752272b2f79fd6684fee8dff2808","date":1494821985,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public Map getOperation() {\n      if (!isInitialized) {\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fca549db64ee4c87a83a94e7c224506fa20d396","date":1495433449,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2e1fb1b46fffdd00b6f31596d6eee00b71015fc","date":1495616754,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        if(coll != null){\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if(session.matrix.stream().noneMatch(row -> row.replicaInfo.containsKey(coll))){\n            session.matrix.get(0).replicaInfo.put(coll, new HashMap<>());\n            session.addClausesForCollection(session.dataProvider, coll);\n            Collections.sort(session.expandedClauses);\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4b9ebbc68c1b39e292c3efe82bfa15e372351b4","date":1495700700,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if(session.matrix.stream().noneMatch(row -> row.replicaInfo.containsKey(coll))){\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if(coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.replicaInfo.containsKey(coll)) row.replicaInfo.put(coll, new HashMap<>());\n            if(shard != null){\n              Map<String, List<ReplicaInfo>> shardInfo = row.replicaInfo.get(coll);\n              if(!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        if(coll != null){\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if(session.matrix.stream().noneMatch(row -> row.replicaInfo.containsKey(coll))){\n            session.matrix.get(0).replicaInfo.put(coll, new HashMap<>());\n            session.addClausesForCollection(session.dataProvider, coll);\n            Collections.sort(session.expandedClauses);\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f78c807c3692e5b227a71538672d87d78c3cd9ba","date":1495764154,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.replicaInfo.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.replicaInfo.containsKey(coll)) row.replicaInfo.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.replicaInfo.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if(session.matrix.stream().noneMatch(row -> row.replicaInfo.containsKey(coll))){\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if(coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.replicaInfo.containsKey(coll)) row.replicaInfo.put(coll, new HashMap<>());\n            if(shard != null){\n              Map<String, List<ReplicaInfo>> shardInfo = row.replicaInfo.get(coll);\n              if(!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa61ea06d4d27acb465d77e15f20aae84531d73","date":1495784617,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.replicaInfo.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.replicaInfo.containsKey(coll)) row.replicaInfo.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.replicaInfo.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a513b6a92751e54c76fb5447948c9e7d437163a7","date":1496136565,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"/dev/null","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74aea047dff7f7c38a2d766827bd20d356f98c6a","date":1496721416,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"/dev/null","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f6b20dc453cee198956989b90aa24bef0232bcf","date":1498221066,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2","date":1498616740,"type":5,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98f11c416d30e556e0004a9a84960702d12d35b1","date":1498628359,"type":5,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"5d14f4b04a5c752272b2f79fd6684fee8dff2808":["653c1ca305e0065ee988a09e59c8316b8cde02fd"],"d2e1fb1b46fffdd00b6f31596d6eee00b71015fc":["1fca549db64ee4c87a83a94e7c224506fa20d396"],"1fca549db64ee4c87a83a94e7c224506fa20d396":["5d14f4b04a5c752272b2f79fd6684fee8dff2808"],"a4b9ebbc68c1b39e292c3efe82bfa15e372351b4":["d2e1fb1b46fffdd00b6f31596d6eee00b71015fc"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a513b6a92751e54c76fb5447948c9e7d437163a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8aa61ea06d4d27acb465d77e15f20aae84531d73":["f78c807c3692e5b227a71538672d87d78c3cd9ba"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"653c1ca305e0065ee988a09e59c8316b8cde02fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f78c807c3692e5b227a71538672d87d78c3cd9ba":["a4b9ebbc68c1b39e292c3efe82bfa15e372351b4"],"1f6b20dc453cee198956989b90aa24bef0232bcf":["8aa61ea06d4d27acb465d77e15f20aae84531d73"],"98f11c416d30e556e0004a9a84960702d12d35b1":["1f6b20dc453cee198956989b90aa24bef0232bcf","6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2":["98f11c416d30e556e0004a9a84960702d12d35b1"],"5d14f4b04a5c752272b2f79fd6684fee8dff2808":["1fca549db64ee4c87a83a94e7c224506fa20d396"],"d2e1fb1b46fffdd00b6f31596d6eee00b71015fc":["a4b9ebbc68c1b39e292c3efe82bfa15e372351b4"],"1fca549db64ee4c87a83a94e7c224506fa20d396":["d2e1fb1b46fffdd00b6f31596d6eee00b71015fc"],"a4b9ebbc68c1b39e292c3efe82bfa15e372351b4":["f78c807c3692e5b227a71538672d87d78c3cd9ba"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74aea047dff7f7c38a2d766827bd20d356f98c6a","a513b6a92751e54c76fb5447948c9e7d437163a7","653c1ca305e0065ee988a09e59c8316b8cde02fd","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"8aa61ea06d4d27acb465d77e15f20aae84531d73":["1f6b20dc453cee198956989b90aa24bef0232bcf"],"653c1ca305e0065ee988a09e59c8316b8cde02fd":["5d14f4b04a5c752272b2f79fd6684fee8dff2808"],"f78c807c3692e5b227a71538672d87d78c3cd9ba":["8aa61ea06d4d27acb465d77e15f20aae84531d73"],"1f6b20dc453cee198956989b90aa24bef0232bcf":["98f11c416d30e556e0004a9a84960702d12d35b1"],"98f11c416d30e556e0004a9a84960702d12d35b1":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["98f11c416d30e556e0004a9a84960702d12d35b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}