{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(int[],int,boolean).mjava","commits":[{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(int[],int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Expert: Don't use this!\n   */\n  public LevenshteinAutomata(int[] word, int alphaMax, boolean withTranspositions) {\n    this.word = word;\n    this.alphaMax = alphaMax;\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= alphaMax) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = alphaMax;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31b5edc7f41e0c481513ce8881696e3e042ff493","date":1351528983,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(int[],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(int[],int,boolean).mjava","sourceNew":"  /**\n   * Expert: specify a custom maximum possible symbol\n   * (alphaMax); default is Character.MAX_CODE_POINT.\n   */\n  public LevenshteinAutomata(int[] word, int alphaMax, boolean withTranspositions) {\n    this.word = word;\n    this.alphaMax = alphaMax;\n\n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++) {\n      int v = word[i];\n      if (v > alphaMax) {\n        throw new IllegalArgumentException(\"alphaMax exceeded by symbol \" + v + \" in word\");\n      }\n      set.add(v);\n    }\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= alphaMax) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = alphaMax;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":"  /**\n   * Expert: Don't use this!\n   */\n  public LevenshteinAutomata(int[] word, int alphaMax, boolean withTranspositions) {\n    this.word = word;\n    this.alphaMax = alphaMax;\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= alphaMax) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = alphaMax;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(int[],int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Expert: specify a custom maximum possible symbol\n   * (alphaMax); default is Character.MAX_CODE_POINT.\n   */\n  public LevenshteinAutomata(int[] word, int alphaMax, boolean withTranspositions) {\n    this.word = word;\n    this.alphaMax = alphaMax;\n\n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++) {\n      int v = word[i];\n      if (v > alphaMax) {\n        throw new IllegalArgumentException(\"alphaMax exceeded by symbol \" + v + \" in word\");\n      }\n      set.add(v);\n    }\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= alphaMax) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = alphaMax;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(int[],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(int[],int,boolean).mjava","sourceNew":"  /**\n   * Expert: specify a custom maximum possible symbol\n   * (alphaMax); default is Character.MAX_CODE_POINT.\n   */\n  public LevenshteinAutomata(int[] word, int alphaMax, boolean withTranspositions) {\n    this.word = word;\n    this.alphaMax = alphaMax;\n\n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<>();\n    for (int i = 0; i < word.length; i++) {\n      int v = word[i];\n      if (v > alphaMax) {\n        throw new IllegalArgumentException(\"alphaMax exceeded by symbol \" + v + \" in word\");\n      }\n      set.add(v);\n    }\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= alphaMax) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = alphaMax;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":"  /**\n   * Expert: specify a custom maximum possible symbol\n   * (alphaMax); default is Character.MAX_CODE_POINT.\n   */\n  public LevenshteinAutomata(int[] word, int alphaMax, boolean withTranspositions) {\n    this.word = word;\n    this.alphaMax = alphaMax;\n\n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++) {\n      int v = word[i];\n      if (v > alphaMax) {\n        throw new IllegalArgumentException(\"alphaMax exceeded by symbol \" + v + \" in word\");\n      }\n      set.add(v);\n    }\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= alphaMax) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = alphaMax;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","31b5edc7f41e0c481513ce8881696e3e042ff493"],"cc41b743423981e7ec17a024ce7e107096e472fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"31b5edc7f41e0c481513ce8881696e3e042ff493":["cc41b743423981e7ec17a024ce7e107096e472fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cc41b743423981e7ec17a024ce7e107096e472fe":["31b5edc7f41e0c481513ce8881696e3e042ff493"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","cc41b743423981e7ec17a024ce7e107096e472fe"],"31b5edc7f41e0c481513ce8881696e3e042ff493":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}