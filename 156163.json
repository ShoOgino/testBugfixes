{"path":"solr/core/src/java/org/apache/solr/search/stats/LRUStatsCache#doRetrieveStatsRequest(ResponseBuilder).mjava","commits":[{"id":"df72a23fb74bebe914e3f3972063a884327c0436","date":1570470832,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/LRUStatsCache#doRetrieveStatsRequest(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected ShardRequest doRetrieveStatsRequest(ResponseBuilder rb) {\n    // check approximately what terms are needed.\n\n    // NOTE: query rewrite only expands to terms that are present in the local index\n    // so it's possible that the result will contain less terms than present in all shards.\n\n    // HOWEVER: the absence of these terms is recorded by LRUStatsSource, and they will be\n    // force-fetched on next request and cached.\n\n    // check for missing stats from previous requests\n    if (!missingColStats.isEmpty() || !missingColStats.isEmpty()) {\n      // needs to fetch anyway, so get the full query stats + the missing stats for caching\n      ShardRequest sreq = super.doRetrieveStatsRequest(rb);\n      if (!missingColStats.isEmpty()) {\n        Set<String> requestColStats = missingColStats;\n        // there's a small window when new items may be added before\n        // creating the request and clearing, so don't clear - instead replace the instance\n        missingColStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(FIELDS_KEY, StatsUtil.fieldsToString(requestColStats));\n      }\n      if (!missingTermStats.isEmpty()) {\n        Set<Term> requestTermStats = missingTermStats;\n        missingTermStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(TERMS_KEY, StatsUtil.termsToEncodedString(requestTermStats));\n      }\n      return sreq;\n    }\n\n    // rewrite locally to see if there are any missing terms. See the note above for caveats.\n    LongAdder missing = new LongAdder();\n    try {\n      // use ignorableMetrics to avoid counting this checking as real misses\n      approxCheckMissingStats(rb, new LRUStatsSource(ignorableMetrics), t -> missing.increment(), f -> missing.increment());\n      if (missing.sum() == 0) {\n        // it should be (approximately) ok to skip the fetching\n\n        // since we already incremented the stats decrement it here\n        statsCacheMetrics.retrieveStats.decrement();\n        statsCacheMetrics.useCachedGlobalStats.increment();\n        return null;\n      } else {\n        return super.doRetrieveStatsRequest(rb);\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception checking missing stats for query \" + rb.getQuery() + \", forcing retrieving stats\", e);\n      // retrieve anyway\n      return super.doRetrieveStatsRequest(rb);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":0,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/LRUStatsCache#doRetrieveStatsRequest(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected ShardRequest doRetrieveStatsRequest(ResponseBuilder rb) {\n    // check approximately what terms are needed.\n\n    // NOTE: query rewrite only expands to terms that are present in the local index\n    // so it's possible that the result will contain less terms than present in all shards.\n\n    // HOWEVER: the absence of these terms is recorded by LRUStatsSource, and they will be\n    // force-fetched on next request and cached.\n\n    // check for missing stats from previous requests\n    if (!missingColStats.isEmpty() || !missingColStats.isEmpty()) {\n      // needs to fetch anyway, so get the full query stats + the missing stats for caching\n      ShardRequest sreq = super.doRetrieveStatsRequest(rb);\n      if (!missingColStats.isEmpty()) {\n        Set<String> requestColStats = missingColStats;\n        // there's a small window when new items may be added before\n        // creating the request and clearing, so don't clear - instead replace the instance\n        missingColStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(FIELDS_KEY, StatsUtil.fieldsToString(requestColStats));\n      }\n      if (!missingTermStats.isEmpty()) {\n        Set<Term> requestTermStats = missingTermStats;\n        missingTermStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(TERMS_KEY, StatsUtil.termsToEncodedString(requestTermStats));\n      }\n      return sreq;\n    }\n\n    // rewrite locally to see if there are any missing terms. See the note above for caveats.\n    LongAdder missing = new LongAdder();\n    try {\n      // use ignorableMetrics to avoid counting this checking as real misses\n      approxCheckMissingStats(rb, new LRUStatsSource(ignorableMetrics), t -> missing.increment(), f -> missing.increment());\n      if (missing.sum() == 0) {\n        // it should be (approximately) ok to skip the fetching\n\n        // since we already incremented the stats decrement it here\n        statsCacheMetrics.retrieveStats.decrement();\n        statsCacheMetrics.useCachedGlobalStats.increment();\n        return null;\n      } else {\n        return super.doRetrieveStatsRequest(rb);\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception checking missing stats for query \" + rb.getQuery() + \", forcing retrieving stats\", e);\n      // retrieve anyway\n      return super.doRetrieveStatsRequest(rb);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/LRUStatsCache#doRetrieveStatsRequest(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/LRUStatsCache#doRetrieveStatsRequest(ResponseBuilder).mjava","sourceNew":"  @Override\n  protected ShardRequest doRetrieveStatsRequest(ResponseBuilder rb) {\n    // check approximately what terms are needed.\n\n    // NOTE: query rewrite only expands to terms that are present in the local index\n    // so it's possible that the result will contain less terms than present in all shards.\n\n    // HOWEVER: the absence of these terms is recorded by LRUStatsSource, and they will be\n    // force-fetched on next request and cached.\n\n    // check for missing stats from previous requests\n    if (!missingColStats.isEmpty() || !missingColStats.isEmpty()) {\n      // needs to fetch anyway, so get the full query stats + the missing stats for caching\n      ShardRequest sreq = super.doRetrieveStatsRequest(rb);\n      if (!missingColStats.isEmpty()) {\n        Set<String> requestColStats = missingColStats;\n        // there's a small window when new items may be added before\n        // creating the request and clearing, so don't clear - instead replace the instance\n        missingColStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(FIELDS_KEY, StatsUtil.fieldsToString(requestColStats));\n      }\n      if (!missingTermStats.isEmpty()) {\n        Set<Term> requestTermStats = missingTermStats;\n        missingTermStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(TERMS_KEY, StatsUtil.termsToEncodedString(requestTermStats));\n      }\n      return sreq;\n    }\n\n    // rewrite locally to see if there are any missing terms. See the note above for caveats.\n    LongAdder missing = new LongAdder();\n    try {\n      // use ignorableMetrics to avoid counting this checking as real misses\n      approxCheckMissingStats(rb, new LRUStatsSource(ignorableMetrics), t -> missing.increment(), f -> missing.increment());\n      if (missing.sum() == 0) {\n        // it should be (approximately) ok to skip the fetching\n\n        // since we already incremented the stats decrement it here\n        statsCacheMetrics.retrieveStats.decrement();\n        statsCacheMetrics.useCachedGlobalStats.increment();\n        return null;\n      } else {\n        return super.doRetrieveStatsRequest(rb);\n      }\n    } catch (IOException e) {\n      if (log.isWarnEnabled()) {\n        log.warn(\"Exception checking missing stats for query {}, forcing retrieving stats\", rb.getQuery(), e);\n      }\n      // retrieve anyway\n      return super.doRetrieveStatsRequest(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected ShardRequest doRetrieveStatsRequest(ResponseBuilder rb) {\n    // check approximately what terms are needed.\n\n    // NOTE: query rewrite only expands to terms that are present in the local index\n    // so it's possible that the result will contain less terms than present in all shards.\n\n    // HOWEVER: the absence of these terms is recorded by LRUStatsSource, and they will be\n    // force-fetched on next request and cached.\n\n    // check for missing stats from previous requests\n    if (!missingColStats.isEmpty() || !missingColStats.isEmpty()) {\n      // needs to fetch anyway, so get the full query stats + the missing stats for caching\n      ShardRequest sreq = super.doRetrieveStatsRequest(rb);\n      if (!missingColStats.isEmpty()) {\n        Set<String> requestColStats = missingColStats;\n        // there's a small window when new items may be added before\n        // creating the request and clearing, so don't clear - instead replace the instance\n        missingColStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(FIELDS_KEY, StatsUtil.fieldsToString(requestColStats));\n      }\n      if (!missingTermStats.isEmpty()) {\n        Set<Term> requestTermStats = missingTermStats;\n        missingTermStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(TERMS_KEY, StatsUtil.termsToEncodedString(requestTermStats));\n      }\n      return sreq;\n    }\n\n    // rewrite locally to see if there are any missing terms. See the note above for caveats.\n    LongAdder missing = new LongAdder();\n    try {\n      // use ignorableMetrics to avoid counting this checking as real misses\n      approxCheckMissingStats(rb, new LRUStatsSource(ignorableMetrics), t -> missing.increment(), f -> missing.increment());\n      if (missing.sum() == 0) {\n        // it should be (approximately) ok to skip the fetching\n\n        // since we already incremented the stats decrement it here\n        statsCacheMetrics.retrieveStats.decrement();\n        statsCacheMetrics.useCachedGlobalStats.increment();\n        return null;\n      } else {\n        return super.doRetrieveStatsRequest(rb);\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception checking missing stats for query \" + rb.getQuery() + \", forcing retrieving stats\", e);\n      // retrieve anyway\n      return super.doRetrieveStatsRequest(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/LRUStatsCache#doRetrieveStatsRequest(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/LRUStatsCache#doRetrieveStatsRequest(ResponseBuilder).mjava","sourceNew":"  @Override\n  protected ShardRequest doRetrieveStatsRequest(ResponseBuilder rb) {\n    // check approximately what terms are needed.\n\n    // NOTE: query rewrite only expands to terms that are present in the local index\n    // so it's possible that the result will contain less terms than present in all shards.\n\n    // HOWEVER: the absence of these terms is recorded by LRUStatsSource, and they will be\n    // force-fetched on next request and cached.\n\n    // check for missing stats from previous requests\n    if (!missingColStats.isEmpty() || !missingColStats.isEmpty()) {\n      // needs to fetch anyway, so get the full query stats + the missing stats for caching\n      ShardRequest sreq = super.doRetrieveStatsRequest(rb);\n      if (!missingColStats.isEmpty()) {\n        Set<String> requestColStats = missingColStats;\n        // there's a small window when new items may be added before\n        // creating the request and clearing, so don't clear - instead replace the instance\n        missingColStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(FIELDS_KEY, StatsUtil.fieldsToString(requestColStats));\n      }\n      if (!missingTermStats.isEmpty()) {\n        Set<Term> requestTermStats = missingTermStats;\n        missingTermStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(TERMS_KEY, StatsUtil.termsToEncodedString(requestTermStats));\n      }\n      return sreq;\n    }\n\n    // rewrite locally to see if there are any missing terms. See the note above for caveats.\n    LongAdder missing = new LongAdder();\n    try {\n      // use ignorableMetrics to avoid counting this checking as real misses\n      approxCheckMissingStats(rb, new LRUStatsSource(ignorableMetrics), t -> missing.increment(), f -> missing.increment());\n      if (missing.sum() == 0) {\n        // it should be (approximately) ok to skip the fetching\n\n        // since we already incremented the stats decrement it here\n        statsCacheMetrics.retrieveStats.decrement();\n        statsCacheMetrics.useCachedGlobalStats.increment();\n        return null;\n      } else {\n        return super.doRetrieveStatsRequest(rb);\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception checking missing stats for query {}, forcing retrieving stats\", rb.getQuery(), e);\n      // retrieve anyway\n      return super.doRetrieveStatsRequest(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected ShardRequest doRetrieveStatsRequest(ResponseBuilder rb) {\n    // check approximately what terms are needed.\n\n    // NOTE: query rewrite only expands to terms that are present in the local index\n    // so it's possible that the result will contain less terms than present in all shards.\n\n    // HOWEVER: the absence of these terms is recorded by LRUStatsSource, and they will be\n    // force-fetched on next request and cached.\n\n    // check for missing stats from previous requests\n    if (!missingColStats.isEmpty() || !missingColStats.isEmpty()) {\n      // needs to fetch anyway, so get the full query stats + the missing stats for caching\n      ShardRequest sreq = super.doRetrieveStatsRequest(rb);\n      if (!missingColStats.isEmpty()) {\n        Set<String> requestColStats = missingColStats;\n        // there's a small window when new items may be added before\n        // creating the request and clearing, so don't clear - instead replace the instance\n        missingColStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(FIELDS_KEY, StatsUtil.fieldsToString(requestColStats));\n      }\n      if (!missingTermStats.isEmpty()) {\n        Set<Term> requestTermStats = missingTermStats;\n        missingTermStats = ConcurrentHashMap.newKeySet();\n        sreq.params.add(TERMS_KEY, StatsUtil.termsToEncodedString(requestTermStats));\n      }\n      return sreq;\n    }\n\n    // rewrite locally to see if there are any missing terms. See the note above for caveats.\n    LongAdder missing = new LongAdder();\n    try {\n      // use ignorableMetrics to avoid counting this checking as real misses\n      approxCheckMissingStats(rb, new LRUStatsSource(ignorableMetrics), t -> missing.increment(), f -> missing.increment());\n      if (missing.sum() == 0) {\n        // it should be (approximately) ok to skip the fetching\n\n        // since we already incremented the stats decrement it here\n        statsCacheMetrics.retrieveStats.decrement();\n        statsCacheMetrics.useCachedGlobalStats.increment();\n        return null;\n      } else {\n        return super.doRetrieveStatsRequest(rb);\n      }\n    } catch (IOException e) {\n      if (log.isWarnEnabled()) {\n        log.warn(\"Exception checking missing stats for query {}, forcing retrieving stats\", rb.getQuery(), e);\n      }\n      // retrieve anyway\n      return super.doRetrieveStatsRequest(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["df72a23fb74bebe914e3f3972063a884327c0436"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"df72a23fb74bebe914e3f3972063a884327c0436":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"],"b0b597c65628ca9e73913a07e81691f8229bae35":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","df72a23fb74bebe914e3f3972063a884327c0436"]},"commit2Childs":{"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["df72a23fb74bebe914e3f3972063a884327c0436","b0b597c65628ca9e73913a07e81691f8229bae35"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"df72a23fb74bebe914e3f3972063a884327c0436":["54faedfb0e03479a38f5ee82f2dfaeea536e9404","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}