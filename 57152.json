{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateHotOps(List[TriggerEvent.Op],Set[String],Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","commits":[{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateHotOps(List[TriggerEvent.Op],Set[String],Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateHotOps(List[TriggerEvent.Op],Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","sourceNew":"  private void calculateHotOps(List<TriggerEvent.Op> ops,\n                               Set<String> violations,\n                               Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                               Map<String, Double> hotNodes,\n                               Map<String, Double> hotCollections,\n                               Map<String, Map<String, Double>> hotShards,\n                               List<ReplicaInfo> hotReplicas) {\n    // calculate the number of replicas to add to each hot shard, based on how much the rate was\n    // exceeded - but within limits.\n\n    // first resolve a situation when only a node is hot but no collection / shard is hot\n    // TODO: eventually we may want to commission a new node\n    if (!hotNodes.isEmpty()) {\n      if (hotShards.isEmpty() && hotCollections.isEmpty()) {\n        // move replicas around\n        if (aboveNodeOp != null) {\n          hotNodes.forEach((n, r) -> {\n            ops.add(new TriggerEvent.Op(aboveNodeOp, Suggester.Hint.SRC_NODE, n));\n            violations.add(HOT_NODES);\n          });\n        }\n      } else {\n        // ignore - hot shards will result in changes that will change hot node status anyway\n      }\n    }\n    // add replicas\n    Map<String, Map<String, List<Pair<String, String>>>> hints = new HashMap<>();\n\n    // HOT COLLECTIONS\n    // currently we don't do anything for hot collections. Theoretically we could add\n    // 1 replica more to each shard, based on how close to the threshold each shard is\n    // but it's probably better to wait for a shard to become hot and be more precise.\n\n    // HOT SHARDS\n\n    hotShards.forEach((coll, shards) -> shards.forEach((s, r) -> {\n      List<Pair<String, String>> perShard = hints\n          .computeIfAbsent(coll, c -> new HashMap<>())\n          .computeIfAbsent(s, sh -> new ArrayList<>());\n      addReplicaHints(coll, s, r, searchableReplicationFactors.get(coll).get(s).get(), perShard);\n      violations.add(HOT_SHARDS);\n    }));\n\n    // HOT REPLICAS\n    // Hot replicas (while their shards are not hot) may be caused by\n    // dumb clients that use direct replica URLs - this is beyond our control\n    // so ignore them.\n\n    hints.values().forEach(m -> m.values().forEach(lst -> lst.forEach(p -> {\n      ops.add(new TriggerEvent.Op(aboveOp, Suggester.Hint.COLL_SHARD, p));\n    })));\n\n  }\n\n","sourceOld":"  private void calculateHotOps(List<TriggerEvent.Op> ops,\n                               Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                               Map<String, Double> hotNodes,\n                               Map<String, Double> hotCollections,\n                               Map<String, Map<String, Double>> hotShards,\n                               List<ReplicaInfo> hotReplicas) {\n    // calculate the number of replicas to add to each hot shard, based on how much the rate was\n    // exceeded - but within limits.\n\n    // first resolve a situation when only a node is hot but no collection / shard / replica is hot\n    // TODO: eventually we may want to commission a new node\n    if (!hotNodes.isEmpty() && hotShards.isEmpty() && hotCollections.isEmpty() && hotReplicas.isEmpty()) {\n      // move replicas around\n      if (aboveNodeOp != null) {\n        hotNodes.forEach((n, r) -> {\n          ops.add(new TriggerEvent.Op(aboveNodeOp, Suggester.Hint.SRC_NODE, n));\n        });\n      }\n    } else {\n      // add replicas\n      Map<String, Map<String, List<Pair<String, String>>>> hints = new HashMap<>();\n\n      hotShards.forEach((coll, shards) -> shards.forEach((s, r) -> {\n        List<Pair<String, String>> perShard = hints\n            .computeIfAbsent(coll, c -> new HashMap<>())\n            .computeIfAbsent(s, sh -> new ArrayList<>());\n        addReplicaHints(coll, s, r, searchableReplicationFactors.get(coll).get(s).get(), perShard);\n      }));\n      hotReplicas.forEach(ri -> {\n        double r = (Double)ri.getVariable(AutoScalingParams.RATE);\n        // add only if not already accounted for in hotShards\n        List<Pair<String, String>> perShard = hints\n            .computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n            .computeIfAbsent(ri.getShard(), sh -> new ArrayList<>());\n        if (perShard.isEmpty()) {\n          addReplicaHints(ri.getCollection(), ri.getShard(), r, searchableReplicationFactors.get(ri.getCollection()).get(ri.getShard()).get(), perShard);\n        }\n      });\n\n      hints.values().forEach(m -> m.values().forEach(lst -> lst.forEach(p -> {\n        ops.add(new TriggerEvent.Op(aboveOp, Suggester.Hint.COLL_SHARD, p));\n      })));\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateHotOps(List[TriggerEvent.Op],Set[String],Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[Replica]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateHotOps(List[TriggerEvent.Op],Set[String],Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","sourceNew":"  private void calculateHotOps(List<TriggerEvent.Op> ops,\n                               Set<String> violations,\n                               Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                               Map<String, Double> hotNodes,\n                               Map<String, Double> hotCollections,\n                               Map<String, Map<String, Double>> hotShards,\n                               List<Replica> hotReplicas) {\n    // calculate the number of replicas to add to each hot shard, based on how much the rate was\n    // exceeded - but within limits.\n\n    // first resolve a situation when only a node is hot but no collection / shard is hot\n    // TODO: eventually we may want to commission a new node\n    if (!hotNodes.isEmpty()) {\n      if (hotShards.isEmpty() && hotCollections.isEmpty()) {\n        // move replicas around\n        if (aboveNodeOp != null) {\n          hotNodes.forEach((n, r) -> {\n            ops.add(new TriggerEvent.Op(aboveNodeOp, Suggester.Hint.SRC_NODE, n));\n            violations.add(HOT_NODES);\n          });\n        }\n      } else {\n        // ignore - hot shards will result in changes that will change hot node status anyway\n      }\n    }\n    // add replicas\n    Map<String, Map<String, List<Pair<String, String>>>> hints = new HashMap<>();\n\n    // HOT COLLECTIONS\n    // currently we don't do anything for hot collections. Theoretically we could add\n    // 1 replica more to each shard, based on how close to the threshold each shard is\n    // but it's probably better to wait for a shard to become hot and be more precise.\n\n    // HOT SHARDS\n\n    hotShards.forEach((coll, shards) -> shards.forEach((s, r) -> {\n      List<Pair<String, String>> perShard = hints\n          .computeIfAbsent(coll, c -> new HashMap<>())\n          .computeIfAbsent(s, sh -> new ArrayList<>());\n      addReplicaHints(coll, s, r, searchableReplicationFactors.get(coll).get(s).get(), perShard);\n      violations.add(HOT_SHARDS);\n    }));\n\n    // HOT REPLICAS\n    // Hot replicas (while their shards are not hot) may be caused by\n    // dumb clients that use direct replica URLs - this is beyond our control\n    // so ignore them.\n\n    hints.values().forEach(m -> m.values().forEach(lst -> lst.forEach(p -> {\n      ops.add(new TriggerEvent.Op(aboveOp, Suggester.Hint.COLL_SHARD, p));\n    })));\n\n  }\n\n","sourceOld":"  private void calculateHotOps(List<TriggerEvent.Op> ops,\n                               Set<String> violations,\n                               Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                               Map<String, Double> hotNodes,\n                               Map<String, Double> hotCollections,\n                               Map<String, Map<String, Double>> hotShards,\n                               List<ReplicaInfo> hotReplicas) {\n    // calculate the number of replicas to add to each hot shard, based on how much the rate was\n    // exceeded - but within limits.\n\n    // first resolve a situation when only a node is hot but no collection / shard is hot\n    // TODO: eventually we may want to commission a new node\n    if (!hotNodes.isEmpty()) {\n      if (hotShards.isEmpty() && hotCollections.isEmpty()) {\n        // move replicas around\n        if (aboveNodeOp != null) {\n          hotNodes.forEach((n, r) -> {\n            ops.add(new TriggerEvent.Op(aboveNodeOp, Suggester.Hint.SRC_NODE, n));\n            violations.add(HOT_NODES);\n          });\n        }\n      } else {\n        // ignore - hot shards will result in changes that will change hot node status anyway\n      }\n    }\n    // add replicas\n    Map<String, Map<String, List<Pair<String, String>>>> hints = new HashMap<>();\n\n    // HOT COLLECTIONS\n    // currently we don't do anything for hot collections. Theoretically we could add\n    // 1 replica more to each shard, based on how close to the threshold each shard is\n    // but it's probably better to wait for a shard to become hot and be more precise.\n\n    // HOT SHARDS\n\n    hotShards.forEach((coll, shards) -> shards.forEach((s, r) -> {\n      List<Pair<String, String>> perShard = hints\n          .computeIfAbsent(coll, c -> new HashMap<>())\n          .computeIfAbsent(s, sh -> new ArrayList<>());\n      addReplicaHints(coll, s, r, searchableReplicationFactors.get(coll).get(s).get(), perShard);\n      violations.add(HOT_SHARDS);\n    }));\n\n    // HOT REPLICAS\n    // Hot replicas (while their shards are not hot) may be caused by\n    // dumb clients that use direct replica URLs - this is beyond our control\n    // so ignore them.\n\n    hints.values().forEach(m -> m.values().forEach(lst -> lst.forEach(p -> {\n      ops.add(new TriggerEvent.Op(aboveOp, Suggester.Hint.COLL_SHARD, p));\n    })));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"]},"commit2Childs":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}