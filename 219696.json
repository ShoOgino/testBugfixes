{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","commits":[{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63caed6eb28209e181e97822c4c8fdf808884c3b","date":1337712793,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"498e63ab0d700e7d3172d8553248c14031b4c850","date":1337719076,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ee159418514037b0fa456cf8b5d6c91e2bf5557","date":1337721836,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb5728b83dbb3e002cdd22adfe6caf103a96ef15","date":1337791289,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"203d7d3cb7712e10ef33009a63247ae40c302d7a","date":1337798111,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(), info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a917aca07a305ab70118a83e84d931503441271","date":1337826487,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      info.info.putAttribute(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(), info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f00f0f8c602950d28e2cb62039b72f51f5d5c44c","date":1337861286,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    // copy the attributes map, we modify it for the preflex case\n    final Map<String,String> attributes;\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      info.info.putAttribute(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), info.info.attributes());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc2469a10cffdebd38d207761a32c90c12316b52","date":1337861944,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    // copy the attributes map, we modify it for the preflex case\n    final Map<String,String> attributes;\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      // cant we determine a file is a 3.x shared doc store file if hasSharedDocStore=true\n      // and the segment prefix != info.info.name instead of this stuff?\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    // copy the attributes map, we modify it for the preflex case\n    final Map<String,String> attributes;\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee3df95012e016c229172f87a6c4077957246c4a","date":1337867023,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n\n    // copy the attributes map, we modify it for the preflex case\n    final Map<String,String> attributes;\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      // cant we determine a file is a 3.x shared doc store file if hasSharedDocStore=true\n      // and the segment prefix != info.info.name instead of this stuff?\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    // copy the attributes map, we modify it for the preflex case\n    final Map<String,String> attributes;\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      // cant we determine a file is a 3.x shared doc store file if hasSharedDocStore=true\n      // and the segment prefix != info.info.name instead of this stuff?\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"764b942fd30efcae6e532c19771f32eeeb0037b2","date":1337868546,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n\n    // copy the attributes map, we modify it for the preflex case\n    final Map<String,String> attributes;\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      // cant we determine a file is a 3.x shared doc store file if hasSharedDocStore=true\n      // and the segment prefix != info.info.name instead of this stuff?\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n\n    // copy the attributes map, we modify it for the preflex case\n    final Map<String,String> attributes;\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      // cant we determine a file is a 3.x shared doc store file if hasSharedDocStore=true\n      // and the segment prefix != info.info.name instead of this stuff?\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c646ace64c35832d8e70eb297906f9b141eddbd","date":1337885335,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    Set<String> docStoreFiles3xOnly = Lucene3xCodec.getDocStoreFiles(info.info);\n\n    final Map<String,String> attributes;\n    if (docStoreFiles3xOnly != null) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // change docStoreSegment to newDsName\n      // copy the attributes map, we modify it below:\n      if (info.info.attributes() == null) {\n        attributes = new HashMap<String,String>();\n      } else {\n        attributes = new HashMap<String,String>(info.info.attributes());\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    } else {\n      attributes = info.info.attributes();\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = Lucene3xSegmentInfoFormat.getDocStoreOffset(info.info) != -1;\n\n    // copy the attributes map, we modify it for the preflex case\n    final Map<String,String> attributes;\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // nocommit what to do....\n      // cant we determine a file is a 3.x shared doc store file if hasSharedDocStore=true\n      // and the segment prefix != info.info.name instead of this stuff?\n      if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(info.info)) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(dsName, \"\", \"tvd\"));\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07087852d7b2a5c7e7d79b19c3e3ba775596b5d8","date":1337887183,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    Set<String> docStoreFiles3xOnly = Lucene3xCodec.getDocStoreFiles(info.info);\n\n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (docStoreFiles3xOnly != null) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // nocommit: this gets insanely crazy: if there is any 3.x can we just open a reader and AddIndexes(Reader) ?!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    Set<String> docStoreFiles3xOnly = Lucene3xCodec.getDocStoreFiles(info.info);\n\n    final Map<String,String> attributes;\n    if (docStoreFiles3xOnly != null) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // change docStoreSegment to newDsName\n      // copy the attributes map, we modify it below:\n      if (info.info.attributes() == null) {\n        attributes = new HashMap<String,String>();\n      } else {\n        attributes = new HashMap<String,String>(info.info.attributes());\n      }\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    } else {\n      attributes = info.info.attributes();\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), Collections.unmodifiableMap(attributes));\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","5f6bd27530a2846413fe2d00030493c0e2d3a072","2edef7afebca00bf81a8bef95d44ea971ba309fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    Set<String> docStoreFiles3xOnly = Lucene3xCodec.getDocStoreFiles(info.info);\n\n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (docStoreFiles3xOnly != null) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // TODO: this can be substantially simplified now that 3.x support/shared docstores is removed!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.name;\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = Lucene3xSegmentInfoFormat.getDocStoreSegment(info.info);\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    Set<String> docStoreFiles3xOnly = Lucene3xCodec.getDocStoreFiles(info.info);\n\n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n    if (docStoreFiles3xOnly != null) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      // change docStoreSegment to newDsName\n      attributes.put(Lucene3xSegmentInfoFormat.DS_NAME_KEY, newDsName);\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (docStoreFiles3xOnly != null && docStoreFiles3xOnly.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2edef7afebca00bf81a8bef95d44ea971ba309fa","date":1339101284,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // TODO: this can be substantially simplified now that 3.x support/shared docstores is removed!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.name;\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // TODO: this can be substantially simplified now that 3.x support/shared docstores is removed!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.name;\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfosWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":["07087852d7b2a5c7e7d79b19c3e3ba775596b5d8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"23ab146d336df02e9a396ea060f8f4b114dc33a6","date":1344450994,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // TODO: this can be substantially simplified now that 3.x support/shared docstores is removed!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.name;\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":null,"sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // TODO: this can be substantially simplified now that 3.x support/shared docstores is removed!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.name;\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // TODO: this can be substantially simplified now that 3.x support/shared docstores is removed!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.name;\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ee3df95012e016c229172f87a6c4077957246c4a":["cc2469a10cffdebd38d207761a32c90c12316b52"],"fb5728b83dbb3e002cdd22adfe6caf103a96ef15":["9ee159418514037b0fa456cf8b5d6c91e2bf5557"],"23ab146d336df02e9a396ea060f8f4b114dc33a6":["2edef7afebca00bf81a8bef95d44ea971ba309fa"],"6a917aca07a305ab70118a83e84d931503441271":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"2edef7afebca00bf81a8bef95d44ea971ba309fa":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"764b942fd30efcae6e532c19771f32eeeb0037b2":["ee3df95012e016c229172f87a6c4077957246c4a"],"63caed6eb28209e181e97822c4c8fdf808884c3b":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"07087852d7b2a5c7e7d79b19c3e3ba775596b5d8":["7c646ace64c35832d8e70eb297906f9b141eddbd"],"498e63ab0d700e7d3172d8553248c14031b4c850":["63caed6eb28209e181e97822c4c8fdf808884c3b"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","07087852d7b2a5c7e7d79b19c3e3ba775596b5d8"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["2edef7afebca00bf81a8bef95d44ea971ba309fa","23ab146d336df02e9a396ea060f8f4b114dc33a6"],"7c646ace64c35832d8e70eb297906f9b141eddbd":["764b942fd30efcae6e532c19771f32eeeb0037b2"],"f00f0f8c602950d28e2cb62039b72f51f5d5c44c":["6a917aca07a305ab70118a83e84d931503441271"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["2edef7afebca00bf81a8bef95d44ea971ba309fa","23ab146d336df02e9a396ea060f8f4b114dc33a6"],"9ee159418514037b0fa456cf8b5d6c91e2bf5557":["498e63ab0d700e7d3172d8553248c14031b4c850"],"cc2469a10cffdebd38d207761a32c90c12316b52":["f00f0f8c602950d28e2cb62039b72f51f5d5c44c"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["fb5728b83dbb3e002cdd22adfe6caf103a96ef15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23ab146d336df02e9a396ea060f8f4b114dc33a6"]},"commit2Childs":{"ee3df95012e016c229172f87a6c4077957246c4a":["764b942fd30efcae6e532c19771f32eeeb0037b2"],"fb5728b83dbb3e002cdd22adfe6caf103a96ef15":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"23ab146d336df02e9a396ea060f8f4b114dc33a6":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6a917aca07a305ab70118a83e84d931503441271":["f00f0f8c602950d28e2cb62039b72f51f5d5c44c"],"2edef7afebca00bf81a8bef95d44ea971ba309fa":["23ab146d336df02e9a396ea060f8f4b114dc33a6","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"764b942fd30efcae6e532c19771f32eeeb0037b2":["7c646ace64c35832d8e70eb297906f9b141eddbd"],"63caed6eb28209e181e97822c4c8fdf808884c3b":["498e63ab0d700e7d3172d8553248c14031b4c850"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["63caed6eb28209e181e97822c4c8fdf808884c3b"],"07087852d7b2a5c7e7d79b19c3e3ba775596b5d8":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"498e63ab0d700e7d3172d8553248c14031b4c850":["9ee159418514037b0fa456cf8b5d6c91e2bf5557"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["2edef7afebca00bf81a8bef95d44ea971ba309fa"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"7c646ace64c35832d8e70eb297906f9b141eddbd":["07087852d7b2a5c7e7d79b19c3e3ba775596b5d8"],"f00f0f8c602950d28e2cb62039b72f51f5d5c44c":["cc2469a10cffdebd38d207761a32c90c12316b52"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9d153abcf92dc5329d98571a8c3035df9bd80648","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"9ee159418514037b0fa456cf8b5d6c91e2bf5557":["fb5728b83dbb3e002cdd22adfe6caf103a96ef15"],"cc2469a10cffdebd38d207761a32c90c12316b52":["ee3df95012e016c229172f87a6c4077957246c4a"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["6a917aca07a305ab70118a83e84d931503441271"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}