{"path":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","commits":[{"id":"bc45495cddab770758da8a7fe79f01747b83c9ee","date":1392859277,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {\n    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {\n      @Override\n      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {\n        SortedSetDocValues sortedSet = FieldCache.DEFAULT.getDocTermOrds(context.reader(), field);\n        \n        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n          throw new UnsupportedOperationException(\"fields containing more than \" + (Integer.MAX_VALUE-1) + \" unique terms are unsupported\");\n        }\n        \n        if (sortedSet instanceof SingletonSortedSetDocValues) {\n          // it's actually single-valued in practice, but indexed as multi-valued,\n          // so just sort on the underlying single-valued dv directly.\n          // regardless of selector type, this optimization is safe!\n          return ((SingletonSortedSetDocValues) sortedSet).getSortedDocValues();\n        } else if (selector == Selector.MIN) {\n          return new MinValue(sortedSet);\n        } else {\n          if (sortedSet instanceof RandomAccessOrds == false) {\n            throw new UnsupportedOperationException(\"codec does not support random access ordinals, cannot use selector: \" + selector);\n          }\n          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;\n          switch(selector) {\n            case MAX: return new MaxValue(randomOrds);\n            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);\n            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);\n            case MIN: \n            default: \n              throw new AssertionError();\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e","date":1397206443,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","sourceNew":"  @Override\n  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {\n    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {\n      @Override\n      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {\n        SortedSetDocValues sortedSet = FieldCache.DEFAULT.getDocTermOrds(context.reader(), field);\n        \n        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n          throw new UnsupportedOperationException(\"fields containing more than \" + (Integer.MAX_VALUE-1) + \" unique terms are unsupported\");\n        }\n        \n        SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);\n        if (singleton != null) {\n          // it's actually single-valued in practice, but indexed as multi-valued,\n          // so just sort on the underlying single-valued dv directly.\n          // regardless of selector type, this optimization is safe!\n          return singleton;\n        } else if (selector == Selector.MIN) {\n          return new MinValue(sortedSet);\n        } else {\n          if (sortedSet instanceof RandomAccessOrds == false) {\n            throw new UnsupportedOperationException(\"codec does not support random access ordinals, cannot use selector: \" + selector);\n          }\n          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;\n          switch(selector) {\n            case MAX: return new MaxValue(randomOrds);\n            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);\n            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);\n            case MIN: \n            default: \n              throw new AssertionError();\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {\n    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {\n      @Override\n      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {\n        SortedSetDocValues sortedSet = FieldCache.DEFAULT.getDocTermOrds(context.reader(), field);\n        \n        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n          throw new UnsupportedOperationException(\"fields containing more than \" + (Integer.MAX_VALUE-1) + \" unique terms are unsupported\");\n        }\n        \n        if (sortedSet instanceof SingletonSortedSetDocValues) {\n          // it's actually single-valued in practice, but indexed as multi-valued,\n          // so just sort on the underlying single-valued dv directly.\n          // regardless of selector type, this optimization is safe!\n          return ((SingletonSortedSetDocValues) sortedSet).getSortedDocValues();\n        } else if (selector == Selector.MIN) {\n          return new MinValue(sortedSet);\n        } else {\n          if (sortedSet instanceof RandomAccessOrds == false) {\n            throw new UnsupportedOperationException(\"codec does not support random access ordinals, cannot use selector: \" + selector);\n          }\n          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;\n          switch(selector) {\n            case MAX: return new MaxValue(randomOrds);\n            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);\n            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);\n            case MIN: \n            default: \n              throw new AssertionError();\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":["bc45495cddab770758da8a7fe79f01747b83c9ee"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","sourceNew":"  @Override\n  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {\n    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {\n      @Override\n      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {\n        SortedSetDocValues sortedSet = DocValues.getSortedSet(context.reader(), field);\n        \n        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n          throw new UnsupportedOperationException(\"fields containing more than \" + (Integer.MAX_VALUE-1) + \" unique terms are unsupported\");\n        }\n        \n        SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);\n        if (singleton != null) {\n          // it's actually single-valued in practice, but indexed as multi-valued,\n          // so just sort on the underlying single-valued dv directly.\n          // regardless of selector type, this optimization is safe!\n          return singleton;\n        } else if (selector == Selector.MIN) {\n          return new MinValue(sortedSet);\n        } else {\n          if (sortedSet instanceof RandomAccessOrds == false) {\n            throw new UnsupportedOperationException(\"codec does not support random access ordinals, cannot use selector: \" + selector);\n          }\n          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;\n          switch(selector) {\n            case MAX: return new MaxValue(randomOrds);\n            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);\n            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);\n            case MIN: \n            default: \n              throw new AssertionError();\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {\n    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {\n      @Override\n      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {\n        SortedSetDocValues sortedSet = FieldCache.DEFAULT.getDocTermOrds(context.reader(), field);\n        \n        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n          throw new UnsupportedOperationException(\"fields containing more than \" + (Integer.MAX_VALUE-1) + \" unique terms are unsupported\");\n        }\n        \n        SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);\n        if (singleton != null) {\n          // it's actually single-valued in practice, but indexed as multi-valued,\n          // so just sort on the underlying single-valued dv directly.\n          // regardless of selector type, this optimization is safe!\n          return singleton;\n        } else if (selector == Selector.MIN) {\n          return new MinValue(sortedSet);\n        } else {\n          if (sortedSet instanceof RandomAccessOrds == false) {\n            throw new UnsupportedOperationException(\"codec does not support random access ordinals, cannot use selector: \" + selector);\n          }\n          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;\n          switch(selector) {\n            case MAX: return new MaxValue(randomOrds);\n            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);\n            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);\n            case MIN: \n            default: \n              throw new AssertionError();\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cb48b0969187aad3e0c6befa65e4421e1e1f667","date":1399982311,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","sourceNew":null,"sourceOld":"  @Override\n  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {\n    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {\n      @Override\n      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {\n        SortedSetDocValues sortedSet = DocValues.getSortedSet(context.reader(), field);\n        \n        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n          throw new UnsupportedOperationException(\"fields containing more than \" + (Integer.MAX_VALUE-1) + \" unique terms are unsupported\");\n        }\n        \n        SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);\n        if (singleton != null) {\n          // it's actually single-valued in practice, but indexed as multi-valued,\n          // so just sort on the underlying single-valued dv directly.\n          // regardless of selector type, this optimization is safe!\n          return singleton;\n        } else if (selector == Selector.MIN) {\n          return new MinValue(sortedSet);\n        } else {\n          if (sortedSet instanceof RandomAccessOrds == false) {\n            throw new UnsupportedOperationException(\"codec does not support random access ordinals, cannot use selector: \" + selector);\n          }\n          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;\n          switch(selector) {\n            case MAX: return new MaxValue(randomOrds);\n            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);\n            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);\n            case MIN: \n            default: \n              throw new AssertionError();\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","sourceNew":null,"sourceOld":"  @Override\n  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {\n    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {\n      @Override\n      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {\n        SortedSetDocValues sortedSet = FieldCache.DEFAULT.getDocTermOrds(context.reader(), field);\n        \n        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n          throw new UnsupportedOperationException(\"fields containing more than \" + (Integer.MAX_VALUE-1) + \" unique terms are unsupported\");\n        }\n        \n        SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);\n        if (singleton != null) {\n          // it's actually single-valued in practice, but indexed as multi-valued,\n          // so just sort on the underlying single-valued dv directly.\n          // regardless of selector type, this optimization is safe!\n          return singleton;\n        } else if (selector == Selector.MIN) {\n          return new MinValue(sortedSet);\n        } else {\n          if (sortedSet instanceof RandomAccessOrds == false) {\n            throw new UnsupportedOperationException(\"codec does not support random access ordinals, cannot use selector: \" + selector);\n          }\n          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;\n          switch(selector) {\n            case MAX: return new MaxValue(randomOrds);\n            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);\n            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);\n            case MIN: \n            default: \n              throw new AssertionError();\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField#getComparator(int,int).mjava","sourceNew":null,"sourceOld":"  @Override\n  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {\n    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {\n      @Override\n      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {\n        SortedSetDocValues sortedSet = FieldCache.DEFAULT.getDocTermOrds(context.reader(), field);\n        \n        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {\n          throw new UnsupportedOperationException(\"fields containing more than \" + (Integer.MAX_VALUE-1) + \" unique terms are unsupported\");\n        }\n        \n        SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);\n        if (singleton != null) {\n          // it's actually single-valued in practice, but indexed as multi-valued,\n          // so just sort on the underlying single-valued dv directly.\n          // regardless of selector type, this optimization is safe!\n          return singleton;\n        } else if (selector == Selector.MIN) {\n          return new MinValue(sortedSet);\n        } else {\n          if (sortedSet instanceof RandomAccessOrds == false) {\n            throw new UnsupportedOperationException(\"codec does not support random access ordinals, cannot use selector: \" + selector);\n          }\n          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;\n          switch(selector) {\n            case MAX: return new MaxValue(randomOrds);\n            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);\n            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);\n            case MIN: \n            default: \n              throw new AssertionError();\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"93dd449115a9247533e44bab47e8429e5dccbc6d":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e","4cb48b0969187aad3e0c6befa65e4421e1e1f667"],"bc45495cddab770758da8a7fe79f01747b83c9ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cb48b0969187aad3e0c6befa65e4421e1e1f667":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"56572ec06f1407c066d6b7399413178b33176cd8":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e","93dd449115a9247533e44bab47e8429e5dccbc6d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e":["bc45495cddab770758da8a7fe79f01747b83c9ee"]},"commit2Childs":{"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bc45495cddab770758da8a7fe79f01747b83c9ee":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc45495cddab770758da8a7fe79f01747b83c9ee"],"4cb48b0969187aad3e0c6befa65e4421e1e1f667":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["4cb48b0969187aad3e0c6befa65e4421e1e1f667"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e":["93dd449115a9247533e44bab47e8429e5dccbc6d","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}