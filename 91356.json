{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","commits":[{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"/dev/null","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      updateExecutor.submit(new Callable<Boolean>() {\n        \n        @Override\n        public Boolean call() {\n          return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n        }\n      });\n      \n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLive(zkStateReader, collection, coreNodeName, createUrl, 30);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f0e2371177a7e7481ec310b297af566ccfb3397d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0e2371177a7e7481ec310b297af566ccfb3397d","date":1419297372,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      updateExecutor.submit(new Callable<Boolean>() {\n        \n        @Override\n        public Boolean call() {\n          return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n        }\n      });\n      \n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLive(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      updateExecutor.submit(new Callable<Boolean>() {\n        \n        @Override\n        public Boolean call() {\n          return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n        }\n      });\n      \n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLive(zkStateReader, collection, coreNodeName, createUrl, 30);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"bugIntro":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3747a28ce6c262c1e27f7c7b30a827bc1a17260b","date":1428529761,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      updateExecutor.submit(new Callable<Boolean>() {\n        \n        @Override\n        public Boolean call() {\n          return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n        }\n      });\n      \n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      updateExecutor.submit(new Callable<Boolean>() {\n        \n        @Override\n        public Boolean call() {\n          return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n        }\n      });\n      \n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLive(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":["f0e2371177a7e7481ec310b297af566ccfb3397d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","date":1429031018,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(new Callable<Boolean>() {\n\n          @Override\n          public Boolean call() {\n            return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n          }\n        });\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      updateExecutor.submit(new Callable<Boolean>() {\n        \n        @Override\n        public Boolean call() {\n          return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n        }\n      });\n      \n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(new Callable<Boolean>() {\n\n          @Override\n          public Boolean call() {\n            return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n          }\n        });\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":["6ae3ad2b3d171060b5f8d2780f38b1dae608e02d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(new Callable<Boolean>() {\n\n          @Override\n          public Boolean call() {\n            return createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName);\n          }\n        });\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbed9f780536d62957bf82cf6c87b75c5b4cd30b","date":1462731618,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = (Integer) zkStateReader.getClusterProps().get(ZkStateReader.MAX_CORES_PER_NODE);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55a4fb564f94e7d0f0dfce705d51533be9f1c22e","date":1462769458,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = (Integer) zkStateReader.getClusterProps().get(ZkStateReader.MAX_CORES_PER_NODE);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = (Integer) zkStateReader.getClusterProps().get(ZkStateReader.MAX_CORES_PER_NODE);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"115923bc88e5b1dc4bef049b1ded8486723052ed","date":1463216796,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = (Integer) zkStateReader.getClusterProps().get(ZkStateReader.MAX_CORES_PER_NODE);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = (Integer) zkStateReader.getClusterProps().get(ZkStateReader.MAX_CORES_PER_NODE);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = (Integer) zkStateReader.getClusterProps().get(ZkStateReader.MAX_CORES_PER_NODE);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"579fab47a447cb68f742b3ea201e3398f84daaef","date":1489485666,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    final String shardId = badReplica.slice.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName, shardId));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ae3ad2b3d171060b5f8d2780f38b1dae608e02d","date":1489651910,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    final String shardId = badReplica.slice.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName, shardId));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":["043df2e9a841864922c32756a44c939ed768cb89"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    final String shardId = badReplica.slice.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName, shardId));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"717e5ceb2acae36d422ec75e5a4ce9fac40506e1","date":1501239603,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":null,"sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    final String shardId = badReplica.slice.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName, shardId));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":null,"sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    final String shardId = badReplica.slice.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName, shardId));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":4,"author":"Cao Manh Dat","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#addReplica(String,DownReplica).mjava","sourceNew":null,"sourceOld":"  private boolean addReplica(final String collection, DownReplica badReplica) {\n    // first find best home - first strategy, sort by number of cores\n    // hosted where maxCoresPerNode is not violated\n    final Integer maxCoreCount = zkStateReader.getClusterProperty(ZkStateReader.MAX_CORES_PER_NODE, (Integer) null);\n    final String createUrl = getBestCreateUrl(zkStateReader, badReplica, maxCoreCount);\n    if (createUrl == null) {\n      log.warn(\"Could not find a node to create new replica on.\");\n      return false;\n    }\n    \n    // NOTE: we send the absolute path, which will slightly change\n    // behavior of these cores as they won't respond to changes\n    // in the solr.hdfs.home sys prop as they would have.\n    final String dataDir = badReplica.replica.getStr(\"dataDir\");\n    final String ulogDir = badReplica.replica.getStr(\"ulogDir\");\n    final String coreNodeName = badReplica.replica.getName();\n    final String shardId = badReplica.slice.getName();\n    if (dataDir != null) {\n      // need an async request - full shard goes down leader election\n      final String coreName = badReplica.replica.getStr(ZkStateReader.CORE_NAME_PROP);\n      log.debug(\"submit call to {}\", createUrl);\n      MDC.put(\"OverseerAutoReplicaFailoverThread.createUrl\", createUrl);\n      try {\n        updateExecutor.submit(() -> createSolrCore(collection, createUrl, dataDir, ulogDir, coreNodeName, coreName, shardId));\n      } finally {\n        MDC.remove(\"OverseerAutoReplicaFailoverThread.createUrl\");\n      }\n\n      // wait to see state for core we just created\n      boolean success = ClusterStateUtil.waitToSeeLiveReplica(zkStateReader, collection, coreNodeName, createUrl, 30000);\n      if (!success) {\n        log.error(\"Creating new replica appears to have failed, timed out waiting to see created SolrCore register in the clusterstate.\");\n        return false;\n      }\n      return true;\n    }\n    \n    log.warn(\"Could not find dataDir or ulogDir in cluster state.\");\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"043df2e9a841864922c32756a44c939ed768cb89":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["579fab47a447cb68f742b3ea201e3398f84daaef","717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["ab68488225b6a6c357dda72ed11dedca9914a192"],"6ae3ad2b3d171060b5f8d2780f38b1dae608e02d":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"0ad30c6a479e764150a3316e57263319775f1df2":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e","115923bc88e5b1dc4bef049b1ded8486723052ed"],"3747a28ce6c262c1e27f7c7b30a827bc1a17260b":["f0e2371177a7e7481ec310b297af566ccfb3397d"],"fbed9f780536d62957bf82cf6c87b75c5b4cd30b":["b6284684320a9808c41a5e43de958b2da22f89bd"],"f0e2371177a7e7481ec310b297af566ccfb3397d":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b6284684320a9808c41a5e43de958b2da22f89bd","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e","0ad30c6a479e764150a3316e57263319775f1df2"],"579fab47a447cb68f742b3ea201e3398f84daaef":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"b6284684320a9808c41a5e43de958b2da22f89bd":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","043df2e9a841864922c32756a44c939ed768cb89"],"115923bc88e5b1dc4bef049b1ded8486723052ed":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55a4fb564f94e7d0f0dfce705d51533be9f1c22e":["b6284684320a9808c41a5e43de958b2da22f89bd","fbed9f780536d62957bf82cf6c87b75c5b4cd30b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e66a459d38c1c4a2f97128433dab546f683a9fed":["b6284684320a9808c41a5e43de958b2da22f89bd","55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"560c18d71dad43d675158783c3840f8c80d6d39c":["579fab47a447cb68f742b3ea201e3398f84daaef","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"ab68488225b6a6c357dda72ed11dedca9914a192":["d470c8182e92b264680e34081b75e70a9f2b3c89","6ae3ad2b3d171060b5f8d2780f38b1dae608e02d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["560c18d71dad43d675158783c3840f8c80d6d39c"]},"commit2Childs":{"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"6ae3ad2b3d171060b5f8d2780f38b1dae608e02d":["ab68488225b6a6c357dda72ed11dedca9914a192"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3747a28ce6c262c1e27f7c7b30a827bc1a17260b":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"fbed9f780536d62957bf82cf6c87b75c5b4cd30b":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"f0e2371177a7e7481ec310b297af566ccfb3397d":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["6ae3ad2b3d171060b5f8d2780f38b1dae608e02d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","579fab47a447cb68f742b3ea201e3398f84daaef","ab68488225b6a6c357dda72ed11dedca9914a192"],"579fab47a447cb68f742b3ea201e3398f84daaef":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c"],"b6284684320a9808c41a5e43de958b2da22f89bd":["fbed9f780536d62957bf82cf6c87b75c5b4cd30b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","55a4fb564f94e7d0f0dfce705d51533be9f1c22e","e66a459d38c1c4a2f97128433dab546f683a9fed"],"115923bc88e5b1dc4bef049b1ded8486723052ed":["0ad30c6a479e764150a3316e57263319775f1df2"],"55a4fb564f94e7d0f0dfce705d51533be9f1c22e":["0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89","115923bc88e5b1dc4bef049b1ded8486723052ed","e66a459d38c1c4a2f97128433dab546f683a9fed"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["f0e2371177a7e7481ec310b297af566ccfb3397d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"560c18d71dad43d675158783c3840f8c80d6d39c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ab68488225b6a6c357dda72ed11dedca9914a192":["717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e66a459d38c1c4a2f97128433dab546f683a9fed","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}