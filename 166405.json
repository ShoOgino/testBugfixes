{"path":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","commits":[{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.get(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.get(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.get(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.get(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":1,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.get(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.get(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.get(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.get(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.get(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.get(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.get(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.get(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.get(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.get(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (Exception e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (SolrServerException e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f67c95b2bc441f70e39a7dd6223e53b709f4e7c","date":1355781565,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    SolrParams q = params(\"q\",\"*:*\",\"fl\",\"id,_version_\",\"rows\",\"100000\");\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long docs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (Exception e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n\n      if (docs != cnt || cloudClientDocs != docs) {\n        String msg = \"document count mismatch.  control=\" + docs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n        log.error(msg);\n        showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (Exception e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","bugFix":null,"bugIntro":["29372a57b7e46d222a80429ad6b96413b7319eea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f6cdcb09b588b7338eeb23a1ab45ce9a1974188","date":1355781807,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    SolrParams q = params(\"q\",\"*:*\",\"fl\",\"id\",\"rows\",\"100000\");\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long docs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (Exception e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n\n      if (docs != cnt || cloudClientDocs != docs) {\n        String msg = \"document count mismatch.  control=\" + docs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n        log.error(msg);\n        showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n        fail(msg);\n      }\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    SolrParams q = params(\"q\",\"*:*\",\"fl\",\"id,_version_\",\"rows\",\"100000\");\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long docs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (Exception e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n\n      if (docs != cnt || cloudClientDocs != docs) {\n        String msg = \"document count mismatch.  control=\" + docs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n        log.error(msg);\n        showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042c474f8983c7bfede807d97ad9faf73ff694cc","date":1355859039,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      // re-execute the query getting ids\n      q = params(\"q\",\"*:*\",\"rows\",\"100000\", \"fl\",\"id\", \"tests\",\"checkShardConsistency(vsControl)/getIds\");    // add a tag to aid in debugging via logs\n      controlDocList = controlClient.query(q).getResults();\n      if (controlDocs != controlDocList.getNumFound()) {\n        log.error(\"Something changed! control now \" + controlDocList.getNumFound());\n      };\n\n      cloudDocList = cloudClient.query(q).getResults();\n      if (cloudClientDocs != cloudDocList.getNumFound()) {\n        log.error(\"Something changed! cloudClient now \" + cloudDocList.getNumFound());\n      };\n\n      Set<Map> differences = showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n\n      // get versions for the mismatched ids\n      StringBuilder ids = new StringBuilder(\"id:(\");\n      for (Map doc : differences) {\n        ids.append(\" \"+doc.get(\"id\"));\n      }\n      ids.append(\")\");\n\n      // get versions for those ids that don't match\n      q = params(\"q\",ids.toString(),\"rows\",\"100000\", \"fl\",\"id,_version_\", \"sort\",\"id asc\",\n                 \"tests\",\"checkShardConsistency(vsControl)/getVers\");    // add a tag to aid in debugging via logs\n\n      SolrDocumentList a = controlClient.query(q).getResults();\n      SolrDocumentList b = cloudClient.query(q).getResults();\n\n      log.error(\"controlClient :\" + a + \"\\n\\tcloudClient :\" + b);\n\n      fail(msg);\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    SolrParams q = params(\"q\",\"*:*\",\"fl\",\"id\",\"rows\",\"100000\");\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long docs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (Exception e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n\n      if (docs != cnt || cloudClientDocs != docs) {\n        String msg = \"document count mismatch.  control=\" + docs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n        log.error(msg);\n        showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n        fail(msg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["29372a57b7e46d222a80429ad6b96413b7319eea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"081ca3f126420cdea0d63c70f424cfba6cc97742","date":1357087643,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      // re-execute the query getting ids\n      q = params(\"q\",\"*:*\",\"rows\",\"100000\", \"fl\",\"id\", \"tests\",\"checkShardConsistency(vsControl)/getIds\");    // add a tag to aid in debugging via logs\n      controlDocList = controlClient.query(q).getResults();\n      if (controlDocs != controlDocList.getNumFound()) {\n        log.error(\"Something changed! control now \" + controlDocList.getNumFound());\n      };\n\n      cloudDocList = cloudClient.query(q).getResults();\n      if (cloudClientDocs != cloudDocList.getNumFound()) {\n        log.error(\"Something changed! cloudClient now \" + cloudDocList.getNumFound());\n      };\n\n      Set<Map> differences = showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n\n      // get versions for the mismatched ids\n      StringBuilder ids = new StringBuilder(\"id:(\");\n      for (Map doc : differences) {\n        ids.append(\" \"+doc.get(\"id\"));\n      }\n      ids.append(\")\");\n      \n      if (ids.length() > 0) {\n        // get versions for those ids that don't match\n        q = params(\"q\", ids.toString(), \"rows\", \"100000\", \"fl\", \"id,_version_\",\n            \"sort\", \"id asc\", \"tests\",\n            \"checkShardConsistency(vsControl)/getVers\"); // add a tag to aid in\n                                                         // debugging via logs\n        \n        SolrDocumentList a = controlClient.query(q).getResults();\n        SolrDocumentList b = cloudClient.query(q).getResults();\n        \n        log.error(\"controlClient :\" + a + \"\\n\\tcloudClient :\" + b);\n      }\n\n      fail(msg);\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      // re-execute the query getting ids\n      q = params(\"q\",\"*:*\",\"rows\",\"100000\", \"fl\",\"id\", \"tests\",\"checkShardConsistency(vsControl)/getIds\");    // add a tag to aid in debugging via logs\n      controlDocList = controlClient.query(q).getResults();\n      if (controlDocs != controlDocList.getNumFound()) {\n        log.error(\"Something changed! control now \" + controlDocList.getNumFound());\n      };\n\n      cloudDocList = cloudClient.query(q).getResults();\n      if (cloudClientDocs != cloudDocList.getNumFound()) {\n        log.error(\"Something changed! cloudClient now \" + cloudDocList.getNumFound());\n      };\n\n      Set<Map> differences = showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n\n      // get versions for the mismatched ids\n      StringBuilder ids = new StringBuilder(\"id:(\");\n      for (Map doc : differences) {\n        ids.append(\" \"+doc.get(\"id\"));\n      }\n      ids.append(\")\");\n\n      // get versions for those ids that don't match\n      q = params(\"q\",ids.toString(),\"rows\",\"100000\", \"fl\",\"id,_version_\", \"sort\",\"id asc\",\n                 \"tests\",\"checkShardConsistency(vsControl)/getVers\");    // add a tag to aid in debugging via logs\n\n      SolrDocumentList a = controlClient.query(q).getResults();\n      SolrDocumentList b = cloudClient.query(q).getResults();\n\n      log.error(\"controlClient :\" + a + \"\\n\\tcloudClient :\" + b);\n\n      fail(msg);\n    }\n  }\n\n","bugFix":null,"bugIntro":["29372a57b7e46d222a80429ad6b96413b7319eea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"88ee200d5f80eccbe1b5bd07826c4c5b00f7e787","date":1357089548,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      // re-execute the query getting ids\n      q = params(\"q\",\"*:*\",\"rows\",\"100000\", \"fl\",\"id\", \"tests\",\"checkShardConsistency(vsControl)/getIds\");    // add a tag to aid in debugging via logs\n      controlDocList = controlClient.query(q).getResults();\n      if (controlDocs != controlDocList.getNumFound()) {\n        log.error(\"Something changed! control now \" + controlDocList.getNumFound());\n      };\n\n      cloudDocList = cloudClient.query(q).getResults();\n      if (cloudClientDocs != cloudDocList.getNumFound()) {\n        log.error(\"Something changed! cloudClient now \" + cloudDocList.getNumFound());\n      };\n\n      Set<Map> differences = showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n\n      // get versions for the mismatched ids\n      boolean foundId = false;\n      StringBuilder ids = new StringBuilder(\"id:(\");\n      for (Map doc : differences) {\n        ids.append(\" \"+doc.get(\"id\"));\n        foundId = true;\n      }\n      ids.append(\")\");\n      \n      if (foundId) {\n        // get versions for those ids that don't match\n        q = params(\"q\", ids.toString(), \"rows\", \"100000\", \"fl\", \"id,_version_\",\n            \"sort\", \"id asc\", \"tests\",\n            \"checkShardConsistency(vsControl)/getVers\"); // add a tag to aid in\n                                                         // debugging via logs\n        \n        SolrDocumentList a = controlClient.query(q).getResults();\n        SolrDocumentList b = cloudClient.query(q).getResults();\n        \n        log.error(\"controlClient :\" + a + \"\\n\\tcloudClient :\" + b);\n      }\n\n      fail(msg);\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      // re-execute the query getting ids\n      q = params(\"q\",\"*:*\",\"rows\",\"100000\", \"fl\",\"id\", \"tests\",\"checkShardConsistency(vsControl)/getIds\");    // add a tag to aid in debugging via logs\n      controlDocList = controlClient.query(q).getResults();\n      if (controlDocs != controlDocList.getNumFound()) {\n        log.error(\"Something changed! control now \" + controlDocList.getNumFound());\n      };\n\n      cloudDocList = cloudClient.query(q).getResults();\n      if (cloudClientDocs != cloudDocList.getNumFound()) {\n        log.error(\"Something changed! cloudClient now \" + cloudDocList.getNumFound());\n      };\n\n      Set<Map> differences = showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n\n      // get versions for the mismatched ids\n      StringBuilder ids = new StringBuilder(\"id:(\");\n      for (Map doc : differences) {\n        ids.append(\" \"+doc.get(\"id\"));\n      }\n      ids.append(\")\");\n      \n      if (ids.length() > 0) {\n        // get versions for those ids that don't match\n        q = params(\"q\", ids.toString(), \"rows\", \"100000\", \"fl\", \"id,_version_\",\n            \"sort\", \"id asc\", \"tests\",\n            \"checkShardConsistency(vsControl)/getVers\"); // add a tag to aid in\n                                                         // debugging via logs\n        \n        SolrDocumentList a = controlClient.query(q).getResults();\n        SolrDocumentList b = cloudClient.query(q).getResults();\n        \n        log.error(\"controlClient :\" + a + \"\\n\\tcloudClient :\" + b);\n      }\n\n      fail(msg);\n    }\n  }\n\n","bugFix":null,"bugIntro":["29372a57b7e46d222a80429ad6b96413b7319eea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      // re-execute the query getting ids\n      q = params(\"q\",\"*:*\",\"rows\",\"100000\", \"fl\",\"id\", \"tests\",\"checkShardConsistency(vsControl)/getIds\");    // add a tag to aid in debugging via logs\n      controlDocList = controlClient.query(q).getResults();\n      if (controlDocs != controlDocList.getNumFound()) {\n        log.error(\"Something changed! control now \" + controlDocList.getNumFound());\n      };\n\n      cloudDocList = cloudClient.query(q).getResults();\n      if (cloudClientDocs != cloudDocList.getNumFound()) {\n        log.error(\"Something changed! cloudClient now \" + cloudDocList.getNumFound());\n      };\n\n      Set<Map> differences = showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n\n      // get versions for the mismatched ids\n      boolean foundId = false;\n      StringBuilder ids = new StringBuilder(\"id:(\");\n      for (Map doc : differences) {\n        ids.append(\" \"+doc.get(\"id\"));\n        foundId = true;\n      }\n      ids.append(\")\");\n      \n      if (foundId) {\n        // get versions for those ids that don't match\n        q = params(\"q\", ids.toString(), \"rows\", \"100000\", \"fl\", \"id,_version_\",\n            \"sort\", \"id asc\", \"tests\",\n            \"checkShardConsistency(vsControl)/getVers\"); // add a tag to aid in\n                                                         // debugging via logs\n        \n        SolrDocumentList a = controlClient.query(q).getResults();\n        SolrDocumentList b = cloudClient.query(q).getResults();\n        \n        log.error(\"controlClient :\" + a + \"\\n\\tcloudClient :\" + b);\n      }\n\n      fail(msg);\n    }\n  }\n\n","sourceOld":"  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    long docs = controlClient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    if (verbose) System.err.println(\"Control Docs:\" + docs);\n    \n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n    \n    if (checkVsControl) {\n      // now check that the right # are on each shard\n      theShards = shardToJetty.keySet();\n      int cnt = 0;\n      for (String s : theShards) {\n        int times = shardToJetty.get(s).size();\n        for (int i = 0; i < times; i++) {\n          try {\n            CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n            ZkNodeProps props = cjetty.info;\n            SolrServer client = cjetty.client.solrClient;\n            boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n                ZkStateReader.ACTIVE);\n            if (active) {\n              SolrQuery query = new SolrQuery(\"*:*\");\n              query.set(\"distrib\", false);\n              long results = client.query(query).getResults().getNumFound();\n              if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                  .getCoreUrl() + \" : \" + results);\n              if (verbose) System.err.println(\"shard:\"\n                  + props.getStr(ZkStateReader.SHARD_ID_PROP));\n              cnt += results;\n              break;\n            }\n          } catch (Exception e) {\n            // if we have a problem, try the next one\n            if (i == times - 1) {\n              throw e;\n            }\n          }\n        }\n      }\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      long cloudClientDocs = cloudClient.query(q).getResults().getNumFound();\n      assertEquals(\n          \"adding up the # of docs on each shard does not match the control - cloud client returns:\"\n              + cloudClientDocs, docs, cnt);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29372a57b7e46d222a80429ad6b96413b7319eea","date":1390584196,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      compareResults(controlDocs, cloudClientDocs);\n\n      fail(msg);\n    }\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      // re-execute the query getting ids\n      q = params(\"q\",\"*:*\",\"rows\",\"100000\", \"fl\",\"id\", \"tests\",\"checkShardConsistency(vsControl)/getIds\");    // add a tag to aid in debugging via logs\n      controlDocList = controlClient.query(q).getResults();\n      if (controlDocs != controlDocList.getNumFound()) {\n        log.error(\"Something changed! control now \" + controlDocList.getNumFound());\n      };\n\n      cloudDocList = cloudClient.query(q).getResults();\n      if (cloudClientDocs != cloudDocList.getNumFound()) {\n        log.error(\"Something changed! cloudClient now \" + cloudDocList.getNumFound());\n      };\n\n      Set<Map> differences = showDiff(controlDocList, cloudDocList,\"controlDocList\",\"cloudDocList\");\n\n      // get versions for the mismatched ids\n      boolean foundId = false;\n      StringBuilder ids = new StringBuilder(\"id:(\");\n      for (Map doc : differences) {\n        ids.append(\" \"+doc.get(\"id\"));\n        foundId = true;\n      }\n      ids.append(\")\");\n      \n      if (foundId) {\n        // get versions for those ids that don't match\n        q = params(\"q\", ids.toString(), \"rows\", \"100000\", \"fl\", \"id,_version_\",\n            \"sort\", \"id asc\", \"tests\",\n            \"checkShardConsistency(vsControl)/getVers\"); // add a tag to aid in\n                                                         // debugging via logs\n        \n        SolrDocumentList a = controlClient.query(q).getResults();\n        SolrDocumentList b = cloudClient.query(q).getResults();\n        \n        log.error(\"controlClient :\" + a + \"\\n\\tcloudClient :\" + b);\n      }\n\n      fail(msg);\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","7f67c95b2bc441f70e39a7dd6223e53b709f4e7c","88ee200d5f80eccbe1b5bd07826c4c5b00f7e787","042c474f8983c7bfede807d97ad9faf73ff694cc","081ca3f126420cdea0d63c70f424cfba6cc97742"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02c6a0e240c698414e7728a55f07361be84852d8","date":1392675457,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkShardConsistency(boolean,boolean).mjava","sourceNew":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n    checkShardConsistency(checkVsControl, verbose, null, null);\n  }\n\n","sourceOld":"  /* Checks shard consistency and optionally checks against the control shard.\n   * The test will be failed if differences are found.\n   */\n  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)\n      throws Exception {\n\n    updateMappingsFromZk(jettys, clients, true);\n    \n    Set<String> theShards = shardToJetty.keySet();\n    String failMessage = null;\n    for (String shard : theShards) {\n      String shardFailMessage = checkShardConsistency(shard, false, verbose);\n      if (shardFailMessage != null && failMessage == null) {\n        failMessage = shardFailMessage;\n      }\n    }\n    \n    if (failMessage != null) {\n      fail(failMessage);\n    }\n\n    if (!checkVsControl) return;\n\n    SolrParams q = params(\"q\",\"*:*\",\"rows\",\"0\", \"tests\",\"checkShardConsistency(vsControl)\");    // add a tag to aid in debugging via logs\n\n    SolrDocumentList controlDocList = controlClient.query(q).getResults();\n    long controlDocs = controlDocList.getNumFound();\n\n    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();\n    long cloudClientDocs = cloudDocList.getNumFound();\n\n\n\n\n    // now check that the right # are on each shard\n    theShards = shardToJetty.keySet();\n    int cnt = 0;\n    for (String s : theShards) {\n      int times = shardToJetty.get(s).size();\n      for (int i = 0; i < times; i++) {\n        try {\n          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);\n          ZkNodeProps props = cjetty.info;\n          SolrServer client = cjetty.client.solrClient;\n          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(\n              ZkStateReader.ACTIVE);\n          if (active) {\n            SolrQuery query = new SolrQuery(\"*:*\");\n            query.set(\"distrib\", false);\n            long results = client.query(query).getResults().getNumFound();\n            if (verbose) System.err.println(new ZkCoreNodeProps(props)\n                .getCoreUrl() + \" : \" + results);\n            if (verbose) System.err.println(\"shard:\"\n                + props.getStr(ZkStateReader.SHARD_ID_PROP));\n            cnt += results;\n            break;\n          }\n        } catch (Exception e) {\n          // if we have a problem, try the next one\n          if (i == times - 1) {\n            throw e;\n          }\n        }\n      }\n    }\n\n\n    if (controlDocs != cnt || cloudClientDocs != controlDocs) {\n      String msg = \"document count mismatch.  control=\" + controlDocs + \" sum(shards)=\"+ cnt + \" cloudClient=\"+cloudClientDocs;\n      log.error(msg);\n\n      compareResults(controlDocs, cloudClientDocs);\n\n      fail(msg);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a6378064655e76cd7b908b1cab4ce425b384b508","88ee200d5f80eccbe1b5bd07826c4c5b00f7e787"],"0f6cdcb09b588b7338eeb23a1ab45ce9a1974188":["7f67c95b2bc441f70e39a7dd6223e53b709f4e7c"],"fa64435b5902ce266c23755a4a00691a3285dab8":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"02c6a0e240c698414e7728a55f07361be84852d8":["29372a57b7e46d222a80429ad6b96413b7319eea"],"081ca3f126420cdea0d63c70f424cfba6cc97742":["042c474f8983c7bfede807d97ad9faf73ff694cc"],"29372a57b7e46d222a80429ad6b96413b7319eea":["88ee200d5f80eccbe1b5bd07826c4c5b00f7e787"],"a6378064655e76cd7b908b1cab4ce425b384b508":["fa64435b5902ce266c23755a4a00691a3285dab8"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"88ee200d5f80eccbe1b5bd07826c4c5b00f7e787":["081ca3f126420cdea0d63c70f424cfba6cc97742"],"042c474f8983c7bfede807d97ad9faf73ff694cc":["0f6cdcb09b588b7338eeb23a1ab45ce9a1974188"],"7f67c95b2bc441f70e39a7dd6223e53b709f4e7c":["a6378064655e76cd7b908b1cab4ce425b384b508"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["02c6a0e240c698414e7728a55f07361be84852d8"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"0f6cdcb09b588b7338eeb23a1ab45ce9a1974188":["042c474f8983c7bfede807d97ad9faf73ff694cc"],"fa64435b5902ce266c23755a4a00691a3285dab8":["a6378064655e76cd7b908b1cab4ce425b384b508"],"02c6a0e240c698414e7728a55f07361be84852d8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"081ca3f126420cdea0d63c70f424cfba6cc97742":["88ee200d5f80eccbe1b5bd07826c4c5b00f7e787"],"29372a57b7e46d222a80429ad6b96413b7319eea":["02c6a0e240c698414e7728a55f07361be84852d8"],"a6378064655e76cd7b908b1cab4ce425b384b508":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7f67c95b2bc441f70e39a7dd6223e53b709f4e7c"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","2c30e4c1cee08b3b229a77991882594fe7250b66"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"88ee200d5f80eccbe1b5bd07826c4c5b00f7e787":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","29372a57b7e46d222a80429ad6b96413b7319eea"],"042c474f8983c7bfede807d97ad9faf73ff694cc":["081ca3f126420cdea0d63c70f424cfba6cc97742"],"7f67c95b2bc441f70e39a7dd6223e53b709f4e7c":["0f6cdcb09b588b7338eeb23a1ab45ce9a1974188"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["fa64435b5902ce266c23755a4a00691a3285dab8","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}