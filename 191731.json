{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","commits":[{"id":"51b92ffe30c50bb08699200b62c40420378ac3df","date":1423881454,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  private void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = getCommonCloudSolrClient()\n        .getZkStateReader().getClusterState().getLiveNodes().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    Map<String, Object> props = makeMap(\n        REPLICATION_FACTOR, liveNodes,\n        MAX_SHARDS_PER_NODE, liveNodes,\n        NUM_SLICES, liveNodes);\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, collectionName, props, controlClientCloud);\n    waitForRecoveriesToFinish(collectionName, false);\n\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n    assertNotNull(cloudClient);\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    waitForThingsToLevelOut(30);\n\n    // Remove any documents from previous test (if any)\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n\n    // Add some new documents\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    SolrInputDocument doc3 = new SolrInputDocument();\n    doc3.addField(id, \"3\");\n    doc3.addField(\"a_t\", \"hello2\");\n\n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.add(doc3);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cloudClient, true, collectionName);\n\n    // Cleanup\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b940572a59da1b42b6c20ab5278155b12816807a","date":1462388874,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(cluster.getSolrClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cluster.getSolrClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  private void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = getCommonCloudSolrClient()\n        .getZkStateReader().getClusterState().getLiveNodes().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    Map<String, Object> props = makeMap(\n        REPLICATION_FACTOR, liveNodes,\n        MAX_SHARDS_PER_NODE, liveNodes,\n        NUM_SLICES, liveNodes);\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, collectionName, props, controlClientCloud);\n    waitForRecoveriesToFinish(collectionName, false);\n\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n    assertNotNull(cloudClient);\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    waitForThingsToLevelOut(30);\n\n    // Remove any documents from previous test (if any)\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n\n    // Add some new documents\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    SolrInputDocument doc3 = new SolrInputDocument();\n    doc3.addField(id, \"3\");\n    doc3.addField(\"a_t\", \"hello2\");\n\n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.add(doc3);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cloudClient, true, collectionName);\n\n    // Cleanup\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd78ba595fa6cdd7fff930f26d154d13a823fa47","date":1462400514,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(cluster.getSolrClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cluster.getSolrClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  private void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = getCommonCloudSolrClient()\n        .getZkStateReader().getClusterState().getLiveNodes().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    Map<String, Object> props = makeMap(\n        REPLICATION_FACTOR, liveNodes,\n        MAX_SHARDS_PER_NODE, liveNodes,\n        NUM_SLICES, liveNodes);\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, collectionName, props, controlClientCloud);\n    waitForRecoveriesToFinish(collectionName, false);\n\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n    assertNotNull(cloudClient);\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    waitForThingsToLevelOut(30);\n\n    // Remove any documents from previous test (if any)\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n\n    // Add some new documents\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    SolrInputDocument doc3 = new SolrInputDocument();\n    doc3.addField(id, \"3\");\n    doc3.addField(\"a_t\", \"hello2\");\n\n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.add(doc3);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cloudClient, true, collectionName);\n\n    // Cleanup\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(cluster.getSolrClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cluster.getSolrClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  private void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = getCommonCloudSolrClient()\n        .getZkStateReader().getClusterState().getLiveNodes().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    Map<String, Object> props = makeMap(\n        REPLICATION_FACTOR, liveNodes,\n        MAX_SHARDS_PER_NODE, liveNodes,\n        NUM_SLICES, liveNodes);\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, collectionName, props, controlClientCloud);\n    waitForRecoveriesToFinish(collectionName, false);\n\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n    assertNotNull(cloudClient);\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    waitForThingsToLevelOut(30);\n\n    // Remove any documents from previous test (if any)\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n\n    // Add some new documents\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    SolrInputDocument doc3 = new SolrInputDocument();\n    doc3.addField(id, \"3\");\n    doc3.addField(\"a_t\", \"hello2\");\n\n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.add(doc3);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cloudClient, true, collectionName);\n\n    // Cleanup\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(cluster.getSolrClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cluster.getSolrClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  private void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = getCommonCloudSolrClient()\n        .getZkStateReader().getClusterState().getLiveNodes().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    Map<String, Object> props = makeMap(\n        REPLICATION_FACTOR, liveNodes,\n        MAX_SHARDS_PER_NODE, liveNodes,\n        NUM_SLICES, liveNodes);\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    createCollection(collectionInfos, collectionName, props, controlClientCloud);\n    waitForRecoveriesToFinish(collectionName, false);\n\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n    assertNotNull(cloudClient);\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    waitForThingsToLevelOut(30);\n\n    // Remove any documents from previous test (if any)\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n\n    // Add some new documents\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    SolrInputDocument doc3 = new SolrInputDocument();\n    doc3.addField(id, \"3\");\n    doc3.addField(\"a_t\", \"hello2\");\n\n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.add(doc3);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cloudClient, true, collectionName);\n\n    // Cleanup\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a64b273d51a6540272668680ece9f8b686ff0004","date":1492404078,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(getRandomClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(cluster.getSolrClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cluster.getSolrClient(), true, collectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(getRandomClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(cluster.getSolrClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(cluster.getSolrClient(), true, collectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2576170b353998ba9157b6d148ebfde21138316","date":1523488980,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(getRandomClient(), true, collectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f5a9deac6e313e80a1f56468e14bb4c491b83d7","date":1523529596,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithPreferLocalShards(getRandomClient(), true, collectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108","date":1533256859,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes * liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    cluster.waitForActiveCollection(collectionName, liveNodes, liveNodes * liveNodes);\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, cluster.getSolrClient().getZkStateReader(), false, true, TIMEOUT);\n\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","bugFix":["51b92ffe30c50bb08699200b62c40420378ac3df","b940572a59da1b42b6c20ab5278155b12816807a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#preferLocalShardsTest().mjava","sourceNew":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    cluster.waitForActiveCollection(collectionName, liveNodes, liveNodes * liveNodes);\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","sourceOld":"  /**\n   * Tests if the specification of 'preferLocalShards' in the query-params\n   * limits the distributed query to locally hosted shards only\n   */\n  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void preferLocalShardsTest() throws Exception {\n\n    String collectionName = \"localShardsTestColl\";\n\n    int liveNodes = cluster.getJettySolrRunners().size();\n\n    // For preferLocalShards to succeed in a test, every shard should have\n    // all its cores on the same node.\n    // Hence the below configuration for our collection\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", liveNodes, liveNodes)\n        .setMaxShardsPerNode(liveNodes * liveNodes)\n        .processAndWait(cluster.getSolrClient(), TIMEOUT);\n    cluster.waitForActiveCollection(collectionName, liveNodes, liveNodes * liveNodes);\n    // Add some new documents\n    new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .add(id, \"3\", \"a_t\", \"hello2\")\n        .commit(getRandomClient(), collectionName);\n\n    // Run the actual test for 'preferLocalShards'\n    queryWithShardsPreferenceRules(getRandomClient(), false, collectionName);\n    queryWithShardsPreferenceRules(getRandomClient(), true, collectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["73450c0955930295d34703e7ddbfc6973b7a121a"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["1f5a9deac6e313e80a1f56468e14bb4c491b83d7"],"51b92ffe30c50bb08699200b62c40420378ac3df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"a64b273d51a6540272668680ece9f8b686ff0004":["73450c0955930295d34703e7ddbfc6973b7a121a"],"73450c0955930295d34703e7ddbfc6973b7a121a":["51b92ffe30c50bb08699200b62c40420378ac3df","b940572a59da1b42b6c20ab5278155b12816807a"],"b940572a59da1b42b6c20ab5278155b12816807a":["51b92ffe30c50bb08699200b62c40420378ac3df"],"a2576170b353998ba9157b6d148ebfde21138316":["a64b273d51a6540272668680ece9f8b686ff0004"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bd78ba595fa6cdd7fff930f26d154d13a823fa47":["51b92ffe30c50bb08699200b62c40420378ac3df","b940572a59da1b42b6c20ab5278155b12816807a"],"1f5a9deac6e313e80a1f56468e14bb4c491b83d7":["a64b273d51a6540272668680ece9f8b686ff0004","a2576170b353998ba9157b6d148ebfde21138316"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["51b92ffe30c50bb08699200b62c40420378ac3df","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"51b92ffe30c50bb08699200b62c40420378ac3df":["73450c0955930295d34703e7ddbfc6973b7a121a","b940572a59da1b42b6c20ab5278155b12816807a","bd78ba595fa6cdd7fff930f26d154d13a823fa47","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"73450c0955930295d34703e7ddbfc6973b7a121a":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","a64b273d51a6540272668680ece9f8b686ff0004","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a64b273d51a6540272668680ece9f8b686ff0004":["a2576170b353998ba9157b6d148ebfde21138316","1f5a9deac6e313e80a1f56468e14bb4c491b83d7"],"b940572a59da1b42b6c20ab5278155b12816807a":["73450c0955930295d34703e7ddbfc6973b7a121a","bd78ba595fa6cdd7fff930f26d154d13a823fa47"],"a2576170b353998ba9157b6d148ebfde21138316":["1f5a9deac6e313e80a1f56468e14bb4c491b83d7"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd78ba595fa6cdd7fff930f26d154d13a823fa47":[],"1f5a9deac6e313e80a1f56468e14bb4c491b83d7":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["51b92ffe30c50bb08699200b62c40420378ac3df"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","bd78ba595fa6cdd7fff930f26d154d13a823fa47","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}