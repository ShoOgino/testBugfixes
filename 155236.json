{"path":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61f30939a6ca0891c7b0c0f34aa43800bd4c9a15","date":1322511317,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    InvertedFields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    InvertedFields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":["e03427f33820a2bde791de703292dcdfe2d6bdd6","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final AtomicReader indexReader = rb.req.getSearcher().getAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8028ab7a24273833d53d35eb160dba5b57283cf5","date":1416767720,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":["fba2d2f1d5c0627026d5c26df8daac1ee3a4a0bd","e03427f33820a2bde791de703292dcdfe2d6bdd6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator(null);\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e7761210febbbf9eb64d86512126e718181aec9","date":1467828397,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b92f86e90a95b8fc860ddecd9470ffb89a9fa7d","date":1467828398,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"stats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6d4ff6bc316c2cad4d245958a058040d9add305","date":1467828398,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"stats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6457c5bbf93b640fc949540903318e320e52beb","date":1467828398,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e07c409cff8701e4dc3d45934b021a949a5a8822","date":1475694629,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getLeafReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"194ca6939cf04fa69e4bbcaf0fed482ae1f5fa53","date":1490757519,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4302dfeb5d01c940f69c48bec27f03ad8828668","date":1490873946,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if(termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb88a28fb92adce0607c5b28f8f1cce9e3171639","date":1492689807,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60481acc5083329d2ffbf27397331a25baad88de","date":1492691547,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if(termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","date":1497408244,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n    Fields lfields = indexReader.fields();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a92ffe0d2961113e5588e614f8dc22b42bf10a95","date":1503304229,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          if (lowerStr!=null || upperStr!=null || prefix!=null || regexp!=null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = (sort ? new BoundedTreeSet<>(limit) : null);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(item.key.toString(), item.val);\n            }\n            termsResult.add(field, fieldTerms);\n            continue;\n          }\n\n          if (!sort) {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(mv.toString(), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(mv.toString(), (int)count); // match the numeric type of terms\n            }\n\n            termsResult.add(field, fieldTerms);\n            continue;\n          }\n        }\n\n        termsResult.add(field, fieldTerms);  // add empty\n        continue;\n      }\n      termsResult.add(field, fieldTerms);\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n    \n    for (String field : fields) {\n      FieldType fieldType = rb.req.getSchema().getFieldTypeNoEx(field);\n      if (null != fieldType) {\n        if (fieldType.isPointField()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"The terms component does not support Points-based field \" + field);\n        }\n      }\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee8ab3e5e7c88ac47842e73e81cf68d90dd1dca6","date":1501534988,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n    \n    for (String field : fields) {\n      FieldType fieldType = rb.req.getSchema().getFieldTypeNoEx(field);\n      if (null != fieldType) {\n        if (fieldType.isPointField()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"The terms component does not support Points-based field \" + field);\n        }\n      }\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n    \n    for (String field : fields) {\n      FieldType fieldType = rb.req.getSchema().getFieldTypeNoEx(field);\n      if (null != fieldType) {\n        if (fieldType.isPointField()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"The terms component does not support Points-based field \" + field);\n        }\n      }\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f7ebafe1543d3847a1cb09988cb6c46d48741f8","date":1503180131,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          if (lowerStr!=null || upperStr!=null || prefix!=null || regexp!=null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = (sort ? new BoundedTreeSet<>(limit) : null);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(item.key.toString(), item.val);\n            }\n            termsResult.add(field, fieldTerms);\n            continue;\n          }\n\n          if (!sort) {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(mv.toString(), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(mv.toString(), (int)count); // match the numeric type of terms\n            }\n\n            termsResult.add(field, fieldTerms);\n            continue;\n          }\n        }\n\n        termsResult.add(field, fieldTerms);  // add empty\n        continue;\n      }\n      termsResult.add(field, fieldTerms);\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n    \n    for (String field : fields) {\n      FieldType fieldType = rb.req.getSchema().getFieldTypeNoEx(field);\n      if (null != fieldType) {\n        if (fieldType.isPointField()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"The terms component does not support Points-based field \" + field);\n        }\n      }\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d","bb65c51348af9263e432c5a93cd98be0ca68ec3a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3051d6122751c8f6cc1e9cf24592658b59843ec2","date":1503298024,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          if (lowerStr!=null || upperStr!=null || prefix!=null || regexp!=null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = (sort ? new BoundedTreeSet<>(limit) : null);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(item.key.toString(), item.val);\n            }\n            termsResult.add(field, fieldTerms);\n            continue;\n          }\n\n          if (!sort) {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(mv.toString(), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(mv.toString(), (int)count); // match the numeric type of terms\n            }\n\n            termsResult.add(field, fieldTerms);\n            continue;\n          }\n        }\n\n        termsResult.add(field, fieldTerms);  // add empty\n        continue;\n      }\n      termsResult.add(field, fieldTerms);\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n    \n    for (String field : fields) {\n      FieldType fieldType = rb.req.getSchema().getFieldTypeNoEx(field);\n      if (null != fieldType) {\n        if (fieldType.isPointField()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"The terms component does not support Points-based field \" + field);\n        }\n      }\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a45ddee14ecadf18bc50fff428911687afb4745d","date":1560519742,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(TermsParams.TERMS, termsResult);\n\n    if (fields == null || fields.length == 0) {\n      return;\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n    if (termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Object> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          // FIXME: terms.ttf=true is not supported for pointFields\n          if (lowerStr!=null || upperStr!=null || prefix!=null || regexp!=null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = new BoundedTreeSet<>(limit);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(item.key.toString(), item.val);\n            }\n            continue;\n          } else {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(mv.toString(), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(mv.toString(), (int)count); // match the numeric type of terms\n            }\n            continue;\n          }\n        }\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft == null) {\n        ft = new StrField();\n      }\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix == null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n      TermsEnum termsEnum = terms.iterator();\n      BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<TermsResponse.Term> queue = (sort? new BoundedTreeSet<>(limit, new TermCountComparator()): null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i < limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // TODO: handle raw somehow\n          if (!externalized) {\n            ft.indexedToReadable(term, external);\n          }\n          // add the term to the list\n          if (sort) {\n            queue.add(new TermsResponse.Term(external.toString(), docFreq, termsEnum.totalTermFreq()));\n          } else {\n            addTermToNamedList(fieldTerms, external.toString(),\n                docFreq, termsEnum.totalTermFreq(), includeTotalTermFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (TermsResponse.Term item : queue) {\n          if (i >= limit) {\n            break;\n          }\n          addTermToNamedList(fieldTerms, item.getTerm(), item.getFrequency(),\n              item.getTotalTermFreq(), includeTotalTermFreq);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    if (termList != null) {\n      boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<>();\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          if (lowerStr!=null || upperStr!=null || prefix!=null || regexp!=null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = (sort ? new BoundedTreeSet<>(limit) : null);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(item.key.toString(), item.val);\n            }\n            termsResult.add(field, fieldTerms);\n            continue;\n          }\n\n          if (!sort) {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(mv.toString(), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(mv.toString(), (int)count); // match the numeric type of terms\n            }\n\n            termsResult.add(field, fieldTerms);\n            continue;\n          }\n        }\n\n        termsResult.add(field, fieldTerms);  // add empty\n        continue;\n      }\n      termsResult.add(field, fieldTerms);\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<>(BytesRef.deepCopyOf(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);\n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","634f330c54fd3f9f491d52036dc3f40b4f4d8934","194ca6939cf04fa69e4bbcaf0fed482ae1f5fa53","2f7ebafe1543d3847a1cb09988cb6c46d48741f8","79c4ed12556e6c87ce3972fad8b9ae2376ec2c2e","725326303b39157323796ef620a9ad99eb185f11","e03427f33820a2bde791de703292dcdfe2d6bdd6","60481acc5083329d2ffbf27397331a25baad88de","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8998ebc47a334c61dfed58318c481a7d84e3eaeb","date":1560839882,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(TermsParams.TERMS, termsResult);\n\n    if (fields == null || fields.length == 0) {\n      return;\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n    if (termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Object> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          // FIXME: terms.ttf=true is not supported for pointFields\n          if (lowerStr!=null || upperStr!=null || prefix!=null || regexp!=null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = new BoundedTreeSet<>(limit);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(item.key.toString(), item.val);\n            }\n            continue;\n          } else {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(mv.toString(), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(mv.toString(), (int)count); // match the numeric type of terms\n            }\n            continue;\n          }\n        }\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft == null) {\n        ft = new StrField();\n      }\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix == null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n      TermsEnum termsEnum = terms.iterator();\n      BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<TermsResponse.Term> queue = (sort? new BoundedTreeSet<>(limit, new TermCountComparator()): null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i < limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // TODO: handle raw somehow\n          if (!externalized) {\n            ft.indexedToReadable(term, external);\n          }\n          // add the term to the list\n          if (sort) {\n            queue.add(new TermsResponse.Term(external.toString(), docFreq, termsEnum.totalTermFreq()));\n          } else {\n            addTermToNamedList(fieldTerms, external.toString(),\n                docFreq, termsEnum.totalTermFreq(), includeTotalTermFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (TermsResponse.Term item : queue) {\n          if (i >= limit) {\n            break;\n          }\n          addTermToNamedList(fieldTerms, item.getTerm(), item.getFrequency(),\n              item.getTotalTermFreq(), includeTotalTermFreq);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(TermsParams.TERMS, termsResult);\n\n    if (fields == null || fields.length == 0) {\n      return;\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n    if (termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Object> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          // FIXME: terms.ttf=true is not supported for pointFields\n          if (lowerStr!=null || upperStr!=null || prefix!=null || regexp!=null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = new BoundedTreeSet<>(limit);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(item.key.toString(), item.val);\n            }\n            continue;\n          } else {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(mv.toString(), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(mv.toString(), (int)count); // match the numeric type of terms\n            }\n            continue;\n          }\n        }\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft == null) {\n        ft = new StrField();\n      }\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix == null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n      TermsEnum termsEnum = terms.iterator();\n      BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<TermsResponse.Term> queue = (sort? new BoundedTreeSet<>(limit, new TermCountComparator()): null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i < limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // TODO: handle raw somehow\n          if (!externalized) {\n            ft.indexedToReadable(term, external);\n          }\n          // add the term to the list\n          if (sort) {\n            queue.add(new TermsResponse.Term(external.toString(), docFreq, termsEnum.totalTermFreq()));\n          } else {\n            addTermToNamedList(fieldTerms, external.toString(),\n                docFreq, termsEnum.totalTermFreq(), includeTotalTermFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (TermsResponse.Term item : queue) {\n          if (i >= limit) {\n            break;\n          }\n          addTermToNamedList(fieldTerms, item.getTerm(), item.getFrequency(),\n              item.getTotalTermFreq(), includeTotalTermFreq);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09a152fdd1e91e2dc8949c867985ea649b2a0c37","date":1571422557,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(TermsParams.TERMS, termsResult);\n\n    if (fields == null || fields.length == 0) {\n      return;\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n    if (termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Object> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          // FIXME: terms.ttf=true is not supported for pointFields\n          if (lowerStr != null || upperStr != null || prefix != null || regexp != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = new BoundedTreeSet<>(limit);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(Utils.OBJECT_TO_STRING.apply(item.key.toObject()), item.val);\n            }\n            continue;\n          } else {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(Utils.OBJECT_TO_STRING.apply(mv.toObject()), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(Utils.OBJECT_TO_STRING.apply(mv.toObject()), (int)count); // match the numeric type of terms\n            }\n            continue;\n          }\n        }\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft == null) {\n        ft = new StrField();\n      }\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix == null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n      TermsEnum termsEnum = terms.iterator();\n      BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<TermsResponse.Term> queue = (sort? new BoundedTreeSet<>(limit, new TermCountComparator()): null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i < limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // TODO: handle raw somehow\n          if (!externalized) {\n            ft.indexedToReadable(term, external);\n          }\n          // add the term to the list\n          if (sort) {\n            queue.add(new TermsResponse.Term(external.toString(), docFreq, termsEnum.totalTermFreq()));\n          } else {\n            addTermToNamedList(fieldTerms, external.toString(),\n                docFreq, termsEnum.totalTermFreq(), includeTotalTermFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (TermsResponse.Term item : queue) {\n          if (i >= limit) {\n            break;\n          }\n          addTermToNamedList(fieldTerms, item.getTerm(), item.getFrequency(),\n              item.getTotalTermFreq(), includeTotalTermFreq);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(TermsParams.TERMS, termsResult);\n\n    if (fields == null || fields.length == 0) {\n      return;\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n    if (termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Object> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          // FIXME: terms.ttf=true is not supported for pointFields\n          if (lowerStr!=null || upperStr!=null || prefix!=null || regexp!=null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = new BoundedTreeSet<>(limit);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(item.key.toString(), item.val);\n            }\n            continue;\n          } else {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(mv.toString(), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(mv.toString(), (int)count); // match the numeric type of terms\n            }\n            continue;\n          }\n        }\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft == null) {\n        ft = new StrField();\n      }\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix == null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n      TermsEnum termsEnum = terms.iterator();\n      BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<TermsResponse.Term> queue = (sort? new BoundedTreeSet<>(limit, new TermCountComparator()): null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i < limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // TODO: handle raw somehow\n          if (!externalized) {\n            ft.indexedToReadable(term, external);\n          }\n          // add the term to the list\n          if (sort) {\n            queue.add(new TermsResponse.Term(external.toString(), docFreq, termsEnum.totalTermFreq()));\n          } else {\n            addTermToNamedList(fieldTerms, external.toString(),\n                docFreq, termsEnum.totalTermFreq(), includeTotalTermFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (TermsResponse.Term item : queue) {\n          if (i >= limit) {\n            break;\n          }\n          addTermToNamedList(fieldTerms, item.getTerm(), item.getFrequency(),\n              item.getTotalTermFreq(), includeTotalTermFreq);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb65c51348af9263e432c5a93cd98be0ca68ec3a","date":1571891776,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(TermsParams.TERMS, termsResult);\n\n    if (fields == null || fields.length == 0) {\n      return;\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n    if (termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Object> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          // FIXME: terms.ttf=true is not supported for pointFields\n          if (lowerStr != null || upperStr != null || prefix != null || regexp != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n          MutableValue mv = valueIterator.getMutableValue();\n          if (sort) {\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = new BoundedTreeSet<>(limit);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(Utils.OBJECT_TO_STRING.apply(item.key.toObject()), item.val);\n            }\n            continue;\n          } else {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(Utils.OBJECT_TO_STRING.apply(mv.toObject()), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(Utils.OBJECT_TO_STRING.apply(mv.toObject()), (int)count); // match the numeric type of terms\n            }\n            continue;\n          }\n        }\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft == null) {\n        ft = new StrField();\n      }\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix == null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n      TermsEnum termsEnum = terms.iterator();\n      BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<TermsResponse.Term> queue = (sort? new BoundedTreeSet<>(limit, new TermCountComparator()): null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i < limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // TODO: handle raw somehow\n          if (!externalized) {\n            ft.indexedToReadable(term, external);\n          }\n          // add the term to the list\n          if (sort) {\n            queue.add(new TermsResponse.Term(external.toString(), docFreq, termsEnum.totalTermFreq()));\n          } else {\n            addTermToNamedList(fieldTerms, external.toString(),\n                docFreq, termsEnum.totalTermFreq(), includeTotalTermFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (TermsResponse.Term item : queue) {\n          if (i >= limit) {\n            break;\n          }\n          addTermToNamedList(fieldTerms, item.getTerm(), item.getFrequency(),\n              item.getTotalTermFreq(), includeTotalTermFreq);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.get(TermsParams.TERMS, \"false\").equals(\"true\")) {\n      return;\n    }\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<>();\n    rb.rsp.add(TermsParams.TERMS, termsResult);\n\n    if (fields == null || fields.length == 0) {\n      return;\n    }\n\n    boolean termStats = params.getBool(TermsParams.TERMS_STATS, false);\n\n    if (termStats) {\n      NamedList<Number> stats = new SimpleOrderedMap<>();\n      rb.rsp.add(\"indexstats\", stats);\n      collectStats(rb.req.getSearcher(), stats);\n    }\n\n    String termList = params.get(TermsParams.TERMS_LIST);\n    boolean includeTotalTermFreq = params.getBool(TermsParams.TERMS_TTF, false);\n    if (termList != null) {\n      fetchTerms(rb.req.getSearcher(), fields, termList, includeTotalTermFreq, termsResult);\n      return;\n    }\n\n    int _limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    final int limit = _limit < 0 ? Integer.MAX_VALUE : _limit;\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int _freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    final int freqmax = _freqmax < 0 ? Integer.MAX_VALUE : _freqmax;\n\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n    final LeafReader indexReader = rb.req.getSearcher().getSlowAtomicReader();\n\n    for (String field : fields) {\n      NamedList<Object> fieldTerms = new NamedList<>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = indexReader.terms(field);\n      if (terms == null) {\n        // field does not exist in terms index.  Check points.\n        SchemaField sf = rb.req.getSchema().getFieldOrNull(field);\n        if (sf != null && sf.getType().isPointField()) {\n          // FIXME: terms.ttf=true is not supported for pointFields\n          if (lowerStr != null || upperStr != null || prefix != null || regexp != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                String.format(Locale.ROOT, \"The terms component does not support Points-based fields with sorting or with parameters %s,%s,%s,%s \", TermsParams.TERMS_LOWER, TermsParams.TERMS_UPPER, TermsParams.TERMS_PREFIX_STR, TermsParams.TERMS_REGEXP_STR));\n          }\n\n          if (sort) {\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            BoundedTreeSet<CountPair<MutableValue, Integer>> queue = new BoundedTreeSet<>(limit);\n\n            for (; ; ) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (queue.size() < limit || queue.last().val < count || (queue.last().val == count && queue.last().key.compareTo(mv) < 0)) {\n                queue.add(new CountPair<>(mv.duplicate(), (int) count));\n              }\n            }\n\n            for (CountPair<MutableValue, Integer> item : queue) {\n              fieldTerms.add(Utils.OBJECT_TO_STRING.apply(item.key.toObject()), item.val);\n            }\n            continue;\n          } else {\n            /***\n            // streaming solution that is deferred until writing the response\n            // TODO: we can't use the streaming solution until XML writer supports PushWriter!\n            termsResult.add(field, (MapWriter) ew -> {\n              PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n              MutableValue mv = valueIterator.getMutableValue();\n              int num = 0;\n              for(;;) {\n                long count = valueIterator.getNextCount();\n                if (count < 0) break;\n                if (count < freqmin || count > freqmax) continue;\n                if (++num > limit) break;\n                ew.put(Utils.OBJECT_TO_STRING.apply(mv.toObject()), (int)count); // match the numeric type of terms\n              }\n            });\n             ***/\n\n            PointMerger.ValueIterator valueIterator = new PointMerger.ValueIterator(sf, rb.req.getSearcher().getRawReader().leaves());\n            MutableValue mv = valueIterator.getMutableValue();\n            int num = 0;\n            for(;;) {\n              long count = valueIterator.getNextCount();\n              if (count < 0) break;\n              if (count < freqmin || count > freqmax) continue;\n              if (++num > limit) break;\n              fieldTerms.add(Utils.OBJECT_TO_STRING.apply(mv.toObject()), (int)count); // match the numeric type of terms\n            }\n            continue;\n          }\n        }\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft == null) {\n        ft = new StrField();\n      }\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix == null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        BytesRefBuilder b = new BytesRefBuilder();\n        ft.readableToIndexed(upperStr, b);\n        upperBytes = b.get();\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          BytesRefBuilder b = new BytesRefBuilder();\n          ft.readableToIndexed(lowerStr, b);\n          lowerBytes = b.get();\n        }\n      }\n\n      TermsEnum termsEnum = terms.iterator();\n      BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<TermsResponse.Term> queue = (sort? new BoundedTreeSet<>(limit, new TermCountComparator()): null);\n      CharsRefBuilder external = new CharsRefBuilder();\n      while (term != null && (i < limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !StringHelper.startsWith(term, prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external.get()).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // TODO: handle raw somehow\n          if (!externalized) {\n            ft.indexedToReadable(term, external);\n          }\n          // add the term to the list\n          if (sort) {\n            queue.add(new TermsResponse.Term(external.toString(), docFreq, termsEnum.totalTermFreq()));\n          } else {\n            addTermToNamedList(fieldTerms, external.toString(),\n                docFreq, termsEnum.totalTermFreq(), includeTotalTermFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (TermsResponse.Term item : queue) {\n          if (i >= limit) {\n            break;\n          }\n          addTermToNamedList(fieldTerms, item.getTerm(), item.getFrequency(),\n              item.getTotalTermFreq(), includeTotalTermFreq);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":["2f7ebafe1543d3847a1cb09988cb6c46d48741f8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"60481acc5083329d2ffbf27397331a25baad88de":["cb88a28fb92adce0607c5b28f8f1cce9e3171639"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["60481acc5083329d2ffbf27397331a25baad88de"],"a4302dfeb5d01c940f69c48bec27f03ad8828668":["e07c409cff8701e4dc3d45934b021a949a5a8822"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"61f30939a6ca0891c7b0c0f34aa43800bd4c9a15":["e6e919043fa85ee891123768dd655a98edbbf63c"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["61f30939a6ca0891c7b0c0f34aa43800bd4c9a15"],"c6d4ff6bc316c2cad4d245958a058040d9add305":["8b92f86e90a95b8fc860ddecd9470ffb89a9fa7d"],"3051d6122751c8f6cc1e9cf24592658b59843ec2":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","2f7ebafe1543d3847a1cb09988cb6c46d48741f8"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a4302dfeb5d01c940f69c48bec27f03ad8828668","60481acc5083329d2ffbf27397331a25baad88de"],"ee8ab3e5e7c88ac47842e73e81cf68d90dd1dca6":["28288370235ed02234a64753cdbf0c6ec096304a"],"cb88a28fb92adce0607c5b28f8f1cce9e3171639":["194ca6939cf04fa69e4bbcaf0fed482ae1f5fa53"],"09a152fdd1e91e2dc8949c867985ea649b2a0c37":["8998ebc47a334c61dfed58318c481a7d84e3eaeb"],"a45ddee14ecadf18bc50fff428911687afb4745d":["a92ffe0d2961113e5588e614f8dc22b42bf10a95"],"194ca6939cf04fa69e4bbcaf0fed482ae1f5fa53":["e07c409cff8701e4dc3d45934b021a949a5a8822"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2f7ebafe1543d3847a1cb09988cb6c46d48741f8":["ee8ab3e5e7c88ac47842e73e81cf68d90dd1dca6"],"bb65c51348af9263e432c5a93cd98be0ca68ec3a":["09a152fdd1e91e2dc8949c867985ea649b2a0c37"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"6e7761210febbbf9eb64d86512126e718181aec9":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"e6e919043fa85ee891123768dd655a98edbbf63c":["3cc749c053615f5871f3b95715fe292f34e70a53"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"3cc749c053615f5871f3b95715fe292f34e70a53":["c26f00b574427b55127e869b935845554afde1fa"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"e07c409cff8701e4dc3d45934b021a949a5a8822":["b6457c5bbf93b640fc949540903318e320e52beb"],"a92ffe0d2961113e5588e614f8dc22b42bf10a95":["ee8ab3e5e7c88ac47842e73e81cf68d90dd1dca6","2f7ebafe1543d3847a1cb09988cb6c46d48741f8"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["61f30939a6ca0891c7b0c0f34aa43800bd4c9a15","96d207426bd26fa5c1014e26d21d87603aea68b7"],"28288370235ed02234a64753cdbf0c6ec096304a":["60481acc5083329d2ffbf27397331a25baad88de","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","e07c409cff8701e4dc3d45934b021a949a5a8822"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","ee8ab3e5e7c88ac47842e73e81cf68d90dd1dca6"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"b6457c5bbf93b640fc949540903318e320e52beb":["c6d4ff6bc316c2cad4d245958a058040d9add305"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8998ebc47a334c61dfed58318c481a7d84e3eaeb":["a45ddee14ecadf18bc50fff428911687afb4745d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8b92f86e90a95b8fc860ddecd9470ffb89a9fa7d":["6e7761210febbbf9eb64d86512126e718181aec9"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb65c51348af9263e432c5a93cd98be0ca68ec3a"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["6e7761210febbbf9eb64d86512126e718181aec9","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"60481acc5083329d2ffbf27397331a25baad88de":["e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a4302dfeb5d01c940f69c48bec27f03ad8828668":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"c26f00b574427b55127e869b935845554afde1fa":["3cc749c053615f5871f3b95715fe292f34e70a53"],"61f30939a6ca0891c7b0c0f34aa43800bd4c9a15":["96d207426bd26fa5c1014e26d21d87603aea68b7","5cab9a86bd67202d20b6adc463008c8e982b070a"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"c6d4ff6bc316c2cad4d245958a058040d9add305":["b6457c5bbf93b640fc949540903318e320e52beb"],"3051d6122751c8f6cc1e9cf24592658b59843ec2":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"cb88a28fb92adce0607c5b28f8f1cce9e3171639":["60481acc5083329d2ffbf27397331a25baad88de"],"ee8ab3e5e7c88ac47842e73e81cf68d90dd1dca6":["2f7ebafe1543d3847a1cb09988cb6c46d48741f8","a92ffe0d2961113e5588e614f8dc22b42bf10a95","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"09a152fdd1e91e2dc8949c867985ea649b2a0c37":["bb65c51348af9263e432c5a93cd98be0ca68ec3a"],"a45ddee14ecadf18bc50fff428911687afb4745d":["8998ebc47a334c61dfed58318c481a7d84e3eaeb"],"194ca6939cf04fa69e4bbcaf0fed482ae1f5fa53":["cb88a28fb92adce0607c5b28f8f1cce9e3171639"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"2f7ebafe1543d3847a1cb09988cb6c46d48741f8":["3051d6122751c8f6cc1e9cf24592658b59843ec2","a92ffe0d2961113e5588e614f8dc22b42bf10a95"],"bb65c51348af9263e432c5a93cd98be0ca68ec3a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"6e7761210febbbf9eb64d86512126e718181aec9":["8b92f86e90a95b8fc860ddecd9470ffb89a9fa7d"],"e6e919043fa85ee891123768dd655a98edbbf63c":["61f30939a6ca0891c7b0c0f34aa43800bd4c9a15"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["e6e919043fa85ee891123768dd655a98edbbf63c"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"e07c409cff8701e4dc3d45934b021a949a5a8822":["a4302dfeb5d01c940f69c48bec27f03ad8828668","194ca6939cf04fa69e4bbcaf0fed482ae1f5fa53","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a92ffe0d2961113e5588e614f8dc22b42bf10a95":["a45ddee14ecadf18bc50fff428911687afb4745d"],"28288370235ed02234a64753cdbf0c6ec096304a":["ee8ab3e5e7c88ac47842e73e81cf68d90dd1dca6"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["3051d6122751c8f6cc1e9cf24592658b59843ec2"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"b6457c5bbf93b640fc949540903318e320e52beb":["e07c409cff8701e4dc3d45934b021a949a5a8822"],"8998ebc47a334c61dfed58318c481a7d84e3eaeb":["09a152fdd1e91e2dc8949c867985ea649b2a0c37"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"8b92f86e90a95b8fc860ddecd9470ffb89a9fa7d":["c6d4ff6bc316c2cad4d245958a058040d9add305"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3051d6122751c8f6cc1e9cf24592658b59843ec2","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}