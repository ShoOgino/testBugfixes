{"path":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","commits":[{"id":"afb6bf9ce227ab6aac5068547e286ecc958b8b9d","date":1394661169,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request\n      try {\n        reloadFromStorage();\n      } catch (Exception reloadExc) {\n        // note: the data we're managing now remains in a dubious state\n        // however the text analysis component remains unaffected \n        // (at least until core reload)\n        log.error(\"Failed to load stop words from storage due to: \"+reloadExc);\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new ResourceException(Status.SERVER_ERROR_INTERNAL, errMsg, storeErr);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"637230d0125f5aa153298289322945139167ef76","date":1404226166,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","sourceNew":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request, but only do that\n      // if we've successfully initialized before\n      if (initializedOn != null) {\n        try {\n          reloadFromStorage();\n        } catch (Exception reloadExc) {\n          // note: the data we're managing now remains in a dubious state\n          // however the text analysis component remains unaffected \n          // (at least until core reload)\n          log.error(\"Failed to load stop words from storage due to: \"+reloadExc);\n        }\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new ResourceException(Status.SERVER_ERROR_INTERNAL, errMsg, storeErr);\n    }\n  }\n\n","sourceOld":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request\n      try {\n        reloadFromStorage();\n      } catch (Exception reloadExc) {\n        // note: the data we're managing now remains in a dubious state\n        // however the text analysis component remains unaffected \n        // (at least until core reload)\n        log.error(\"Failed to load stop words from storage due to: \"+reloadExc);\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new ResourceException(Status.SERVER_ERROR_INTERNAL, errMsg, storeErr);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6aa3e82d4adf483b74e6a0b236daff41f928603","date":1453307739,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","sourceNew":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request, but only do that\n      // if we've successfully initialized before\n      if (initializedOn != null) {\n        try {\n          reloadFromStorage();\n        } catch (Exception reloadExc) {\n          // note: the data we're managing now remains in a dubious state\n          // however the text analysis component remains unaffected \n          // (at least until core reload)\n          log.error(\"Failed to load data from storage due to: \"+reloadExc);\n        }\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new ResourceException(Status.SERVER_ERROR_INTERNAL, errMsg, storeErr);\n    }\n  }\n\n","sourceOld":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request, but only do that\n      // if we've successfully initialized before\n      if (initializedOn != null) {\n        try {\n          reloadFromStorage();\n        } catch (Exception reloadExc) {\n          // note: the data we're managing now remains in a dubious state\n          // however the text analysis component remains unaffected \n          // (at least until core reload)\n          log.error(\"Failed to load stop words from storage due to: \"+reloadExc);\n        }\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new ResourceException(Status.SERVER_ERROR_INTERNAL, errMsg, storeErr);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","sourceNew":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request, but only do that\n      // if we've successfully initialized before\n      if (initializedOn != null) {\n        try {\n          reloadFromStorage();\n        } catch (Exception reloadExc) {\n          // note: the data we're managing now remains in a dubious state\n          // however the text analysis component remains unaffected \n          // (at least until core reload)\n          log.error(\"Failed to load data from storage due to: {}\", reloadExc);\n        }\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new ResourceException(Status.SERVER_ERROR_INTERNAL, errMsg, storeErr);\n    }\n  }\n\n","sourceOld":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request, but only do that\n      // if we've successfully initialized before\n      if (initializedOn != null) {\n        try {\n          reloadFromStorage();\n        } catch (Exception reloadExc) {\n          // note: the data we're managing now remains in a dubious state\n          // however the text analysis component remains unaffected \n          // (at least until core reload)\n          log.error(\"Failed to load data from storage due to: \"+reloadExc);\n        }\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new ResourceException(Status.SERVER_ERROR_INTERNAL, errMsg, storeErr);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b","date":1601832109,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/ManagedResource#storeManagedData(Object).mjava","sourceNew":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request, but only do that\n      // if we've successfully initialized before\n      if (initializedOn != null) {\n        try {\n          reloadFromStorage();\n        } catch (Exception reloadExc) {\n          // note: the data we're managing now remains in a dubious state\n          // however the text analysis component remains unaffected \n          // (at least until core reload)\n          log.error(\"Failed to load data from storage due to: {}\", reloadExc);\n        }\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new SolrException(ErrorCode.SERVER_ERROR, errMsg, storeErr);\n    }\n  }\n\n","sourceOld":"  /**\n   * Persists managed data to the configured storage IO as a JSON object. \n   */\n  public synchronized void storeManagedData(Object managedData) {\n    \n    Map<String,Object> toStore = buildMapToStore(managedData);    \n    String resourceId = getResourceId();\n    try {\n      storage.store(resourceId, toStore);\n      // keep track that the managed data has been updated\n      lastUpdateSinceInitialization = new Date();\n    } catch (Throwable storeErr) {\n      \n      // store failed, so try to reset the state of this object by reloading\n      // from storage and then failing the store request, but only do that\n      // if we've successfully initialized before\n      if (initializedOn != null) {\n        try {\n          reloadFromStorage();\n        } catch (Exception reloadExc) {\n          // note: the data we're managing now remains in a dubious state\n          // however the text analysis component remains unaffected \n          // (at least until core reload)\n          log.error(\"Failed to load data from storage due to: {}\", reloadExc);\n        }\n      }\n      \n      String errMsg = String.format(Locale.ROOT,\n          \"Failed to store data for %s due to: %s\",\n          resourceId, storeErr.toString());\n      log.error(errMsg, storeErr);\n      throw new ResourceException(Status.SERVER_ERROR_INTERNAL, errMsg, storeErr);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"637230d0125f5aa153298289322945139167ef76":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b":["140be51d03394488536f4aacedace29f9b318347"],"c6aa3e82d4adf483b74e6a0b236daff41f928603":["637230d0125f5aa153298289322945139167ef76"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"140be51d03394488536f4aacedace29f9b318347":["c6aa3e82d4adf483b74e6a0b236daff41f928603"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b"]},"commit2Childs":{"637230d0125f5aa153298289322945139167ef76":["c6aa3e82d4adf483b74e6a0b236daff41f928603"],"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c6aa3e82d4adf483b74e6a0b236daff41f928603":["140be51d03394488536f4aacedace29f9b318347"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["637230d0125f5aa153298289322945139167ef76"],"140be51d03394488536f4aacedace29f9b318347":["89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}