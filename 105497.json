{"path":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","commits":[{"id":"8cd2638c91e278a2831e83135b2c895d04defa90","date":1231272033,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    \n    if( lock != null ) {\n      lock.lock();  // keep it from adding new commands while we block\n    }\n    try {\n      queue.put( req );\n      \n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n        synchronized( runners ) {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interuped\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    finally {\n      if( lock != null ) {\n        lock.unlock();\n      }\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["22ee5eab9703d27221d8940a0c284b42ce57676c","67ecb9d23ff772533efca1970925175ae7620dc4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22ee5eab9703d27221d8940a0c284b42ce57676c","date":1257472539,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    try {\n      CountDownLatch tmpLock = lock;\n      if( tmpLock != null ) {\n        tmpLock.await();\n      }\n\n      queue.put( req );\n      \n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n        synchronized( runners ) {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interuped\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    \n    if( lock != null ) {\n      lock.lock();  // keep it from adding new commands while we block\n    }\n    try {\n      queue.put( req );\n      \n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n        synchronized( runners ) {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interuped\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    finally {\n      if( lock != null ) {\n        lock.unlock();\n      }\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","bugFix":["8cd2638c91e278a2831e83135b2c895d04defa90"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f93b56c42efb8f552fd3c79a559b7f46cecaf432","date":1261651809,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    try {\n      CountDownLatch tmpLock = lock;\n      if( tmpLock != null ) {\n        tmpLock.await();\n      }\n\n      queue.put( req );\n      \n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n        synchronized( runners ) {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interrupted\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    try {\n      CountDownLatch tmpLock = lock;\n      if( tmpLock != null ) {\n        tmpLock.await();\n      }\n\n      queue.put( req );\n      \n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n        synchronized( runners ) {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interuped\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0","date":1264520006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    try {\n      CountDownLatch tmpLock = lock;\n      if( tmpLock != null ) {\n        tmpLock.await();\n      }\n\n      queue.put( req );\n      \n        synchronized( runners ) {\n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interrupted\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    try {\n      CountDownLatch tmpLock = lock;\n      if( tmpLock != null ) {\n        tmpLock.await();\n      }\n\n      queue.put( req );\n      \n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n        synchronized( runners ) {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interrupted\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","pathOld":"src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    try {\n      CountDownLatch tmpLock = lock;\n      if( tmpLock != null ) {\n        tmpLock.await();\n      }\n\n      queue.put( req );\n      \n        synchronized( runners ) {\n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interrupted\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    if( !(request instanceof UpdateRequest) ) {\n      return super.request( request );\n    }\n    UpdateRequest req = (UpdateRequest)request;\n    \n    // this happens for commit...\n    if( req.getDocuments()==null || req.getDocuments().isEmpty() ) {\n      blockUntilFinished();\n      return super.request( request );\n    }\n\n    SolrParams params = req.getParams();\n    if( params != null ) {\n      // check if it is waiting for the searcher\n      if( params.getBool( UpdateParams.WAIT_SEARCHER, false ) ) {\n        log.info( \"blocking for commit/optimize\" );\n        blockUntilFinished();  // empty the queue\n        return super.request( request );\n      }\n    }\n    \n    try {\n      CountDownLatch tmpLock = lock;\n      if( tmpLock != null ) {\n        tmpLock.await();\n      }\n\n      queue.put( req );\n      \n        synchronized( runners ) {\n      if( runners.isEmpty() \n        || (queue.remainingCapacity() < queue.size() \n         && runners.size() < threadCount) ) \n      {\n          Runner r = new Runner();\n          scheduler.execute( r );\n          runners.add( r );\n        }\n      }\n    } \n    catch (InterruptedException e) {\n      log.error( \"interrupted\", e );\n      throw new IOException( e.getLocalizedMessage() );\n    }\n    \n    // RETURN A DUMMY result\n    NamedList<Object> dummy = new NamedList<Object>();\n    dummy.add( \"NOTE\", \"the request is processed in a background stream\" );\n    return dummy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"8cd2638c91e278a2831e83135b2c895d04defa90":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0":["f93b56c42efb8f552fd3c79a559b7f46cecaf432"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"22ee5eab9703d27221d8940a0c284b42ce57676c":["8cd2638c91e278a2831e83135b2c895d04defa90"],"ad94625fb8d088209f46650c8097196fec67f00c":["dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0"],"f93b56c42efb8f552fd3c79a559b7f46cecaf432":["22ee5eab9703d27221d8940a0c284b42ce57676c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"8cd2638c91e278a2831e83135b2c895d04defa90":["22ee5eab9703d27221d8940a0c284b42ce57676c"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["8cd2638c91e278a2831e83135b2c895d04defa90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0":["ad94625fb8d088209f46650c8097196fec67f00c"],"22ee5eab9703d27221d8940a0c284b42ce57676c":["f93b56c42efb8f552fd3c79a559b7f46cecaf432"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"f93b56c42efb8f552fd3c79a559b7f46cecaf432":["dbfc77560023f6ab3d02a9797e491cbeb9e1f0d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}