{"path":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0226c4da52b4b59afa6d616cdf5bacb3733ca47e","date":1305730778,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     *       This relies on that the position in PP is computed as (TP.position - offset) and \n     *       so by adding offset we actually compare positions and identify that the two are \n     *       the same term.\n     *       An exclusion to this is two distinct terms in the same offset in query and same \n     *       position in doc. This case is detected by comparing just the (query) offsets, \n     *       and two such PPs are not considered \"repeating\". \n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashSet<PhrasePositions> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    if (pp.offset == pp2.offset) {\n                      continue; // not a repetition: the two PPs are originally in same offset in the query! \n                    }\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashSet<PhrasePositions>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.add(pp);\n                        m.add(pp2);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":["76bdd2a0d65c8a40e657fbefccfc915026e4902b","c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     *       This relies on that the position in PP is computed as (TP.position - offset) and \n     *       so by adding offset we actually compare positions and identify that the two are \n     *       the same term.\n     *       An exclusion to this is two distinct terms in the same offset in query and same \n     *       position in doc. This case is detected by comparing just the (query) offsets, \n     *       and two such PPs are not considered \"repeating\". \n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashSet<PhrasePositions> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    if (pp.offset == pp2.offset) {\n                      continue; // not a repetition: the two PPs are originally in same offset in the query! \n                    }\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashSet<PhrasePositions>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.add(pp);\n                        m.add(pp2);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     *       This relies on that the position in PP is computed as (TP.position - offset) and \n     *       so by adding offset we actually compare positions and identify that the two are \n     *       the same term.\n     *       An exclusion to this is two distinct terms in the same offset in query and same \n     *       position in doc. This case is detected by comparing just the (query) offsets, \n     *       and two such PPs are not considered \"repeating\". \n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashSet<PhrasePositions> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    if (pp.offset == pp2.offset) {\n                      continue; // not a repetition: the two PPs are originally in same offset in the query! \n                    }\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashSet<PhrasePositions>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.add(pp);\n                        m.add(pp2);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76bdd2a0d65c8a40e657fbefccfc915026e4902b","date":1315464700,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     *       This relies on that the position in PP is computed as (TP.position - offset) and \n     *       so by adding offset we actually compare positions and identify that the two are \n     *       the same term.\n     *       An exclusion to this is two distinct terms in the same offset in query and same \n     *       position in doc. This case is detected by comparing just the (query) offsets, \n     *       and two such PPs are not considered \"repeating\". \n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsConflict(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initialization for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            LinkedHashSet<PhrasePositions> m = null; // see comment (*) below why order is important\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    if (pp.offset == pp2.offset) {\n                      continue; // not a repetition: the two PPs are originally in same offset in the query! \n                    }\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new LinkedHashSet<PhrasePositions>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.add(pp);\n                        m.add(pp2);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's\n        // (*) It is important that pps are handled by their original order in the query,\n        // because we advance the pp with larger offset, and so processing them in that order\n        // allows to cover all pairs.\n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsConflict(pp)) != null) {\n                  if (!pp2.nextPosition()) // among pps that do not differ, advance the pp with higher offset\n                      return -1;           // ran out of a term -- done\n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        \n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     *       This relies on that the position in PP is computed as (TP.position - offset) and \n     *       so by adding offset we actually compare positions and identify that the two are \n     *       the same term.\n     *       An exclusion to this is two distinct terms in the same offset in query and same \n     *       position in doc. This case is detected by comparing just the (query) offsets, \n     *       and two such PPs are not considered \"repeating\". \n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashSet<PhrasePositions> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    if (pp.offset == pp2.offset) {\n                      continue; // not a repetition: the two PPs are originally in same offset in the query! \n                    }\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashSet<PhrasePositions>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.add(pp);\n                        m.add(pp2);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a","b3e493496c35fb4f17315b8827d1ba1ae1585554","0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9ff635e6838a2facda02727dec5b77d9e64dc4c","date":1316672863,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"  /**\n   * Initialize PhrasePositions in place.\n   * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n   * <ul>\n   *  <li>Detect groups of repeating pps: those with same tpPos (tpPos==position in the doc) but different offsets in query.\n   *  <li>For each such group:\n   *  <ul>\n   *   <li>form an inner linked list of the repeating ones.\n   *   <li>propagate all group members but first so that they land on different tpPos().\n   *  </ul>\n   *  <li>Mark whether there are repetitions at all, so that scoring queries with no repetitions has no overhead due to this computation.\n   *  <li>Insert to pq only non repeating PPs, or PPs that are the first in a repeating group.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return end (max position), or Integer.MIN_VALUE if any term ran out (i.e. done) \n   */\n  private int initPhrasePositions() throws IOException {\n    int end = Integer.MIN_VALUE;\n    \n    // no repeats at all (most common case is also the simplest one)\n    if (checkedRepeats && !hasRepeats) {\n      // build queue from list\n      pq.clear();\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        pp.firstPosition();\n        if (pp.position > end) {\n          end = pp.position;\n        }\n        pq.add(pp);         // build pq from list\n      }\n      return end;\n    }\n    \n    //printPositions(System.err, \"Init: 1: Bef position\");\n    \n    // position the pp's\n    for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max  \n      pp.firstPosition();\n    }\n    \n    //printPositions(System.err, \"Init: 2: Aft position\");\n    \n    // one time initialization for this scorer (done only for the first candidate doc)\n    if (!checkedRepeats) {\n      checkedRepeats = true;\n      ArrayList<PhrasePositions> ppsA = new ArrayList<PhrasePositions>();\n      PhrasePositions dummyPP = new PhrasePositions(null, -1, -1);\n      // check for repeats\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        if (pp.nextRepeating != null) {\n          continue; // a repetition of an earlier pp\n        }\n        ppsA.add(pp);\n        int tpPos = tpPos(pp);\n        for (PhrasePositions prevB=pp, pp2=pp.next; pp2!= min; pp2=pp2.next) {\n          if (\n              pp2.nextRepeating != null  // already detected as a repetition of an earlier pp\n              || pp.offset == pp2.offset // not a repetition: the two PPs are originally in same offset in the query! \n              || tpPos(pp2) != tpPos) {  // not a repetition\n            continue; \n          }\n          // a repetition\n          hasRepeats = true;\n          prevB.nextRepeating = pp2;  // add pp2 to the repeats linked list\n          pp2.nextRepeating = dummyPP; // allows not to handle the last pp in a sub-list\n          prevB = pp2;\n        }\n      }\n      if (hasRepeats) {\n        // clean dummy markers\n        for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n          if (pp.nextRepeating == dummyPP) {\n            pp.nextRepeating = null;\n          }\n        }\n      }\n      nrPps = ppsA.toArray(new PhrasePositions[0]);\n      pq = new PhraseQueue(nrPps.length);\n    }\n    \n    //printPositions(System.err, \"Init: 3: Aft check-repeats\");\n    \n    // with repeats must advance some repeating pp's so they all start with differing tp's\n    if (hasRepeats) {\n      for (PhrasePositions pp: nrPps) {\n        if ((end=advanceRepeats(pp, end)) == Integer.MIN_VALUE) {\n          return Integer.MIN_VALUE; // ran out of a term -- done (no valid matches in current doc)\n        }\n      }\n    }\n    \n    //printPositions(System.err, \"Init: 4: Aft advance-repeats\");\n    \n    // build queue from non repeating pps \n    pq.clear();\n    for (PhrasePositions pp: nrPps) {\n      if (pp.position > end) {\n        end = pp.position;\n      }\n      pq.add(pp);\n    }\n    \n    return end;\n  }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     *       This relies on that the position in PP is computed as (TP.position - offset) and \n     *       so by adding offset we actually compare positions and identify that the two are \n     *       the same term.\n     *       An exclusion to this is two distinct terms in the same offset in query and same \n     *       position in doc. This case is detected by comparing just the (query) offsets, \n     *       and two such PPs are not considered \"repeating\". \n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsConflict(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initialization for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            LinkedHashSet<PhrasePositions> m = null; // see comment (*) below why order is important\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    if (pp.offset == pp2.offset) {\n                      continue; // not a repetition: the two PPs are originally in same offset in the query! \n                    }\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new LinkedHashSet<PhrasePositions>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.add(pp);\n                        m.add(pp2);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's\n        // (*) It is important that pps are handled by their original order in the query,\n        // because we advance the pp with larger offset, and so processing them in that order\n        // allows to cover all pairs.\n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsConflict(pp)) != null) {\n                  if (!pp2.nextPosition()) // among pps that do not differ, advance the pp with higher offset\n                      return -1;           // ran out of a term -- done\n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        \n        return end;\n    }\n\n","bugFix":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a","0731e137bcbb58121034de6ddaa67332fbe6e5d1","b3e493496c35fb4f17315b8827d1ba1ae1585554","76bdd2a0d65c8a40e657fbefccfc915026e4902b","0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"  /**\n   * Initialize PhrasePositions in place.\n   * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n   * <ul>\n   *  <li>Detect groups of repeating pps: those with same tpPos (tpPos==position in the doc) but different offsets in query.\n   *  <li>For each such group:\n   *  <ul>\n   *   <li>form an inner linked list of the repeating ones.\n   *   <li>propagate all group members but first so that they land on different tpPos().\n   *  </ul>\n   *  <li>Mark whether there are repetitions at all, so that scoring queries with no repetitions has no overhead due to this computation.\n   *  <li>Insert to pq only non repeating PPs, or PPs that are the first in a repeating group.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return end (max position), or Integer.MIN_VALUE if any term ran out (i.e. done) \n   */\n  private int initPhrasePositions() throws IOException {\n    int end = Integer.MIN_VALUE;\n    \n    // no repeats at all (most common case is also the simplest one)\n    if (checkedRepeats && !hasRepeats) {\n      // build queue from list\n      pq.clear();\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        pp.firstPosition();\n        if (pp.position > end) {\n          end = pp.position;\n        }\n        pq.add(pp);         // build pq from list\n      }\n      return end;\n    }\n    \n    //printPositions(System.err, \"Init: 1: Bef position\");\n    \n    // position the pp's\n    for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max  \n      pp.firstPosition();\n    }\n    \n    //printPositions(System.err, \"Init: 2: Aft position\");\n    \n    // one time initialization for this scorer (done only for the first candidate doc)\n    if (!checkedRepeats) {\n      checkedRepeats = true;\n      ArrayList<PhrasePositions> ppsA = new ArrayList<PhrasePositions>();\n      PhrasePositions dummyPP = new PhrasePositions(null, -1, -1);\n      // check for repeats\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        if (pp.nextRepeating != null) {\n          continue; // a repetition of an earlier pp\n        }\n        ppsA.add(pp);\n        int tpPos = tpPos(pp);\n        for (PhrasePositions prevB=pp, pp2=pp.next; pp2!= min; pp2=pp2.next) {\n          if (\n              pp2.nextRepeating != null  // already detected as a repetition of an earlier pp\n              || pp.offset == pp2.offset // not a repetition: the two PPs are originally in same offset in the query! \n              || tpPos(pp2) != tpPos) {  // not a repetition\n            continue; \n          }\n          // a repetition\n          hasRepeats = true;\n          prevB.nextRepeating = pp2;  // add pp2 to the repeats linked list\n          pp2.nextRepeating = dummyPP; // allows not to handle the last pp in a sub-list\n          prevB = pp2;\n        }\n      }\n      if (hasRepeats) {\n        // clean dummy markers\n        for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n          if (pp.nextRepeating == dummyPP) {\n            pp.nextRepeating = null;\n          }\n        }\n      }\n      nrPps = ppsA.toArray(new PhrasePositions[0]);\n      pq = new PhraseQueue(nrPps.length);\n    }\n    \n    //printPositions(System.err, \"Init: 3: Aft check-repeats\");\n    \n    // with repeats must advance some repeating pp's so they all start with differing tp's\n    if (hasRepeats) {\n      for (PhrasePositions pp: nrPps) {\n        if ((end=advanceRepeats(pp, end)) == Integer.MIN_VALUE) {\n          return Integer.MIN_VALUE; // ran out of a term -- done (no valid matches in current doc)\n        }\n      }\n    }\n    \n    //printPositions(System.err, \"Init: 4: Aft advance-repeats\");\n    \n    // build queue from non repeating pps \n    pq.clear();\n    for (PhrasePositions pp: nrPps) {\n      if (pp.position > end) {\n        end = pp.position;\n      }\n      pq.add(pp);\n    }\n    \n    return end;\n  }\n\n","sourceOld":"  /**\n   * Initialize PhrasePositions in place.\n   * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n   * <ul>\n   *  <li>Detect groups of repeating pps: those with same tpPos (tpPos==position in the doc) but different offsets in query.\n   *  <li>For each such group:\n   *  <ul>\n   *   <li>form an inner linked list of the repeating ones.\n   *   <li>propagate all group members but first so that they land on different tpPos().\n   *  </ul>\n   *  <li>Mark whether there are repetitions at all, so that scoring queries with no repetitions has no overhead due to this computation.\n   *  <li>Insert to pq only non repeating PPs, or PPs that are the first in a repeating group.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return end (max position), or Integer.MIN_VALUE if any term ran out (i.e. done) \n   */\n  private int initPhrasePositions() throws IOException {\n    int end = Integer.MIN_VALUE;\n    \n    // no repeats at all (most common case is also the simplest one)\n    if (checkedRepeats && !hasRepeats) {\n      // build queue from list\n      pq.clear();\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        pp.firstPosition();\n        if (pp.position > end) {\n          end = pp.position;\n        }\n        pq.add(pp);         // build pq from list\n      }\n      return end;\n    }\n    \n    //printPositions(System.err, \"Init: 1: Bef position\");\n    \n    // position the pp's\n    for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max  \n      pp.firstPosition();\n    }\n    \n    //printPositions(System.err, \"Init: 2: Aft position\");\n    \n    // one time initialization for this scorer (done only for the first candidate doc)\n    if (!checkedRepeats) {\n      checkedRepeats = true;\n      ArrayList<PhrasePositions> ppsA = new ArrayList<PhrasePositions>();\n      PhrasePositions dummyPP = new PhrasePositions(null, -1, -1);\n      // check for repeats\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        if (pp.nextRepeating != null) {\n          continue; // a repetition of an earlier pp\n        }\n        ppsA.add(pp);\n        int tpPos = tpPos(pp);\n        for (PhrasePositions prevB=pp, pp2=pp.next; pp2!= min; pp2=pp2.next) {\n          if (\n              pp2.nextRepeating != null  // already detected as a repetition of an earlier pp\n              || pp.offset == pp2.offset // not a repetition: the two PPs are originally in same offset in the query! \n              || tpPos(pp2) != tpPos) {  // not a repetition\n            continue; \n          }\n          // a repetition\n          hasRepeats = true;\n          prevB.nextRepeating = pp2;  // add pp2 to the repeats linked list\n          pp2.nextRepeating = dummyPP; // allows not to handle the last pp in a sub-list\n          prevB = pp2;\n        }\n      }\n      if (hasRepeats) {\n        // clean dummy markers\n        for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n          if (pp.nextRepeating == dummyPP) {\n            pp.nextRepeating = null;\n          }\n        }\n      }\n      nrPps = ppsA.toArray(new PhrasePositions[0]);\n      pq = new PhraseQueue(nrPps.length);\n    }\n    \n    //printPositions(System.err, \"Init: 3: Aft check-repeats\");\n    \n    // with repeats must advance some repeating pp's so they all start with differing tp's\n    if (hasRepeats) {\n      for (PhrasePositions pp: nrPps) {\n        if ((end=advanceRepeats(pp, end)) == Integer.MIN_VALUE) {\n          return Integer.MIN_VALUE; // ran out of a term -- done (no valid matches in current doc)\n        }\n      }\n    }\n    \n    //printPositions(System.err, \"Init: 4: Aft advance-repeats\");\n    \n    // build queue from non repeating pps \n    pq.clear();\n    for (PhrasePositions pp: nrPps) {\n      if (pp.position > end) {\n        end = pp.position;\n      }\n      pq.add(pp);\n    }\n    \n    return end;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"76bdd2a0d65c8a40e657fbefccfc915026e4902b":["0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["9454a6510e2db155fb01faa5c049b06ece95fab9","0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"c9ff635e6838a2facda02727dec5b77d9e64dc4c":["76bdd2a0d65c8a40e657fbefccfc915026e4902b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"a3776dccca01c11e7046323cfad46a3b4a471233":["9454a6510e2db155fb01faa5c049b06ece95fab9","0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0226c4da52b4b59afa6d616cdf5bacb3733ca47e":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"76bdd2a0d65c8a40e657fbefccfc915026e4902b":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"c9ff635e6838a2facda02727dec5b77d9e64dc4c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"0226c4da52b4b59afa6d616cdf5bacb3733ca47e":["76bdd2a0d65c8a40e657fbefccfc915026e4902b","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}