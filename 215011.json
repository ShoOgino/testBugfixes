{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentInfo> mergedAway = new HashSet<SegmentInfo>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n\n    // update the Set\n    if (!dropSegment) {\n      segmentSet.add(merge.info);\n    }\n    segmentSet.removeAll(mergedAway);\n    \n    assert segmentSet.size() == segments.size();\n  }\n\n","sourceOld":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentInfo> mergedAway = new HashSet<SegmentInfo>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n\n    // update the Set\n    if (!dropSegment) {\n      segmentSet.add(merge.info);\n    }\n    segmentSet.removeAll(mergedAway);\n    \n    assert segmentSet.size() == segments.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentInfoPerCommit> mergedAway = new HashSet<SegmentInfoPerCommit>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentInfoPerCommit info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","sourceOld":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentInfo> mergedAway = new HashSet<SegmentInfo>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n\n    // update the Set\n    if (!dropSegment) {\n      segmentSet.add(merge.info);\n    }\n    segmentSet.removeAll(mergedAway);\n    \n    assert segmentSet.size() == segments.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentInfoPerCommit> mergedAway = new HashSet<SegmentInfoPerCommit>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentInfoPerCommit info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","sourceOld":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentInfo> mergedAway = new HashSet<SegmentInfo>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n\n    // update the Set\n    if (!dropSegment) {\n      segmentSet.add(merge.info);\n    }\n    segmentSet.removeAll(mergedAway);\n    \n    assert segmentSet.size() == segments.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentCommitInfo> mergedAway = new HashSet<SegmentCommitInfo>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentCommitInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","sourceOld":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentInfoPerCommit> mergedAway = new HashSet<SegmentInfoPerCommit>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentInfoPerCommit info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentCommitInfo> mergedAway = new HashSet<>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentCommitInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","sourceOld":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentCommitInfo> mergedAway = new HashSet<SegmentCommitInfo>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentCommitInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    if (indexCreatedVersionMajor >= 7 && merge.info.info.minVersion == null) {\n      throw new IllegalArgumentException(\"All segments must record the minVersion for indices created on or after Lucene 7\");\n    }\n\n    final Set<SegmentCommitInfo> mergedAway = new HashSet<>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentCommitInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","sourceOld":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentCommitInfo> mergedAway = new HashSet<>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentCommitInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#applyMergeChanges(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    if (indexCreatedVersionMajor >= 7 && merge.info.info.minVersion == null) {\n      throw new IllegalArgumentException(\"All segments must record the minVersion for indices created on or after Lucene 7\");\n    }\n\n    final Set<SegmentCommitInfo> mergedAway = new HashSet<>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentCommitInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","sourceOld":"  /** applies all changes caused by committing a merge to this SegmentInfos */\n  void applyMergeChanges(MergePolicy.OneMerge merge, boolean dropSegment) {\n    final Set<SegmentCommitInfo> mergedAway = new HashSet<>(merge.segments);\n    boolean inserted = false;\n    int newSegIdx = 0;\n    for (int segIdx = 0, cnt = segments.size(); segIdx < cnt; segIdx++) {\n      assert segIdx >= newSegIdx;\n      final SegmentCommitInfo info = segments.get(segIdx);\n      if (mergedAway.contains(info)) {\n        if (!inserted && !dropSegment) {\n          segments.set(segIdx, merge.info);\n          inserted = true;\n          newSegIdx++;\n        }\n      } else {\n        segments.set(newSegIdx, info);\n        newSegIdx++;\n      }\n    }\n\n    // the rest of the segments in list are duplicates, so don't remove from map, only list!\n    segments.subList(newSegIdx, segments.size()).clear();\n    \n    // Either we found place to insert segment, or, we did\n    // not, but only because all segments we merged becamee\n    // deleted while we are merging, in which case it should\n    // be the case that the new segment is also all deleted,\n    // we insert it at the beginning if it should not be dropped:\n    if (!inserted && !dropSegment) {\n      segments.add(0, merge.info);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","9d153abcf92dc5329d98571a8c3035df9bd80648"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d153abcf92dc5329d98571a8c3035df9bd80648":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","31741cf1390044e38a2ec3127cf302ba841bfd75"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","9d153abcf92dc5329d98571a8c3035df9bd80648"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"31741cf1390044e38a2ec3127cf302ba841bfd75":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}