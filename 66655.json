{"path":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","sourceNew":"  public int add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.length);\n    final FST.BytesReader in = fst.getBytesReader(0);\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final int v = table[pos];\n      if (v == 0) {\n        // freeze & add\n        final int node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table[pos] = node;\n        if (table.length < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v, in)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","sourceOld":"  public int add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.length);\n    final FST.BytesReader in = fst.getBytesReader(0);\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final int v = table[pos];\n      if (v == 0) {\n        // freeze & add\n        final int node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table[pos] = node;\n        if (table.length < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v, in)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4612a1625257c97ec7983c15cbc6289689e42fed","date":1358010116,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","sourceNew":"  public int add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.length);\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final int v = table[pos];\n      if (v == 0) {\n        // freeze & add\n        final int node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table[pos] = node;\n        if (table.length < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","sourceOld":"  public int add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.length);\n    final FST.BytesReader in = fst.getBytesReader(0);\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final int v = table[pos];\n      if (v == 0) {\n        // freeze & add\n        final int node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table[pos] = node;\n        if (table.length < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v, in)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","sourceNew":"  public long add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.size());\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final long v = table.get(pos);\n      if (v == 0) {\n        // freeze & add\n        final long node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table.set(pos, node);\n        if (table.size() < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","sourceOld":"  public int add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.length);\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final int v = table[pos];\n      if (v == 0) {\n        // freeze & add\n        final int node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table[pos] = node;\n        if (table.length < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","sourceNew":"  public long add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.size());\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final long v = table.get(pos);\n      if (v == 0) {\n        // freeze & add\n        final long node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table.set(pos, node);\n        if (table.size() < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","sourceOld":"  public int add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.length);\n    final FST.BytesReader in = fst.getBytesReader(0);\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final int v = table[pos];\n      if (v == 0) {\n        // freeze & add\n        final int node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table[pos] = node;\n        if (table.length < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v, in)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5","date":1370275238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","sourceNew":"  public long add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"hash: add count=\" + count + \" vs \" + table.size() + \" mask=\" + mask);\n    final long h = hash(nodeIn);\n    long pos = h & mask;\n    int c = 0;\n    while(true) {\n      final long v = table.get(pos);\n      if (v == 0) {\n        // freeze & add\n        final long node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table.set(pos, node);\n        // Rehash at 2/3 occupancy:\n        if (count > 2*table.size()/3) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","sourceOld":"  public long add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    // System.out.println(\"hash: add count=\" + count + \" vs \" + table.size());\n    final int h = hash(nodeIn);\n    int pos = h & mask;\n    int c = 0;\n    while(true) {\n      final long v = table.get(pos);\n      if (v == 0) {\n        // freeze & add\n        final long node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table.set(pos, node);\n        if (table.size() < 2*count) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#add(Builder.UnCompiledNode[T]).mjava","sourceNew":"  public long add(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"hash: add count=\" + count + \" vs \" + table.size() + \" mask=\" + mask);\n    final long h = hash(nodeIn);\n    long pos = h & mask;\n    int c = 0;\n    while(true) {\n      final long v = table.get(pos);\n      if (v == 0) {\n        // freeze & add\n        final long node = fst.addNode(builder, nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table.set(pos, node);\n        // Rehash at 2/3 occupancy:\n        if (count > 2*table.size()/3) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","sourceOld":"  public long add(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"hash: add count=\" + count + \" vs \" + table.size() + \" mask=\" + mask);\n    final long h = hash(nodeIn);\n    long pos = h & mask;\n    int c = 0;\n    while(true) {\n      final long v = table.get(pos);\n      if (v == 0) {\n        // freeze & add\n        final long node = fst.addNode(nodeIn);\n        //System.out.println(\"  now freeze node=\" + node);\n        assert hash(node) == h : \"frozenHash=\" + hash(node) + \" vs h=\" + h;\n        count++;\n        table.set(pos, node);\n        // Rehash at 2/3 occupancy:\n        if (count > 2*table.size()/3) {\n          rehash();\n        }\n        return node;\n      } else if (nodesEqual(nodeIn, v)) {\n        // same node is already here\n        return v;\n      }\n\n      // quadratic probe\n      pos = (pos + (++c)) & mask;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5"],"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["4612a1625257c97ec7983c15cbc6289689e42fed"],"4612a1625257c97ec7983c15cbc6289689e42fed":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1abb939fb41b2fe4f89fd518f3da288c0213341d"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5","8917bfede3b4ca30f4305c1e391e9218959cd723"],"4612a1625257c97ec7983c15cbc6289689e42fed":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4612a1625257c97ec7983c15cbc6289689e42fed","8917bfede3b4ca30f4305c1e391e9218959cd723"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}