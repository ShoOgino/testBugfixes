{"path":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","commits":[{"id":"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2","date":1460953142,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"713122036535651642e6d4fe57ce12b449e18473","date":1461000510,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7e72caffc799b265e17158ff9b0aad014849ad8","date":1466582027,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":["ac94c1c73e01278464e2c6be2b6f7ea0df26a571","0da288484d638cec72e8fc33363e4c0532d35ff0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06fc6aedefe19d7a0b0d82dac953a4f161e16b5c","date":1531585717,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60f64dc6ee2edd7a99b719d96f6d9e7ef0ae5980","date":1533125102,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * randomDouble();\n      double radiusDelta = randomDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += randomDouble() * 40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * randomDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b39f95206bdb2c5b28ef7e848cacce7f2baefea","date":1533131097,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * randomDouble();\n      double radiusDelta = randomDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += randomDouble() * 40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * randomDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71a92b21a4564a0dd5e0559cebf435a5fe34542e","date":1573666298,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));\n        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||\n            lat > 90 || lat < -90) {\n          // cannot cross dateline or pole: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60f64dc6ee2edd7a99b719d96f6d9e7ef0ae5980":["06fc6aedefe19d7a0b0d82dac953a4f161e16b5c"],"06fc6aedefe19d7a0b0d82dac953a4f161e16b5c":["c7e72caffc799b265e17158ff9b0aad014849ad8"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["c7e72caffc799b265e17158ff9b0aad014849ad8","06fc6aedefe19d7a0b0d82dac953a4f161e16b5c"],"1b39f95206bdb2c5b28ef7e848cacce7f2baefea":["60f64dc6ee2edd7a99b719d96f6d9e7ef0ae5980"],"713122036535651642e6d4fe57ce12b449e18473":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c7e72caffc799b265e17158ff9b0aad014849ad8":["713122036535651642e6d4fe57ce12b449e18473"],"71a92b21a4564a0dd5e0559cebf435a5fe34542e":["1b39f95206bdb2c5b28ef7e848cacce7f2baefea"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["713122036535651642e6d4fe57ce12b449e18473","c7e72caffc799b265e17158ff9b0aad014849ad8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71a92b21a4564a0dd5e0559cebf435a5fe34542e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["c7e72caffc799b265e17158ff9b0aad014849ad8","06fc6aedefe19d7a0b0d82dac953a4f161e16b5c"]},"commit2Childs":{"60f64dc6ee2edd7a99b719d96f6d9e7ef0ae5980":["1b39f95206bdb2c5b28ef7e848cacce7f2baefea"],"06fc6aedefe19d7a0b0d82dac953a4f161e16b5c":["60f64dc6ee2edd7a99b719d96f6d9e7ef0ae5980","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"1b39f95206bdb2c5b28ef7e848cacce7f2baefea":["71a92b21a4564a0dd5e0559cebf435a5fe34542e"],"713122036535651642e6d4fe57ce12b449e18473":["c7e72caffc799b265e17158ff9b0aad014849ad8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["713122036535651642e6d4fe57ce12b449e18473","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["713122036535651642e6d4fe57ce12b449e18473"],"c7e72caffc799b265e17158ff9b0aad014849ad8":["06fc6aedefe19d7a0b0d82dac953a4f161e16b5c","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"71a92b21a4564a0dd5e0559cebf435a5fe34542e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}