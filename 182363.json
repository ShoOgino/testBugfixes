{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRemoveNode(String).mjava","commits":[{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRemoveNode(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRemoveNode(String).mjava","sourceNew":"  /**\n   * Remove node from a cluster. This is equivalent to a situation when a node is lost.\n   * All replicas that were assigned to this node are marked as DOWN.\n   * @param nodeId node id\n   * @return true if a node existed and was removed\n   */\n  public boolean simRemoveNode(String nodeId) throws Exception {\n    ensureNotClosed();\n    lock.lockInterruptibly();\n    try {\n      Set<String> collections = new HashSet<>();\n      // mark every replica on that node as down\n      boolean res = liveNodes.remove(nodeId);\n      setReplicaStates(nodeId, Replica.State.DOWN, collections);\n      if (!collections.isEmpty()) {\n        collectionsStatesRef.set(null);\n      }\n      // remove ephemeral nodes\n      stateManager.getRoot().removeEphemeralChildren(nodeId);\n      // create a nodeLost marker if needed\n      AutoScalingConfig cfg = stateManager.getAutoScalingConfig(null);\n      if (cfg.hasTriggerForEvents(TriggerEventType.NODELOST)) {\n        String path = ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH + \"/\" + nodeId;\n        byte[] json = Utils.toJSON(Collections.singletonMap(\"timestamp\", cloudManager.getTimeSource().getEpochTimeNs()));\n        stateManager.makePath(path,\n            json, CreateMode.PERSISTENT, false);\n        log.debug(\" -- created marker: {}\", path);\n      }\n      updateOverseerLeader();\n      if (!collections.isEmpty()) {\n        simRunLeaderElection(collections, true);\n      }\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Remove node from a cluster. This is equivalent to a situation when a node is lost.\n   * All replicas that were assigned to this node are marked as DOWN.\n   * @param nodeId node id\n   * @return true if a node existed and was removed\n   */\n  public boolean simRemoveNode(String nodeId) throws Exception {\n    ensureNotClosed();\n    lock.lockInterruptibly();\n    try {\n      Set<String> collections = new HashSet<>();\n      // mark every replica on that node as down\n      boolean res = liveNodes.remove(nodeId);\n      setReplicaStates(nodeId, Replica.State.DOWN, collections);\n      if (!collections.isEmpty()) {\n        collectionsStatesRef.set(null);\n      }\n      // remove ephemeral nodes\n      stateManager.getRoot().removeEphemeralChildren(nodeId);\n      // create a nodeLost marker if needed\n      AutoScalingConfig cfg = stateManager.getAutoScalingConfig(null);\n      if (cfg.hasTriggerForEvents(TriggerEventType.NODELOST)) {\n        String path = ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH + \"/\" + nodeId;\n        byte[] json = Utils.toJSON(Collections.singletonMap(\"timestamp\", cloudManager.getTimeSource().getEpochTimeNs()));\n        stateManager.makePath(path,\n            json, CreateMode.PERSISTENT, false);\n        log.debug(\" -- created marker: {}\", path);\n      }\n      updateOverseerLeader();\n      if (!collections.isEmpty()) {\n        simRunLeaderElection(collections, true);\n      }\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a","date":1589907167,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRemoveNode(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRemoveNode(String).mjava","sourceNew":"  /**\n   * Remove node from a cluster. This is equivalent to a situation when a node is lost.\n   * All replicas that were assigned to this node are marked as DOWN.\n   * @param nodeId node id\n   * @return true if a node existed and was removed\n   */\n  public boolean simRemoveNode(String nodeId) throws Exception {\n    ensureNotClosed();\n    lock.lockInterruptibly();\n    try {\n      Set<String> collections = new HashSet<>();\n      // mark every replica on that node as down\n      boolean res = liveNodes.remove(nodeId);\n      setReplicaStates(nodeId, Replica.State.DOWN, collections);\n      for (String collection : collections) {\n        collectionsStatesRef.get(collection).invalidate();;\n      }\n      // remove ephemeral nodes\n      stateManager.getRoot().removeEphemeralChildren(nodeId);\n      // create a nodeLost marker if needed\n      AutoScalingConfig cfg = stateManager.getAutoScalingConfig(null);\n      if (cfg.hasTriggerForEvents(TriggerEventType.NODELOST)) {\n        String path = ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH + \"/\" + nodeId;\n        byte[] json = Utils.toJSON(Collections.singletonMap(\"timestamp\", cloudManager.getTimeSource().getEpochTimeNs()));\n        stateManager.makePath(path,\n            json, CreateMode.PERSISTENT, false);\n        log.debug(\" -- created marker: {}\", path);\n      }\n      updateOverseerLeader();\n      if (!collections.isEmpty()) {\n        simRunLeaderElection(collections, true);\n      }\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Remove node from a cluster. This is equivalent to a situation when a node is lost.\n   * All replicas that were assigned to this node are marked as DOWN.\n   * @param nodeId node id\n   * @return true if a node existed and was removed\n   */\n  public boolean simRemoveNode(String nodeId) throws Exception {\n    ensureNotClosed();\n    lock.lockInterruptibly();\n    try {\n      Set<String> collections = new HashSet<>();\n      // mark every replica on that node as down\n      boolean res = liveNodes.remove(nodeId);\n      setReplicaStates(nodeId, Replica.State.DOWN, collections);\n      if (!collections.isEmpty()) {\n        collectionsStatesRef.set(null);\n      }\n      // remove ephemeral nodes\n      stateManager.getRoot().removeEphemeralChildren(nodeId);\n      // create a nodeLost marker if needed\n      AutoScalingConfig cfg = stateManager.getAutoScalingConfig(null);\n      if (cfg.hasTriggerForEvents(TriggerEventType.NODELOST)) {\n        String path = ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH + \"/\" + nodeId;\n        byte[] json = Utils.toJSON(Collections.singletonMap(\"timestamp\", cloudManager.getTimeSource().getEpochTimeNs()));\n        stateManager.makePath(path,\n            json, CreateMode.PERSISTENT, false);\n        log.debug(\" -- created marker: {}\", path);\n      }\n      updateOverseerLeader();\n      if (!collections.isEmpty()) {\n        simRunLeaderElection(collections, true);\n      }\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRemoveNode(String).mjava","sourceNew":null,"sourceOld":"  /**\n   * Remove node from a cluster. This is equivalent to a situation when a node is lost.\n   * All replicas that were assigned to this node are marked as DOWN.\n   * @param nodeId node id\n   * @return true if a node existed and was removed\n   */\n  public boolean simRemoveNode(String nodeId) throws Exception {\n    ensureNotClosed();\n    lock.lockInterruptibly();\n    try {\n      Set<String> collections = new HashSet<>();\n      // mark every replica on that node as down\n      boolean res = liveNodes.remove(nodeId);\n      setReplicaStates(nodeId, Replica.State.DOWN, collections);\n      for (String collection : collections) {\n        collectionsStatesRef.get(collection).invalidate();;\n      }\n      // remove ephemeral nodes\n      stateManager.getRoot().removeEphemeralChildren(nodeId);\n      // create a nodeLost marker if needed\n      AutoScalingConfig cfg = stateManager.getAutoScalingConfig(null);\n      if (cfg.hasTriggerForEvents(TriggerEventType.NODELOST)) {\n        String path = ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH + \"/\" + nodeId;\n        byte[] json = Utils.toJSON(Collections.singletonMap(\"timestamp\", cloudManager.getTimeSource().getEpochTimeNs()));\n        stateManager.makePath(path,\n            json, CreateMode.PERSISTENT, false);\n        log.debug(\" -- created marker: {}\", path);\n      }\n      updateOverseerLeader();\n      if (!collections.isEmpty()) {\n        simRunLeaderElection(collections, true);\n      }\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["3f504512a03d978990cbff30db0522b354e846db"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}