{"path":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","commits":[{"id":"b01431682e11036a1a7d757a3fa7c1f903fb2c45","date":1460646145,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","pathOld":"/dev/null","sourceNew":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: r=\" + r + \" liveDocs=\" + liveDocs);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      byte[] minPackedValue = reader.getMinPackedValue();\n      double minLat = decodeLatitude(minPackedValue, 0);\n      double minLon = decodeLongitude(minPackedValue, Integer.BYTES);\n\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      double maxLat = decodeLatitude(maxPackedValue, 0);\n      double maxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n      states.add(reader.getIntersectState(visitor));\n\n      cellQueue.offer(new Cell(i, 1, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minLat, maxLat, minLon, maxLon, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (reader.isLeafNode(cell.nodeID)) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.nodeID, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        byte[] splitPackedValue = cell.maxPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID+1, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c728c2c4e564b70110b013139d764abe136033f2","date":1460649910,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","sourceNew":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      states.add(reader.getIntersectState(visitor));\n\n      cellQueue.offer(new Cell(i, 1, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (reader.isLeafNode(cell.nodeID)) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.nodeID, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        byte[] splitPackedValue = cell.maxPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID+1, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","sourceOld":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: r=\" + r + \" liveDocs=\" + liveDocs);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      byte[] minPackedValue = reader.getMinPackedValue();\n      double minLat = decodeLatitude(minPackedValue, 0);\n      double minLon = decodeLongitude(minPackedValue, Integer.BYTES);\n\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      double maxLat = decodeLatitude(maxPackedValue, 0);\n      double maxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n      states.add(reader.getIntersectState(visitor));\n\n      cellQueue.offer(new Cell(i, 1, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minLat, maxLat, minLon, maxLon, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (reader.isLeafNode(cell.nodeID)) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.nodeID, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        byte[] splitPackedValue = cell.maxPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID+1, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","sourceNew":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","sourceOld":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      states.add(reader.getIntersectState(visitor));\n\n      cellQueue.offer(new Cell(i, 1, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (reader.isLeafNode(cell.nodeID)) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.nodeID, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        byte[] splitPackedValue = cell.maxPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID+1, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","sourceNew":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","sourceOld":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      states.add(reader.getIntersectState(visitor));\n\n      cellQueue.offer(new Cell(i, 1, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (reader.isLeafNode(cell.nodeID)) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.nodeID, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        byte[] splitPackedValue = cell.maxPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        reader.copySplitValue(cell.nodeID, splitPackedValue);\n        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID+1, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor#nearest(double,double,List[BKDReader],List[Bits],List[Integer],int).mjava","sourceNew":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","sourceOld":"  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {\n\n    //System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {\n        @Override\n        public int compare(NearestHit a, NearestHit b) {\n          // sort by opposite distanceMeters natural order\n          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n          if (cmp != 0) {\n            return -cmp;\n          }\n\n          // tie-break by higher docID:\n          return b.docID - a.docID;\n        }\n      });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n    \n    for(int i=0;i<readers.size();i++) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n                               approxBestDistance(minPackedValue, maxPackedValue, pointLat, pointLon)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      //System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        //System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        //System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        //System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        double cellMinLat = decodeLatitude(cell.minPacked, 0);\n        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);\n        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);\n        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);\n\n        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {\n          // this cell is outside our search bbox; don't bother exploring any more\n          continue;\n        }\n        \n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n        \n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["c728c2c4e564b70110b013139d764abe136033f2"],"b01431682e11036a1a7d757a3fa7c1f903fb2c45":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c728c2c4e564b70110b013139d764abe136033f2":["b01431682e11036a1a7d757a3fa7c1f903fb2c45"],"9856095f7afb5a607bf5e65077615ed91273508c":["c728c2c4e564b70110b013139d764abe136033f2","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["88b0212386fe531136816706dc37dc49b9dbf7dc"]},"commit2Childs":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["88b0212386fe531136816706dc37dc49b9dbf7dc","9856095f7afb5a607bf5e65077615ed91273508c"],"b01431682e11036a1a7d757a3fa7c1f903fb2c45":["c728c2c4e564b70110b013139d764abe136033f2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b01431682e11036a1a7d757a3fa7c1f903fb2c45"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c728c2c4e564b70110b013139d764abe136033f2":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}