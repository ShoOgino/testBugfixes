{"path":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef).mjava","commits":[{"id":"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c","date":1310389132,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          futureInputs[outputUpto].keepOrig |= keepOrig;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de11853c992f764e52d4164cc9afdebb989dba8a","date":1313510465,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef).mjava","sourceNew":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","sourceOld":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          futureInputs[outputUpto].keepOrig |= keepOrig;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"de11853c992f764e52d4164cc9afdebb989dba8a":["44d6f0ab53c1962856b9f48dedb7a2a6cc18905c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["de11853c992f764e52d4164cc9afdebb989dba8a"]},"commit2Childs":{"de11853c992f764e52d4164cc9afdebb989dba8a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["44d6f0ab53c1962856b9f48dedb7a2a6cc18905c"],"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c":["de11853c992f764e52d4164cc9afdebb989dba8a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}