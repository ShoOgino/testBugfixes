{"path":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyPruned(int,FST[T],int,int).mjava","commits":[{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"/dev/null","sourceNew":"  // FST is pruned\n  private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n      for(InputOutput<T> pair : pairs) {\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    // To validate the FST, we brute-force compute all prefixes\n    // in the terms, matched to their \"common\" outputs, prune that\n    // set according to the prune thresholds, then assert the FST\n    // matches that same set.\n\n    // NOTE: Crazy RAM intensive!!\n\n    //System.out.println(\"TEST: tally prefixes\");\n\n    // build all prefixes\n    final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n    final IntsRef scratch = new IntsRef(10);\n    for(InputOutput<T> pair: pairs) {\n      scratch.copyInts(pair.input);\n      for(int idx=0;idx<=pair.input.length;idx++) {\n        scratch.length = idx;\n        CountMinOutput<T> cmo = prefixes.get(scratch);\n        if (cmo == null) {\n          cmo = new CountMinOutput<T>();\n          cmo.count = 1;\n          cmo.output = pair.output;\n          prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n        } else {\n          cmo.count++;\n          T output1 = cmo.output;\n          if (output1.equals(outputs.getNoOutput())) {\n            output1 = outputs.getNoOutput();\n          }\n          T output2 = pair.output;\n          if (output2.equals(outputs.getNoOutput())) {\n            output2 = outputs.getNoOutput();\n          }\n          cmo.output = outputs.common(output1, output2);\n        }\n        if (idx == pair.input.length) {\n          cmo.isFinal = true;\n          cmo.finalOutput = cmo.output;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now prune\");\n    }\n\n    // prune 'em\n    final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n    while(it.hasNext()) {\n      Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n      final IntsRef prefix = ent.getKey();\n      final CountMinOutput<T> cmo = ent.getValue();\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n      }\n      final boolean keep;\n      if (prune1 > 0) {\n        keep = cmo.count >= prune1;\n      } else {\n        assert prune2 > 0;\n        if (prune2 > 1 && cmo.count >= prune2) {\n          keep = true;\n        } else if (prefix.length > 0) {\n          // consult our parent\n          scratch.length = prefix.length-1;\n          System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n          //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n          keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n        } else if (cmo.count >= prune2) {\n          keep = true;\n        } else {\n          keep = false;\n        }\n      }\n\n      if (!keep) {\n        it.remove();\n        //System.out.println(\"    remove\");\n      } else {\n        // clear isLeaf for all ancestors\n        //System.out.println(\"    keep\");\n        scratch.copyInts(prefix);\n        scratch.length--;\n        while(scratch.length >= 0) {\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n          if (cmo2 != null) {\n            //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n            cmo2.isLeaf = false;\n          }\n          scratch.length--;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: after prune\");\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n          System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n      }\n    }\n\n    if (prefixes.size() <= 1) {\n      assertNull(fst);\n      return;\n    }\n\n    assertNotNull(fst);\n\n    // make sure FST only enums valid prefixes\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check pruned enum\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n    IntsRefFSTEnum.InputOutput<T> current;\n    while((current = fstEnum.next()) != null) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n      }\n      final CountMinOutput<T> cmo = prefixes.get(current.input);\n      assertNotNull(cmo);\n      assertTrue(cmo.isLeaf || cmo.isFinal);\n      //if (cmo.isFinal && !cmo.isLeaf) {\n      if (cmo.isFinal) {\n        assertEquals(cmo.finalOutput, current.output);\n      } else {\n        assertEquals(cmo.output, current.output);\n      }\n    }\n\n    // make sure all non-pruned prefixes are present in the FST\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify all prefixes\");\n    }\n    final int[] stopNode = new int[1];\n    for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n      if (ent.getKey().length > 0) {\n        final CountMinOutput<T> cmo = ent.getValue();\n        final T output = run(fst, ent.getKey(), stopNode);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n        }\n        // if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, output);\n        } else {\n          assertEquals(cmo.output, output);\n        }\n        assertEquals(ent.getKey().length, stopNode[0]);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"  // FST is pruned\n  private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n      for(InputOutput<T> pair : pairs) {\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    // To validate the FST, we brute-force compute all prefixes\n    // in the terms, matched to their \"common\" outputs, prune that\n    // set according to the prune thresholds, then assert the FST\n    // matches that same set.\n\n    // NOTE: Crazy RAM intensive!!\n\n    //System.out.println(\"TEST: tally prefixes\");\n\n    // build all prefixes\n    final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<>();\n    final IntsRef scratch = new IntsRef(10);\n    for(InputOutput<T> pair: pairs) {\n      scratch.copyInts(pair.input);\n      for(int idx=0;idx<=pair.input.length;idx++) {\n        scratch.length = idx;\n        CountMinOutput<T> cmo = prefixes.get(scratch);\n        if (cmo == null) {\n          cmo = new CountMinOutput<>();\n          cmo.count = 1;\n          cmo.output = pair.output;\n          prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n        } else {\n          cmo.count++;\n          T output1 = cmo.output;\n          if (output1.equals(outputs.getNoOutput())) {\n            output1 = outputs.getNoOutput();\n          }\n          T output2 = pair.output;\n          if (output2.equals(outputs.getNoOutput())) {\n            output2 = outputs.getNoOutput();\n          }\n          cmo.output = outputs.common(output1, output2);\n        }\n        if (idx == pair.input.length) {\n          cmo.isFinal = true;\n          cmo.finalOutput = cmo.output;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now prune\");\n    }\n\n    // prune 'em\n    final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n    while(it.hasNext()) {\n      Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n      final IntsRef prefix = ent.getKey();\n      final CountMinOutput<T> cmo = ent.getValue();\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n      }\n      final boolean keep;\n      if (prune1 > 0) {\n        keep = cmo.count >= prune1;\n      } else {\n        assert prune2 > 0;\n        if (prune2 > 1 && cmo.count >= prune2) {\n          keep = true;\n        } else if (prefix.length > 0) {\n          // consult our parent\n          scratch.length = prefix.length-1;\n          System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n          //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n          keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n        } else if (cmo.count >= prune2) {\n          keep = true;\n        } else {\n          keep = false;\n        }\n      }\n\n      if (!keep) {\n        it.remove();\n        //System.out.println(\"    remove\");\n      } else {\n        // clear isLeaf for all ancestors\n        //System.out.println(\"    keep\");\n        scratch.copyInts(prefix);\n        scratch.length--;\n        while(scratch.length >= 0) {\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n          if (cmo2 != null) {\n            //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n            cmo2.isLeaf = false;\n          }\n          scratch.length--;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: after prune\");\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n          System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n      }\n    }\n\n    if (prefixes.size() <= 1) {\n      assertNull(fst);\n      return;\n    }\n\n    assertNotNull(fst);\n\n    // make sure FST only enums valid prefixes\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check pruned enum\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    IntsRefFSTEnum.InputOutput<T> current;\n    while((current = fstEnum.next()) != null) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n      }\n      final CountMinOutput<T> cmo = prefixes.get(current.input);\n      assertNotNull(cmo);\n      assertTrue(cmo.isLeaf || cmo.isFinal);\n      //if (cmo.isFinal && !cmo.isLeaf) {\n      if (cmo.isFinal) {\n        assertEquals(cmo.finalOutput, current.output);\n      } else {\n        assertEquals(cmo.output, current.output);\n      }\n    }\n\n    // make sure all non-pruned prefixes are present in the FST\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify all prefixes\");\n    }\n    final int[] stopNode = new int[1];\n    for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n      if (ent.getKey().length > 0) {\n        final CountMinOutput<T> cmo = ent.getValue();\n        final T output = run(fst, ent.getKey(), stopNode);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n        }\n        // if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, output);\n        } else {\n          assertEquals(cmo.output, output);\n        }\n        assertEquals(ent.getKey().length, stopNode[0]);\n      }\n    }\n  }\n\n","sourceOld":"  // FST is pruned\n  private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n      for(InputOutput<T> pair : pairs) {\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    // To validate the FST, we brute-force compute all prefixes\n    // in the terms, matched to their \"common\" outputs, prune that\n    // set according to the prune thresholds, then assert the FST\n    // matches that same set.\n\n    // NOTE: Crazy RAM intensive!!\n\n    //System.out.println(\"TEST: tally prefixes\");\n\n    // build all prefixes\n    final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n    final IntsRef scratch = new IntsRef(10);\n    for(InputOutput<T> pair: pairs) {\n      scratch.copyInts(pair.input);\n      for(int idx=0;idx<=pair.input.length;idx++) {\n        scratch.length = idx;\n        CountMinOutput<T> cmo = prefixes.get(scratch);\n        if (cmo == null) {\n          cmo = new CountMinOutput<T>();\n          cmo.count = 1;\n          cmo.output = pair.output;\n          prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n        } else {\n          cmo.count++;\n          T output1 = cmo.output;\n          if (output1.equals(outputs.getNoOutput())) {\n            output1 = outputs.getNoOutput();\n          }\n          T output2 = pair.output;\n          if (output2.equals(outputs.getNoOutput())) {\n            output2 = outputs.getNoOutput();\n          }\n          cmo.output = outputs.common(output1, output2);\n        }\n        if (idx == pair.input.length) {\n          cmo.isFinal = true;\n          cmo.finalOutput = cmo.output;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now prune\");\n    }\n\n    // prune 'em\n    final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n    while(it.hasNext()) {\n      Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n      final IntsRef prefix = ent.getKey();\n      final CountMinOutput<T> cmo = ent.getValue();\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n      }\n      final boolean keep;\n      if (prune1 > 0) {\n        keep = cmo.count >= prune1;\n      } else {\n        assert prune2 > 0;\n        if (prune2 > 1 && cmo.count >= prune2) {\n          keep = true;\n        } else if (prefix.length > 0) {\n          // consult our parent\n          scratch.length = prefix.length-1;\n          System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n          //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n          keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n        } else if (cmo.count >= prune2) {\n          keep = true;\n        } else {\n          keep = false;\n        }\n      }\n\n      if (!keep) {\n        it.remove();\n        //System.out.println(\"    remove\");\n      } else {\n        // clear isLeaf for all ancestors\n        //System.out.println(\"    keep\");\n        scratch.copyInts(prefix);\n        scratch.length--;\n        while(scratch.length >= 0) {\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n          if (cmo2 != null) {\n            //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n            cmo2.isLeaf = false;\n          }\n          scratch.length--;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: after prune\");\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n          System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n      }\n    }\n\n    if (prefixes.size() <= 1) {\n      assertNull(fst);\n      return;\n    }\n\n    assertNotNull(fst);\n\n    // make sure FST only enums valid prefixes\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check pruned enum\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n    IntsRefFSTEnum.InputOutput<T> current;\n    while((current = fstEnum.next()) != null) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n      }\n      final CountMinOutput<T> cmo = prefixes.get(current.input);\n      assertNotNull(cmo);\n      assertTrue(cmo.isLeaf || cmo.isFinal);\n      //if (cmo.isFinal && !cmo.isLeaf) {\n      if (cmo.isFinal) {\n        assertEquals(cmo.finalOutput, current.output);\n      } else {\n        assertEquals(cmo.output, current.output);\n      }\n    }\n\n    // make sure all non-pruned prefixes are present in the FST\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify all prefixes\");\n    }\n    final int[] stopNode = new int[1];\n    for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n      if (ent.getKey().length > 0) {\n        final CountMinOutput<T> cmo = ent.getValue();\n        final T output = run(fst, ent.getKey(), stopNode);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n        }\n        // if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, output);\n        } else {\n          assertEquals(cmo.output, output);\n        }\n        assertEquals(ent.getKey().length, stopNode[0]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"  // FST is pruned\n  private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n      for(InputOutput<T> pair : pairs) {\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    // To validate the FST, we brute-force compute all prefixes\n    // in the terms, matched to their \"common\" outputs, prune that\n    // set according to the prune thresholds, then assert the FST\n    // matches that same set.\n\n    // NOTE: Crazy RAM intensive!!\n\n    //System.out.println(\"TEST: tally prefixes\");\n\n    // build all prefixes\n    final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<>();\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n    for(InputOutput<T> pair: pairs) {\n      scratch.copyInts(pair.input);\n      for(int idx=0;idx<=pair.input.length;idx++) {\n        scratch.setLength(idx);\n        CountMinOutput<T> cmo = prefixes.get(scratch.get());\n        if (cmo == null) {\n          cmo = new CountMinOutput<>();\n          cmo.count = 1;\n          cmo.output = pair.output;\n          prefixes.put(scratch.toIntsRef(), cmo);\n        } else {\n          cmo.count++;\n          T output1 = cmo.output;\n          if (output1.equals(outputs.getNoOutput())) {\n            output1 = outputs.getNoOutput();\n          }\n          T output2 = pair.output;\n          if (output2.equals(outputs.getNoOutput())) {\n            output2 = outputs.getNoOutput();\n          }\n          cmo.output = outputs.common(output1, output2);\n        }\n        if (idx == pair.input.length) {\n          cmo.isFinal = true;\n          cmo.finalOutput = cmo.output;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now prune\");\n    }\n\n    // prune 'em\n    final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n    while(it.hasNext()) {\n      Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n      final IntsRef prefix = ent.getKey();\n      final CountMinOutput<T> cmo = ent.getValue();\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n      }\n      final boolean keep;\n      if (prune1 > 0) {\n        keep = cmo.count >= prune1;\n      } else {\n        assert prune2 > 0;\n        if (prune2 > 1 && cmo.count >= prune2) {\n          keep = true;\n        } else if (prefix.length > 0) {\n          // consult our parent\n          scratch.setLength(prefix.length-1);\n          System.arraycopy(prefix.ints, prefix.offset, scratch.ints(), 0, scratch.length());\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch.get());\n          //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n          keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n        } else if (cmo.count >= prune2) {\n          keep = true;\n        } else {\n          keep = false;\n        }\n      }\n\n      if (!keep) {\n        it.remove();\n        //System.out.println(\"    remove\");\n      } else {\n        // clear isLeaf for all ancestors\n        //System.out.println(\"    keep\");\n        scratch.copyInts(prefix);\n        scratch.setLength(scratch.length() - 1);\n        while(scratch.length() >= 0) {\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch.get());\n          if (cmo2 != null) {\n            //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n            cmo2.isLeaf = false;\n          }\n          scratch.setLength(scratch.length() - 1);\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: after prune\");\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n          System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n      }\n    }\n\n    if (prefixes.size() <= 1) {\n      assertNull(fst);\n      return;\n    }\n\n    assertNotNull(fst);\n\n    // make sure FST only enums valid prefixes\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check pruned enum\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    IntsRefFSTEnum.InputOutput<T> current;\n    while((current = fstEnum.next()) != null) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n      }\n      final CountMinOutput<T> cmo = prefixes.get(current.input);\n      assertNotNull(cmo);\n      assertTrue(cmo.isLeaf || cmo.isFinal);\n      //if (cmo.isFinal && !cmo.isLeaf) {\n      if (cmo.isFinal) {\n        assertEquals(cmo.finalOutput, current.output);\n      } else {\n        assertEquals(cmo.output, current.output);\n      }\n    }\n\n    // make sure all non-pruned prefixes are present in the FST\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify all prefixes\");\n    }\n    final int[] stopNode = new int[1];\n    for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n      if (ent.getKey().length > 0) {\n        final CountMinOutput<T> cmo = ent.getValue();\n        final T output = run(fst, ent.getKey(), stopNode);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n        }\n        // if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, output);\n        } else {\n          assertEquals(cmo.output, output);\n        }\n        assertEquals(ent.getKey().length, stopNode[0]);\n      }\n    }\n  }\n\n","sourceOld":"  // FST is pruned\n  private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n      for(InputOutput<T> pair : pairs) {\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    // To validate the FST, we brute-force compute all prefixes\n    // in the terms, matched to their \"common\" outputs, prune that\n    // set according to the prune thresholds, then assert the FST\n    // matches that same set.\n\n    // NOTE: Crazy RAM intensive!!\n\n    //System.out.println(\"TEST: tally prefixes\");\n\n    // build all prefixes\n    final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<>();\n    final IntsRef scratch = new IntsRef(10);\n    for(InputOutput<T> pair: pairs) {\n      scratch.copyInts(pair.input);\n      for(int idx=0;idx<=pair.input.length;idx++) {\n        scratch.length = idx;\n        CountMinOutput<T> cmo = prefixes.get(scratch);\n        if (cmo == null) {\n          cmo = new CountMinOutput<>();\n          cmo.count = 1;\n          cmo.output = pair.output;\n          prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n        } else {\n          cmo.count++;\n          T output1 = cmo.output;\n          if (output1.equals(outputs.getNoOutput())) {\n            output1 = outputs.getNoOutput();\n          }\n          T output2 = pair.output;\n          if (output2.equals(outputs.getNoOutput())) {\n            output2 = outputs.getNoOutput();\n          }\n          cmo.output = outputs.common(output1, output2);\n        }\n        if (idx == pair.input.length) {\n          cmo.isFinal = true;\n          cmo.finalOutput = cmo.output;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now prune\");\n    }\n\n    // prune 'em\n    final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n    while(it.hasNext()) {\n      Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n      final IntsRef prefix = ent.getKey();\n      final CountMinOutput<T> cmo = ent.getValue();\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n      }\n      final boolean keep;\n      if (prune1 > 0) {\n        keep = cmo.count >= prune1;\n      } else {\n        assert prune2 > 0;\n        if (prune2 > 1 && cmo.count >= prune2) {\n          keep = true;\n        } else if (prefix.length > 0) {\n          // consult our parent\n          scratch.length = prefix.length-1;\n          System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n          //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n          keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n        } else if (cmo.count >= prune2) {\n          keep = true;\n        } else {\n          keep = false;\n        }\n      }\n\n      if (!keep) {\n        it.remove();\n        //System.out.println(\"    remove\");\n      } else {\n        // clear isLeaf for all ancestors\n        //System.out.println(\"    keep\");\n        scratch.copyInts(prefix);\n        scratch.length--;\n        while(scratch.length >= 0) {\n          final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n          if (cmo2 != null) {\n            //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n            cmo2.isLeaf = false;\n          }\n          scratch.length--;\n        }\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: after prune\");\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n          System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n      }\n    }\n\n    if (prefixes.size() <= 1) {\n      assertNull(fst);\n      return;\n    }\n\n    assertNotNull(fst);\n\n    // make sure FST only enums valid prefixes\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check pruned enum\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    IntsRefFSTEnum.InputOutput<T> current;\n    while((current = fstEnum.next()) != null) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n      }\n      final CountMinOutput<T> cmo = prefixes.get(current.input);\n      assertNotNull(cmo);\n      assertTrue(cmo.isLeaf || cmo.isFinal);\n      //if (cmo.isFinal && !cmo.isLeaf) {\n      if (cmo.isFinal) {\n        assertEquals(cmo.finalOutput, current.output);\n      } else {\n        assertEquals(cmo.output, current.output);\n      }\n    }\n\n    // make sure all non-pruned prefixes are present in the FST\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify all prefixes\");\n    }\n    final int[] stopNode = new int[1];\n    for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n      if (ent.getKey().length > 0) {\n        final CountMinOutput<T> cmo = ent.getValue();\n        final T output = run(fst, ent.getKey(), stopNode);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n        }\n        // if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, output);\n        } else {\n          assertEquals(cmo.output, output);\n        }\n        assertEquals(ent.getKey().length, stopNode[0]);\n      }\n    }\n  }\n\n","bugFix":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}