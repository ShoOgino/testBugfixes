{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), false);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), false);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), 0);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), false);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","bugFix":["872cff1d3a554e0cd64014cd97f88d3002b0f491"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), 0);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), false);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), 0);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), false);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e3613d9274c0d98ca67d976e415c82e9f9cf46","date":1352285414,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  @Override\n  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), 0);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), 0);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1","date":1353511594,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  @Override\n  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length() == 0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(path), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(path, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), 0);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  @Override\n  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length() == 0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(path), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(path, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length()==0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized(ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res!=null) {\n        return res.intValue();\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    try {\n      indexReaderLock.readLock().lock();\n      // TODO (Facet): avoid Multi*?\n      Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n      DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, liveDocs, Consts.FULL, new BytesRef(path), 0);\n      if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        ret = docs.docID();\n      }\n    } finally {\n      indexReaderLock.readLock().unlock();\n    }\n\n    // Put the new value in the cache. Note that it is possible that while\n    // we were doing the above fetching (without the cache locked), some\n    // other thread already added the same category to the cache. We do\n    // not care about this possibilty, as LRUCache replaces previous values\n    // of the same keys (it doesn't store duplicates).\n    synchronized(ordinalCache) {\n      // GB: new Integer(int); creates a new object each and every time.\n      // Integer.valueOf(int) might not (See JavaDoc). \n      ordinalCache.put(path, Integer.valueOf(ret));\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","date":1357499264,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  @Override\n  public int getOrdinal(CategoryPath cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(cp.toString(delimiter)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length() == 0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(path), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(path, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  @Override\n  public int getOrdinal(CategoryPath cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(cp.toString(delimiter)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(CategoryPath categoryPath) throws IOException {\n    ensureOpen();\n    if (categoryPath.length() == 0) {\n      return ROOT_ORDINAL;\n    }\n    String path = categoryPath.toString(delimiter);\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(path);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(path), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(path, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(cp.toString(delimiter)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(CategoryPath cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(cp.toString(delimiter)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":null,"sourceOld":"  @Override\n  public int getOrdinal(CategoryPath cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(cp.toString(delimiter)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"407687e67faf6e1f02a211ca078d8e3eed631027":["78e3613d9274c0d98ca67d976e415c82e9f9cf46","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"78e3613d9274c0d98ca67d976e415c82e9f9cf46":["02331260bb246364779cb6f04919ca47900d01bb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["b89678825b68eccaf09e6ab71675fc0b0af1e099","02331260bb246364779cb6f04919ca47900d01bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["b89678825b68eccaf09e6ab71675fc0b0af1e099","02331260bb246364779cb6f04919ca47900d01bb"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"02331260bb246364779cb6f04919ca47900d01bb":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["407687e67faf6e1f02a211ca078d8e3eed631027","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c190847801a50f4dd20fd639bdc29b54ea3b288b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","02331260bb246364779cb6f04919ca47900d01bb"],"78e3613d9274c0d98ca67d976e415c82e9f9cf46":["407687e67faf6e1f02a211ca078d8e3eed631027","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"02331260bb246364779cb6f04919ca47900d01bb":["78e3613d9274c0d98ca67d976e415c82e9f9cf46","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}