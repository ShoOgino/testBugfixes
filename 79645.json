{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.TraversalStrategy#apply(GeoPoint,boolean,double,double,double).mjava","commits":[{"id":"6b04a6a507e06fd3523a15fac87b8311583936fa","date":1525083151,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.TraversalStrategy#apply(GeoPoint,boolean,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"    public boolean apply(final GeoPoint testPoint, final boolean testPointInSet,\n      final double x, final double y, final double z) {\n      // First, try with two individual legs.  If that doesn't work, try the DualCrossingIterator.\n      try {\n        // First, we'll determine if the intersection point is in set or not\n        //System.out.println(\" Finding whether \"+intersectionPoint+\" is in-set, based on travel from \"+testPoint+\" along \"+firstLegPlane+\" (value=\"+firstLegValue+\")\");\n        final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n        // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n        firstLegTree.traverse(testPointEdgeIterator, firstLegValue);\n        final boolean intersectionPointOnEdge = testPointEdgeIterator.isOnEdge();\n        // If the intersection point is on the edge, we cannot use this combination of legs, since it's not logically possible to compute in-set or out-of-set\n        // with such a starting point.\n        if (intersectionPointOnEdge) {\n          throw new IllegalArgumentException(\"Intersection point landed on an edge -- illegal path\");\n        }\n        final boolean intersectionPointInSet = intersectionPointOnEdge || (((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n        \n        //System.out.println(\"  Intersection point in-set? \"+intersectionPointInSet+\" On edge? \"+intersectionPointOnEdge);\n\n        // Now do the final leg\n        //System.out.println(\" Finding whether [\"+x+\",\"+y+\",\"+z+\"] is in-set, based on travel from \"+intersectionPoint+\" along \"+secondLegPlane+\" (value=\"+secondLegValue+\")\");\n        final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z);\n        // Traverse our way from the test point to the check point.\n        secondLegTree.traverse(travelEdgeIterator, secondLegValue);\n        final boolean rval = travelEdgeIterator.isOnEdge() || (((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet);\n        \n        //System.out.println(\" Check point in set? \"+rval);\n        return rval;\n      } catch (IllegalArgumentException e) {\n        // Intersection point apparently was on edge, so try another strategy\n        final CountingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z, intersectionPoint);\n        firstLegTree.traverse(edgeIterator, firstLegValue);\n        if (edgeIterator.isOnEdge()) {\n          return true;\n        }\n        secondLegTree.traverse(edgeIterator, secondLegValue);\n        return edgeIterator.isOnEdge() || (((edgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cd25c083a7199445f2db6f32d322eeac1afc99e","date":1527642183,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.TraversalStrategy#apply(GeoPoint,boolean,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.TraversalStrategy#apply(GeoPoint,boolean,double,double,double).mjava","sourceNew":"    public boolean apply(final GeoPoint testPoint, final boolean testPointInSet,\n      final double x, final double y, final double z) {\n      // First, try with two individual legs.  If that doesn't work, try the DualCrossingIterator.\n      try {\n        // First, we'll determine if the intersection point is in set or not\n        //System.out.println(\" Finding whether \"+intersectionPoint+\" is in-set, based on travel from \"+testPoint+\" along \"+firstLegPlane+\" (value=\"+firstLegValue+\")\");\n        final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n        // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n        firstLegTree.traverse(testPointEdgeIterator, firstLegValue);\n        final boolean intersectionPointOnEdge = testPointEdgeIterator.isOnEdge();\n        // If the intersection point is on the edge, we cannot use this combination of legs, since it's not logically possible to compute in-set or out-of-set\n        // with such a starting point.\n        if (intersectionPointOnEdge) {\n          throw new IllegalArgumentException(\"Intersection point landed on an edge -- illegal path\");\n        }\n        final boolean intersectionPointInSet = intersectionPointOnEdge || (((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n        \n        //System.out.println(\"  Intersection point in-set? \"+intersectionPointInSet+\" On edge? \"+intersectionPointOnEdge);\n\n        // Now do the final leg\n        //System.out.println(\" Finding whether [\"+x+\",\"+y+\",\"+z+\"] is in-set, based on travel from \"+intersectionPoint+\" along \"+secondLegPlane+\" (value=\"+secondLegValue+\")\");\n        final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z);\n        // Traverse our way from the test point to the check point.\n        secondLegTree.traverse(travelEdgeIterator, secondLegValue);\n        final boolean rval = travelEdgeIterator.isOnEdge() || (((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet);\n        \n        //System.out.println(\" Check point in set? \"+rval);\n        return rval;\n      } catch (IllegalArgumentException e) {\n        // Intersection point apparently was on edge, so try another strategy\n        //System.out.println(\" Trying dual crossing edge iterator\");\n        final CountingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z, intersectionPoint);\n        firstLegTree.traverse(edgeIterator, firstLegValue);\n        if (edgeIterator.isOnEdge()) {\n          return true;\n        }\n        secondLegTree.traverse(edgeIterator, secondLegValue);\n        return edgeIterator.isOnEdge() || (((edgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n      }\n    }\n\n","sourceOld":"    public boolean apply(final GeoPoint testPoint, final boolean testPointInSet,\n      final double x, final double y, final double z) {\n      // First, try with two individual legs.  If that doesn't work, try the DualCrossingIterator.\n      try {\n        // First, we'll determine if the intersection point is in set or not\n        //System.out.println(\" Finding whether \"+intersectionPoint+\" is in-set, based on travel from \"+testPoint+\" along \"+firstLegPlane+\" (value=\"+firstLegValue+\")\");\n        final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n        // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n        firstLegTree.traverse(testPointEdgeIterator, firstLegValue);\n        final boolean intersectionPointOnEdge = testPointEdgeIterator.isOnEdge();\n        // If the intersection point is on the edge, we cannot use this combination of legs, since it's not logically possible to compute in-set or out-of-set\n        // with such a starting point.\n        if (intersectionPointOnEdge) {\n          throw new IllegalArgumentException(\"Intersection point landed on an edge -- illegal path\");\n        }\n        final boolean intersectionPointInSet = intersectionPointOnEdge || (((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n        \n        //System.out.println(\"  Intersection point in-set? \"+intersectionPointInSet+\" On edge? \"+intersectionPointOnEdge);\n\n        // Now do the final leg\n        //System.out.println(\" Finding whether [\"+x+\",\"+y+\",\"+z+\"] is in-set, based on travel from \"+intersectionPoint+\" along \"+secondLegPlane+\" (value=\"+secondLegValue+\")\");\n        final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z);\n        // Traverse our way from the test point to the check point.\n        secondLegTree.traverse(travelEdgeIterator, secondLegValue);\n        final boolean rval = travelEdgeIterator.isOnEdge() || (((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet);\n        \n        //System.out.println(\" Check point in set? \"+rval);\n        return rval;\n      } catch (IllegalArgumentException e) {\n        // Intersection point apparently was on edge, so try another strategy\n        final CountingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z, intersectionPoint);\n        firstLegTree.traverse(edgeIterator, firstLegValue);\n        if (edgeIterator.isOnEdge()) {\n          return true;\n        }\n        secondLegTree.traverse(edgeIterator, secondLegValue);\n        return edgeIterator.isOnEdge() || (((edgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6b04a6a507e06fd3523a15fac87b8311583936fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cd25c083a7199445f2db6f32d322eeac1afc99e":["6b04a6a507e06fd3523a15fac87b8311583936fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cd25c083a7199445f2db6f32d322eeac1afc99e"]},"commit2Childs":{"6b04a6a507e06fd3523a15fac87b8311583936fa":["3cd25c083a7199445f2db6f32d322eeac1afc99e"],"3cd25c083a7199445f2db6f32d322eeac1afc99e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6b04a6a507e06fd3523a15fac87b8311583936fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}