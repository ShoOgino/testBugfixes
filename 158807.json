{"path":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","commits":[{"id":"770281b8a8459cafcdd2354b6a06078fea2d83c9","date":1077308096,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * \n   * @param fieldNum The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector\n    if (numTerms == 0) return new SegmentTermVector(field, null, null);\n\n    int length = numTerms + tvf.readVInt();\n\n    String terms[] = new String[numTerms];\n    \n    int termFreqs[] = new int[numTerms];\n\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = {};\n    String previousString = \"\";\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength)\n      {\n        buffer = new char[totalLength];\n        for (int j = 0; j < previousString.length(); j++)  // copy contents\n          buffer[j] = previousString.charAt(j);\n      }\n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousString = terms[i];\n      termFreqs[i] = tvf.readVInt();\n    }\n    SegmentTermVector tv = new SegmentTermVector(field, terms, termFreqs);\n    return tv;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87db844581c7233592c7f27f51c72354697ace34","date":1091825400,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector\n    if (numTerms == 0) return new SegmentTermVector(field, null, null);\n\n    int length = numTerms + tvf.readVInt();\n\n    String terms[] = new String[numTerms];\n    \n    int termFreqs[] = new int[numTerms];\n\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = {};\n    String previousString = \"\";\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength)\n      {\n        buffer = new char[totalLength];\n        for (int j = 0; j < previousString.length(); j++)  // copy contents\n          buffer[j] = previousString.charAt(j);\n      }\n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousString = terms[i];\n      termFreqs[i] = tvf.readVInt();\n    }\n    SegmentTermVector tv = new SegmentTermVector(field, terms, termFreqs);\n    return tv;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param fieldNum The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector\n    if (numTerms == 0) return new SegmentTermVector(field, null, null);\n\n    int length = numTerms + tvf.readVInt();\n\n    String terms[] = new String[numTerms];\n    \n    int termFreqs[] = new int[numTerms];\n\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = {};\n    String previousString = \"\";\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength)\n      {\n        buffer = new char[totalLength];\n        for (int j = 0; j < previousString.length(); j++)  // copy contents\n          buffer[j] = previousString.charAt(j);\n      }\n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousString = terms[i];\n      termFreqs[i] = tvf.readVInt();\n    }\n    SegmentTermVector tv = new SegmentTermVector(field, terms, termFreqs);\n    return tv;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11f65ca883c12cb520aa6deffe97701dde4f18c8","date":1092775996,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector\n    if (numTerms == 0) return new SegmentTermVector(field, null, null);\n\n    tvf.readVInt();\n    \n    String terms[] = new String[numTerms];\n    \n    int termFreqs[] = new int[numTerms];\n\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = {};\n    String previousString = \"\";\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength)\n      {\n        buffer = new char[totalLength];\n        for (int j = 0; j < previousString.length(); j++)  // copy contents\n          buffer[j] = previousString.charAt(j);\n      }\n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousString = terms[i];\n      termFreqs[i] = tvf.readVInt();\n    }\n    SegmentTermVector tv = new SegmentTermVector(field, terms, termFreqs);\n    return tv;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector\n    if (numTerms == 0) return new SegmentTermVector(field, null, null);\n\n    int length = numTerms + tvf.readVInt();\n\n    String terms[] = new String[numTerms];\n    \n    int termFreqs[] = new int[numTerms];\n\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = {};\n    String previousString = \"\";\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength)\n      {\n        buffer = new char[totalLength];\n        for (int j = 0; j < previousString.length(); j++)  // copy contents\n          buffer[j] = previousString.charAt(j);\n      }\n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousString = terms[i];\n      termFreqs[i] = tvf.readVInt();\n    }\n    SegmentTermVector tv = new SegmentTermVector(field, terms, termFreqs);\n    return tv;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6177f0f28ace66d1538b1e6ac5f1773e5449a0b0","date":1096997448,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return new SegmentTermVector(field, null, null);\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == TermVectorsWriter.FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & TermVectorsWriter.STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & TermVectorsWriter.STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n\n    String terms[] = new String[numTerms];\n    int termFreqs[] = new int[numTerms];\n    \n    //  we may not need these, but declare them\n    int positions[][] = null;\n    TermVectorOffsetInfo offsets[][] = null;\n    if(storePositions)\n      positions = new int[numTerms][];\n    if(storeOffsets)\n      offsets = new TermVectorOffsetInfo[numTerms][];\n    \n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = {};\n    String previousString = \"\";\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength)\n      {\n        buffer = new char[totalLength];\n        for (int j = 0; j < previousString.length(); j++)  // copy contents\n          buffer[j] = previousString.charAt(j);\n      }\n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousString = terms[i];\n      int freq = tvf.readVInt();\n      termFreqs[i] = freq;\n      \n      if (storePositions) { //read in the positions\n        int [] pos = new int[freq];\n        positions[i] = pos;\n        int prevPosition = 0;\n        for (int j = 0; j < freq; j++)\n        {\n          pos[j] = prevPosition + tvf.readVInt();\n          prevPosition = pos[j];\n        }\n      }\n      \n      if (storeOffsets) {\n        TermVectorOffsetInfo[] offs = new TermVectorOffsetInfo[freq];\n        offsets[i] = offs;\n        int prevOffset = 0;\n        for (int j = 0; j < freq; j++) {\n          int startOffset = prevOffset + tvf.readVInt();\n          int endOffset = startOffset + tvf.readVInt();\n          offs[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n          prevOffset = endOffset;\n        }\n      }\n    }\n    \n    SegmentTermVector tv;\n    if (storePositions || storeOffsets){\n      tv = new SegmentTermPositionVector(field, terms, termFreqs, positions, offsets);\n    }\n    else {\n      tv = new SegmentTermVector(field, terms, termFreqs);\n    }\n    return tv;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector\n    if (numTerms == 0) return new SegmentTermVector(field, null, null);\n\n    tvf.readVInt();\n    \n    String terms[] = new String[numTerms];\n    \n    int termFreqs[] = new int[numTerms];\n\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = {};\n    String previousString = \"\";\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength)\n      {\n        buffer = new char[totalLength];\n        for (int j = 0; j < previousString.length(); j++)  // copy contents\n          buffer[j] = previousString.charAt(j);\n      }\n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousString = terms[i];\n      termFreqs[i] = tvf.readVInt();\n    }\n    SegmentTermVector tv = new SegmentTermVector(field, terms, termFreqs);\n    return tv;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"802a9ee1b623e3adb3177d6bf2472489a4f12989","date":1116169479,"type":3,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return new SegmentTermVector(field, null, null);\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == TermVectorsWriter.FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & TermVectorsWriter.STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & TermVectorsWriter.STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n\n    String terms[] = new String[numTerms];\n    int termFreqs[] = new int[numTerms];\n    \n    //  we may not need these, but declare them\n    int positions[][] = null;\n    TermVectorOffsetInfo offsets[][] = null;\n    if(storePositions)\n      positions = new int[numTerms][];\n    if(storeOffsets)\n      offsets = new TermVectorOffsetInfo[numTerms][];\n    \n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      termFreqs[i] = freq;\n      \n      if (storePositions) { //read in the positions\n        int [] pos = new int[freq];\n        positions[i] = pos;\n        int prevPosition = 0;\n        for (int j = 0; j < freq; j++)\n        {\n          pos[j] = prevPosition + tvf.readVInt();\n          prevPosition = pos[j];\n        }\n      }\n      \n      if (storeOffsets) {\n        TermVectorOffsetInfo[] offs = new TermVectorOffsetInfo[freq];\n        offsets[i] = offs;\n        int prevOffset = 0;\n        for (int j = 0; j < freq; j++) {\n          int startOffset = prevOffset + tvf.readVInt();\n          int endOffset = startOffset + tvf.readVInt();\n          offs[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n          prevOffset = endOffset;\n        }\n      }\n    }\n    \n    SegmentTermVector tv;\n    if (storePositions || storeOffsets){\n      tv = new SegmentTermPositionVector(field, terms, termFreqs, positions, offsets);\n    }\n    else {\n      tv = new SegmentTermVector(field, terms, termFreqs);\n    }\n    return tv;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return new SegmentTermVector(field, null, null);\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == TermVectorsWriter.FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & TermVectorsWriter.STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & TermVectorsWriter.STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n\n    String terms[] = new String[numTerms];\n    int termFreqs[] = new int[numTerms];\n    \n    //  we may not need these, but declare them\n    int positions[][] = null;\n    TermVectorOffsetInfo offsets[][] = null;\n    if(storePositions)\n      positions = new int[numTerms][];\n    if(storeOffsets)\n      offsets = new TermVectorOffsetInfo[numTerms][];\n    \n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = {};\n    String previousString = \"\";\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength)\n      {\n        buffer = new char[totalLength];\n        for (int j = 0; j < previousString.length(); j++)  // copy contents\n          buffer[j] = previousString.charAt(j);\n      }\n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousString = terms[i];\n      int freq = tvf.readVInt();\n      termFreqs[i] = freq;\n      \n      if (storePositions) { //read in the positions\n        int [] pos = new int[freq];\n        positions[i] = pos;\n        int prevPosition = 0;\n        for (int j = 0; j < freq; j++)\n        {\n          pos[j] = prevPosition + tvf.readVInt();\n          prevPosition = pos[j];\n        }\n      }\n      \n      if (storeOffsets) {\n        TermVectorOffsetInfo[] offs = new TermVectorOffsetInfo[freq];\n        offsets[i] = offs;\n        int prevOffset = 0;\n        for (int j = 0; j < freq; j++) {\n          int startOffset = prevOffset + tvf.readVInt();\n          int endOffset = startOffset + tvf.readVInt();\n          offs[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n          prevOffset = endOffset;\n        }\n      }\n    }\n    \n    SegmentTermVector tv;\n    if (storePositions || storeOffsets){\n      tv = new SegmentTermPositionVector(field, terms, termFreqs, positions, offsets);\n    }\n    else {\n      tv = new SegmentTermVector(field, terms, termFreqs);\n    }\n    return tv;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"352bfe1fae83b92d1562f01c057bfbe6f5af3ddb","date":1185160645,"type":5,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == TermVectorsWriter.FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & TermVectorsWriter.STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & TermVectorsWriter.STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      String term = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return new SegmentTermVector(field, null, null);\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == TermVectorsWriter.FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & TermVectorsWriter.STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & TermVectorsWriter.STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n\n    String terms[] = new String[numTerms];\n    int termFreqs[] = new int[numTerms];\n    \n    //  we may not need these, but declare them\n    int positions[][] = null;\n    TermVectorOffsetInfo offsets[][] = null;\n    if(storePositions)\n      positions = new int[numTerms][];\n    if(storeOffsets)\n      offsets = new TermVectorOffsetInfo[numTerms][];\n    \n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      termFreqs[i] = freq;\n      \n      if (storePositions) { //read in the positions\n        int [] pos = new int[freq];\n        positions[i] = pos;\n        int prevPosition = 0;\n        for (int j = 0; j < freq; j++)\n        {\n          pos[j] = prevPosition + tvf.readVInt();\n          prevPosition = pos[j];\n        }\n      }\n      \n      if (storeOffsets) {\n        TermVectorOffsetInfo[] offs = new TermVectorOffsetInfo[freq];\n        offsets[i] = offs;\n        int prevOffset = 0;\n        for (int j = 0; j < freq; j++) {\n          int startOffset = prevOffset + tvf.readVInt();\n          int endOffset = startOffset + tvf.readVInt();\n          offs[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n          prevOffset = endOffset;\n        }\n      }\n    }\n    \n    SegmentTermVector tv;\n    if (storePositions || storeOffsets){\n      tv = new SegmentTermPositionVector(field, terms, termFreqs, positions, offsets);\n    }\n    else {\n      tv = new SegmentTermVector(field, terms, termFreqs);\n    }\n    return tv;\n  }\n\n","bugFix":null,"bugIntro":["11764865fb318bf86302eab36bdf9cd00c50c110"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"770281b8a8459cafcdd2354b6a06078fea2d83c9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"87db844581c7233592c7f27f51c72354697ace34":["770281b8a8459cafcdd2354b6a06078fea2d83c9"],"802a9ee1b623e3adb3177d6bf2472489a4f12989":["6177f0f28ace66d1538b1e6ac5f1773e5449a0b0"],"352bfe1fae83b92d1562f01c057bfbe6f5af3ddb":["802a9ee1b623e3adb3177d6bf2472489a4f12989"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"11f65ca883c12cb520aa6deffe97701dde4f18c8":["87db844581c7233592c7f27f51c72354697ace34"],"6177f0f28ace66d1538b1e6ac5f1773e5449a0b0":["11f65ca883c12cb520aa6deffe97701dde4f18c8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["352bfe1fae83b92d1562f01c057bfbe6f5af3ddb"]},"commit2Childs":{"770281b8a8459cafcdd2354b6a06078fea2d83c9":["87db844581c7233592c7f27f51c72354697ace34"],"87db844581c7233592c7f27f51c72354697ace34":["11f65ca883c12cb520aa6deffe97701dde4f18c8"],"802a9ee1b623e3adb3177d6bf2472489a4f12989":["352bfe1fae83b92d1562f01c057bfbe6f5af3ddb"],"352bfe1fae83b92d1562f01c057bfbe6f5af3ddb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["770281b8a8459cafcdd2354b6a06078fea2d83c9"],"11f65ca883c12cb520aa6deffe97701dde4f18c8":["6177f0f28ace66d1538b1e6ac5f1773e5449a0b0"],"6177f0f28ace66d1538b1e6ac5f1773e5449a0b0":["802a9ee1b623e3adb3177d6bf2472489a4f12989"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}