{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts[target.node]++;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.length) {\n        nodeAddress = ArrayUtil.grow(nodeAddress);\n        inCounts = ArrayUtil.grow(inCounts);\n      }\n      nodeAddress[nodeCount] = endAddress;\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts[target.node]++;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.length) {\n        nodeAddress = ArrayUtil.grow(nodeAddress);\n        inCounts = ArrayUtil.grow(inCounts);\n      }\n      nodeAddress[nodeCount] = endAddress;\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts[target.node]++;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.length) {\n        nodeAddress = ArrayUtil.grow(nodeAddress);\n        inCounts = ArrayUtil.grow(inCounts);\n      }\n      nodeAddress[nodeCount] = endAddress;\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45155bce1f2625f94a75296bb8a509d5d3265294","date":1342560816,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.write(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cb27634f76319b68d6d8fd11a7104d20294722c5","date":1355210077,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.getPosition();\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.getPosition() - lastArcStart;\n        lastArcStart = writer.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.setPosition(destPos);\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.getPosition() - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.getPosition();\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.getPosition() - lastArcStart;\n        lastArcStart = writer.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.setPosition(destPos);\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.getPosition() - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.posWrite;\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.posWrite;\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.posWrite;\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.posWrite - lastArcStart;\n        lastArcStart = writer.posWrite;\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.posWrite;\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.posWrite = destPos;\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.posWrite - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      bytes.writeByte(ARCS_AS_FIXED_ARRAY);\n      bytes.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      bytes.writeInt(0);\n      fixedArrayStart = bytes.getPosition();\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = bytes.getPosition() - lastArcStart;\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // TODO: we could make this a vInt instead\n      bytes.writeInt(fixedArrayStart-4, maxBytesPerArc);\n\n      // expand the arcs in place, backwards\n      int srcPos = bytes.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skip(destPos - srcPos);\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n    }\n\n    final int thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.getPosition();\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.getPosition() - lastArcStart;\n        lastArcStart = writer.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.setPosition(destPos);\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.getPosition() - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":["7f32ed90e12610550e1363aea43afe3d6e292cf9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"556c8202987f72dd8458e25e21a82d98fc274979","date":1358008288,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      bytes.writeByte(ARCS_AS_FIXED_ARRAY);\n      bytes.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      bytes.writeInt(0);\n      fixedArrayStart = bytes.getPosition();\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = bytes.getPosition() - lastArcStart;\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // TODO: we could make this a vInt instead\n      bytes.writeInt(fixedArrayStart-4, maxBytesPerArc);\n\n      // expand the arcs in place, backwards\n      int srcPos = bytes.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skip(destPos - srcPos);\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n    }\n\n    final int thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      bytes.writeByte(ARCS_AS_FIXED_ARRAY);\n      bytes.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      bytes.writeInt(0);\n      fixedArrayStart = bytes.getPosition();\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = bytes.getPosition() - lastArcStart;\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // TODO: we could make this a vInt instead\n      bytes.writeInt(fixedArrayStart-4, maxBytesPerArc);\n\n      // expand the arcs in place, backwards\n      int srcPos = bytes.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skip(destPos - srcPos);\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n    }\n\n    final int thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc6d3be942e675e8251dbe10796cdb3a484bf607","date":1358026184,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final int startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = bytes.getPosition() - lastArcStart;\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      assert ((long) startAddress+MAX_HEADER_SIZE) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final int fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      int srcPos = bytes.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skip(destPos - srcPos);\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final int thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      bytes.writeByte(ARCS_AS_FIXED_ARRAY);\n      bytes.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      bytes.writeInt(0);\n      fixedArrayStart = bytes.getPosition();\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = bytes.getPosition() - lastArcStart;\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // TODO: we could make this a vInt instead\n      bytes.writeInt(fixedArrayStart-4, maxBytesPerArc);\n\n      // expand the arcs in place, backwards\n      int srcPos = bytes.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skip(destPos - srcPos);\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n    }\n\n    final int thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73e44327cb5401cc5098da2f488c899954c9bfbc","date":1358092175,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final int startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = bytes.getPosition() - lastArcStart;\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      assert ((long) startAddress+MAX_HEADER_SIZE) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final int fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      int srcPos = bytes.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skipBytes(destPos - srcPos);\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final int thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final int startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = bytes.getPosition() - lastArcStart;\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      assert ((long) startAddress+MAX_HEADER_SIZE) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final int fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      int srcPos = bytes.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skip(destPos - srcPos);\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final int thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = (int) (bytes.getPosition() - lastArcStart);\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final int startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = bytes.getPosition() - lastArcStart;\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      assert ((long) startAddress+MAX_HEADER_SIZE) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final int fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      int srcPos = bytes.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skipBytes(destPos - srcPos);\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final int thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":null,"bugIntro":["7f32ed90e12610550e1363aea43afe3d6e292cf9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = (int) (bytes.getPosition() - lastArcStart);\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  int addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    //System.out.println(\"FST.addNode pos=\" + writer.posWrite + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    int startAddress = writer.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    final int fixedArrayStart;\n    if (doFixedArray) {\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n      // write a \"false\" first arc:\n      writer.writeByte(ARCS_AS_FIXED_ARRAY);\n      writer.writeVInt(nodeIn.numArcs);\n      // placeholder -- we'll come back and write the number\n      // of bytes per arc (int) here:\n      // TODO: we could make this a vInt instead\n      writer.writeInt(0);\n      fixedArrayStart = writer.getPosition();\n      //System.out.println(\"  do fixed arcs array arcsStart=\" + fixedArrayStart);\n    } else {\n      fixedArrayStart = 0;\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    int lastArcStart = writer.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set(target.node, inCounts.get(target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      writer.writeByte((byte) flags);\n      writeLabel(arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + writer.posWrite + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, writer);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        writer.writeInt(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = writer.getPosition() - lastArcStart;\n        lastArcStart = writer.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: if arc'd arrays will be \"too wasteful\" by some\n    // measure, eg if arcs have vastly different sized\n    // outputs, then we should selectively disable array for\n    // such cases\n\n    if (doFixedArray) {\n      //System.out.println(\"  doFixedArray\");\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n      final int sizeNeeded = fixedArrayStart + nodeIn.numArcs * maxBytesPerArc;\n      assert ((long) fixedArrayStart) + ((long) nodeIn.numArcs) * maxBytesPerArc < Integer.MAX_VALUE: \"FST too large (> 2.1 GB)\";\n\n      bytes = ArrayUtil.grow(bytes, sizeNeeded);\n      // TODO: we could make this a vInt instead\n      bytes[fixedArrayStart-4] = (byte) (maxBytesPerArc >> 24);\n      bytes[fixedArrayStart-3] = (byte) (maxBytesPerArc >> 16);\n      bytes[fixedArrayStart-2] = (byte) (maxBytesPerArc >> 8);\n      bytes[fixedArrayStart-1] = (byte) maxBytesPerArc;\n\n      // expand the arcs in place, backwards\n      int srcPos = writer.getPosition();\n      int destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      writer.setPosition(destPos);\n      for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n        //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n        destPos -= maxBytesPerArc;\n        srcPos -= bytesPerArc[arcIdx];\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          System.arraycopy(bytes, srcPos, bytes, destPos, bytesPerArc[arcIdx]);\n        }\n      }\n    }\n\n    // reverse bytes in-place; we do this so that the\n    // \"BIT_TARGET_NEXT\" opto can work, ie, it reads the\n    // node just before the current one\n    final int endAddress = writer.getPosition() - 1;\n\n    int left = startAddress;\n    int right = endAddress;\n    while (left < right) {\n      final byte b = bytes[left];\n      bytes[left++] = bytes[right];\n      bytes[right--] = b;\n    }\n    //System.out.println(\"  endAddress=\" + endAddress);\n\n    nodeCount++;\n    final int node;\n    if (nodeAddress != null) {\n      // Nodes are addressed by 1+ord:\n      if (nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set(nodeCount, endAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = endAddress;\n    }\n    lastFrozenNode = node;\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f32ed90e12610550e1363aea43afe3d6e292cf9","date":1418230105,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (reusedBytesPerArc.length < nodeIn.numArcs) {\n        reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        reusedBytesPerArc[arcIdx] = (int) (bytes.getPosition() - lastArcStart);\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (bytesPerArc.length < nodeIn.numArcs) {\n        bytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        bytesPerArc[arcIdx] = (int) (bytes.getPosition() - lastArcStart);\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, bytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + bytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= bytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + bytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" bytesPerArc[arcIdx]=\" + bytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, bytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","87e78f3c129251e74ecc2ff73a32de0f27cf09d5","b3be20ca1091c0b7cdb2308b9023606a5e451cec","d4769bdea5a853f1841c485bc1fd9d79cb7022fc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = builder.bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        builder.bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= builder.reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + builder.reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + builder.reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            builder.bytes.copyBytes(srcPos, destPos, builder.reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && builder.nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    builder.nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) builder.nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) builder.nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = builder.nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (reusedBytesPerArc.length < nodeIn.numArcs) {\n        reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        reusedBytesPerArc[arcIdx] = (int) (bytes.getPosition() - lastArcStart);\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["7f32ed90e12610550e1363aea43afe3d6e292cf9"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["5ebe14aae60589c9bb6423f3cce02d5f599e1540","cb27634f76319b68d6d8fd11a7104d20294722c5"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["73e44327cb5401cc5098da2f488c899954c9bfbc"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"556c8202987f72dd8458e25e21a82d98fc274979":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"45155bce1f2625f94a75296bb8a509d5d3265294":["edb74c83fff94196b864e08ca033d92823252cb7"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["cb27634f76319b68d6d8fd11a7104d20294722c5"],"cb27634f76319b68d6d8fd11a7104d20294722c5":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"73e44327cb5401cc5098da2f488c899954c9bfbc":["fc6d3be942e675e8251dbe10796cdb3a484bf607"],"aba371508186796cc6151d8223a5b4e16d02e26e":["edb74c83fff94196b864e08ca033d92823252cb7","45155bce1f2625f94a75296bb8a509d5d3265294"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["edb74c83fff94196b864e08ca033d92823252cb7","45155bce1f2625f94a75296bb8a509d5d3265294"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edb74c83fff94196b864e08ca033d92823252cb7":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["45155bce1f2625f94a75296bb8a509d5d3265294"],"fc6d3be942e675e8251dbe10796cdb3a484bf607":["556c8202987f72dd8458e25e21a82d98fc274979"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"7f32ed90e12610550e1363aea43afe3d6e292cf9":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["8917bfede3b4ca30f4305c1e391e9218959cd723","7f32ed90e12610550e1363aea43afe3d6e292cf9"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["edb74c83fff94196b864e08ca033d92823252cb7"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"556c8202987f72dd8458e25e21a82d98fc274979":["fc6d3be942e675e8251dbe10796cdb3a484bf607"],"45155bce1f2625f94a75296bb8a509d5d3265294":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["556c8202987f72dd8458e25e21a82d98fc274979"],"cb27634f76319b68d6d8fd11a7104d20294722c5":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"73e44327cb5401cc5098da2f488c899954c9bfbc":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"edb74c83fff94196b864e08ca033d92823252cb7":["45155bce1f2625f94a75296bb8a509d5d3265294","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cb27634f76319b68d6d8fd11a7104d20294722c5"],"fc6d3be942e675e8251dbe10796cdb3a484bf607":["73e44327cb5401cc5098da2f488c899954c9bfbc"],"7f32ed90e12610550e1363aea43afe3d6e292cf9":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}