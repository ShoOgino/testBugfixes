{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[]).mjava","commits":[{"id":"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","date":1411708843,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,String).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[])}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[])\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    return version;\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, String segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    String id = in.readString();\n    if (!id.equals(segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + segmentID + \", got=\" + id, in);\n    }\n    return version;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f6bd27530a2846413fe2d00030493c0e2d3a072","date":1411811855,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[])}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[])\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    return version;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78b813d9350cc28625598f6dbbb49b586a40618","date":1412073147,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[]).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[], String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @param segmentSuffix The expected auxiliary segment suffix for this file.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         or <code>segmentSuffix</code> do not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[],String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID, String segmentSuffix) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    int suffixLength = in.readByte() & 0xFF;\n    byte suffixBytes[] = new byte[suffixLength];\n    in.readBytes(suffixBytes, 0, suffixBytes.length);\n    String suffix = new String(suffixBytes, 0, suffixBytes.length, StandardCharsets.UTF_8);\n    if (!suffix.equals(segmentSuffix)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment suffix=\" + segmentSuffix\n                                                                     + \", got=\" + suffix, in);\n    }\n    return version;\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[])}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[])\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    return version;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[]).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[], String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @param segmentSuffix The expected auxiliary segment suffix for this file.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         or <code>segmentSuffix</code> do not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[],String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID, String segmentSuffix) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    int suffixLength = in.readByte() & 0xFF;\n    byte suffixBytes[] = new byte[suffixLength];\n    in.readBytes(suffixBytes, 0, suffixBytes.length);\n    String suffix = new String(suffixBytes, 0, suffixBytes.length, StandardCharsets.UTF_8);\n    if (!suffix.equals(segmentSuffix)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment suffix=\" + segmentSuffix\n                                                                     + \", got=\" + suffix, in);\n    }\n    return version;\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[])}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[])\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    return version;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a78b813d9350cc28625598f6dbbb49b586a40618":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9bb9a29a5e71a90295f175df8919802993142c9a":["5f6bd27530a2846413fe2d00030493c0e2d3a072","a78b813d9350cc28625598f6dbbb49b586a40618"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9bb9a29a5e71a90295f175df8919802993142c9a"]},"commit2Childs":{"a78b813d9350cc28625598f6dbbb49b586a40618":["9bb9a29a5e71a90295f175df8919802993142c9a"],"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["a78b813d9350cc28625598f6dbbb49b586a40618","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"9bb9a29a5e71a90295f175df8919802993142c9a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["9bb9a29a5e71a90295f175df8919802993142c9a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}