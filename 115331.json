{"path":"lucene/core/src/java/org/apache/lucene/index/ReaderPool#release(ReadersAndUpdates,boolean).mjava","commits":[{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReaderPool#release(ReadersAndUpdates,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Releases the {@link ReadersAndUpdates}. This should only be called if the {@link #get(SegmentCommitInfo, boolean)}\n   * is called with the create paramter set to true.\n   * @return <code>true</code> if any files were written by this release call.\n   */\n  synchronized boolean release(ReadersAndUpdates rld, boolean assertInfoLive) throws IOException {\n    boolean changed = false;\n    // Matches incRef in get:\n    rld.decRef();\n\n    if (rld.refCount() == 0) {\n      // This happens if the segment was just merged away,\n      // while a buffered deletes packet was still applying deletes/updates to it.\n      assert readerMap.containsKey(rld.info) == false: \"seg=\" + rld.info\n          + \" has refCount 0 but still unexpectedly exists in the reader pool\";\n    } else {\n\n      // Pool still holds a ref:\n      assert rld.refCount() > 0: \"refCount=\" + rld.refCount() + \" reader=\" + rld.info;\n\n      if (poolReaders == false && rld.refCount() == 1 && readerMap.containsKey(rld.info)) {\n        // This is the last ref to this RLD, and we're not\n        // pooling, so remove it:\n        if (rld.writeLiveDocs(directory)) {\n          // Make sure we only write del docs for a live segment:\n          assert assertInfoLive == false || assertInfoIsLive(rld.info);\n          // Must checkpoint because we just\n          // created new _X_N.del and field updates files;\n          // don't call IW.checkpoint because that also\n          // increments SIS.version, which we do not want to\n          // do here: it was done previously (after we\n          // invoked BDS.applyDeletes), whereas here all we\n          // did was move the state to disk:\n          changed = true;\n        }\n        if (rld.writeFieldUpdates(directory, fieldNumbers, completedDelGenSupplier.getAsLong(), infoStream)) {\n          changed = true;\n        }\n        if (rld.getNumDVUpdates() == 0) {\n          rld.dropReaders();\n          readerMap.remove(rld.info);\n        } else {\n          // We are forced to pool this segment until its deletes fully apply (no delGen gaps)\n        }\n      }\n    }\n    return changed;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1926100d9b67becc9701c54266fee3ba7878a5f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1926100d9b67becc9701c54266fee3ba7878a5f0"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}