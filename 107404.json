{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","commits":[{"id":"7b2c4e17100e207bc842e56d016b9f91f411304e","date":1434336696,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getName(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      String[] bucketValues = new String[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getName(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3078cad1008b796c6d573b743c586fdf9ef5660a","date":1436019875,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      String[] bucketValues = new String[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getName(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      String[] bucketValues = new String[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getName(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da9a71da64ce12a97dcfcdd912893aeb1fa2981","date":1437510515,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      String[] bucketValues = new String[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      String[] bucketValues = new String[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ced76ea488919a7dca53e413e903839996d0f3c","date":1453928984,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      String[] bucketValues = new String[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      String[] bucketValues = new String[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i].toString());\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e81b63c9ecb10b3cb98b3cc5e255b8d91021b941","date":1461079048,"type":3,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b71fe681187ac8552caaff9d5a7f1f3cac47b56","date":1461081992,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map map = new HashMap();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"612da0a0a2d5f4409da55729b9833e799f905ac5","date":1479142562,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentKey = hashKey;\n        if (metrics != null) {\n          currentMetrics = new Metric[metrics.length];\n          for(int i=0; i<metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i]  = bucketMetric;\n          }\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"116fdd6b9e04e18a6547a5650bc0afd3fda020aa","date":1487184909,"type":3,"author":"Joel Bernstein","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentKey = hashKey;\n        if (metrics != null) {\n          currentMetrics = new Metric[metrics.length];\n          for(int i=0; i<metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i]  = bucketMetric;\n          }\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentMetrics = new Metric[metrics.length];\n        currentKey = hashKey;\n        for(int i=0; i<metrics.length; i++) {\n          Metric bucketMetric = metrics[i].newInstance();\n          bucketMetric.update(tuple);\n          currentMetrics[i]  = bucketMetric;\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Tuple t = new Tuple();\n          for(Metric metric : currentMetrics) {\n            t.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            t.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          t = new Tuple();\n          for(Metric metric : currentMetrics) {\n            t.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            t.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n        }\n\n        currentKey = hashKey;\n        if (metrics != null) {\n          currentMetrics = new Metric[metrics.length];\n          for(int i=0; i<metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i]  = bucketMetric;\n          }\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    while(true) {\n      Tuple tuple = tupleStream.read();\n      if(tuple.EOF) {\n        if(!finished) {\n\n          if(currentMetrics == null) {\n            return tuple;\n          }\n\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          Tuple t = new Tuple(map);\n          tupleStream.pushBack(tuple);\n          finished = true;\n          return t;\n        } else {\n          return tuple;\n        }\n      }\n\n      Object[] bucketValues = new Object[buckets.length];\n      for(int i=0; i<buckets.length; i++) {\n        bucketValues[i] = buckets[i].getBucketValue(tuple);\n      }\n\n      HashKey hashKey = new HashKey(bucketValues);\n\n      if(hashKey.equals(currentKey)) {\n        for(Metric bucketMetric : currentMetrics) {\n          bucketMetric.update(tuple);\n        }\n      } else {\n        Tuple t = null;\n        if(currentMetrics != null) {\n          Map<String,Object> map = new HashMap<String,Object>();\n          for(Metric metric : currentMetrics) {\n            map.put(metric.getIdentifier(), metric.getValue());\n          }\n\n          for(int i=0; i<buckets.length; i++) {\n            map.put(buckets[i].toString(), currentKey.getParts()[i]);\n          }\n          t = new Tuple(map);\n        }\n\n        currentKey = hashKey;\n        if (metrics != null) {\n          currentMetrics = new Metric[metrics.length];\n          for(int i=0; i<metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i]  = bucketMetric;\n          }\n        }\n\n        if(t != null) {\n          return t;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3078cad1008b796c6d573b743c586fdf9ef5660a":["7b2c4e17100e207bc842e56d016b9f91f411304e"],"612da0a0a2d5f4409da55729b9833e799f905ac5":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56"],"3b71fe681187ac8552caaff9d5a7f1f3cac47b56":["2ced76ea488919a7dca53e413e903839996d0f3c","e81b63c9ecb10b3cb98b3cc5e255b8d91021b941"],"116fdd6b9e04e18a6547a5650bc0afd3fda020aa":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56","612da0a0a2d5f4409da55729b9833e799f905ac5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["8da9a71da64ce12a97dcfcdd912893aeb1fa2981","2ced76ea488919a7dca53e413e903839996d0f3c"],"2ced76ea488919a7dca53e413e903839996d0f3c":["8da9a71da64ce12a97dcfcdd912893aeb1fa2981"],"7b2c4e17100e207bc842e56d016b9f91f411304e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e81b63c9ecb10b3cb98b3cc5e255b8d91021b941":["2ced76ea488919a7dca53e413e903839996d0f3c"],"8da9a71da64ce12a97dcfcdd912893aeb1fa2981":["3078cad1008b796c6d573b743c586fdf9ef5660a"],"804a8d5358fe7b7563b85ee7838714d720b89272":["116fdd6b9e04e18a6547a5650bc0afd3fda020aa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["804a8d5358fe7b7563b85ee7838714d720b89272"]},"commit2Childs":{"3078cad1008b796c6d573b743c586fdf9ef5660a":["8da9a71da64ce12a97dcfcdd912893aeb1fa2981"],"612da0a0a2d5f4409da55729b9833e799f905ac5":["116fdd6b9e04e18a6547a5650bc0afd3fda020aa"],"3b71fe681187ac8552caaff9d5a7f1f3cac47b56":["612da0a0a2d5f4409da55729b9833e799f905ac5","116fdd6b9e04e18a6547a5650bc0afd3fda020aa"],"116fdd6b9e04e18a6547a5650bc0afd3fda020aa":["804a8d5358fe7b7563b85ee7838714d720b89272"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b2c4e17100e207bc842e56d016b9f91f411304e"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"7b2c4e17100e207bc842e56d016b9f91f411304e":["3078cad1008b796c6d573b743c586fdf9ef5660a"],"2ced76ea488919a7dca53e413e903839996d0f3c":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56","1e6acbaae7af722f17204ceccf0f7db5753eccf3","e81b63c9ecb10b3cb98b3cc5e255b8d91021b941"],"e81b63c9ecb10b3cb98b3cc5e255b8d91021b941":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56"],"8da9a71da64ce12a97dcfcdd912893aeb1fa2981":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","2ced76ea488919a7dca53e413e903839996d0f3c"],"804a8d5358fe7b7563b85ee7838714d720b89272":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}