{"path":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"    public void test() throws IOException {\n\n        Term allTerm = new Term(FIELD, \"all\");\n        TermQuery termQuery = new TermQuery(allTerm);\n\n        Weight weight = termQuery.weight(indexSearcher);\n\n        TermScorer ts = new TermScorer(weight,\n                                       indexReader.termDocs(allTerm), indexSearcher.getSimilarity(),\n                                       indexReader.norms(FIELD));\n        //we have 2 documents with the term all in them, one document for all the other values\n        final List<TestHit> docs = new ArrayList<TestHit>();\n        //must call next first\n\n\n        ts.score(new Collector() {\n            private int base = 0;\n            private Scorer scorer;\n            @Override\n            public void setScorer(Scorer scorer) throws IOException {\n              this.scorer = scorer; \n            }\n\n            @Override\n            public void collect(int doc) throws IOException {\n              float score = scorer.score();\n              doc = doc + base;\n              docs.add(new TestHit(doc, score));\n              assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n              assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n                            doc == 0 || doc == 5);\n            }\n            @Override\n            public void setNextReader(IndexReader reader, int docBase) {\n              base = docBase;\n            }\n            @Override\n            public boolean acceptsDocsOutOfOrder() {\n              return true;\n            }\n        });\n        assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n        TestHit doc0 =  docs.get(0);\n        TestHit doc5 =  docs.get(1);\n        //The scores should be the same\n        assertTrue(doc0.score + \" does not equal: \" + doc5.score, doc0.score == doc5.score);\n        /*\n        Score should be (based on Default Sim.:\n        All floats are approximate\n        tf = 1\n        numDocs = 6\n        docFreq(all) = 2\n        idf = ln(6/3) + 1 = 1.693147\n        idf ^ 2 = 2.8667\n        boost = 1\n        lengthNorm = 1 //there is 1 term in every document\n        coord = 1\n        sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n        queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n\n         score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n\n        */\n        assertTrue(doc0.score + \" does not equal: \" + 1.6931472f, doc0.score == 1.6931472f);\n    }\n\n","sourceOld":"    public void test() throws IOException {\n\n        Term allTerm = new Term(FIELD, \"all\");\n        TermQuery termQuery = new TermQuery(allTerm);\n\n        Weight weight = termQuery.weight(indexSearcher);\n\n        TermScorer ts = new TermScorer(weight,\n                                       indexReader.termDocs(allTerm), indexSearcher.getSimilarity(),\n                                       indexReader.norms(FIELD));\n        //we have 2 documents with the term all in them, one document for all the other values\n        final List<TestHit> docs = new ArrayList<TestHit>();\n        //must call next first\n\n\n        ts.score(new Collector() {\n            private int base = 0;\n            private Scorer scorer;\n            @Override\n            public void setScorer(Scorer scorer) throws IOException {\n              this.scorer = scorer; \n            }\n\n            @Override\n            public void collect(int doc) throws IOException {\n              float score = scorer.score();\n              doc = doc + base;\n              docs.add(new TestHit(doc, score));\n              assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n              assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n                            doc == 0 || doc == 5);\n            }\n            @Override\n            public void setNextReader(IndexReader reader, int docBase) {\n              base = docBase;\n            }\n            @Override\n            public boolean acceptsDocsOutOfOrder() {\n              return true;\n            }\n        });\n        assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n        TestHit doc0 =  docs.get(0);\n        TestHit doc5 =  docs.get(1);\n        //The scores should be the same\n        assertTrue(doc0.score + \" does not equal: \" + doc5.score, doc0.score == doc5.score);\n        /*\n        Score should be (based on Default Sim.:\n        All floats are approximate\n        tf = 1\n        numDocs = 6\n        docFreq(all) = 2\n        idf = ln(6/3) + 1 = 1.693147\n        idf ^ 2 = 2.8667\n        boost = 1\n        lengthNorm = 1 //there is 1 term in every document\n        coord = 1\n        sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n        queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n\n         score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n\n        */\n        assertTrue(doc0.score + \" does not equal: \" + 1.6931472f, doc0.score == 1.6931472f);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"    public void test() throws IOException {\n\n        Term allTerm = new Term(FIELD, \"all\");\n        TermQuery termQuery = new TermQuery(allTerm);\n\n        Weight weight = termQuery.weight(indexSearcher);\n\n        Scorer ts = weight.scorer(indexSearcher.getIndexReader(),\n                                  true, true);\n        //we have 2 documents with the term all in them, one document for all the other values\n        final List<TestHit> docs = new ArrayList<TestHit>();\n        //must call next first\n\n\n        ts.score(new Collector() {\n            private int base = 0;\n            private Scorer scorer;\n            @Override\n            public void setScorer(Scorer scorer) throws IOException {\n              this.scorer = scorer; \n            }\n\n            @Override\n            public void collect(int doc) throws IOException {\n              float score = scorer.score();\n              doc = doc + base;\n              docs.add(new TestHit(doc, score));\n              assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n              assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n                            doc == 0 || doc == 5);\n            }\n            @Override\n            public void setNextReader(IndexReader reader, int docBase) {\n              base = docBase;\n            }\n            @Override\n            public boolean acceptsDocsOutOfOrder() {\n              return true;\n            }\n        });\n        assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n        TestHit doc0 =  docs.get(0);\n        TestHit doc5 =  docs.get(1);\n        //The scores should be the same\n        assertTrue(doc0.score + \" does not equal: \" + doc5.score, doc0.score == doc5.score);\n        /*\n        Score should be (based on Default Sim.:\n        All floats are approximate\n        tf = 1\n        numDocs = 6\n        docFreq(all) = 2\n        idf = ln(6/3) + 1 = 1.693147\n        idf ^ 2 = 2.8667\n        boost = 1\n        lengthNorm = 1 //there is 1 term in every document\n        coord = 1\n        sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n        queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n\n         score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n\n        */\n        assertTrue(doc0.score + \" does not equal: \" + 1.6931472f, doc0.score == 1.6931472f);\n    }\n\n","sourceOld":"    public void test() throws IOException {\n\n        Term allTerm = new Term(FIELD, \"all\");\n        TermQuery termQuery = new TermQuery(allTerm);\n\n        Weight weight = termQuery.weight(indexSearcher);\n\n        TermScorer ts = new TermScorer(weight,\n                                       indexReader.termDocs(allTerm), indexSearcher.getSimilarity(),\n                                       indexReader.norms(FIELD));\n        //we have 2 documents with the term all in them, one document for all the other values\n        final List<TestHit> docs = new ArrayList<TestHit>();\n        //must call next first\n\n\n        ts.score(new Collector() {\n            private int base = 0;\n            private Scorer scorer;\n            @Override\n            public void setScorer(Scorer scorer) throws IOException {\n              this.scorer = scorer; \n            }\n\n            @Override\n            public void collect(int doc) throws IOException {\n              float score = scorer.score();\n              doc = doc + base;\n              docs.add(new TestHit(doc, score));\n              assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n              assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n                            doc == 0 || doc == 5);\n            }\n            @Override\n            public void setNextReader(IndexReader reader, int docBase) {\n              base = docBase;\n            }\n            @Override\n            public boolean acceptsDocsOutOfOrder() {\n              return true;\n            }\n        });\n        assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n        TestHit doc0 =  docs.get(0);\n        TestHit doc5 =  docs.get(1);\n        //The scores should be the same\n        assertTrue(doc0.score + \" does not equal: \" + doc5.score, doc0.score == doc5.score);\n        /*\n        Score should be (based on Default Sim.:\n        All floats are approximate\n        tf = 1\n        numDocs = 6\n        docFreq(all) = 2\n        idf = ln(6/3) + 1 = 1.693147\n        idf ^ 2 = 2.8667\n        boost = 1\n        lengthNorm = 1 //there is 1 term in every document\n        coord = 1\n        sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n        queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n\n         score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n\n        */\n        assertTrue(doc0.score + \" does not equal: \" + 1.6931472f, doc0.score == 1.6931472f);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c084e47df29de3330311d69dabf515ceaa989512","date":1279030906,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    \n    Scorer ts = weight.scorer(indexSearcher.getIndexReader(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"    public void test() throws IOException {\n\n        Term allTerm = new Term(FIELD, \"all\");\n        TermQuery termQuery = new TermQuery(allTerm);\n\n        Weight weight = termQuery.weight(indexSearcher);\n\n        Scorer ts = weight.scorer(indexSearcher.getIndexReader(),\n                                  true, true);\n        //we have 2 documents with the term all in them, one document for all the other values\n        final List<TestHit> docs = new ArrayList<TestHit>();\n        //must call next first\n\n\n        ts.score(new Collector() {\n            private int base = 0;\n            private Scorer scorer;\n            @Override\n            public void setScorer(Scorer scorer) throws IOException {\n              this.scorer = scorer; \n            }\n\n            @Override\n            public void collect(int doc) throws IOException {\n              float score = scorer.score();\n              doc = doc + base;\n              docs.add(new TestHit(doc, score));\n              assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n              assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n                            doc == 0 || doc == 5);\n            }\n            @Override\n            public void setNextReader(IndexReader reader, int docBase) {\n              base = docBase;\n            }\n            @Override\n            public boolean acceptsDocsOutOfOrder() {\n              return true;\n            }\n        });\n        assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n        TestHit doc0 =  docs.get(0);\n        TestHit doc5 =  docs.get(1);\n        //The scores should be the same\n        assertTrue(doc0.score + \" does not equal: \" + doc5.score, doc0.score == doc5.score);\n        /*\n        Score should be (based on Default Sim.:\n        All floats are approximate\n        tf = 1\n        numDocs = 6\n        docFreq(all) = 2\n        idf = ln(6/3) + 1 = 1.693147\n        idf ^ 2 = 2.8667\n        boost = 1\n        lengthNorm = 1 //there is 1 term in every document\n        coord = 1\n        sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n        queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n\n         score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n\n        */\n        assertTrue(doc0.score + \" does not equal: \" + 1.6931472f, doc0.score == 1.6931472f);\n    }\n\n","bugFix":null,"bugIntro":["6e75448368ba628d73e9967b45e29c40bbfe39fa","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    \n    Scorer ts = weight.scorer(indexSearcher.getIndexReader(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"    public void test() throws IOException {\n\n        Term allTerm = new Term(FIELD, \"all\");\n        TermQuery termQuery = new TermQuery(allTerm);\n\n        Weight weight = termQuery.weight(indexSearcher);\n\n        Scorer ts = weight.scorer(indexSearcher.getIndexReader(),\n                                  true, true);\n        //we have 2 documents with the term all in them, one document for all the other values\n        final List<TestHit> docs = new ArrayList<TestHit>();\n        //must call next first\n\n\n        ts.score(new Collector() {\n            private int base = 0;\n            private Scorer scorer;\n            @Override\n            public void setScorer(Scorer scorer) throws IOException {\n              this.scorer = scorer; \n            }\n\n            @Override\n            public void collect(int doc) throws IOException {\n              float score = scorer.score();\n              doc = doc + base;\n              docs.add(new TestHit(doc, score));\n              assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n              assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n                            doc == 0 || doc == 5);\n            }\n            @Override\n            public void setNextReader(IndexReader reader, int docBase) {\n              base = docBase;\n            }\n            @Override\n            public boolean acceptsDocsOutOfOrder() {\n              return true;\n            }\n        });\n        assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n        TestHit doc0 =  docs.get(0);\n        TestHit doc5 =  docs.get(1);\n        //The scores should be the same\n        assertTrue(doc0.score + \" does not equal: \" + doc5.score, doc0.score == doc5.score);\n        /*\n        Score should be (based on Default Sim.:\n        All floats are approximate\n        tf = 1\n        numDocs = 6\n        docFreq(all) = 2\n        idf = ln(6/3) + 1 = 1.693147\n        idf ^ 2 = 2.8667\n        boost = 1\n        lengthNorm = 1 //there is 1 term in every document\n        coord = 1\n        sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n        queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n\n         score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n\n        */\n        assertTrue(doc0.score + \" does not equal: \" + 1.6931472f, doc0.score == 1.6931472f);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    \n    Scorer ts = weight.scorer(indexSearcher.getTopReaderContext(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    \n    Scorer ts = weight.scorer(indexSearcher.getIndexReader(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705","date":1294747166,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    \n    Scorer ts = weight.scorer(indexSearcher.getTopReaderContext(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"323f871ffe96b871d8c534a614be60751bb023c2","date":1294820532,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dc63f17f42c64d6ccc8c361cfcdf074f115f770c","date":1294930751,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def().scoreDocsInOrder(true).topScorer(true));\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def().scoreDocsInOrder(true).topScorer(true));\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    \n    Scorer ts = weight.scorer(indexSearcher.getIndexReader(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def().scoreDocsInOrder(true).topScorer(true));\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    \n    Scorer ts = weight.scorer(indexSearcher.getIndexReader(), true, true);\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f7fee42303a18cc146043c96f66491311b345d9","date":1308246904,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def().scoreDocsInOrder(true).topScorer(true));\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def().scoreDocsInOrder(true).topScorer(true));\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def().scoreDocsInOrder(true).topScorer(true));\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = termQuery.weight(indexSearcher);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def().scoreDocsInOrder(true).topScorer(true));\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc1f3f78b299e125f7e60f43b5d457392bea23f","date":1317431015,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader.getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    Scorer ts = weight.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def().scoreDocsInOrder(true).topScorer(true));\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6fff8f4b218bd0626afcdce82027bafeb84a50a4","date":1327229950,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader().getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader.getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a2ec9a9068164200de82395f0e8537a9d9302f3f","date":1327856476,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext() instanceof AtomicReaderContext);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader().getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader().getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext() instanceof AtomicReaderContext);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader().getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext().isAtomic);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader.getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTermScorer#test().mjava","sourceNew":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext() instanceof AtomicReaderContext);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader().getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","sourceOld":"  public void test() throws IOException {\n    \n    Term allTerm = new Term(FIELD, \"all\");\n    TermQuery termQuery = new TermQuery(allTerm);\n    \n    Weight weight = indexSearcher.createNormalizedWeight(termQuery);\n    assertTrue(indexSearcher.getTopReaderContext() instanceof AtomicReaderContext);\n    AtomicReaderContext context = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n    Scorer ts = weight.scorer(context, true, true, context.reader().getLiveDocs());\n    // we have 2 documents with the term all in them, one document for all the\n    // other values\n    final List<TestHit> docs = new ArrayList<TestHit>();\n    // must call next first\n    \n    ts.score(new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      \n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        doc = doc + base;\n        docs.add(new TestHit(doc, score));\n        assertTrue(\"score \" + score + \" is not greater than 0\", score > 0);\n        assertTrue(\"Doc: \" + doc + \" does not equal 0 or doc does not equal 5\",\n            doc == 0 || doc == 5);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        base = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    assertTrue(\"docs Size: \" + docs.size() + \" is not: \" + 2, docs.size() == 2);\n    TestHit doc0 = docs.get(0);\n    TestHit doc5 = docs.get(1);\n    // The scores should be the same\n    assertTrue(doc0.score + \" does not equal: \" + doc5.score,\n        doc0.score == doc5.score);\n    /*\n     * Score should be (based on Default Sim.: All floats are approximate tf = 1\n     * numDocs = 6 docFreq(all) = 2 idf = ln(6/3) + 1 = 1.693147 idf ^ 2 =\n     * 2.8667 boost = 1 lengthNorm = 1 //there is 1 term in every document coord\n     * = 1 sumOfSquaredWeights = (idf * boost) ^ 2 = 1.693147 ^ 2 = 2.8667\n     * queryNorm = 1 / (sumOfSquaredWeights)^0.5 = 1 /(1.693147) = 0.590\n     * \n     * score = 1 * 2.8667 * 1 * 1 * 0.590 = 1.69\n     */\n    assertTrue(doc0.score + \" does not equal: \" + 1.6931472f,\n        doc0.score == 1.6931472f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"323f871ffe96b871d8c534a614be60751bb023c2":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["6f7fee42303a18cc146043c96f66491311b345d9"],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["3fc1f3f78b299e125f7e60f43b5d457392bea23f"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","c084e47df29de3330311d69dabf515ceaa989512"],"dc63f17f42c64d6ccc8c361cfcdf074f115f770c":["323f871ffe96b871d8c534a614be60751bb023c2"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3fc1f3f78b299e125f7e60f43b5d457392bea23f","a2ec9a9068164200de82395f0e8537a9d9302f3f"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["dc63f17f42c64d6ccc8c361cfcdf074f115f770c","6f7fee42303a18cc146043c96f66491311b345d9"],"6f7fee42303a18cc146043c96f66491311b345d9":["dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"c084e47df29de3330311d69dabf515ceaa989512":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a2ec9a9068164200de82395f0e8537a9d9302f3f":["6fff8f4b218bd0626afcdce82027bafeb84a50a4"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["c084e47df29de3330311d69dabf515ceaa989512","dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["c084e47df29de3330311d69dabf515ceaa989512"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["5f4e87790277826a2aea119328600dfb07761f32","dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"323f871ffe96b871d8c534a614be60751bb023c2":["dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["6fff8f4b218bd0626afcdce82027bafeb84a50a4","5cab9a86bd67202d20b6adc463008c8e982b070a"],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["a2ec9a9068164200de82395f0e8537a9d9302f3f"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5f4e87790277826a2aea119328600dfb07761f32","c084e47df29de3330311d69dabf515ceaa989512"],"5f4e87790277826a2aea119328600dfb07761f32":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"dc63f17f42c64d6ccc8c361cfcdf074f115f770c":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","6f7fee42303a18cc146043c96f66491311b345d9","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":[],"6f7fee42303a18cc146043c96f66491311b345d9":["3fc1f3f78b299e125f7e60f43b5d457392bea23f","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b"],"c084e47df29de3330311d69dabf515ceaa989512":["5f4e87790277826a2aea119328600dfb07761f32","29ef99d61cda9641b6250bf9567329a6e65f901d","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"a2ec9a9068164200de82395f0e8537a9d9302f3f":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["323f871ffe96b871d8c534a614be60751bb023c2"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}