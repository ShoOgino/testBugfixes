{"path":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","commits":[{"id":"dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e","date":1456736503,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#initUnmapHack().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object initUnmapHack() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file. \" +\n          \"Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#initUnmapHack().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object initUnmapHack() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file. \" +\n          \"Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71f8255d67554b78ea0a26a5cdb916a759261aab","date":1471024473,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b91b377e7c6013759f4396dd5cb6e8cf13142aa","date":1481304997,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2613a05c615dab2b84745ce1983d2f053fdb4358","date":1482346162,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer, sun.misc.Cleaner, and sun.misc.Unsafe to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      try {\n        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n        final Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n        // first check if Unsafe has the right method, otherwise we can give up\n        // without doing any security critical stuff:\n        final MethodHandle unmapper = lookup.findVirtual(unsafeClass, \"invokeCleaner\",\n            methodType(void.class, ByteBuffer.class));\n        // fetch the unsafe instance and bind it to the virtual MH:\n        final Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object theUnsafe = f.get(null);\n        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n      } catch (SecurityException se) {\n        // rethrow to report errors correctly (we need to catch it here, as we also catch RuntimeException below!):\n        throw se;\n      } catch (ReflectiveOperationException | RuntimeException e) {\n        // *** sun.misc.Cleaner unmapping (Java 8) ***\n        final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n        \n        final Method m = directBufferClass.getMethod(\"cleaner\");\n        m.setAccessible(true);\n        final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n        final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n        \n        /* \"Compile\" a MH that basically is equivalent to the following code:\n         * void unmapper(ByteBuffer byteBuffer) {\n         *   sun.misc.Cleaner cleaner = ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n         *   if (Objects.nonNull(cleaner)) {\n         *     cleaner.clean();\n         *   } else {\n         *     noop(cleaner); // the noop is needed because MethodHandles#guardWithTest always needs ELSE\n         *   }\n         * }\n         */\n        final MethodHandle cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n        final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n            .asType(methodType(boolean.class, cleanerClass));\n        final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n        final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n            .asType(methodType(void.class, ByteBuffer.class));\n        return newBufferCleaner(directBufferClass, unmapper);\n      }\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + se +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer, sun.misc.Cleaner, and sun.misc.Unsafe to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      try {\n        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n        final Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n        // first check if Unsafe has the right method, otherwise we can give up\n        // without doing any security critical stuff:\n        final MethodHandle unmapper = lookup.findVirtual(unsafeClass, \"invokeCleaner\",\n            methodType(void.class, ByteBuffer.class));\n        // fetch the unsafe instance and bind it to the virtual MH:\n        final Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object theUnsafe = f.get(null);\n        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n      } catch (SecurityException se) {\n        // rethrow to report errors correctly (we need to catch it here, as we also catch RuntimeException below!):\n        throw se;\n      } catch (ReflectiveOperationException | RuntimeException e) {\n        // *** sun.misc.Cleaner unmapping (Java 8) ***\n        final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n        \n        final Method m = directBufferClass.getMethod(\"cleaner\");\n        m.setAccessible(true);\n        final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n        final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n        \n        /* \"Compile\" a MH that basically is equivalent to the following code:\n         * void unmapper(ByteBuffer byteBuffer) {\n         *   sun.misc.Cleaner cleaner = ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n         *   if (Objects.nonNull(cleaner)) {\n         *     cleaner.clean();\n         *   } else {\n         *     noop(cleaner); // the noop is needed because MethodHandles#guardWithTest always needs ELSE\n         *   }\n         * }\n         */\n        final MethodHandle cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n        final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n            .asType(methodType(boolean.class, cleanerClass));\n        final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n        final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n            .asType(methodType(void.class, ByteBuffer.class));\n        return newBufferCleaner(directBufferClass, unmapper);\n      }\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + se +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (String resourceDescription, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + resourceDescription, error);\n          }\n        }\n      };\n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0be30988d843c98ed8022001bbd05005d9f27c","date":1483958934,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer, sun.misc.Cleaner, and sun.misc.Unsafe to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      try {\n        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n        final Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n        // first check if Unsafe has the right method, otherwise we can give up\n        // without doing any security critical stuff:\n        final MethodHandle unmapper = lookup.findVirtual(unsafeClass, \"invokeCleaner\",\n            methodType(void.class, ByteBuffer.class));\n        // fetch the unsafe instance and bind it to the virtual MH:\n        final Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object theUnsafe = f.get(null);\n        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n      } catch (SecurityException se) {\n        // rethrow to report errors correctly (we need to catch it here, as we also catch RuntimeException below!):\n        throw se;\n      } catch (ReflectiveOperationException | RuntimeException e) {\n        // *** sun.misc.Cleaner unmapping (Java 8) ***\n        final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n        \n        final Method m = directBufferClass.getMethod(\"cleaner\");\n        m.setAccessible(true);\n        final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n        final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n        \n        /* \"Compile\" a MH that basically is equivalent to the following code:\n         * void unmapper(ByteBuffer byteBuffer) {\n         *   sun.misc.Cleaner cleaner = ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n         *   if (Objects.nonNull(cleaner)) {\n         *     cleaner.clean();\n         *   } else {\n         *     noop(cleaner); // the noop is needed because MethodHandles#guardWithTest always needs ELSE\n         *   }\n         * }\n         */\n        final MethodHandle cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n        final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n            .asType(methodType(boolean.class, cleanerClass));\n        final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n        final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n            .asType(methodType(void.class, ByteBuffer.class));\n        return newBufferCleaner(directBufferClass, unmapper);\n      }\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + se +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible with this Lucene version: \" + e; \n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer, sun.misc.Cleaner, and sun.misc.Unsafe to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      try {\n        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n        final Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n        // first check if Unsafe has the right method, otherwise we can give up\n        // without doing any security critical stuff:\n        final MethodHandle unmapper = lookup.findVirtual(unsafeClass, \"invokeCleaner\",\n            methodType(void.class, ByteBuffer.class));\n        // fetch the unsafe instance and bind it to the virtual MH:\n        final Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object theUnsafe = f.get(null);\n        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n      } catch (SecurityException se) {\n        // rethrow to report errors correctly (we need to catch it here, as we also catch RuntimeException below!):\n        throw se;\n      } catch (ReflectiveOperationException | RuntimeException e) {\n        // *** sun.misc.Cleaner unmapping (Java 8) ***\n        final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n        \n        final Method m = directBufferClass.getMethod(\"cleaner\");\n        m.setAccessible(true);\n        final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n        final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n        \n        /* \"Compile\" a MH that basically is equivalent to the following code:\n         * void unmapper(ByteBuffer byteBuffer) {\n         *   sun.misc.Cleaner cleaner = ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n         *   if (Objects.nonNull(cleaner)) {\n         *     cleaner.clean();\n         *   } else {\n         *     noop(cleaner); // the noop is needed because MethodHandles#guardWithTest always needs ELSE\n         *   }\n         * }\n         */\n        final MethodHandle cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n        final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n            .asType(methodType(boolean.class, cleanerClass));\n        final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n        final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n            .asType(methodType(void.class, ByteBuffer.class));\n        return newBufferCleaner(directBufferClass, unmapper);\n      }\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + se +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer, sun.misc.Cleaner, and sun.misc.Unsafe to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      try {\n        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n        final Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n        // first check if Unsafe has the right method, otherwise we can give up\n        // without doing any security critical stuff:\n        final MethodHandle unmapper = lookup.findVirtual(unsafeClass, \"invokeCleaner\",\n            methodType(void.class, ByteBuffer.class));\n        // fetch the unsafe instance and bind it to the virtual MH:\n        final Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object theUnsafe = f.get(null);\n        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n      } catch (SecurityException se) {\n        // rethrow to report errors correctly (we need to catch it here, as we also catch RuntimeException below!):\n        throw se;\n      } catch (ReflectiveOperationException | RuntimeException e) {\n        // *** sun.misc.Cleaner unmapping (Java 8) ***\n        final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n        \n        final Method m = directBufferClass.getMethod(\"cleaner\");\n        m.setAccessible(true);\n        final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n        final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n        \n        /* \"Compile\" a MH that basically is equivalent to the following code:\n         * void unmapper(ByteBuffer byteBuffer) {\n         *   sun.misc.Cleaner cleaner = ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n         *   if (Objects.nonNull(cleaner)) {\n         *     cleaner.clean();\n         *   } else {\n         *     noop(cleaner); // the noop is needed because MethodHandles#guardWithTest always needs ELSE\n         *   }\n         * }\n         */\n        final MethodHandle cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n        final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n            .asType(methodType(boolean.class, cleanerClass));\n        final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n        final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n            .asType(methodType(void.class, ByteBuffer.class));\n        return newBufferCleaner(directBufferClass, unmapper);\n      }\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + se +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible with this Lucene version: \" + e; \n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer, sun.misc.Cleaner, and sun.misc.Unsafe to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      try {\n        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n        final Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n        // first check if Unsafe has the right method, otherwise we can give up\n        // without doing any security critical stuff:\n        final MethodHandle unmapper = lookup.findVirtual(unsafeClass, \"invokeCleaner\",\n            methodType(void.class, ByteBuffer.class));\n        // fetch the unsafe instance and bind it to the virtual MH:\n        final Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object theUnsafe = f.get(null);\n        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n      } catch (SecurityException se) {\n        // rethrow to report errors correctly (we need to catch it here, as we also catch RuntimeException below!):\n        throw se;\n      } catch (ReflectiveOperationException | RuntimeException e) {\n        // *** sun.misc.Cleaner unmapping (Java 8) ***\n        final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n        \n        final Method m = directBufferClass.getMethod(\"cleaner\");\n        m.setAccessible(true);\n        final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n        final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n        \n        /* \"Compile\" a MH that basically is equivalent to the following code:\n         * void unmapper(ByteBuffer byteBuffer) {\n         *   sun.misc.Cleaner cleaner = ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n         *   if (Objects.nonNull(cleaner)) {\n         *     cleaner.clean();\n         *   } else {\n         *     noop(cleaner); // the noop is needed because MethodHandles#guardWithTest always needs ELSE\n         *   }\n         * }\n         */\n        final MethodHandle cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n        final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n            .asType(methodType(boolean.class, cleanerClass));\n        final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n        final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n            .asType(methodType(void.class, ByteBuffer.class));\n        return newBufferCleaner(directBufferClass, unmapper);\n      }\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + se +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer, sun.misc.Cleaner, and sun.misc.Unsafe to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      // *** sun.misc.Unsafe unmapping (Java 9+) ***\n      final Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n      // first check if Unsafe has the right method, otherwise we can give up\n      // without doing any security critical stuff:\n      final MethodHandle unmapper = lookup.findVirtual(unsafeClass, \"invokeCleaner\",\n          methodType(void.class, ByteBuffer.class));\n      // fetch the unsafe instance and bind it to the virtual MH:\n      final Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n      f.setAccessible(true);\n      final Object theUnsafe = f.get(null);\n      return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + se +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible with this Lucene version: \" + e; \n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer, sun.misc.Cleaner, and sun.misc.Unsafe to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      try {\n        // *** sun.misc.Unsafe unmapping (Java 9+) ***\n        final Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n        // first check if Unsafe has the right method, otherwise we can give up\n        // without doing any security critical stuff:\n        final MethodHandle unmapper = lookup.findVirtual(unsafeClass, \"invokeCleaner\",\n            methodType(void.class, ByteBuffer.class));\n        // fetch the unsafe instance and bind it to the virtual MH:\n        final Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        final Object theUnsafe = f.get(null);\n        return newBufferCleaner(ByteBuffer.class, unmapper.bindTo(theUnsafe));\n      } catch (SecurityException se) {\n        // rethrow to report errors correctly (we need to catch it here, as we also catch RuntimeException below!):\n        throw se;\n      } catch (ReflectiveOperationException | RuntimeException e) {\n        // *** sun.misc.Cleaner unmapping (Java 8) ***\n        final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n        \n        final Method m = directBufferClass.getMethod(\"cleaner\");\n        m.setAccessible(true);\n        final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n        final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n        \n        /* \"Compile\" a MH that basically is equivalent to the following code:\n         * void unmapper(ByteBuffer byteBuffer) {\n         *   sun.misc.Cleaner cleaner = ((java.nio.DirectByteBuffer) byteBuffer).cleaner();\n         *   if (Objects.nonNull(cleaner)) {\n         *     cleaner.clean();\n         *   } else {\n         *     noop(cleaner); // the noop is needed because MethodHandles#guardWithTest always needs ELSE\n         *   }\n         * }\n         */\n        final MethodHandle cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n        final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n            .asType(methodType(boolean.class, cleanerClass));\n        final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n        final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n            .asType(methodType(void.class, ByteBuffer.class));\n        return newBufferCleaner(directBufferClass, unmapper);\n      }\n    } catch (SecurityException se) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + se +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\") \" +\n          \" and ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    } catch (ReflectiveOperationException | RuntimeException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible with this Lucene version: \" + e; \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["af2638813028b254a88b418ebeafb541afb49653","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["af2638813028b254a88b418ebeafb541afb49653","71f8255d67554b78ea0a26a5cdb916a759261aab"],"71f8255d67554b78ea0a26a5cdb916a759261aab":["af2638813028b254a88b418ebeafb541afb49653"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["f03e4bed5023ec3ef93a771b8888cae991cf448d","3a0be30988d843c98ed8022001bbd05005d9f27c"],"2613a05c615dab2b84745ce1983d2f053fdb4358":["0b91b377e7c6013759f4396dd5cb6e8cf13142aa"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["af2638813028b254a88b418ebeafb541afb49653","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["9856095f7afb5a607bf5e65077615ed91273508c","2613a05c615dab2b84745ce1983d2f053fdb4358"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["3a0be30988d843c98ed8022001bbd05005d9f27c"],"0b91b377e7c6013759f4396dd5cb6e8cf13142aa":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3a0be30988d843c98ed8022001bbd05005d9f27c":["2613a05c615dab2b84745ce1983d2f053fdb4358"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0b91b377e7c6013759f4396dd5cb6e8cf13142aa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b88a121b875f9ae2ac50f85cf46dcb680f126357"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["403d05f7f8d69b65659157eff1bc1d2717f04c66","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","71f8255d67554b78ea0a26a5cdb916a759261aab","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0b91b377e7c6013759f4396dd5cb6e8cf13142aa"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"71f8255d67554b78ea0a26a5cdb916a759261aab":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"2613a05c615dab2b84745ce1983d2f053fdb4358":["f03e4bed5023ec3ef93a771b8888cae991cf448d","3a0be30988d843c98ed8022001bbd05005d9f27c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e":["af2638813028b254a88b418ebeafb541afb49653"],"0b91b377e7c6013759f4396dd5cb6e8cf13142aa":["2613a05c615dab2b84745ce1983d2f053fdb4358","9856095f7afb5a607bf5e65077615ed91273508c"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e"],"3a0be30988d843c98ed8022001bbd05005d9f27c":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","b88a121b875f9ae2ac50f85cf46dcb680f126357"],"9856095f7afb5a607bf5e65077615ed91273508c":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}