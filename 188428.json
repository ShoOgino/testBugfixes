{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","commits":[{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","pathOld":"/dev/null","sourceNew":"  /** Gracefully shuts down this {@code IndexWriter} instance,\n   *  by writing any changes, waiting for any running\n   *  merges, committing, and closing.  If you don't want to\n   *  wait for merges, use {@link #shutdown(boolean)} instead.\n   *\n   *  <p>If you called prepareCommit but failed to call\n   *  commit, this method will throw {@code\n   *  IllegalStateException} and the {@code IndexWriter}\n   *  will not be closed.\n   *\n   *  <p>If this method throws any other\n   *  exception, the {@code IndexWriter} will be closed, but\n   *  changes may have been lost.\n   *\n   *  <p><b>NOTE</b>: You must ensure no\n   *  other threads are still making changes at the same\n   *  time that this method is invoked.  */\n  public void shutdown() throws IOException {\n    shutdown(true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","sourceNew":"  /**\n   * Implementation for {@link #close()} when {@link IndexWriterConfig#commitOnClose} is true.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"now flush at close\");\n    }\n    boolean success = false;\n    try {\n      flush(true, true);\n      finishMerges(true);\n      commit();\n      rollback(); // ie close, since we just committed\n      success = true;\n    } finally {\n      if (success == false) {\n        // Be certain to close the index on any exception\n        try {\n          rollback();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Gracefully shuts down this {@code IndexWriter} instance,\n   *  by writing any changes, waiting for any running\n   *  merges, committing, and closing.  If you don't want to\n   *  wait for merges, use {@link #shutdown(boolean)} instead.\n   *\n   *  <p>If you called prepareCommit but failed to call\n   *  commit, this method will throw {@code\n   *  IllegalStateException} and the {@code IndexWriter}\n   *  will not be closed.\n   *\n   *  <p>If this method throws any other\n   *  exception, the {@code IndexWriter} will be closed, but\n   *  changes may have been lost.\n   *\n   *  <p><b>NOTE</b>: You must ensure no\n   *  other threads are still making changes at the same\n   *  time that this method is invoked.  */\n  public void shutdown() throws IOException {\n    shutdown(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ea6955c7bfffe05682ad0a667afb2a6fa85e9da","date":1408027865,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","sourceNew":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose()) {\n      boolean success = false;\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n        flush(true, true);\n        finishMerges(true);\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n        success = true;\n      } finally {\n        if (success == false) {\n          // Be certain to close the index on any exception\n          try {\n            rollbackInternal();\n          } catch (Throwable t) {\n            // Suppress so we keep throwing original exception\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Implementation for {@link #close()} when {@link IndexWriterConfig#commitOnClose} is true.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"now flush at close\");\n    }\n    boolean success = false;\n    try {\n      flush(true, true);\n      finishMerges(true);\n      commit();\n      rollback(); // ie close, since we just committed\n      success = true;\n    } finally {\n      if (success == false) {\n        // Be certain to close the index on any exception\n        try {\n          rollback();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a64ffebe62143a8d4c37d99b6ece6d430d948ebc","date":1408382164,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","sourceNew":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose()) {\n      boolean success = false;\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n        success = true;\n      } finally {\n        if (success == false) {\n          // Be certain to close the index on any exception\n          try {\n            rollbackInternal();\n          } catch (Throwable t) {\n            // Suppress so we keep throwing original exception\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose()) {\n      boolean success = false;\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n        flush(true, true);\n        finishMerges(true);\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n        success = true;\n      } finally {\n        if (success == false) {\n          // Be certain to close the index on any exception\n          try {\n            rollbackInternal();\n          } catch (Throwable t) {\n            // Suppress so we keep throwing original exception\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9e22bdf0692bfa61e342b04a6ac7078670c1e16","date":1436866730,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","sourceNew":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose(true)) {\n      boolean success = false;\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n        success = true;\n      } finally {\n        if (success == false) {\n          // Be certain to close the index on any exception\n          try {\n            rollbackInternal();\n          } catch (Throwable t) {\n            // Suppress so we keep throwing original exception\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose()) {\n      boolean success = false;\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n        success = true;\n      } finally {\n        if (success == false) {\n          // Be certain to close the index on any exception\n          try {\n            rollbackInternal();\n          } catch (Throwable t) {\n            // Suppress so we keep throwing original exception\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","date":1512420564,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","sourceNew":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose(true)) {\n      boolean success = false;\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n        success = true;\n      } finally {\n        if (success == false) {\n          // Be certain to close the index on any exception\n          try {\n            rollbackInternal();\n          } catch (Throwable t) {\n            // Suppress so we keep throwing original exception\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose(true)) {\n      boolean success = false;\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n        success = true;\n      } finally {\n        if (success == false) {\n          // Be certain to close the index on any exception\n          try {\n            rollbackInternal();\n          } catch (Throwable t) {\n            // Suppress so we keep throwing original exception\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","sourceNew":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose(true)) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n      } catch (Throwable t) {\n        // Be certain to close the index on any exception\n        try {\n          rollbackInternal();\n        } catch (Throwable t1) {\n          t.addSuppressed(t1);\n        }\n        throw t;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose(true)) {\n      boolean success = false;\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n        success = true;\n      } finally {\n        if (success == false) {\n          // Be certain to close the index on any exception\n          try {\n            rollbackInternal();\n          } catch (Throwable t) {\n            // Suppress so we keep throwing original exception\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9841ef0704c22c54e9a7c60b228a863a08e50520","date":1597905625,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#shutdown().mjava","sourceNew":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose(true)) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n      } catch (Throwable t) {\n        // Be certain to close the index on any exception\n        try {\n          rollbackInternal();\n        } catch (Throwable t1) {\n          t.addSuppressed(t1);\n        }\n        throw t;\n      }\n      rollbackInternal(); // if we got that far lets rollback and close\n    }\n  }\n\n","sourceOld":"  /**\n   * Gracefully closes (commits, waits for merges), but calls rollback\n   * if there's an exc so the IndexWriter is always closed.  This is called\n   * from {@link #close} when {@link IndexWriterConfig#commitOnClose} is\n   * {@code true}.\n   */\n  private void shutdown() throws IOException {\n    if (pendingCommit != null) {\n      throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n    }\n    // Ensure that only one thread actually gets to do the\n    // closing\n    if (shouldClose(true)) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"now flush at close\");\n        }\n\n        flush(true, true);\n        waitForMerges();\n        commitInternal(config.getMergePolicy());\n        rollbackInternal(); // ie close, since we just committed\n      } catch (Throwable t) {\n        // Be certain to close the index on any exception\n        try {\n          rollbackInternal();\n        } catch (Throwable t1) {\n          t.addSuppressed(t1);\n        }\n        throw t;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["a64ffebe62143a8d4c37d99b6ece6d430d948ebc"],"5ea6955c7bfffe05682ad0a667afb2a6fa85e9da":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"a64ffebe62143a8d4c37d99b6ece6d430d948ebc":["5ea6955c7bfffe05682ad0a667afb2a6fa85e9da"],"9841ef0704c22c54e9a7c60b228a863a08e50520":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9841ef0704c22c54e9a7c60b228a863a08e50520"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["9841ef0704c22c54e9a7c60b228a863a08e50520"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"5ea6955c7bfffe05682ad0a667afb2a6fa85e9da":["a64ffebe62143a8d4c37d99b6ece6d430d948ebc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["5ea6955c7bfffe05682ad0a667afb2a6fa85e9da"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"a64ffebe62143a8d4c37d99b6ece6d430d948ebc":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"9841ef0704c22c54e9a7c60b228a863a08e50520":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}