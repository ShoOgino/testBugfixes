{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.AutomatonNextTermCalculator#nextString(int,int).mjava","commits":[{"id":"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89","date":1567784912,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.AutomatonNextTermCalculator#nextString(int,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Returns the next String in lexicographic order that will not put\n     * the machine into a reject state.\n     *\n     * This method traverses the DFA from the given position in the String,\n     * starting at the given state.\n     *\n     * If this cannot satisfy the machine, returns false. This method will\n     * walk the minimal path, in lexicographic order, as long as possible.\n     *\n     * If this method returns false, then there might still be more solutions,\n     * it is necessary to backtrack to find out.\n     *\n     * @param state current non-reject state\n     * @param position useful portion of the string\n     * @return true if more possible solutions exist for the DFA from this\n     *         position\n     */\n    protected boolean nextString(int state, int position) {\n      /*\n       * the next lexicographic character must be greater than the existing\n       * character, if it exists.\n       */\n      int c = 0;\n      if (position < seekBytesRef.length()) {\n        c = seekBytesRef.byteAt(position) & 0xff;\n        // if the next byte is 0xff and is not part of the useful portion,\n        // then by definition it puts us in a reject state, and therefore this\n        // path is dead. there cannot be any higher transitions. backtrack.\n        if (c++ == 0xff)\n          return false;\n      }\n\n      seekBytesRef.setLength(position);\n      visited[state] = curGen;\n\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      // find the minimal path (lexicographic order) that is >= c\n\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.max >= c) {\n          int nextChar = Math.max(c, transition.min);\n          // append either the next sequential char, or the minimum transition\n          seekBytesRef.grow(seekBytesRef.length() + 1);\n          seekBytesRef.append((byte) nextChar);\n          state = transition.dest;\n          /*\n           * as long as is possible, continue down the minimal path in\n           * lexicographic order. if a loop or accept state is encountered, stop.\n           */\n          while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n            visited[state] = curGen;\n            /*\n             * Note: we work with a DFA with no transitions to dead states.\n             * so the below is ok, if it is not an accept state,\n             * then there MUST be at least one transition.\n             */\n            automaton.initTransition(state, transition);\n            automaton.getNextTransition(transition);\n            state = transition.dest;\n\n            // append the minimum transition\n            seekBytesRef.grow(seekBytesRef.length() + 1);\n            seekBytesRef.append((byte) transition.min);\n\n            // we found a loop, record it for faster enumeration\n            if (!finite && !linear && visited[state] == curGen) {\n              setLinear(seekBytesRef.length()-1);\n            }\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23fcccd57316410c404dd37307a496ab850efa9c","date":1582897939,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.AutomatonNextTermCalculator#nextString(int,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.AutomatonNextTermCalculator#nextString(int,int).mjava","sourceNew":"    /**\n     * Returns the next String in lexicographic order that will not put\n     * the machine into a reject state.\n     * <p>\n     * This method traverses the DFA from the given position in the String,\n     * starting at the given state.\n     * <p>\n     * If this cannot satisfy the machine, returns false. This method will\n     * walk the minimal path, in lexicographic order, as long as possible.\n     * <p>\n     * If this method returns false, then there might still be more solutions,\n     * it is necessary to backtrack to find out.\n     *\n     * @param state    current non-reject state\n     * @param position useful portion of the string\n     * @return true if more possible solutions exist for the DFA from this\n     * position\n     */\n    protected boolean nextString(int state, int position) {\n      /*\n       * the next lexicographic character must be greater than the existing\n       * character, if it exists.\n       */\n      int c = 0;\n      if (position < seekBytesRef.length()) {\n        c = seekBytesRef.byteAt(position) & 0xff;\n        // if the next byte is 0xff and is not part of the useful portion,\n        // then by definition it puts us in a reject state, and therefore this\n        // path is dead. there cannot be any higher transitions. backtrack.\n        if (c++ == 0xff)\n          return false;\n      }\n\n      seekBytesRef.setLength(position);\n      setVisited(state);\n\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      // find the minimal path (lexicographic order) that is >= c\n\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.max >= c) {\n          int nextChar = Math.max(c, transition.min);\n          // append either the next sequential char, or the minimum transition\n          seekBytesRef.grow(seekBytesRef.length() + 1);\n          seekBytesRef.append((byte) nextChar);\n          state = transition.dest;\n          /*\n           * as long as is possible, continue down the minimal path in\n           * lexicographic order. if a loop or accept state is encountered, stop.\n           */\n          while (!isVisited(state) && !runAutomaton.isAccept(state)) {\n            setVisited(state);\n            /*\n             * Note: we work with a DFA with no transitions to dead states.\n             * so the below is ok, if it is not an accept state,\n             * then there MUST be at least one transition.\n             */\n            automaton.initTransition(state, transition);\n            automaton.getNextTransition(transition);\n            state = transition.dest;\n\n            // append the minimum transition\n            seekBytesRef.grow(seekBytesRef.length() + 1);\n            seekBytesRef.append((byte) transition.min);\n\n            // we found a loop, record it for faster enumeration\n            if (!linear && isVisited(state)) {\n              setLinear(seekBytesRef.length() - 1);\n            }\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n\n","sourceOld":"    /**\n     * Returns the next String in lexicographic order that will not put\n     * the machine into a reject state.\n     *\n     * This method traverses the DFA from the given position in the String,\n     * starting at the given state.\n     *\n     * If this cannot satisfy the machine, returns false. This method will\n     * walk the minimal path, in lexicographic order, as long as possible.\n     *\n     * If this method returns false, then there might still be more solutions,\n     * it is necessary to backtrack to find out.\n     *\n     * @param state current non-reject state\n     * @param position useful portion of the string\n     * @return true if more possible solutions exist for the DFA from this\n     *         position\n     */\n    protected boolean nextString(int state, int position) {\n      /*\n       * the next lexicographic character must be greater than the existing\n       * character, if it exists.\n       */\n      int c = 0;\n      if (position < seekBytesRef.length()) {\n        c = seekBytesRef.byteAt(position) & 0xff;\n        // if the next byte is 0xff and is not part of the useful portion,\n        // then by definition it puts us in a reject state, and therefore this\n        // path is dead. there cannot be any higher transitions. backtrack.\n        if (c++ == 0xff)\n          return false;\n      }\n\n      seekBytesRef.setLength(position);\n      visited[state] = curGen;\n\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      // find the minimal path (lexicographic order) that is >= c\n\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.max >= c) {\n          int nextChar = Math.max(c, transition.min);\n          // append either the next sequential char, or the minimum transition\n          seekBytesRef.grow(seekBytesRef.length() + 1);\n          seekBytesRef.append((byte) nextChar);\n          state = transition.dest;\n          /*\n           * as long as is possible, continue down the minimal path in\n           * lexicographic order. if a loop or accept state is encountered, stop.\n           */\n          while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n            visited[state] = curGen;\n            /*\n             * Note: we work with a DFA with no transitions to dead states.\n             * so the below is ok, if it is not an accept state,\n             * then there MUST be at least one transition.\n             */\n            automaton.initTransition(state, transition);\n            automaton.getNextTransition(transition);\n            state = transition.dest;\n\n            // append the minimum transition\n            seekBytesRef.grow(seekBytesRef.length() + 1);\n            seekBytesRef.append((byte) transition.min);\n\n            // we found a loop, record it for faster enumeration\n            if (!finite && !linear && visited[state] == curGen) {\n              setLinear(seekBytesRef.length()-1);\n            }\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"23fcccd57316410c404dd37307a496ab850efa9c":["09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23fcccd57316410c404dd37307a496ab850efa9c"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89"],"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89":["23fcccd57316410c404dd37307a496ab850efa9c"],"23fcccd57316410c404dd37307a496ab850efa9c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}