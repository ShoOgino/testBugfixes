{"path":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","commits":[{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","pathOld":"/dev/null","sourceNew":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    //System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n    //System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n    //System.out.println(\"actual count \" + actualCount);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    //System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n    //System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    //System.out.println(\"TEST: index terms\");\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      //System.out.println(\"  \" + term);\n    }\n\n    //System.out.println(\"TEST: now force merge\");\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    //System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          //System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          count++;\n        }\n        //System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n    } else if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n    }\n\n    assertEquals(actualCount, s.search(q, 1).totalHits);\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","pathOld":"/dev/null","sourceNew":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    //System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n    //System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n    //System.out.println(\"actual count \" + actualCount);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    //System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n    //System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    //System.out.println(\"TEST: index terms\");\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      //System.out.println(\"  \" + term);\n    }\n\n    //System.out.println(\"TEST: now force merge\");\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    //System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          //System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          count++;\n        }\n        //System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n    } else if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n    }\n\n    assertEquals(actualCount, s.search(q, 1).totalHits);\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d36b496b747a10405f5d42dfea257bbe0cf3399","date":1428484752,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","sourceNew":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n    } else if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n    }\n    assertEquals(actualCount, s.search(q, 1).totalHits);\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    //System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n    //System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n    //System.out.println(\"actual count \" + actualCount);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    //System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n    //System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    //System.out.println(\"TEST: index terms\");\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      //System.out.println(\"  \" + term);\n    }\n\n    //System.out.println(\"TEST: now force merge\");\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    //System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          //System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          count++;\n        }\n        //System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n    } else if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n    }\n\n    assertEquals(actualCount, s.search(q, 1).totalHits);\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7444290b9d8b70753b9a34f1a0a0a3feab4b16f2","date":1428591480,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","sourceNew":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n\n    try {\n\n      if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n      }\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(maxClauseCount);\n    }\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n    } else if (random().nextBoolean()) {\n      q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n    }\n    assertEquals(actualCount, s.search(q, 1).totalHits);\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17a677e88529303e630fb314d1506ea0cdb40f00","date":1432211402,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms#testTermRange().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","sourceNew":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testTermRange() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n\n    try {\n\n      // TODO test with boolean rewrite as well once we can create term\n      // queries on fake terms\n      /*if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      }*/\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n      }\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(maxClauseCount);\n    }\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n\n    try {\n\n      if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n      }\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(maxClauseCount);\n    }\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7444290b9d8b70753b9a34f1a0a0a3feab4b16f2":["5d36b496b747a10405f5d42dfea257bbe0cf3399"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"17a677e88529303e630fb314d1506ea0cdb40f00":["7444290b9d8b70753b9a34f1a0a0a3feab4b16f2"],"5d36b496b747a10405f5d42dfea257bbe0cf3399":["3e8715d826e588419327562287d5d6a8040d63d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17a677e88529303e630fb314d1506ea0cdb40f00"]},"commit2Childs":{"7444290b9d8b70753b9a34f1a0a0a3feab4b16f2":["17a677e88529303e630fb314d1506ea0cdb40f00"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["d2638f781be724518ff6c2263d14a48cf6e68017","5d36b496b747a10405f5d42dfea257bbe0cf3399"],"17a677e88529303e630fb314d1506ea0cdb40f00":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5d36b496b747a10405f5d42dfea257bbe0cf3399":["7444290b9d8b70753b9a34f1a0a0a3feab4b16f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}