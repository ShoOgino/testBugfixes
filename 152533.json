{"path":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","commits":[{"id":"7e2cb543b41c145f33390f460ee743d6693c9c6c","date":1219243087,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","pathOld":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return reusableToken.reinit(buffer, 0, length, start, start+length, tokenType);\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         hanppened in the InputStream\n     *\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"538bcf4e0713df4177ab60efe2c40fc08ac83d74","date":1237397333,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","pathOld":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    /** convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return reusableToken.reinit(buffer, 0, length, start, start+length, tokenType);\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return reusableToken.reinit(buffer, 0, length, start, start+length, tokenType);\n    }\n\n","bugFix":null,"bugIntro":["0291cd5597e313c484c410b94adc8f0172e0306e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0291cd5597e313c484c410b94adc8f0172e0306e","date":1245170319,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","pathOld":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n            return reusableToken.reinit\n                (buffer, 0, length, start, start+length, TOKEN_TYPE_NAMES[tokenType]);\n        } else if (dataLen == -1) {\n          return null;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    /** convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return reusableToken.reinit(buffer, 0, length, start, start+length, tokenType);\n    }\n\n","bugFix":["538bcf4e0713df4177ab60efe2c40fc08ac83d74","7e2cb543b41c145f33390f460ee743d6693c9c6c","7c9cc1cf78edc774cdf339bab3ae62f077929607"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd27af5c226d98a7c6378c388a67a3bff7c0b3a2","date":1245784531,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","pathOld":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n            return reusableToken.reinit\n                (buffer, 0, length, input.correctOffset(start), input.correctOffset(start+length), TOKEN_TYPE_NAMES[tokenType]);\n        } else if (dataLen == -1) {\n          return null;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n            return reusableToken.reinit\n                (buffer, 0, length, start, start+length, TOKEN_TYPE_NAMES[tokenType]);\n        } else if (dataLen == -1) {\n          return null;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd745d580729e528151b58aeda87ef82f1b95c9b","date":1248369082,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","pathOld":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n            return reusableToken.reinit\n                (buffer, 0, length, input.correctOffset(start), input.correctOffset(start+length), TOKEN_TYPE_NAMES[tokenType]);\n        } else if (dataLen == -1) {\n          return null;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n            return reusableToken.reinit\n                (buffer, 0, length, input.correctOffset(start), input.correctOffset(start+length), TOKEN_TYPE_NAMES[tokenType]);\n        } else if (dataLen == -1) {\n          return null;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dd745d580729e528151b58aeda87ef82f1b95c9b":["cd27af5c226d98a7c6378c388a67a3bff7c0b3a2"],"538bcf4e0713df4177ab60efe2c40fc08ac83d74":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0291cd5597e313c484c410b94adc8f0172e0306e":["538bcf4e0713df4177ab60efe2c40fc08ac83d74"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dd745d580729e528151b58aeda87ef82f1b95c9b"],"cd27af5c226d98a7c6378c388a67a3bff7c0b3a2":["0291cd5597e313c484c410b94adc8f0172e0306e"]},"commit2Childs":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["538bcf4e0713df4177ab60efe2c40fc08ac83d74"],"dd745d580729e528151b58aeda87ef82f1b95c9b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"538bcf4e0713df4177ab60efe2c40fc08ac83d74":["0291cd5597e313c484c410b94adc8f0172e0306e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"0291cd5597e313c484c410b94adc8f0172e0306e":["cd27af5c226d98a7c6378c388a67a3bff7c0b3a2"],"cd27af5c226d98a7c6378c388a67a3bff7c0b3a2":["dd745d580729e528151b58aeda87ef82f1b95c9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}