{"path":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","commits":[{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (FutureArrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n                                 FutureArrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n                                 FutureArrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n                                 FutureArrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c226b0eeb8b028f572020f459851a663a2c064e","date":1542377651,"type":3,"author":"Christophe Bismuth","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (FutureArrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n                                 FutureArrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n                                 FutureArrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n                                 FutureArrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), scoreMode, result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (FutureArrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n                                 FutureArrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n                                 FutureArrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n                                 FutureArrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (Arrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n                                 Arrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n                                 Arrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n                                 Arrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), scoreMode, result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (FutureArrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n                                 FutureArrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n                                 FutureArrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n                                 FutureArrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), scoreMode, result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"646cad9a0473e40f431299c5d1567d1f4d32f689","date":1562050301,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               visit(docID);\n                             }\n                           }\n\n                           @Override\n                           public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               int docID;\n                               while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                                 visit(docID);\n                               }\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (Arrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n                                 Arrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n                                 Arrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n                                 Arrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), scoreMode, result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (Arrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n                                 Arrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n                                 Arrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n                                 Arrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), scoreMode, result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf78061c9d70ef5c0d858908e932205ee2a4a39a","date":1567496758,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimatePointCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect( \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               visit(docID);\n                             }\n                           }\n\n                           @Override\n                           public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n                             if (polygonPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n                                                       NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               int docID;\n                               while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                                 visit(docID);\n                               }\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (Arrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n                                 Arrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n                                 Arrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n                                 Arrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), scoreMode, result.build().iterator());\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","date":1570176835,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimateDocCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimatePointCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","bugFix":["cf78061c9d70ef5c0d858908e932205ee2a4a39a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1","date":1571074565,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    final Component2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createComponentPredicate(tree);\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(tree.getMinY()), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(tree.getMaxY()), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(tree.getMinX()), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(tree.getMaxX()), maxLon, 0);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimateDocCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimateDocCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    final Component2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createComponentPredicate(tree);\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(tree.getMinY()), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(tree.getMaxY()), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(tree.getMinX()), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(tree.getMaxX()), maxLon, 0);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimateDocCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createPolygonPredicate(polygons, tree);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimatePointCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a923e28c9d079048c6993884ec89c44f0380b923","date":1581100153,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    final Component2D tree = LatLonGeometry.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createComponentPredicate(tree);\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(tree.getMinY()), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(tree.getMaxY()), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(tree.getMinX()), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(tree.getMaxX()), maxLon, 0);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimateDocCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    final Component2D tree = Polygon2D.create(polygons);\n    final GeoEncodingUtils.PolygonPredicate polygonPredicate = GeoEncodingUtils.createComponentPredicate(tree);\n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(tree.getMinY()), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(tree.getMaxY()), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(tree.getMinX()), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(tree.getMaxX()), maxLon, 0);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        final Weight weight = this;\n\n        return new ScorerSupplier() {\n\n          long cost = -1;\n          DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n          final IntersectVisitor visitor = getIntersectVisitor(result, tree, polygonPredicate, minLat, maxLat, minLon, maxLon);\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            values.intersect(visitor);\n            return new ConstantScoreScorer(weight, score(), scoreMode, result.build().iterator());\n          }\n\n          @Override\n          public long cost() {\n            if (cost == -1) {\n               // Computing the cost may be expensive, so only do it if necessary\n              cost = values.estimateDocCount(visitor);\n              assert cost >= 0;\n            }\n            return cost;\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n    };\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"cf78061c9d70ef5c0d858908e932205ee2a4a39a":["646cad9a0473e40f431299c5d1567d1f4d32f689"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["9c226b0eeb8b028f572020f459851a663a2c064e"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"646cad9a0473e40f431299c5d1567d1f4d32f689":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a923e28c9d079048c6993884ec89c44f0380b923":["b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"],"9c226b0eeb8b028f572020f459851a663a2c064e":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a923e28c9d079048c6993884ec89c44f0380b923"],"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49":["cf78061c9d70ef5c0d858908e932205ee2a4a39a"],"b0b597c65628ca9e73913a07e81691f8229bae35":["cf78061c9d70ef5c0d858908e932205ee2a4a39a","b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"]},"commit2Childs":{"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1":["a923e28c9d079048c6993884ec89c44f0380b923","b0b597c65628ca9e73913a07e81691f8229bae35"],"cf78061c9d70ef5c0d858908e932205ee2a4a39a":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","b0b597c65628ca9e73913a07e81691f8229bae35"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["646cad9a0473e40f431299c5d1567d1f4d32f689"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["9c226b0eeb8b028f572020f459851a663a2c064e"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"646cad9a0473e40f431299c5d1567d1f4d32f689":["cf78061c9d70ef5c0d858908e932205ee2a4a39a"],"a923e28c9d079048c6993884ec89c44f0380b923":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9c226b0eeb8b028f572020f459851a663a2c064e":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49":["b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}