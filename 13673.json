{"path":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","commits":[{"id":"cad90908fe6b90a8b7310dc8c2dceac34341580c","date":1344538399,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access.  We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access.  We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access.  We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","sourceNew":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","sourceOld":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access.  We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7da9d8536c11576df10e348efa79d2739170936","date":1509475399,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","sourceNew":"  protected void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","sourceOld":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a885a9bb91342e3cf8bfcf53610ab8d6307ef3d","date":1509475828,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","sourceNew":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","sourceOld":"  protected void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fba58147c9753bb58bbfbd2ebbbf02aecc1eafde","date":1509748659,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","sourceNew":"  protected void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","sourceOld":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/TransactionLog#checkWriteHeader(LogCodec,SolrInputDocument).mjava","sourceNew":"  protected void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","sourceOld":"  private void checkWriteHeader(LogCodec codec, SolrInputDocument optional) throws IOException {\n\n    // Unsynchronized access. We can get away with an unsynchronized access here\n    // since we will never get a false non-zero when the position is in fact 0.\n    // rollback() is the only function that can reset to zero, and it blocks updates.\n    if (fos.size() != 0) return;\n\n    synchronized (this) {\n      if (fos.size() != 0) return;  // check again while synchronized\n      if (optional != null) {\n        addGlobalStrings(optional.getFieldNames());\n      }\n      writeLogHeader(codec);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"86290366cefc1b9d4eced13b430858c4a4c0421d":["cad90908fe6b90a8b7310dc8c2dceac34341580c"],"fba58147c9753bb58bbfbd2ebbbf02aecc1eafde":["1a885a9bb91342e3cf8bfcf53610ab8d6307ef3d"],"e7da9d8536c11576df10e348efa79d2739170936":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cad90908fe6b90a8b7310dc8c2dceac34341580c"],"cad90908fe6b90a8b7310dc8c2dceac34341580c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["1a885a9bb91342e3cf8bfcf53610ab8d6307ef3d","fba58147c9753bb58bbfbd2ebbbf02aecc1eafde"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1a885a9bb91342e3cf8bfcf53610ab8d6307ef3d":["e7da9d8536c11576df10e348efa79d2739170936"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cad90908fe6b90a8b7310dc8c2dceac34341580c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"]},"commit2Childs":{"86290366cefc1b9d4eced13b430858c4a4c0421d":["e7da9d8536c11576df10e348efa79d2739170936"],"fba58147c9753bb58bbfbd2ebbbf02aecc1eafde":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"e7da9d8536c11576df10e348efa79d2739170936":["1a885a9bb91342e3cf8bfcf53610ab8d6307ef3d"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"cad90908fe6b90a8b7310dc8c2dceac34341580c":["86290366cefc1b9d4eced13b430858c4a4c0421d","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","cad90908fe6b90a8b7310dc8c2dceac34341580c","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"1a885a9bb91342e3cf8bfcf53610ab8d6307ef3d":["fba58147c9753bb58bbfbd2ebbbf02aecc1eafde","d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}