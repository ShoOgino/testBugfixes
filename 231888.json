{"path":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","commits":[{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(PlanetModel.WGS84);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(PlanetModel.WGS84);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b","date":1459439641,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(PlanetModel.WGS84);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, toRadians(lats[id]), toRadians(lons[id]));\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(PlanetModel.WGS84);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9","date":1459984736,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n\n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        points[i] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i])));\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n              \n      Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        if (point != null) {\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  point=\" + point + \"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(PlanetModel.WGS84);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, toRadians(lats[id]), toRadians(lons[id]));\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f77a7e20dbadc238bc591ca864625fbf17c7976","date":1460093626,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n\n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        points[i] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i])));\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        if (point != null) {\n          boolean expected = ((deleted.contains(id) == false) && ((PointInGeo3DShapeQuery)query).getShape().isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n            b.append(\"  point=\" + point + \"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", ((PointInGeo3DShapeQuery)query).getShape(), r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n\n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        points[i] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i])));\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n              \n      Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        if (point != null) {\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  point=\" + point + \"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62d7a29c02d2e863a5d8859ecc18a20c743e7f79","date":1460177787,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n\n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        points[i] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i])));\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        if (point != null) {\n          boolean expected = ((deleted.contains(id) == false) && ((PointInGeo3DShapeQuery)query).getShape().isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n            b.append(\"  point=\" + point + \"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", ((PointInGeo3DShapeQuery)query).getShape(), point, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n\n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        points[i] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i])));\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        if (point != null) {\n          boolean expected = ((deleted.contains(id) == false) && ((PointInGeo3DShapeQuery)query).getShape().isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n            b.append(\"  point=\" + point + \"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", ((PointInGeo3DShapeQuery)query).getShape(), r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":["dc584fa95053c03d95035277a2d2aaddd537c0fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dc584fa95053c03d95035277a2d2aaddd537c0fa","date":1460232759,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n\n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        points[i] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i])));\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        if (point != null) {\n          boolean expected = ((deleted.contains(id) == false) && ((PointInGeo3DShapeQuery)query).getShape().isWithin(point));\n          if (hits.get(docID) != expected) {\n            GeoPoint scaledPoint = PlanetModel.WGS84.createSurfacePoint(point);\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  point=\" + point + \"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", ((PointInGeo3DShapeQuery)query).getShape(), point, scaledPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n\n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        points[i] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i])));\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        if (point != null) {\n          boolean expected = ((deleted.contains(id) == false) && ((PointInGeo3DShapeQuery)query).getShape().isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n            b.append(\"  point=\" + point + \"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", ((PointInGeo3DShapeQuery)query).getShape(), point, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":["62d7a29c02d2e863a5d8859ecc18a20c743e7f79"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fce328ef870a3ecd74b752ab0906156ff29a4b93","date":1460809783,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          // If there's a conflict, we don't know what 'truth' actually is; either result is OK\n          boolean conflict = shape.isWithin(point) != shape.isWithin(unquantizedPoint);\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(unquantizedPoint));\n          if (hits.get(docID) != expected) {\n            if (conflict) {\n              if (VERBOSE) {\n                System.err.println(\"CONFLICT: id=\" + id + \" quantized point membership disagrees with non-quantized point: truth unknown\");\n              }\n            } else {\n              StringBuilder b = new StringBuilder();\n              if (expected) {\n                b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n              } else {\n                b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n              }\n              b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n              b.append(\"  world bounds=(\" +\n                \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n                \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n                \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n              b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\"\\n\");\n              b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\"\\n\");\n              b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n              b.append(\"  query=\" + query + \"\\n\");\n              b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n              fail(b.toString());\n            }\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n\n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        points[i] = quantize(new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i])));\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        if (point != null) {\n          boolean expected = ((deleted.contains(id) == false) && ((PointInGeo3DShapeQuery)query).getShape().isWithin(point));\n          if (hits.get(docID) != expected) {\n            GeoPoint scaledPoint = PlanetModel.WGS84.createSurfacePoint(point);\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  point=\" + point + \"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", ((PointInGeo3DShapeQuery)query).getShape(), point, scaledPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44bf8a78f9923d5491766bd26aff6897a47b2833","date":1460837509,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          // If there's a conflict, we don't know what 'truth' actually is; either result is OK\n          boolean conflict = shape.isWithin(point) != shape.isWithin(unquantizedPoint);\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(unquantizedPoint));\n          if (hits.get(docID) != expected) {\n            if (conflict) {\n              if (VERBOSE) {\n                System.err.println(\"CONFLICT: id=\" + id + \" quantized point membership disagrees with non-quantized point: truth unknown\");\n              }\n            } else {\n              StringBuilder b = new StringBuilder();\n              if (expected) {\n                b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n              } else {\n                b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n              }\n              b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n              b.append(\"  world bounds=(\" +\n                \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n                \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n                \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n              b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\"\\n\");\n              b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\"\\n\");\n              b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n              b.append(\"  query=\" + query + \"\\n\");\n              b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n              fail(b.toString());\n            }\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":["50cd5ab0847feff9dd830dd02415e8e9fa0a80e7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50cd5ab0847feff9dd830dd02415e8e9fa0a80e7","date":1461002039,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + ((PointInGeo3DShapeQuery)query).getShape() + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":["44bf8a78f9923d5491766bd26aff6897a47b2833"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      for(int docID=0;docID<r.maxDoc();docID++) {\n        int id = (int) docIDToID.get(docID);\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[],PlanetModel).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons, final PlanetModel planetModel) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(planetModel, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i], planetModel);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\", planetModel); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(planetModel, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + planetModel.getMinimumXValue() + \" maxX=\" + planetModel.getMaximumXValue() +\n              \" minY=\" + planetModel.getMinimumYValue() + \" maxY=\" + planetModel.getMaximumYValue() +\n              \" minZ=\" + planetModel.getMinimumZValue() + \" maxZ=\" + planetModel.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    GeoPoint[] points = new GeoPoint[lats.length];\n    GeoPoint[] unquantizedPoints = new GeoPoint[lats.length];\n    \n    // Pre-quantize all lat/lons:\n    for(int i=0;i<lats.length;i++) {\n      if (Double.isNaN(lats[i]) == false) {\n        //System.out.println(\"lats[\" + i + \"] = \" + lats[i]);\n        unquantizedPoints[i] = new GeoPoint(PlanetModel.WGS84, toRadians(lats[i]), toRadians(lons[i]));\n        points[i] = quantize(unquantizedPoints[i]);\n      }\n    }\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < points.length/100) {\n      iwc.setMaxBufferedDocs(points.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (points.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<points.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      GeoPoint point = points[id];\n      if (point != null) {\n        doc.add(new Geo3DPoint(\"point\", point.x, point.y, point.z));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    if (VERBOSE) {\n      System.out.println(\"TEST: using reader \" + r);\n    }\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(100);\n\n    for (int iter=0;iter<iters;iter++) {\n\n      /*\n      GeoShape shape = randomShape();\n\n      if (VERBOSE) {\n        System.err.println(\"\\nTEST: iter=\" + iter + \" shape=\"+shape);\n      }\n      */\n      \n      Query query = random3DQuery(\"point\"); // Geo3DPoint.newShapeQuery(\"point\", shape);\n\n      if (VERBOSE) {\n        System.err.println(\"  using query: \" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      if (VERBOSE) {\n        System.err.println(\"  hitCount: \" + hits.cardinality());\n      }\n      \n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n      for(int docID=0;docID<r.maxDoc();docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        GeoPoint point = points[id];\n        GeoPoint unquantizedPoint = unquantizedPoints[id];\n        if (point != null && unquantizedPoint != null) {\n          GeoShape shape = ((PointInGeo3DShapeQuery)query).getShape();\n          XYZBounds bounds = new XYZBounds();\n          shape.getBounds(bounds);\n          XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, bounds.getMinimumX(), bounds.getMaximumX(), bounds.getMinimumY(), bounds.getMaximumY(), bounds.getMinimumZ(), bounds.getMaximumZ());\n\n          boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point));\n          if (hits.get(docID) != expected) {\n            StringBuilder b = new StringBuilder();\n            if (expected) {\n              b.append(\"FAIL: id=\" + id + \" should have matched but did not\\n\");\n            } else {\n              b.append(\"FAIL: id=\" + id + \" should not have matched but did\\n\");\n            }\n            b.append(\"  shape=\" + shape + \"\\n\");\n            b.append(\"  bounds=\" + bounds + \"\\n\");\n            b.append(\"  world bounds=(\" +\n              \" minX=\" + PlanetModel.WGS84.getMinimumXValue() + \" maxX=\" + PlanetModel.WGS84.getMaximumXValue() +\n              \" minY=\" + PlanetModel.WGS84.getMinimumYValue() + \" maxY=\" + PlanetModel.WGS84.getMaximumYValue() +\n              \" minZ=\" + PlanetModel.WGS84.getMinimumZValue() + \" maxZ=\" + PlanetModel.WGS84.getMaximumZValue() + \"\\n\");\n            b.append(\"  quantized point=\" + point + \" within shape? \"+shape.isWithin(point)+\" within bounds? \"+solid.isWithin(point)+\"\\n\");\n            b.append(\"  unquantized point=\" + unquantizedPoint + \" within shape? \"+shape.isWithin(unquantizedPoint)+\" within bounds? \"+solid.isWithin(unquantizedPoint)+\"\\n\");\n            b.append(\"  docID=\" + docID + \" deleted?=\" + deleted.contains(id) + \"\\n\");\n            b.append(\"  query=\" + query + \"\\n\");\n            b.append(\"  explanation:\\n    \" + explain(\"point\", shape, point, unquantizedPoint, r, docID).replace(\"\\n\", \"\\n  \"));\n            fail(b.toString());\n          }\n        } else {\n          assertFalse(hits.get(docID));\n        }\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44bf8a78f9923d5491766bd26aff6897a47b2833":["fce328ef870a3ecd74b752ab0906156ff29a4b93"],"c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b":["b4e444678504caf66a8060b1d514383aa4feac0c"],"4f77a7e20dbadc238bc591ca864625fbf17c7976":["4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9"],"62d7a29c02d2e863a5d8859ecc18a20c743e7f79":["4f77a7e20dbadc238bc591ca864625fbf17c7976"],"fce328ef870a3ecd74b752ab0906156ff29a4b93":["dc584fa95053c03d95035277a2d2aaddd537c0fa"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["417142ff08fda9cf0b72d5133e63097a166c6458"],"b4e444678504caf66a8060b1d514383aa4feac0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["50cd5ab0847feff9dd830dd02415e8e9fa0a80e7","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"417142ff08fda9cf0b72d5133e63097a166c6458":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","9fc47cb7b4346802411bb432f501ed0673d7119e"],"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9":["c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b"],"dc584fa95053c03d95035277a2d2aaddd537c0fa":["62d7a29c02d2e863a5d8859ecc18a20c743e7f79"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["50cd5ab0847feff9dd830dd02415e8e9fa0a80e7","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["50cd5ab0847feff9dd830dd02415e8e9fa0a80e7"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"50cd5ab0847feff9dd830dd02415e8e9fa0a80e7":["44bf8a78f9923d5491766bd26aff6897a47b2833"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"]},"commit2Childs":{"44bf8a78f9923d5491766bd26aff6897a47b2833":["50cd5ab0847feff9dd830dd02415e8e9fa0a80e7"],"c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b":["4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9"],"4f77a7e20dbadc238bc591ca864625fbf17c7976":["62d7a29c02d2e863a5d8859ecc18a20c743e7f79"],"62d7a29c02d2e863a5d8859ecc18a20c743e7f79":["dc584fa95053c03d95035277a2d2aaddd537c0fa"],"fce328ef870a3ecd74b752ab0906156ff29a4b93":["44bf8a78f9923d5491766bd26aff6897a47b2833"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b4e444678504caf66a8060b1d514383aa4feac0c":["c6e339fe2e96467edfc4bf0aa5654e4da37e2d1b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9":["4f77a7e20dbadc238bc591ca864625fbf17c7976"],"dc584fa95053c03d95035277a2d2aaddd537c0fa":["fce328ef870a3ecd74b752ab0906156ff29a4b93"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4e444678504caf66a8060b1d514383aa4feac0c"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"50cd5ab0847feff9dd830dd02415e8e9fa0a80e7":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}