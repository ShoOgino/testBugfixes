{"path":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","commits":[{"id":"849083f8095b1ffaff05a66e0b1e024617b9968d","date":1536291524,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = TimeRoutedAliasUpdateProcessorTest.configName + getTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    waitCol(\"2017-10-26\", numShards);\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    waitCol(\"2017-10-26\", numShards);\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = TimeRoutedAliasUpdateProcessorTest.configName + getTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    waitCol(\"2017-10-26\", numShards);\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n  }\n\n","bugFix":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb","date":1543645563,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4, cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    waitCol(\"2017-10-26\", numShards);\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5, cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(8,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    waitCol(\"2017-10-26\", numShards);\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ff8a68c1177ac430ec03832a6e1c969b8a5b902","date":1543786480,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n\n    // TIME SENSITIVE SECTION BEGINS\n\n    // In this section we intentionally rely on timing of a race condition but the gap in collection creation time vs\n    // requesting the list of aliases and adding a single doc should be very large (1-2 seconds vs a few ms so we\n    // should always win the race) This is necessary  because we are testing that we can guard against specific race\n    // conditions that happen while a collection is being created. To test this without timing sensitivity we would\n    // need a means to pass a semaphore to the server that it can use to delay collection creation\n    //\n    // This section must NOT gain any Thread.sleep() statements, nor should it gain any long running operations\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3, cols.size());\n    assertTrue(\"Preemptive creation appears to not be asynchronous anymore\",!cols.contains(\"myalias_2017-10-26\"));\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    // Here we quickly add another doc in a separate request, before the collection creation has completed.\n    // This has the potential to incorrectly cause preemptive collection creation to run twice and create a\n    // second collection. TimeRoutedAliasUpdateProcessor is meant to guard against this race condition.\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // TIME SENSITIVE SECTION ENDS\n\n    waitCol(\"2017-10-26\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation happened twice and created a collection \" +\n        \"further in the future than the configured time slice!\",!cols.contains(\"myalias_2017-10-27\"));\n\n    assertEquals(4, cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitCol(\"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitCol(\"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitCol(\"2017-11-03\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias_2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n    waitCol(\"2017-11-04\",numShards);\n\n    Thread.sleep(2000); // allow the executor used in preemptive creation time to shut down.\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4, cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    waitCol(\"2017-10-26\", numShards);\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5, cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(8,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e79d9882f7c12bf527a76ffa43328e4e634db60","date":1543786915,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n\n    // TIME SENSITIVE SECTION BEGINS\n\n    // In this section we intentionally rely on timing of a race condition but the gap in collection creation time vs\n    // requesting the list of aliases and adding a single doc should be very large (1-2 seconds vs a few ms so we\n    // should always win the race) This is necessary  because we are testing that we can guard against specific race\n    // conditions that happen while a collection is being created. To test this without timing sensitivity we would\n    // need a means to pass a semaphore to the server that it can use to delay collection creation\n    //\n    // This section must NOT gain any Thread.sleep() statements, nor should it gain any long running operations\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3, cols.size());\n    assertTrue(\"Preemptive creation appears to not be asynchronous anymore\",!cols.contains(\"myalias_2017-10-26\"));\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    // Here we quickly add another doc in a separate request, before the collection creation has completed.\n    // This has the potential to incorrectly cause preemptive collection creation to run twice and create a\n    // second collection. TimeRoutedAliasUpdateProcessor is meant to guard against this race condition.\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // TIME SENSITIVE SECTION ENDS\n\n    waitCol(\"2017-10-26\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation happened twice and created a collection \" +\n        \"further in the future than the configured time slice!\",!cols.contains(\"myalias_2017-10-27\"));\n\n    assertEquals(4, cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitCol(\"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitCol(\"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitCol(\"2017-11-03\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias_2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should cause preemptive creation 11-04\n        params));\n    waitCol(\"2017-11-04\",numShards);\n\n    Thread.sleep(2000); // allow the executor used in preemptive creation time to shut down.\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n\n    // TIME SENSITIVE SECTION BEGINS\n\n    // In this section we intentionally rely on timing of a race condition but the gap in collection creation time vs\n    // requesting the list of aliases and adding a single doc should be very large (1-2 seconds vs a few ms so we\n    // should always win the race) This is necessary  because we are testing that we can guard against specific race\n    // conditions that happen while a collection is being created. To test this without timing sensitivity we would\n    // need a means to pass a semaphore to the server that it can use to delay collection creation\n    //\n    // This section must NOT gain any Thread.sleep() statements, nor should it gain any long running operations\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3, cols.size());\n    assertTrue(\"Preemptive creation appears to not be asynchronous anymore\",!cols.contains(\"myalias_2017-10-26\"));\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    // Here we quickly add another doc in a separate request, before the collection creation has completed.\n    // This has the potential to incorrectly cause preemptive collection creation to run twice and create a\n    // second collection. TimeRoutedAliasUpdateProcessor is meant to guard against this race condition.\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // TIME SENSITIVE SECTION ENDS\n\n    waitCol(\"2017-10-26\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation happened twice and created a collection \" +\n        \"further in the future than the configured time slice!\",!cols.contains(\"myalias_2017-10-27\"));\n\n    assertEquals(4, cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitCol(\"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitCol(\"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitCol(\"2017-11-03\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias_2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n    waitCol(\"2017-11-04\",numShards);\n\n    Thread.sleep(2000); // allow the executor used in preemptive creation time to shut down.\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6","date":1547236077,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        //noinspection ThrowFromFinallyBlock\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(\"2017-10-26\", numShards, alias);\n    waitColAndAlias(\"2017-10-26\", numShards, alias2);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(\"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(\"2017-10-23\",2, \"foo\");\n    waitCoreCount(\"foo_2017-10-23\", 1); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(\"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(\"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(\"foo\");\n\n    CollectionAdminRequest.deleteAlias(\"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(\"2017-10-27\", numShards, alias);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 5, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(\"2017-10-27\", numShards, alias);\n    waitColAndAlias(\"2017-10-28\", numShards, alias);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(\"2017-10-29\", numShards, alias);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(\"2017-10-30\", numShards, alias);\n    waitColAndAlias(\"2017-10-31\", numShards, alias); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n    assertNumDocs(\"2017-10-31\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(\"2017-11-01\", numShards, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(\"2017-11-02\", numShards, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(\"2017-11-03\", numShards, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias_2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should cause preemptive creation 11-04\n        params));\n    waitColAndAlias(\"2017-11-04\",numShards, alias);\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")\n    ));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards); // This one should have already existed from the alias creation\n    waitCol(\"2017-10-24\", numShards); // Create 1\n    waitCol(\"2017-10-25\", numShards); // Create 2nd synchronously (ensure this is not broken)\n\n    // normal update, nothing special, no collection creation required.\n    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3,cols.size());\n\n    assertNumDocs(\"2017-10-23\", 0);\n    assertNumDocs(\"2017-10-24\", 0);\n    assertNumDocs(\"2017-10-25\", 1);\n\n    // cause some collections to be created\n\n    ModifiableSolrParams params = params();\n\n    // TIME SENSITIVE SECTION BEGINS\n\n    // In this section we intentionally rely on timing of a race condition but the gap in collection creation time vs\n    // requesting the list of aliases and adding a single doc should be very large (1-2 seconds vs a few ms so we\n    // should always win the race) This is necessary  because we are testing that we can guard against specific race\n    // conditions that happen while a collection is being created. To test this without timing sensitivity we would\n    // need a means to pass a semaphore to the server that it can use to delay collection creation\n    //\n    // This section must NOT gain any Thread.sleep() statements, nor should it gain any long running operations\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n        sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n        sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\"),\n        sdoc(\"id\", \"5\", \"timestamp_dt\", \"2017-10-25T23:00:00Z\")), // should cause preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(3, cols.size());\n    assertTrue(\"Preemptive creation appears to not be asynchronous anymore\",!cols.contains(\"myalias_2017-10-26\"));\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 3);\n\n    // Here we quickly add another doc in a separate request, before the collection creation has completed.\n    // This has the potential to incorrectly cause preemptive collection creation to run twice and create a\n    // second collection. TimeRoutedAliasUpdateProcessor is meant to guard against this race condition.\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"6\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // might cause duplicate preemptive creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // TIME SENSITIVE SECTION ENDS\n\n    waitCol(\"2017-10-26\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation happened twice and created a collection \" +\n        \"further in the future than the configured time slice!\",!cols.contains(\"myalias_2017-10-27\"));\n\n    assertEquals(4, cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 4);\n    assertNumDocs(\"2017-10-26\", 0);\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 5);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-27\", numShards);\n    waitCol(\"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 0);\n    assertNumDocs(\"2017-10-28\", 0);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitCol(\"2017-10-30\", numShards);\n    waitCol(\"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1);\n    assertNumDocs(\"2017-10-24\", 1);\n    assertNumDocs(\"2017-10-25\", 6);\n    assertNumDocs(\"2017-10-26\", 0);\n    assertNumDocs(\"2017-10-27\", 1);\n    assertNumDocs(\"2017-10-28\", 3); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0);\n    assertNumDocs(\"2017-10-30\", 1);\n    assertNumDocs(\"2017-10-31\", 0);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitCol(\"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitCol(\"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitCol(\"2017-11-03\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias_2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should cause preemptive creation 11-04\n        params));\n    waitCol(\"2017-11-04\",numShards);\n\n    Thread.sleep(2000); // allow the executor used in preemptive creation time to shut down.\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        //noinspection ThrowFromFinallyBlock\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(alias, \"_\", \"2017-10-26\", numShards);\n    waitColAndAlias(alias2, \"_\", \"2017-10-26\", numShards);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(\"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(\"foo\", \"_\", \"2017-10-23\",2);\n    waitCoreCount(\"foo_2017-10-23\", 1); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(\"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(\"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(\"foo\");\n\n    CollectionAdminRequest.deleteAlias(\"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, \"_\", \"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 5, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, \"_\", \"2017-10-27\", numShards);\n    waitColAndAlias(alias, \"_\", \"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, \"_\", \"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, \"_\", \"2017-10-30\", numShards);\n    waitColAndAlias(alias, \"_\", \"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n    assertNumDocs(\"2017-10-31\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(alias, \"_\", \"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(alias, \"_\", \"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(alias, \"_\", \"2017-11-03\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias_2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should cause preemptive creation 11-04\n        params));\n    waitColAndAlias(alias, \"_\", \"2017-11-04\",numShards);\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        //noinspection ThrowFromFinallyBlock\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(\"2017-10-26\", numShards, alias);\n    waitColAndAlias(\"2017-10-26\", numShards, alias2);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(\"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(\"2017-10-23\",2, \"foo\");\n    waitCoreCount(\"foo_2017-10-23\", 1); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(\"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(\"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(\"foo\");\n\n    CollectionAdminRequest.deleteAlias(\"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(\"2017-10-27\", numShards, alias);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 5, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(\"2017-10-27\", numShards, alias);\n    waitColAndAlias(\"2017-10-28\", numShards, alias);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(\"2017-10-29\", numShards, alias);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(\"2017-10-30\", numShards, alias);\n    waitColAndAlias(\"2017-10-31\", numShards, alias); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n    assertNumDocs(\"2017-10-31\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(\"2017-11-01\", numShards, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(\"2017-11-02\", numShards, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(\"2017-11-03\", numShards, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias_2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should cause preemptive creation 11-04\n        params));\n    waitColAndAlias(\"2017-11-04\",numShards, alias);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"105e345cf3c0abed3cb6c109274a379cb2655adc","date":1561038472,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(alias, TRA, \"2017-10-26\", numShards);\n    waitColAndAlias(alias2, TRA, \"2017-10-26\", numShards);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(\"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(\"foo\", TRA, \"2017-10-23\",2);\n    waitCoreCount(\"foo\" + TRA + \"2017-10-23\", 4); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(\"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(\"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(\"foo\");\n\n    CollectionAdminRequest.deleteAlias(\"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 5, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-27\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-30\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n    assertNumDocs(\"2017-10-31\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-03\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias\" + TRA + \"2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should cause preemptive creation 11-04\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-04\",numShards);\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        //noinspection ThrowFromFinallyBlock\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(alias, \"_\", \"2017-10-26\", numShards);\n    waitColAndAlias(alias2, \"_\", \"2017-10-26\", numShards);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(\"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(\"foo\", \"_\", \"2017-10-23\",2);\n    waitCoreCount(\"foo_2017-10-23\", 1); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(\"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(\"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(\"foo\");\n\n    CollectionAdminRequest.deleteAlias(\"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, \"_\", \"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 5, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, \"_\", \"2017-10-27\", numShards);\n    waitColAndAlias(alias, \"_\", \"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, \"_\", \"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, \"_\", \"2017-10-30\", numShards);\n    waitColAndAlias(alias, \"_\", \"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n    assertNumDocs(\"2017-10-31\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(alias, \"_\", \"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(alias, \"_\", \"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(alias, \"_\", \"2017-11-03\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias_2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should cause preemptive creation 11-04\n        params));\n    waitColAndAlias(alias, \"_\", \"2017-11-04\",numShards);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(alias, TRA, \"2017-10-26\", numShards);\n    waitColAndAlias(alias2, TRA, \"2017-10-26\", numShards);\n\n    // these next checks will be checking that a collection DID NOT get created asynchronously, there's\n    // no way to wait for something that should never exist to not exist... so all we can do is sleep\n    // a good while before checking\n    Thread.sleep(5000);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(getSaferTestName() + \"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(getSaferTestName() + \"foo\", TRA, \"2017-10-23\",2);\n    waitCoreCount(getSaferTestName() + \"foo\" + TRA + \"2017-10-23\", 4); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(getSaferTestName() + \"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(getSaferTestName() + \"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(getSaferTestName() + \"foo\");\n\n    CollectionAdminRequest.deleteAlias(getSaferTestName() + \"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4,cols.size()); // only one created in async case\n\n    // now test with pre-create window longer than time slice, only one creation per request\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\"), // should cause preemptive creation of 10-27 now\n        sdoc(\"id\", \"71\", \"timestamp_dt\", \"2017-10-25T23:02:00Z\")), // should not cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(9, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-30\", numShards);\n\n    // removed support for this case because it created a LOT of complexity for the benefit of attempting to\n    // (maybe) not pause again after already hitting a synchronous creation (but only if asynch gets it done first,\n    // otherwise we have a race... not enough benefit to justify the support/complexity.\n    //\n    // Now we just let the next doc take care of it...\n    //\n    // waitColAndAlias(alias, TRA, \"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(8,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(14, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 10-31\n        params));\n    waitColAndAlias(alias, TRA, \"2017-10-31\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should NOT cause preemptive creation 11-03\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertFalse(cols.contains(\"myalias\" + TRA + \"2017-11-03\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-03\",numShards);\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(alias, TRA, \"2017-10-26\", numShards);\n    waitColAndAlias(alias2, TRA, \"2017-10-26\", numShards);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(\"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(\"foo\", TRA, \"2017-10-23\",2);\n    waitCoreCount(\"foo\" + TRA + \"2017-10-23\", 4); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(\"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(\"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(\"foo\");\n\n    CollectionAdminRequest.deleteAlias(\"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    // now test with pre-create window longer than time slice, and forcing multiple creations.\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-27 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 5, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-27\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(8, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(12, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-30\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(9,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n    assertNumDocs(\"2017-10-31\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-03\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should NOT cause preemptive creation 11-04\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertTrue(\"Preemptive creation beyond ROUTER_PREEMPTIVE_CREATE_MATH setting of 3DAY!\",!cols.contains(\"myalias\" + TRA + \"2017-11-04\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-11-01T23:01:00Z\")), // should cause preemptive creation 11-04\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-04\",numShards);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testPreemptiveCreation().mjava","sourceNew":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas))\n        .setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas))\n        .setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(alias, TRA, \"2017-10-26\", numShards);\n    waitColAndAlias(alias2, TRA, \"2017-10-26\", numShards);\n\n    // these next checks will be checking that a collection DID NOT get created asynchronously, there's\n    // no way to wait for something that should never exist to not exist... so all we can do is sleep\n    // a good while before checking\n    Thread.sleep(5000);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(getSaferTestName() + \"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2))\n        .setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(getSaferTestName() + \"foo\", TRA, \"2017-10-23\",2);\n    waitCoreCount(getSaferTestName() + \"foo\" + TRA + \"2017-10-23\", 4); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(getSaferTestName() + \"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(getSaferTestName() + \"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(getSaferTestName() + \"foo\");\n\n    CollectionAdminRequest.deleteAlias(getSaferTestName() + \"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4,cols.size()); // only one created in async case\n\n    // now test with pre-create window longer than time slice, only one creation per request\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\"), // should cause preemptive creation of 10-27 now\n        sdoc(\"id\", \"71\", \"timestamp_dt\", \"2017-10-25T23:02:00Z\")), // should not cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(9, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-30\", numShards);\n\n    // removed support for this case because it created a LOT of complexity for the benefit of attempting to\n    // (maybe) not pause again after already hitting a synchronous creation (but only if asynch gets it done first,\n    // otherwise we have a race... not enough benefit to justify the support/complexity.\n    //\n    // Now we just let the next doc take care of it...\n    //\n    // waitColAndAlias(alias, TRA, \"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(8,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(14, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 10-31\n        params));\n    waitColAndAlias(alias, TRA, \"2017-10-31\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should NOT cause preemptive creation 11-03\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertFalse(cols.contains(\"myalias\" + TRA + \"2017-11-03\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-03\",numShards);\n\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void testPreemptiveCreation() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    // needed to verify that preemptive creation in one alias doesn't inhibit preemptive creation in another\n    CollectionAdminRequest.createTimeRoutedAlias(alias2, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    addOneDocSynchCreation(numShards, alias);\n    addOneDocSynchCreation(numShards, alias2);\n\n    List<String> cols;\n    ModifiableSolrParams params = params();\n\n    // Using threads to ensure that two TRA's  are simultaneously preemptively creating and don't\n    // interfere with each other\n    ExecutorService executorService = ExecutorUtil.newMDCAwareCachedThreadPool(\"TimeRoutedAliasProcessorTestx-testPreemptiveCreation\");\n\n    Exception[] threadExceptions = new Exception[2];\n    boolean[] threadStarted = new boolean[2];\n    boolean[] threadFinished = new boolean[2];\n    try {\n      CountDownLatch starter = new CountDownLatch(1);\n      executorService.submit(() -> {\n        threadStarted[0] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias);\n        } catch (Exception e) {\n          threadExceptions[0] = e;\n        }\n        threadFinished[0] = true;\n      });\n\n      executorService.submit(() -> {\n        threadStarted[1] = true;\n        try {\n          starter.await();\n          concurrentUpdates(params, alias2);\n        } catch (Exception e) {\n          threadExceptions[1] = e;\n        }\n        threadFinished[1] = true;\n      });\n      starter.countDown();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(executorService);\n    }\n\n    // threads are known to be terminated by now, check for exceptions\n    for (Exception threadException : threadExceptions) {\n      if (threadException != null) {\n        Thread.sleep(5000); // avoid spurious fails due to TRA thread not done yet\n        throw threadException;\n      }\n    }\n\n    // just for confidence that there's nothing dodgy about how the threads executed.\n    assertTrue(threadStarted[0]);\n    assertTrue(threadStarted[1]);\n    assertTrue(threadFinished[0]);\n    assertTrue(threadFinished[1]);\n\n    // if one of these times out then the test has failed due to interference between aliases\n    waitColAndAlias(alias, TRA, \"2017-10-26\", numShards);\n    waitColAndAlias(alias2, TRA, \"2017-10-26\", numShards);\n\n    // these next checks will be checking that a collection DID NOT get created asynchronously, there's\n    // no way to wait for something that should never exist to not exist... so all we can do is sleep\n    // a good while before checking\n    Thread.sleep(5000);\n\n    // after this we can ignore alias2\n    checkPreemptiveCase1(alias);\n    checkPreemptiveCase1(alias2);\n\n    // Some designs contemplated with close hooks were not properly restricted to the core and would have\n    // failed after other cores with other TRAs were stopped. Make sure that we don't fall into that trap in\n    // the future. The basic problem with a close hook solution is that one either winds up putting the\n    // executor on the TRAUP where it's duplicated/initiated for every request, or putting it at the class level\n    // in which case the hook will remove it for all TRA's which can pass a single TRA test nicely but is not safe\n    // where multiple TRA's might come and go.\n    //\n    // Start and stop some cores that have TRA's... 2x2 used to ensure every jetty gets at least one\n\n    CollectionAdminRequest.createTimeRoutedAlias(getSaferTestName() + \"foo\", \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\")\n        .process(solrClient);\n\n    waitColAndAlias(getSaferTestName() + \"foo\", TRA, \"2017-10-23\",2);\n    waitCoreCount(getSaferTestName() + \"foo\" + TRA + \"2017-10-23\", 4); // prove this works, for confidence in deletion checking below.\n    assertUpdateResponse(solrClient.add(getSaferTestName() + \"foo\",\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:00Z\") // no extra collections should be created\n    ));\n    assertUpdateResponse(solrClient.commit(getSaferTestName() + \"foo\"));\n\n    List<String> foo = solrClient.getClusterStateProvider().resolveAlias(getSaferTestName() + \"foo\");\n\n    CollectionAdminRequest.deleteAlias(getSaferTestName() + \"foo\").process(solrClient);\n\n    for (String colName : foo) {\n      CollectionAdminRequest.deleteCollection(colName).process(solrClient);\n      waitCoreCount(colName, 0);\n    }\n\n    // if the design for terminating our executor is correct create/delete above will not cause failures below\n    // continue testing...\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(4,cols.size()); // only one created in async case\n\n    // now test with pre-create window longer than time slice, only one creation per request\n    CollectionAdminRequest.setAliasProperty(alias)\n        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, \"3DAY\").process(solrClient);\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"7\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\"), // should cause preemptive creation of 10-27 now\n        sdoc(\"id\", \"71\", \"timestamp_dt\", \"2017-10-25T23:02:00Z\")), // should not cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-27\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(5,cols.size()); // only one created in async case\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 6, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"8\", \"timestamp_dt\", \"2017-10-25T23:01:00Z\")), // should cause preemptive creation of 10-28 now\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-28\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(6,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 0, alias);\n    assertNumDocs(\"2017-10-28\", 0, alias);\n\n    QueryResponse resp;\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(9, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"9\", \"timestamp_dt\", \"2017-10-27T23:01:00Z\"), // should cause preemptive creation\n\n        // If these are not ignored properly this test will fail during cleanup with a message about router.name being\n        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain\n        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain\n        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name\n        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.\n        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one\n        // of these.\n        sdoc(\"id\", \"10\", \"timestamp_dt\", \"2017-10-28T23:01:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"11\", \"timestamp_dt\", \"2017-10-28T23:02:00Z\"),  // should be ignored due to in progress creation\n        sdoc(\"id\", \"12\", \"timestamp_dt\", \"2017-10-28T23:03:00Z\")), // should be ignored due to in progress creation\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-29\", numShards);\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(7,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(13, resp.getResults().getNumFound());\n\n    // Sych creation with an interval longer than the time slice for the alias..\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"13\", \"timestamp_dt\", \"2017-10-30T23:03:00Z\")), // lucky?\n        params));\n    assertUpdateResponse(solrClient.commit(alias));\n    waitColAndAlias(alias, TRA, \"2017-10-30\", numShards);\n\n    // removed support for this case because it created a LOT of complexity for the benefit of attempting to\n    // (maybe) not pause again after already hitting a synchronous creation (but only if asynch gets it done first,\n    // otherwise we have a race... not enough benefit to justify the support/complexity.\n    //\n    // Now we just let the next doc take care of it...\n    //\n    // waitColAndAlias(alias, TRA, \"2017-10-31\", numShards); // spooky! async case arising in middle of sync creation!!\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertEquals(8,cols.size());\n    assertNumDocs(\"2017-10-23\", 1, alias);\n    assertNumDocs(\"2017-10-24\", 1, alias);\n    assertNumDocs(\"2017-10-25\", 7, alias);\n    assertNumDocs(\"2017-10-26\", 0, alias);\n    assertNumDocs(\"2017-10-27\", 1, alias);\n    assertNumDocs(\"2017-10-28\", 3, alias); // should get through even though preemptive creation ignored it.\n    assertNumDocs(\"2017-10-29\", 0, alias);\n    assertNumDocs(\"2017-10-30\", 1, alias);\n\n    resp = solrClient.query(alias, params(\n        \"q\", \"*:*\",\n        \"rows\", \"0\"));\n    assertEquals(14, resp.getResults().getNumFound());\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"14\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 10-31\n        params));\n    waitColAndAlias(alias, TRA, \"2017-10-31\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"15\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 11-01\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-01\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"16\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should cause preemptive creation 11-02\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-02\", numShards);\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"17\", \"timestamp_dt\", \"2017-10-30T23:01:00Z\")), // should NOT cause preemptive creation 11-03\n        params));\n\n    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);\n    assertFalse(cols.contains(\"myalias\" + TRA + \"2017-11-03\"));\n\n    assertUpdateResponse(add(alias, Collections.singletonList(\n        sdoc(\"id\", \"18\", \"timestamp_dt\", \"2017-10-31T23:01:00Z\")), // should cause preemptive creation 11-03\n        params));\n    waitColAndAlias(alias, TRA, \"2017-11-03\",numShards);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["b627755385655c7cd3fb296f17593658805cf4d5"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"849083f8095b1ffaff05a66e0b1e024617b9968d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e79d9882f7c12bf527a76ffa43328e4e634db60":["5ff8a68c1177ac430ec03832a6e1c969b8a5b902"],"b627755385655c7cd3fb296f17593658805cf4d5":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"5ff8a68c1177ac430ec03832a6e1c969b8a5b902":["98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["1e79d9882f7c12bf527a76ffa43328e4e634db60"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb"],"849083f8095b1ffaff05a66e0b1e024617b9968d":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"1e79d9882f7c12bf527a76ffa43328e4e634db60":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"b627755385655c7cd3fb296f17593658805cf4d5":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"5ff8a68c1177ac430ec03832a6e1c969b8a5b902":["1e79d9882f7c12bf527a76ffa43328e4e634db60"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["b627755385655c7cd3fb296f17593658805cf4d5"],"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb":["5ff8a68c1177ac430ec03832a6e1c969b8a5b902"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}