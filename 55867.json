{"path":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","commits":[{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.isIndexed(), fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, fi.getNormType(), -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8c146731a64debc22c115bbf11ee1a060aa7ea02","83c8471489eeb663dabdc354a41bea707f560bc9","83c8471489eeb663dabdc354a41bea707f560bc9","83c8471489eeb663dabdc354a41bea707f560bc9","83c8471489eeb663dabdc354a41bea707f560bc9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05da2d758a6089e737cdfc230e57a51b472b94b6","date":1413392310,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.isIndexed(), fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.isIndexed(), fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, fi.getNormType(), -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.isIndexed(), fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.isIndexed(), fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, fi.getNormType(), -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3184874f7f3aca850248483485b4995343066875","date":1413876758,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.isIndexed(), fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.isIndexed(), fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bb2842e561df4e8e9ad89010605fc86ac265465","date":1414768208,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      FieldInfo.DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = FieldInfo.DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = FieldInfo.DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = FieldInfo.DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = FieldInfo.DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"556a4aab886d75371b2af129d87be3c2795cea76","date":1414954991,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.isIndexed() && !fi.hasDocValues()) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":["8c146731a64debc22c115bbf11ee1a060aa7ea02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79700663e164dece87bed4adfd3e28bab6cb1385","date":1425241849,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, Collections.emptyMap()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"299a2348fa24151d150182211b6208a38e5e3450","date":1425304608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, Collections.emptyMap()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, Collections.emptyMap()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, null));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, Collections.emptyMap(), 0, 0));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, Collections.emptyMap()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e22f177344f90a5df0e9179dc4d8722380689866","date":1451404416,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getDimensionCount(), fi.getDimensionNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n                                      fi.hasPayloads(), fi.getIndexOptions(), type, -1, Collections.emptyMap(), 0, 0));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getDimensionCount(), fi.getDimensionNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c146731a64debc22c115bbf11ee1a060aa7ea02","date":1457616596,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {\n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          switch(t) {\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87","556a4aab886d75371b2af129d87be3c2795cea76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a076c3c721f685b7559308fdc2cd72d91bba67e5","date":1464168992,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["c9fb5f46e264daf5ba3860defe623a89d202dd87","05da2d758a6089e737cdfc230e57a51b472b94b6"],"a076c3c721f685b7559308fdc2cd72d91bba67e5":["8c146731a64debc22c115bbf11ee1a060aa7ea02"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["e22f177344f90a5df0e9179dc4d8722380689866"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["8c146731a64debc22c115bbf11ee1a060aa7ea02","a076c3c721f685b7559308fdc2cd72d91bba67e5"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["3184874f7f3aca850248483485b4995343066875"],"556a4aab886d75371b2af129d87be3c2795cea76":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"83870855d82aba6819217abeff5a40779dbb28b4":["8c146731a64debc22c115bbf11ee1a060aa7ea02","0e121d43b5a10f2df530f406f935102656e9c4e8"],"3184874f7f3aca850248483485b4995343066875":["05da2d758a6089e737cdfc230e57a51b472b94b6"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["8c146731a64debc22c115bbf11ee1a060aa7ea02","0e121d43b5a10f2df530f406f935102656e9c4e8"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["556a4aab886d75371b2af129d87be3c2795cea76","79700663e164dece87bed4adfd3e28bab6cb1385"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"e22f177344f90a5df0e9179dc4d8722380689866":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["79700663e164dece87bed4adfd3e28bab6cb1385"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"79700663e164dece87bed4adfd3e28bab6cb1385":["556a4aab886d75371b2af129d87be3c2795cea76"],"8c146731a64debc22c115bbf11ee1a060aa7ea02":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"299a2348fa24151d150182211b6208a38e5e3450":["556a4aab886d75371b2af129d87be3c2795cea76","79700663e164dece87bed4adfd3e28bab6cb1385"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0e121d43b5a10f2df530f406f935102656e9c4e8"]},"commit2Childs":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"a076c3c721f685b7559308fdc2cd72d91bba67e5":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["8c146731a64debc22c115bbf11ee1a060aa7ea02"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["556a4aab886d75371b2af129d87be3c2795cea76"],"556a4aab886d75371b2af129d87be3c2795cea76":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","79700663e164dece87bed4adfd3e28bab6cb1385","299a2348fa24151d150182211b6208a38e5e3450"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["05da2d758a6089e737cdfc230e57a51b472b94b6","c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84"],"3184874f7f3aca850248483485b4995343066875":["2bb2842e561df4e8e9ad89010605fc86ac265465","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"e22f177344f90a5df0e9179dc4d8722380689866":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["e22f177344f90a5df0e9179dc4d8722380689866"],"79700663e164dece87bed4adfd3e28bab6cb1385":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ca792c26af46bd6c4a08d81117c60440cf6a7e3d","299a2348fa24151d150182211b6208a38e5e3450"],"8c146731a64debc22c115bbf11ee1a060aa7ea02":["a076c3c721f685b7559308fdc2cd72d91bba67e5","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"299a2348fa24151d150182211b6208a38e5e3450":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0a22eafe3f72a4c2945eaad9547e6c78816978f4","299a2348fa24151d150182211b6208a38e5e3450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}