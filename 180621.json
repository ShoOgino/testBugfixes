{"path":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilter#getBoxShape(double,double,int).mjava","commits":[{"id":"04a4a94db1eb59c8583adb166acfe686a031bedc","date":1230622637,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilter#getBoxShape(double,double,int).mjava","pathOld":"/dev/null","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, int miles)\n  {  \n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    \n    double latY = box.getMaxPoint().getY();//box.getY();\n    double latX = box.getMinPoint().getY() ; //box.getMaxY();\n    \n    double longY = box.getMaxPoint().getX(); ///box.getX();\n    double longX = box.getMinPoint().getX();//box.getMaxX();\n    \n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    \n   \n    double beginAt = ctp.getTierBoxId(latX, longX);\n    double endAt = ctp.getTierBoxId(latY, longY);\n    \n    double tierVert = ctp.getTierVerticalPosDivider();\n    log.fine(\" | \"+ beginAt+\" | \"+ endAt);\n    \n    double startX = beginAt - (beginAt %1);\n    double startY = beginAt - startX ; //should give a whole number\n    \n    double endX = endAt - (endAt %1);\n    double endY = endAt -endX; //should give a whole number\n    \n    int scale = (int)Math.log10(tierVert);\n    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    log.fine(\"scale \"+scale+\" startX \"+ startX + \" endX \"+endX +\" startY \"+ startY + \" endY \"+ endY +\" tierVert \"+ tierVert);\n    \n    double xInc = 1.0d / tierVert;\n    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    \n    for (; startX <= endX; startX++){\n      \n      double itY = startY;\n      while (itY <= endY){\n        //create a boxId\n        // startX.startY\n        double boxId = startX + itY ;\n        shape.addBox(boxId);\n        //System.out.println(\"----\"+boxId);\n        itY += xInc;\n        \n        // java keeps 0.0001 as 1.0E-1\n        // which ends up as 0.00011111\n        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n      }\n    }\n    return shape;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3b6f51785c57651e9e1864b7b883037f24541c76","e59cead675ff912b2ffdac41ca1a2fa7d905b8fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62ed23bc688871c07712a31edf012919ea9cd466","date":1230660056,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,int).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilter#getBoxShape(double,double,int).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, int miles)\n  {  \n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    \n    double latY = box.getMaxPoint().getY();//box.getY();\n    double latX = box.getMinPoint().getY() ; //box.getMaxY();\n    \n    double longY = box.getMaxPoint().getX(); ///box.getX();\n    double longX = box.getMinPoint().getX();//box.getMaxX();\n    \n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    \n   \n    double beginAt = ctp.getTierBoxId(latX, longX);\n    double endAt = ctp.getTierBoxId(latY, longY);\n    \n    double tierVert = ctp.getTierVerticalPosDivider();\n    log.fine(\" | \"+ beginAt+\" | \"+ endAt);\n    \n    double startX = beginAt - (beginAt %1);\n    double startY = beginAt - startX ; //should give a whole number\n    \n    double endX = endAt - (endAt %1);\n    double endY = endAt -endX; //should give a whole number\n    \n    int scale = (int)Math.log10(tierVert);\n    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    log.fine(\"scale \"+scale+\" startX \"+ startX + \" endX \"+endX +\" startY \"+ startY + \" endY \"+ endY +\" tierVert \"+ tierVert);\n    \n    double xInc = 1.0d / tierVert;\n    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    \n    for (; startX <= endX; startX++){\n      \n      double itY = startY;\n      while (itY <= endY){\n        //create a boxId\n        // startX.startY\n        double boxId = startX + itY ;\n        shape.addBox(boxId);\n        //System.out.println(\"----\"+boxId);\n        itY += xInc;\n        \n        // java keeps 0.0001 as 1.0E-1\n        // which ends up as 0.00011111\n        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n      }\n    }\n    return shape;\n  }\n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, int miles)\n  {  \n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    \n    double latY = box.getMaxPoint().getY();//box.getY();\n    double latX = box.getMinPoint().getY() ; //box.getMaxY();\n    \n    double longY = box.getMaxPoint().getX(); ///box.getX();\n    double longX = box.getMinPoint().getX();//box.getMaxX();\n    \n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    \n   \n    double beginAt = ctp.getTierBoxId(latX, longX);\n    double endAt = ctp.getTierBoxId(latY, longY);\n    \n    double tierVert = ctp.getTierVerticalPosDivider();\n    log.fine(\" | \"+ beginAt+\" | \"+ endAt);\n    \n    double startX = beginAt - (beginAt %1);\n    double startY = beginAt - startX ; //should give a whole number\n    \n    double endX = endAt - (endAt %1);\n    double endY = endAt -endX; //should give a whole number\n    \n    int scale = (int)Math.log10(tierVert);\n    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    log.fine(\"scale \"+scale+\" startX \"+ startX + \" endX \"+endX +\" startY \"+ startY + \" endY \"+ endY +\" tierVert \"+ tierVert);\n    \n    double xInc = 1.0d / tierVert;\n    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    \n    for (; startX <= endX; startX++){\n      \n      double itY = startY;\n      while (itY <= endY){\n        //create a boxId\n        // startX.startY\n        double boxId = startX + itY ;\n        shape.addBox(boxId);\n        //System.out.println(\"----\"+boxId);\n        itY += xInc;\n        \n        // java keeps 0.0001 as 1.0E-1\n        // which ends up as 0.00011111\n        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n      }\n    }\n    return shape;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"04a4a94db1eb59c8583adb166acfe686a031bedc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"62ed23bc688871c07712a31edf012919ea9cd466":["04a4a94db1eb59c8583adb166acfe686a031bedc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["62ed23bc688871c07712a31edf012919ea9cd466"]},"commit2Childs":{"04a4a94db1eb59c8583adb166acfe686a031bedc":["62ed23bc688871c07712a31edf012919ea9cd466"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["04a4a94db1eb59c8583adb166acfe686a031bedc"],"62ed23bc688871c07712a31edf012919ea9cd466":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}