{"path":"lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillSideways#search(SimpleDrillDownQuery,Collector).mjava","commits":[{"id":"28ac5cee8abf30398e12bc016a5ce9d441831a63","date":1384691298,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillSideways#search(SimpleDrillDownQuery,Collector).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public SimpleDrillSidewaysResult search(SimpleDrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    SimpleFacetsCollector drillDownCollector = new SimpleFacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new SimpleDrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    SimpleFacetsCollector[] drillSidewaysCollectors = new SimpleFacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      drillSidewaysCollectors[idx++] = new SimpleFacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      SimpleDrillSidewaysQuery dsq = new SimpleDrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new SimpleDrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillSideways#search(SimpleDrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      drillSidewaysCollectors[idx++] = new FacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public SimpleDrillSidewaysResult search(SimpleDrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    SimpleFacetsCollector drillDownCollector = new SimpleFacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new SimpleDrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    SimpleFacetsCollector[] drillSidewaysCollectors = new SimpleFacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      drillSidewaysCollectors[idx++] = new SimpleFacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      SimpleDrillSidewaysQuery dsq = new SimpleDrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new SimpleDrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"28ac5cee8abf30398e12bc016a5ce9d441831a63":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["28ac5cee8abf30398e12bc016a5ce9d441831a63"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"28ac5cee8abf30398e12bc016a5ce9d441831a63":["21d36d0db865f7b84026b447bec653469a6e66df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["28ac5cee8abf30398e12bc016a5ce9d441831a63","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"21d36d0db865f7b84026b447bec653469a6e66df":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["21d36d0db865f7b84026b447bec653469a6e66df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}