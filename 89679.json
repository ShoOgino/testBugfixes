{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","commits":[{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false);\n    if (core != null) {\n      if(coreId != null && core.uniqueId != coreId) {\n        //trying to reload an already unloaded core\n        return;\n      }\n\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fc1087854af39c9b439f47d913fd3ac1d85ac5c","date":1599523122,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","sourceNew":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false, coreId);\n    if (core != null) {\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false);\n    if (core != null) {\n      if(coreId != null && core.uniqueId != coreId) {\n        //trying to reload an already unloaded core\n        return;\n      }\n\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938fe8fd4d30ae70161827366f67c2382985e446","date":1600050178,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","sourceNew":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false);\n    if (core != null) {\n      if(coreId != null && core.uniqueId != coreId) {\n        //trying to reload an already unloaded core\n        return;\n      }\n\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false, coreId);\n    if (core != null) {\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e451e492cce54699988e2ce0aea55e3ff170cb0","date":1600305561,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","sourceNew":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false, coreId);\n    if (core != null) {\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false);\n    if (core != null) {\n      if(coreId != null && core.uniqueId != coreId) {\n        //trying to reload an already unloaded core\n        return;\n      }\n\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"549c57a06e434a7bf269fcbb2b7007c8e2053108","date":1600664903,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#reload(String,UUID).mjava","sourceNew":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false, coreId);\n    if (core != null) {\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      if(coreId != null) return;// yeah, this core is already reloaded/unloaded return right away\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Recreates a SolrCore.\n   * While the new core is loading, requests will continue to be dispatched to\n   * and processed by the old core\n   *\n   * @param name the name of the SolrCore to reload\n   * @param coreId The unique Id of the core {@link SolrCore#uniqueId}. If this is null, it's reloaded anyway. If the current\n   *               core has a different id, this is a no-op\n   */\n  public void reload(String name, UUID coreId) {\n    if (isShutDown) {\n      throw new AlreadyClosedException();\n    }\n    SolrCore newCore = null;\n    SolrCore core = solrCores.getCoreFromAnyList(name, false, coreId);\n    if (core != null) {\n      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n      // CoreDescriptor and we need to reload it from the disk files\n      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n      solrCores.addCoreDescriptor(cd);\n      Closeable oldCore = null;\n      boolean success = false;\n      try {\n        solrCores.waitAddPendingCoreOps(cd.getName());\n        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n        if (log.isInfoEnabled()) {\n          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n        }\n        newCore = core.reload(coreConfig);\n\n        DocCollection docCollection = null;\n        if (getZkController() != null) {\n          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n          // turn off indexing now, before the new core is registered\n          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n            newCore.readOnly = true;\n          }\n        }\n\n        registerCore(cd, newCore, false, false);\n\n        // force commit on old core if the new one is readOnly and prevent any new updates\n        if (newCore.readOnly) {\n          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n          if (iwRef != null) {\n            IndexWriter iw = iwRef.get();\n            // switch old core to readOnly\n            core.readOnly = true;\n            try {\n              if (iw != null) {\n                iw.commit();\n              }\n            } finally {\n              iwRef.decref();\n            }\n          }\n        }\n\n\n        if (docCollection != null) {\n          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n          assert replica != null;\n          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n            getZkController().stopReplicationFromLeader(core.getName());\n            if (!cd.getCloudDescriptor().isLeader()) {\n              getZkController().startReplicationFromLeader(newCore.getName(), true);\n            }\n\n          } else if (replica.getType() == Replica.Type.PULL) {\n            getZkController().stopReplicationFromLeader(core.getName());\n            getZkController().startReplicationFromLeader(newCore.getName(), false);\n          }\n        }\n        success = true;\n      } catch (SolrCoreState.CoreIsClosedException e) {\n        throw e;\n      } catch (Exception e) {\n        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n      } finally {\n        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n          IOUtils.closeQuietly(newCore);\n        }\n        solrCores.removeFromPendingOps(cd.getName());\n      }\n    } else {\n      CoreLoadFailure clf = coreInitFailures.get(name);\n      if (clf != null) {\n        try {\n          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n          createFromDescriptor(clf.cd, true, false);\n        } finally {\n          solrCores.removeFromPendingOps(clf.cd.getName());\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"549c57a06e434a7bf269fcbb2b7007c8e2053108":["0e451e492cce54699988e2ce0aea55e3ff170cb0"],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"938fe8fd4d30ae70161827366f67c2382985e446":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["938fe8fd4d30ae70161827366f67c2382985e446"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["549c57a06e434a7bf269fcbb2b7007c8e2053108"]},"commit2Childs":{"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"549c57a06e434a7bf269fcbb2b7007c8e2053108":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["938fe8fd4d30ae70161827366f67c2382985e446"],"938fe8fd4d30ae70161827366f67c2382985e446":["0e451e492cce54699988e2ce0aea55e3ff170cb0"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["549c57a06e434a7bf269fcbb2b7007c8e2053108"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}