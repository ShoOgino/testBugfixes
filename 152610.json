{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","commits":[{"id":"f00f1c5fad501b66705121feb623f8cfbb6712f9","date":1431347838,"type":1,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      long time = System.currentTimeMillis();\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random(time));\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      long time = System.currentTimeMillis();\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random(time));\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da9a71da64ce12a97dcfcdd912893aeb1fa2981","date":1437510515,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        throw new Exception(\"Collection not found:\"+this.collection);\n      }\n\n      long time = System.currentTimeMillis();\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random(time));\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      long time = System.currentTimeMillis();\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random(time));\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        throw new Exception(\"Collection not found:\"+this.collection);\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        throw new Exception(\"Collection not found:\"+this.collection);\n      }\n\n      long time = System.currentTimeMillis();\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random(time));\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36479872320bb00635cb97ca6757614c88562e1b","date":1444426483,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n\n        String colLower = this.collection.toLowerCase(Locale.getDefault());\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.toLowerCase(Locale.getDefault()).equals(colLower)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        throw new Exception(\"Collection not found:\"+this.collection);\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2394c8af138e6007607f96374c24aabf72da9ea","date":1455003168,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(this.collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n\n        String colLower = this.collection.toLowerCase(Locale.getDefault());\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.toLowerCase(Locale.getDefault()).equals(colLower)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad0d3af10297301b05f967ec10f31cbd376bdea3","date":1455206043,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(this.collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"826d15444ddf61716dc768c229cd54b2c2ccce1c","date":1462822652,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7acafb1138acd128fde4037d3d5124b66eb07a04","date":1469176018,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      if (slices == null) slices = getSlicesIgnoreCase(this.collection, clusterState);\n      if (slices == null) {\n        throw new Exception(\"Collection not found:\" + this.collection);\n      }\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      if (slices == null) slices = getSlicesIgnoreCase(this.collection, clusterState);\n      if (slices == null) {\n        throw new Exception(\"Collection not found:\" + this.collection);\n      }\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\",\"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, params);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c969f15cd04d31e520319c619a445ae21f02d72","date":1479263638,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      if (slices == null) slices = getSlicesIgnoreCase(this.collection, clusterState);\n      if (slices == null) {\n        throw new Exception(\"Collection not found:\" + this.collection);\n      }\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1ef55e1fff7ff44354432770ad8bc19be1fcc75","date":1479266056,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      if (slices == null) slices = getSlicesIgnoreCase(this.collection, clusterState);\n      if (slices == null) {\n        throw new Exception(\"Collection not found:\" + this.collection);\n      }\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11e5446472f245825b6f1cc220252acaab5990cf","date":1491429444,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c405288c4553ffb50ab8ca5adbdde9881bcec4e4","date":1491938682,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n\n      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      for(String shardUrl : shardUrls) {\n        SolrStream solrStream = new SolrStream(shardUrl, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n\n      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      for(String shardUrl : shardUrls) {\n        SolrStream solrStream = new SolrStream(shardUrl, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, true);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params); \n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for(Slice slice : slices) {\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n          shuffler.add(replica);\n        }\n\n        Collections.shuffle(shuffler, new Random());\n        Replica rep = shuffler.get(0);\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70d9c44f68e848648da304352cf7c045c33148f4","date":1557331987,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n\n      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      for(String shardUrl : shardUrls) {\n        SolrStream solrStream = new SolrStream(shardUrl, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n          if (streamContext.isLocal()) {\n            solrStream.setDistrib(false);\n          }\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n\n      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      for(String shardUrl : shardUrls) {\n        SolrStream solrStream = new SolrStream(shardUrl, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839","date":1575929518,"type":3,"author":"Houston Putman","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext, mParams);\n\n      for(String shardUrl : shardUrls) {\n        SolrStream solrStream = new SolrStream(shardUrl, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n          if (streamContext.isLocal()) {\n            solrStream.setDistrib(false);\n          }\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n\n      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      for(String shardUrl : shardUrls) {\n        SolrStream solrStream = new SolrStream(shardUrl, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n          if (streamContext.isLocal()) {\n            solrStream.setDistrib(false);\n          }\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"993b0c7dda6341b437fe5685d35c6cc35eaac420","date":1575985950,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext, mParams);\n\n      for(String shardUrl : shardUrls) {\n        SolrStream solrStream = new SolrStream(shardUrl, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n          if (streamContext.isLocal()) {\n            solrStream.setDistrib(false);\n          }\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n\n      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams = adjustParams(mParams);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n\n      for(String shardUrl : shardUrls) {\n        SolrStream solrStream = new SolrStream(shardUrl, mParams);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n          if (streamContext.isLocal()) {\n            solrStream.setDistrib(false);\n          }\n        }\n        solrStream.setFieldMappings(this.fieldMappings);\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["6f4c5d3859373c3a74734e85efa122b17514e3e8"],"e2394c8af138e6007607f96374c24aabf72da9ea":["36479872320bb00635cb97ca6757614c88562e1b"],"993b0c7dda6341b437fe5685d35c6cc35eaac420":["70d9c44f68e848648da304352cf7c045c33148f4","ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"c405288c4553ffb50ab8ca5adbdde9881bcec4e4":["11e5446472f245825b6f1cc220252acaab5990cf"],"01624b85de12fb02335810bdf325124e59040772":["8c969f15cd04d31e520319c619a445ae21f02d72"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["73450c0955930295d34703e7ddbfc6973b7a121a","826d15444ddf61716dc768c229cd54b2c2ccce1c"],"11e5446472f245825b6f1cc220252acaab5990cf":["01624b85de12fb02335810bdf325124e59040772"],"36479872320bb00635cb97ca6757614c88562e1b":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"7acafb1138acd128fde4037d3d5124b66eb07a04":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["ad0d3af10297301b05f967ec10f31cbd376bdea3","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e66a459d38c1c4a2f97128433dab546f683a9fed":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","826d15444ddf61716dc768c229cd54b2c2ccce1c"],"8c969f15cd04d31e520319c619a445ae21f02d72":["7acafb1138acd128fde4037d3d5124b66eb07a04"],"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839":["70d9c44f68e848648da304352cf7c045c33148f4"],"70d9c44f68e848648da304352cf7c045c33148f4":["c405288c4553ffb50ab8ca5adbdde9881bcec4e4"],"f00f1c5fad501b66705121feb623f8cfbb6712f9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"73450c0955930295d34703e7ddbfc6973b7a121a":["ad0d3af10297301b05f967ec10f31cbd376bdea3","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["ad0d3af10297301b05f967ec10f31cbd376bdea3","73450c0955930295d34703e7ddbfc6973b7a121a"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["8c969f15cd04d31e520319c619a445ae21f02d72"],"826d15444ddf61716dc768c229cd54b2c2ccce1c":["73450c0955930295d34703e7ddbfc6973b7a121a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","7acafb1138acd128fde4037d3d5124b66eb07a04"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8c969f15cd04d31e520319c619a445ae21f02d72"],"ad0d3af10297301b05f967ec10f31cbd376bdea3":["e2394c8af138e6007607f96374c24aabf72da9ea"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["8da9a71da64ce12a97dcfcdd912893aeb1fa2981"],"8da9a71da64ce12a97dcfcdd912893aeb1fa2981":["f00f1c5fad501b66705121feb623f8cfbb6712f9"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["ad0d3af10297301b05f967ec10f31cbd376bdea3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"e2394c8af138e6007607f96374c24aabf72da9ea":["ad0d3af10297301b05f967ec10f31cbd376bdea3"],"993b0c7dda6341b437fe5685d35c6cc35eaac420":[],"c405288c4553ffb50ab8ca5adbdde9881bcec4e4":["70d9c44f68e848648da304352cf7c045c33148f4"],"01624b85de12fb02335810bdf325124e59040772":["11e5446472f245825b6f1cc220252acaab5990cf"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["7acafb1138acd128fde4037d3d5124b66eb07a04"],"36479872320bb00635cb97ca6757614c88562e1b":["e2394c8af138e6007607f96374c24aabf72da9ea"],"11e5446472f245825b6f1cc220252acaab5990cf":["c405288c4553ffb50ab8ca5adbdde9881bcec4e4"],"7acafb1138acd128fde4037d3d5124b66eb07a04":["8c969f15cd04d31e520319c619a445ae21f02d72","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["e66a459d38c1c4a2f97128433dab546f683a9fed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f00f1c5fad501b66705121feb623f8cfbb6712f9"],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"8c969f15cd04d31e520319c619a445ae21f02d72":["01624b85de12fb02335810bdf325124e59040772","6f4c5d3859373c3a74734e85efa122b17514e3e8","a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839":["993b0c7dda6341b437fe5685d35c6cc35eaac420","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"70d9c44f68e848648da304352cf7c045c33148f4":["993b0c7dda6341b437fe5685d35c6cc35eaac420","ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"f00f1c5fad501b66705121feb623f8cfbb6712f9":["8da9a71da64ce12a97dcfcdd912893aeb1fa2981"],"73450c0955930295d34703e7ddbfc6973b7a121a":["d470c8182e92b264680e34081b75e70a9f2b3c89","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","7dc08f02757dd10637b16a5c65eaaef839a91a9a","826d15444ddf61716dc768c229cd54b2c2ccce1c"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"826d15444ddf61716dc768c229cd54b2c2ccce1c":["d470c8182e92b264680e34081b75e70a9f2b3c89","e66a459d38c1c4a2f97128433dab546f683a9fed"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":[],"ad0d3af10297301b05f967ec10f31cbd376bdea3":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","73450c0955930295d34703e7ddbfc6973b7a121a","7dc08f02757dd10637b16a5c65eaaef839a91a9a","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["36479872320bb00635cb97ca6757614c88562e1b"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"8da9a71da64ce12a97dcfcdd912893aeb1fa2981":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","993b0c7dda6341b437fe5685d35c6cc35eaac420","e66a459d38c1c4a2f97128433dab546f683a9fed","a1ef55e1fff7ff44354432770ad8bc19be1fcc75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}