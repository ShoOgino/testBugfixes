{"path":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanTokenizer#add(Dictionary,Position,int,int,int,Type).mjava","commits":[{"id":"8493925b2e70246f0961df584c01a8c2e61ee52f","date":1523611602,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanTokenizer#add(Dictionary,Position,int,int,int,Type).mjava","pathOld":"/dev/null","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int wordPos, int endPos, int wordID, Type type) throws IOException {\n    final POS.Tag leftPOS = dict.getLeftPOS(wordID);\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // The number of spaces before the term\n      int numSpaces = wordPos - fromPosData.pos;\n\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost and space penalty cost.\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID) + computeSpacePenalty(leftPOS, numSpaces);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) +\n            \" spacePenalty=\" + computeSpacePenalty(leftPOS, numSpaces) + \") leftID=\" + leftID + \" leftPOS=\" + leftPOS.name() + \")\");\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, wordPos, leastIDX, wordID, type);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c6453827f947004a68ad9db7418781e9df2f660","date":1523626811,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanTokenizer#add(Dictionary,Position,int,int,int,Type).mjava","pathOld":"/dev/null","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int wordPos, int endPos, int wordID, Type type) throws IOException {\n    final POS.Tag leftPOS = dict.getLeftPOS(wordID);\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // The number of spaces before the term\n      int numSpaces = wordPos - fromPosData.pos;\n\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost and space penalty cost.\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID) + computeSpacePenalty(leftPOS, numSpaces);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) +\n            \" spacePenalty=\" + computeSpacePenalty(leftPOS, numSpaces) + \") leftID=\" + leftID + \" leftPOS=\" + leftPOS.name() + \")\");\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, wordPos, leastIDX, wordID, type);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9f7831922bb899baba6064894c8ebb795cdee2","date":1566842943,"type":3,"author":"Namgyu Kim","isMerge":false,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanTokenizer#add(Dictionary,Position,int,int,int,Type).mjava","pathOld":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanTokenizer#add(Dictionary,Position,int,int,int,Type).mjava","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int wordPos, int endPos, int wordID, Type type) {\n    final POS.Tag leftPOS = dict.getLeftPOS(wordID);\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // The number of spaces before the term\n      int numSpaces = wordPos - fromPosData.pos;\n\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost and space penalty cost.\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID) + computeSpacePenalty(leftPOS, numSpaces);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) +\n            \" spacePenalty=\" + computeSpacePenalty(leftPOS, numSpaces) + \") leftID=\" + leftID + \" leftPOS=\" + leftPOS.name() + \")\");\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, wordPos, leastIDX, wordID, type);\n  }\n\n","sourceOld":"  private void add(Dictionary dict, Position fromPosData, int wordPos, int endPos, int wordID, Type type) throws IOException {\n    final POS.Tag leftPOS = dict.getLeftPOS(wordID);\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // The number of spaces before the term\n      int numSpaces = wordPos - fromPosData.pos;\n\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost and space penalty cost.\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID) + computeSpacePenalty(leftPOS, numSpaces);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) +\n            \" spacePenalty=\" + computeSpacePenalty(leftPOS, numSpaces) + \") leftID=\" + leftID + \" leftPOS=\" + leftPOS.name() + \")\");\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, wordPos, leastIDX, wordID, type);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8493925b2e70246f0961df584c01a8c2e61ee52f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ac9f7831922bb899baba6064894c8ebb795cdee2":["5c6453827f947004a68ad9db7418781e9df2f660"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ac9f7831922bb899baba6064894c8ebb795cdee2"],"5c6453827f947004a68ad9db7418781e9df2f660":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8493925b2e70246f0961df584c01a8c2e61ee52f"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8493925b2e70246f0961df584c01a8c2e61ee52f","5c6453827f947004a68ad9db7418781e9df2f660"],"8493925b2e70246f0961df584c01a8c2e61ee52f":["5c6453827f947004a68ad9db7418781e9df2f660"],"ac9f7831922bb899baba6064894c8ebb795cdee2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c6453827f947004a68ad9db7418781e9df2f660":["ac9f7831922bb899baba6064894c8ebb795cdee2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}