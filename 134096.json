{"path":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","commits":[{"id":"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","date":1523453934,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of active slices, expected=\" + expectedShards + \", found=\" + collectionState.getSlices().size());\n        return false;\n      }\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas in slice \" + slice.getName() + \", expected=\" + expectedReplicas + \", found=\" + activeReplicas);\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of active slices, expected=\" + expectedShards + \", found=\" + collectionState.getSlices().size());\n        return false;\n      }\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas in slice \" + slice.getName() + \", expected=\" + expectedReplicas + \", found=\" + activeReplicas);\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4aa99957dcb54cefbbec762eb896b084deac1b9","date":1526471995,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @return\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of active slices, expected=\" + expectedShards + \", found=\" + collectionState.getSlices().size());\n        return false;\n      }\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas in slice \" + slice.getName() + \", expected=\" + expectedReplicas + \", found=\" + activeReplicas);\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n","sourceOld":"  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of active slices, expected=\" + expectedShards + \", found=\" + collectionState.getSlices().size());\n        return false;\n      }\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas in slice \" + slice.getName() + \", expected=\" + expectedReplicas + \", found=\" + activeReplicas);\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e09684eeb993adbc684e24ac80071fadd8b4d4f","date":1526479453,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of active slices, expected=\" + expectedShards + \", found=\" + collectionState.getSlices().size());\n        return false;\n      }\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas in slice \" + slice.getName() + \", expected=\" + expectedReplicas + \", found=\" + activeReplicas);\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @return\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of active slices, expected=\" + expectedShards + \", found=\" + collectionState.getSlices().size());\n        return false;\n      }\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas in slice \" + slice.getName() + \", expected=\" + expectedReplicas + \", found=\" + activeReplicas);\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.trace(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.trace(\"-- wrong number of active slices, expected={}, found={}\", expectedShards, collectionState.getSlices().size());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.trace(\"-- wrong number of active replicas in slice {}, expected={}, found={}\", slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.trace(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of active slices, expected=\" + expectedShards + \", found=\" + collectionState.getSlices().size());\n        return false;\n      }\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas in slice \" + slice.getName() + \", expected=\" + expectedReplicas + \", found=\" + activeReplicas);\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["5e09684eeb993adbc684e24ac80071fadd8b4d4f"],"e4aa99957dcb54cefbbec762eb896b084deac1b9":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"5e09684eeb993adbc684e24ac80071fadd8b4d4f":["e4aa99957dcb54cefbbec762eb896b084deac1b9"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"43345f1452f9510f8aaadae6156fe0c834e7d957":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"]},"commit2Childs":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e4aa99957dcb54cefbbec762eb896b084deac1b9":["5e09684eeb993adbc684e24ac80071fadd8b4d4f"],"5e09684eeb993adbc684e24ac80071fadd8b4d4f":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","43345f1452f9510f8aaadae6156fe0c834e7d957"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["e4aa99957dcb54cefbbec762eb896b084deac1b9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}