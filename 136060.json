{"path":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","commits":[{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          String state = ZkStateReader.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = ZkStateReader.ACTIVE;\n                break;\n              case 'R':\n                state = ZkStateReader.RECOVERING;\n                break;\n              case 'D':\n                state = ZkStateReader.DOWN;\n                break;\n              case 'F':\n                state = ZkStateReader.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state);\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(ZkStateReader.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(ZkStateReader.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          String state = ZkStateReader.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = ZkStateReader.ACTIVE;\n                break;\n              case 'R':\n                state = ZkStateReader.RECOVERING;\n                break;\n              case 'D':\n                state = ZkStateReader.DOWN;\n                break;\n              case 'F':\n                state = ZkStateReader.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state);\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(ZkStateReader.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(ZkStateReader.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbed9f780536d62957bf82cf6c87b75c5b4cd30b","date":1462731618,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55a4fb564f94e7d0f0dfce705d51533be9f1c22e","date":1462769458,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<String>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7e7599efe704cd8a873a909e546525ace4b5502","date":1491388304,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(List[Result],String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ClusterStateMockUtil.Result buildClusterState(List<Result> results, String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    ClusterStateMockUtil.Result result = new ClusterStateMockUtil.Result();\n\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new OverseerAutoReplicaFailoverThread.DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    // todo remove the limitation of always having a bad replica\n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n\n    result.reader = reader;\n\n    if (results != null) {\n      results.add(result);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":null,"sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a219f1dcad1700e84807666bdbd2b573e8de7021":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55a4fb564f94e7d0f0dfce705d51533be9f1c22e":["b693a83132c9e45afcd564fd65a25b60ed80388b","fbed9f780536d62957bf82cf6c87b75c5b4cd30b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b693a83132c9e45afcd564fd65a25b60ed80388b":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"e66a459d38c1c4a2f97128433dab546f683a9fed":["b693a83132c9e45afcd564fd65a25b60ed80388b","55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"fbed9f780536d62957bf82cf6c87b75c5b4cd30b":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b693a83132c9e45afcd564fd65a25b60ed80388b","55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7e7599efe704cd8a873a909e546525ace4b5502"],"f7e7599efe704cd8a873a909e546525ace4b5502":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"]},"commit2Childs":{"a219f1dcad1700e84807666bdbd2b573e8de7021":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"55a4fb564f94e7d0f0dfce705d51533be9f1c22e":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","e66a459d38c1c4a2f97128433dab546f683a9fed","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f7e7599efe704cd8a873a909e546525ace4b5502"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e","e66a459d38c1c4a2f97128433dab546f683a9fed","fbed9f780536d62957bf82cf6c87b75c5b4cd30b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"fbed9f780536d62957bf82cf6c87b75c5b4cd30b":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f7e7599efe704cd8a873a909e546525ace4b5502":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","e66a459d38c1c4a2f97128433dab546f683a9fed","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}